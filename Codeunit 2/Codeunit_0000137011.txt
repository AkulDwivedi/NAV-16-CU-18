OBJECT Codeunit 137011 SCM Revaluation-II
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      GeneralLedgerSetup@1010 : Record 98;
      PurchasesPayablesSetup@1019 : Record 312;
      SalesReceivablesSetup@1018 : Record 311;
      InventorySetup@1016 : Record 313;
      OutputItemJournalTemplate@1013 : Record 82;
      OutputItemJournalBatch@1012 : Record 233;
      RevaluationItemJournalTemplate@1014 : Record 82;
      RevaluationItemJournalBatch@1015 : Record 233;
      Assert@1004 : Codeunit 130000;
      LibraryPurchase@1011 : Codeunit 130512;
      LibrarySales@1024 : Codeunit 130509;
      LibraryInventory@1003 : Codeunit 132201;
      LibraryPatterns@1027 : Codeunit 132212;
      LibraryCosting@1021 : Codeunit 132200;
      LibraryManufacturing@1022 : Codeunit 132202;
      LibraryUtility@1002 : Codeunit 131000;
      LibraryWarehouse@1023 : Codeunit 132204;
      LibraryRandom@1009 : Codeunit 130440;
      LibraryFiscalYear@1026 : Codeunit 131302;
      isInitialized@1000 : Boolean;
      ErrMessageQtyMustBeEqual@1005 : TextConst 'ENU=Item Quantity Must Be Equal.';
      CostMustBeEqualErr@1006 : TextConst 'ENU=Costs must be Equal.';
      ExpectedMsg@1008 : TextConst 'ENU=Expected Cost Posting to G/L has been changed.';
      ExpectedCostPostingConfirm@1007 : TextConst 'ENU=Do you really want to change the Expected Cost Posting to G/L?';
      ProductionOrderNo@1001 : Code[20];
      ErrMsgCostAmount@1020 : TextConst 'ENU=The amounts must be equal.';
      PerEntryRevaluationErr@1025 : TextConst 'ENU=You cannot revalue individual item ledger entries for items that use the average costing method.';

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE StdPurchRevalSales@3();
    VAR
      Item@1012 : Record 27;
      InventorySetup@1004 : Record 313;
      ItemJournalLine@1003 : Record 83;
      PurchaseHeader@1010 : Record 38;
      SalesHeader@1001 : Record 36;
      InventoryPostingGroup@1015 : Code[10];
      ItemNo@1009 : Code[20];
      LocationCode@1014 : Code[10];
      AutomaticCostAdjustment@1007 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1006 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1005 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      ItemCostingMethod@1002 : 'FIFO,LIFO,Specific,Average,Standard';
      Qty@1000 : Decimal;
      OldUnitCost@1008 : Decimal;
      NewUnitCost@1013 : Decimal;
      InitialInventory@1016 : Decimal;
    BEGIN
      // Covers TFS_TC_ID = 6202
      // Setup: Update Inventory Setup, Create Item and Purchase Order and Post Purchase Order.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LocationCode := CreateLocationCode(InventoryPostingGroup);
      ItemNo := CreateItem(ItemCostingMethod::Standard,InventoryPostingGroup);
      UpdateItemInventory(ItemNo,LocationCode);
      Qty := LibraryRandom.RandInt(10) + 50;
      CreatePurchaseOrder(PurchaseHeader,ItemNo,'',Qty,LocationCode,FALSE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // Exercise: Run Adjust Cost Item Entries, Create Revaluation Journal, Calculate Inventory Value.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');
      CreateRevaluationJournal(ItemJournalLine);
      Item.GET(ItemNo);
      CalcInventoryValue(Item,ItemJournalLine);
      Item.CALCFIELDS(Inventory);
      InitialInventory := Item.Inventory;

      // Verify: Verify that Revalued Inventory is equal to Calculated Inventory.
      VerifyRevaluedInventory(Item);

      // Exercise: Update Revalued Unit Cost and Post Item Journal Line, Create and Post Sales Order, Run Adjust Cost Item Entries.
      OldUnitCost := Item."Standard Cost";
      NewUnitCost :=
        UpdateRevaluedUnitCost(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",OldUnitCost);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      CreateSalesOrder(SalesHeader,Item."No.",Qty,LocationCode,FALSE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');

      // Verify: Verify Value Entries.
      VerifyValueEntry(Qty,Item."No.",OldUnitCost,NewUnitCost,OldUnitCost - NewUnitCost,InitialInventory,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE StdPurchSalesLessInvoiceReval@5();
    VAR
      Item@1001 : Record 27;
      InventorySetup@1000 : Record 313;
      PurchaseHeader@1007 : Record 38;
      SalesHeader@1009 : Record 36;
      ItemJournalLine@1010 : Record 83;
      AutomaticCostAdjustment@1004 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1003 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1002 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      ItemCostingMethod@1014 : 'FIFO,LIFO,Specific,Average,Standard';
      InventoryPostingGroup@1016 : Code[10];
      ItemNo@1005 : Code[20];
      LocationCode@1015 : Code[10];
      Qty@1006 : Decimal;
      InvQty@1018 : Decimal;
      OldUnitCost@1012 : Decimal;
      NewUnitCost@1011 : Decimal;
      InitialInventory@1017 : Decimal;
    BEGIN
      // Covers TFS_TC_ID = 6175
      // Setup: Update Inventory Setup, Create Item and Purchase Order and Post Purchase Order as Receive.
      // Create and Post Sales Order, Reopen Purchase Order and Post Purchase Order with Less Qty to Invoice.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LocationCode := CreateLocationCode(InventoryPostingGroup);
      ItemNo := CreateItem(ItemCostingMethod::Standard,InventoryPostingGroup);
      UpdateItemInventory(ItemNo,LocationCode);
      Qty := LibraryRandom.RandInt(10) + 50;
      CreatePurchaseOrder(PurchaseHeader,ItemNo,'',Qty,LocationCode,FALSE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);

      Item.GET(ItemNo);
      Item.CALCFIELDS(Inventory);
      InitialInventory := Item.Inventory;
      CreateSalesOrder(SalesHeader,ItemNo,Qty,LocationCode,FALSE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);
      InvQty := Qty - 10;
      PurchaseOrderInvoiceLessQty(PurchaseHeader."No.",InvQty);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE);

      // Exercise: Run Adjust Cost Item Entries, Create Revaluation Journal, Calculate Inventory Value.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');
      CreateRevaluationJournal(ItemJournalLine);
      Item.GET(ItemNo);
      CalcInventoryValue(Item,ItemJournalLine);

      // Verify: Verify that Revalued Inventory is equal to Calculated Inventory.
      VerifyRevaluedInventory(Item);

      // Exercise: Update Revalued Unit Cost and Post Item Journal Line, Run Adjust Cost Item Entries.
      OldUnitCost := Item."Standard Cost";
      NewUnitCost :=
        UpdateRevaluedUnitCost(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",OldUnitCost);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');

      // Verify: Verify Value Entries.
      VerifyValueEntryLessInvoice(Item."No.",OldUnitCost,OldUnitCost - NewUnitCost,InitialInventory,Qty,InvQty);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE StdPurchTwiceRevalTwice@45();
    VAR
      Item@1012 : Record 27;
      InventorySetup@1011 : Record 313;
      ItemJournalLine@1010 : Record 83;
      PurchaseHeader@1009 : Record 38;
      PurchaseHeader2@1008 : Record 38;
      InventoryPostingGroup@1016 : Code[10];
      ItemNo@1007 : Code[20];
      LocationCode@1015 : Code[10];
      AutomaticCostAdjustment@1006 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1005 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1004 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      ItemCostingMethod@1014 : 'FIFO,LIFO,Specific,Average,Standard';
      Qty@1002 : Decimal;
      InvQty@1019 : Decimal;
      OldUnitCost@1001 : Decimal;
      NewUnitCost@1000 : Decimal;
      OldUnitCost2@1018 : Decimal;
      NewUnitCost2@1017 : Decimal;
    BEGIN
      // Covers TFS_TC_ID = 6169,6173
      // Setup: Update Inventory Setup, Create Item and Purchase Order and Post Purchase Order as Receive.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LocationCode := CreateLocationCode(InventoryPostingGroup);
      ItemNo := CreateItem(ItemCostingMethod::Standard,InventoryPostingGroup);
      Qty := LibraryRandom.RandInt(10) + 50;
      CreatePurchaseOrder(PurchaseHeader,ItemNo,'',Qty,LocationCode,FALSE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);

      // Exercise: Run Adjust Cost Item Entries, Create Revaluation Journal, Calculate Inventory Value.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');
      CreateRevaluationJournal(ItemJournalLine);
      Item.GET(ItemNo);
      CalcInventoryValue(Item,ItemJournalLine);

      // Verify: Verify that Revalued Inventory is equal to Calculated Inventory.
      VerifyRevaluedInventory(Item);

      // Exercise: Update Revalued Unit Cost and Post Item Journal Line.
      // Run Adjust Cost Item Entries, Create Revaluation Journal, Calculate Inventory Value.
      OldUnitCost := Item."Standard Cost";
      NewUnitCost :=
        UpdateRevaluedUnitCost(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",OldUnitCost);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      CreatePurchaseOrder(PurchaseHeader2,ItemNo,'',LibraryRandom.RandInt(10),LocationCode,FALSE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader2,TRUE,FALSE);
      LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);
      InvQty := Qty - 10;
      PurchaseOrderInvoiceLessQty(PurchaseHeader."No.",InvQty);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE);
      CreateRevaluationJournal(ItemJournalLine);
      Item.GET(ItemNo);
      CalcInventoryValue(Item,ItemJournalLine);

      // Verify: Verify that Revalued Inventory is equal to Calculated Inventory.
      VerifyRevaluedInventory(Item);

      // Exercise: Update Revalued Unit Cost and Post Item Journal Line.
      OldUnitCost2 := Item."Standard Cost";
      NewUnitCost2 :=
        UpdateRevaluedUnitCost(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",OldUnitCost);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');

      // Verify: Verify Value Entries. check that without Sales Order.
      VerifyValueEntryRevalNoSales(Item."No.",OldUnitCost,NewUnitCost - OldUnitCost,NewUnitCost2 - OldUnitCost2,Qty,InvQty);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE StdPurchRevalTwiceSales@7();
    VAR
      Item@1013 : Record 27;
      InventorySetup@1012 : Record 313;
      PurchaseHeader@1011 : Record 38;
      SalesHeader@1010 : Record 36;
      ItemJournalLine@1009 : Record 83;
      AutomaticCostAdjustment@1007 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1006 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1005 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      ItemCostingMethod@1014 : 'FIFO,LIFO,Specific,Average,Standard';
      InventoryPostingGroup@1016 : Code[10];
      ItemNo@1003 : Code[20];
      LocationCode@1015 : Code[10];
      Qty@1002 : Decimal;
      InvQty@1019 : Decimal;
      OldUnitCost@1001 : Decimal;
      NewUnitCost@1000 : Decimal;
      OldUnitCost2@1018 : Decimal;
      NewUnitCost2@1017 : Decimal;
    BEGIN
      // Covers TFS_TC_ID = 6170,6171,6178
      // Setup: Update Inventory Setup, Create Item and Purchase Order and Post Purchase Order as Receive.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LocationCode := CreateLocationCode(InventoryPostingGroup);
      ItemNo := CreateItem(ItemCostingMethod::Standard,InventoryPostingGroup);
      Qty := LibraryRandom.RandInt(10) + 50;
      CreatePurchaseOrder(PurchaseHeader,ItemNo,'',Qty,LocationCode,FALSE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);

      // Exercise: Run Adjust Cost Item Entries, Create Revaluation Journal, Calculate Inventory Value.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');
      CreateRevaluationJournal(ItemJournalLine);
      Item.GET(ItemNo);
      CalcInventoryValue(Item,ItemJournalLine);

      // Verify: Verify that Revalued Inventory is equal to Calculated Inventory.
      VerifyRevaluedInventory(Item);

      // Exercise: Update Revalued Unit Cost and Post Item Journal Line.
      OldUnitCost := Item."Standard Cost";
      NewUnitCost :=
        UpdateRevaluedUnitCost(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",OldUnitCost);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);
      InvQty := Qty - 10;
      PurchaseOrderInvoiceLessQty(PurchaseHeader."No.",Qty - 10);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE);
      CreateRevaluationJournal(ItemJournalLine);
      Item.GET(ItemNo);
      CalcInventoryValue(Item,ItemJournalLine);

      // Verify: Verify that Revalued Inventory is equal to Calculated Inventory.
      VerifyRevaluedInventory(Item);

      // Exercise: Update Revalued Unit Cost and Post Item Journal Line.
      OldUnitCost2 := Item."Standard Cost";
      NewUnitCost2 :=
        UpdateRevaluedUnitCost(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",OldUnitCost);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      CreateSalesOrder(SalesHeader,Item."No.",Qty,LocationCode,FALSE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');

      // Verify: Verify Value Entries after twice revaluation.
      VerifyValueEntryRevalTwice(Item."No.",OldUnitCost,NewUnitCost - OldUnitCost,NewUnitCost2 - OldUnitCost2,NewUnitCost2,Qty,InvQty);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE AvgPurchRevalSales@9();
    VAR
      Item@1015 : Record 27;
      InventorySetup@1014 : Record 313;
      PurchaseHeader@1013 : Record 38;
      SalesHeader@1012 : Record 36;
      ItemJournalLine@1011 : Record 83;
      AutomaticCostAdjustment@1009 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1008 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1007 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      ItemCostingMethod@1005 : 'FIFO,LIFO,Specific,Average,Standard';
      InventoryPostingGroup@1016 : Code[10];
      ItemNo@1004 : Code[20];
      LocationCode@1000 : Code[10];
      Qty@1003 : Decimal;
      OldUnitCost@1002 : Decimal;
      NewUnitCost@1001 : Decimal;
    BEGIN
      // Covers TFS_TC_ID = 4009
      // Setup: Update Inventory Setup, Create Item and Purchase Order and Post Purchase Order.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LocationCode := CreateLocationCode(InventoryPostingGroup);
      ItemNo := CreateItem(ItemCostingMethod::Average,InventoryPostingGroup);
      Qty := LibraryRandom.RandInt(10) + 50;
      CreatePurchaseOrder(PurchaseHeader,ItemNo,'',Qty,LocationCode,FALSE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      TransferQtyDiffLocation(ItemNo,LocationCode);

      // Exercise: Run Adjust Cost Item Entries, Create Revaluation Journal, Calculate Inventory Value.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');
      CreateRevaluationJournal(ItemJournalLine);
      Item.GET(ItemNo);
      CalcInventoryValue(Item,ItemJournalLine);

      // Verify: Verify that Revalued Inventory is equal to Calculated Inventory.
      VerifyRevaluedInventory(Item);

      // Exercise: Update Revalued Unit Cost and Post Item Journal Line.
      OldUnitCost := Item."Unit Cost";
      NewUnitCost :=
        UpdateRevaluedUnitCost(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",OldUnitCost);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      CreateSalesOrder(SalesHeader,Item."No.",Qty,LocationCode,TRUE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');

      // Verify: Verify Value Entries, GL entries for multiple locations.
      VerifyValueEntry(Qty,Item."No.",OldUnitCost,NewUnitCost,OldUnitCost - NewUnitCost,0,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler,CalculateStdCostMenuHandler,ProdJournalPageHandler)]
    PROCEDURE StdPurchRevalProduction@11();
    VAR
      Item@1022 : Record 27;
      InventorySetup@1021 : Record 313;
      ManufacturingSetup@1018 : Record 99000765;
      ItemJournalLine@1027 : Record 83;
      PurchaseHeader@1033 : Record 38;
      ProductionOrder@1002 : Record 5405;
      CalculateStandardCost@1011 : Codeunit 5812;
      LocationCode@1001 : Code[10];
      InventoryPostingGroup@1032 : Code[10];
      ItemNo@1024 : Code[20];
      ItemNo2@1005 : Code[20];
      ProductionItemNo@1026 : Code[20];
      RoutingNo@1003 : Code[10];
      Qty@1000 : Decimal;
      OldUnitCost@1030 : Decimal;
      NewUnitCost@1029 : Decimal;
      OldUnitCost2@1028 : Decimal;
      NewUnitCost2@1034 : Decimal;
      OldUnitCost3@1036 : Decimal;
      NewUnitCost3@1035 : Decimal;
    BEGIN
      // Covers TFS_TC_ID = 6209,4006
      // Setup: Update Manufacturing Setup and Inventory Setup.
      Initialize;
      ExecuteUIHandlers;
      LibraryManufacturing.UpdateManufacturingSetup(ManufacturingSetup,'','',TRUE,TRUE,TRUE);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,
        InventorySetup."Average Cost Calc. Type"::Item,InventorySetup."Average Cost Period"::Day);

      // Create Work Center and Machine Center with required Flushing method and Create Routing.
      CreateRoutingSetup(RoutingNo);

      // Create child Items with the required Costing method and the parent Item with Routing No. and Production BOM No.
      LocationCode := CreateLocationCode(InventoryPostingGroup);
      ItemNo := CreateItem(Item."Costing Method"::Standard,InventoryPostingGroup);
      ItemNo2 := CreateItem(Item."Costing Method"::Standard,InventoryPostingGroup);
      CreateProdItemWithBOM(Item,Item."Costing Method"::Standard,ItemNo,ItemNo2,InventoryPostingGroup,RoutingNo);
      ProductionItemNo := Item."No.";
      CLEAR(Item);

      // Calculate Standard Cost for the parent Item.
      CalculateStandardCost.CalcItem(ProductionItemNo,FALSE);
      Qty := LibraryRandom.RandInt(10) + 50;
      CreatePurchaseOrder(PurchaseHeader,ItemNo,ItemNo2,Qty,LocationCode,TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // Exercise: Run Adjust Cost Item Entries, Create Revaluation Journal, Calculate Inventory Value for component Item 1.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');
      CreateRevaluationJournal(ItemJournalLine);
      Item.GET(ItemNo);
      CalcInventoryValue(Item,ItemJournalLine);

      // Verify: Verify that Revalued Inventory is equal to Calculated Inventory for component Item 1.
      VerifyRevaluedInventory(Item);

      // Exercise: Update Revalued Unit Cost and Post Item Journal Line for component Item 1.
      OldUnitCost := Item."Standard Cost";
      NewUnitCost :=
        UpdateRevaluedUnitCost(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",OldUnitCost);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Verify: Item Cost with revalued cost for component Item 1.
      VerifyItemCost(ItemNo,NewUnitCost);

      // Exercise: Run Adjust Cost Item Entries, Create Revaluation Journal, Calculate Inventory Value for component Item 2.
      LibraryCosting.AdjustCostItemEntries(ItemNo2,'');
      CreateRevaluationJournal(ItemJournalLine);
      Item.GET(ItemNo2);
      CalcInventoryValue(Item,ItemJournalLine);

      // Verify: Verify that Revalued Inventory is equal to Calculated Inventory for component Item 2.
      VerifyRevaluedInventory(Item);

      // Exercise: Update Revalued Unit Cost and Post Item Journal Line for component Item 2.
      OldUnitCost2 := Item."Standard Cost";
      NewUnitCost2 :=
        UpdateRevaluedUnitCost(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",OldUnitCost2);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Verify: Item Cost with revalued cost for component Item 2.
      VerifyItemCost(ItemNo2,NewUnitCost2);

      // Create and Refresh Production Order and Post Production Journal.
      CreateAndRefreshRelProdOrder(ProductionOrder,ProductionItemNo,LibraryRandom.RandInt(9) + 1,LocationCode);
      ProductionOrderNo := ProductionOrder."No.";
      PostProductionJournal(ProductionOrder);

      // Exercise: Run Adjust Cost Item Entries, Create Revaluation Journal, Calculate Inventory Value for Finished Item.
      LibraryCosting.AdjustCostItemEntries(ProductionItemNo,'');
      CreateRevaluationJournal(ItemJournalLine);
      Item.GET(ProductionItemNo);
      CalcInventoryValue(Item,ItemJournalLine);

      // Verify: Verify that Revalued Inventory is equal to Calculated Inventory for Finished Item.
      VerifyRevaluedInventory(Item);

      // Exercise: Post Revaluation Journal for Finished Item.
      OldUnitCost3 := Item."Standard Cost";
      NewUnitCost3 :=
        UpdateRevaluedUnitCost(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",OldUnitCost3);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Verify: Item Cost with revalued cost for Finished Item.
      VerifyItemCost(ProductionItemNo,NewUnitCost3);

      // Exercise: Finish Production Order and Run Adjust Cost Item Entries.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrderNo);
      LibraryCosting.AdjustCostItemEntries('','');
      LibraryCosting.PostInvtCostToGL(FALSE,WORKDATE,'');

      // Verify: Verify Value Entries.
      VerifyValueEntryComponentItem(Qty,ItemNo,OldUnitCost,NewUnitCost,OldUnitCost - NewUnitCost);
      VerifyValueEntryComponentItem(Qty,ItemNo2,OldUnitCost2,NewUnitCost2,OldUnitCost2 - NewUnitCost2);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler,ProdJournalPageHandler)]
    PROCEDURE FIFORevalProduction@40();
    VAR
      Item@1001 : Record 27;
      ProductionOrder@1010 : Record 5405;
      ItemJournalLine@1011 : Record 83;
      ItemLedgerEntry@1012 : Record 32;
      InventoryPostingGroup@1002 : Code[10];
      ItemNo@1004 : Code[20];
      ItemNo2@1003 : Code[20];
      NegLedgerEntryDocNo@1008 : Code[20];
      Quantity@1009 : Integer;
      OldUnitCost@1014 : Decimal;
      NewUnitCost@1013 : Decimal;
      ExpectedCostAmount@1015 : Decimal;
    BEGIN
      // Setup: Update Inventory Setup.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Always,
        InventorySetup."Average Cost Calc. Type"::Item,InventorySetup."Average Cost Period"::Day);

      // Create child Items with required Costing method and Inventory,Create Production BOM.
      CreateLocationCode(InventoryPostingGroup);
      ItemNo := CreateItem(Item."Costing Method"::FIFO,InventoryPostingGroup);
      ItemNo2 := CreateItem(Item."Costing Method"::FIFO,InventoryPostingGroup);
      UpdateItemInventory(ItemNo,'');
      UpdateItemInventory(ItemNo2,'');
      CreateProdItemWithBOM(Item,Item."Costing Method"::FIFO,ItemNo,ItemNo2,InventoryPostingGroup,'');

      // Create Production Order, Refresh and Post Production Journal.
      Quantity := LibraryRandom.RandInt(2);  // Required at multiple places.
      CreateAndRefreshRelProdOrder(ProductionOrder,Item."No.",Quantity,'');
      ProductionOrderNo := ProductionOrder."No.";
      PostProductionJournal(ProductionOrder);

      // Create Output with negative qty, apply to existing item ledger entry for production item, post to make the Output Nil.
      SelectItemLedgerEntry(ItemLedgerEntry,Item."No.");
      CreateOutputJournal(ItemJournalLine,Item."No.",ProductionOrderNo,-Quantity);
      UpdateAppliesToEntry(ItemJournalLine,ItemLedgerEntry."Entry No.");
      LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
      NegLedgerEntryDocNo := ItemJournalLine."Document No.";

      // Post Output again with positive quantity, finish the Released Production Order and Adjust Cost.
      CreateOutputJournal(ItemJournalLine,Item."No.",ProductionOrderNo,Quantity);
      LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);

      // Exercise: Finish Production Order and run Adjust Cost.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrderNo);

      // Verify: Verify Cost Amount (Actual) for both positive and negative entries in Item Ledger Entry.
      Item.GET(Item."No.");
      OldUnitCost := Item."Unit Cost";
      ExpectedCostAmount := OldUnitCost * Quantity;
      VerifyItemLedgerEntryCostAmt(ItemLedgerEntry."Document No.",ExpectedCostAmount);
      VerifyItemLedgerEntryCostAmt(NegLedgerEntryDocNo,-ExpectedCostAmount);

      // Create Revaluation Journal and apply to first ILE of production Item.
      CreateRevaluationJournal(ItemJournalLine);
      UpdateRevalAppliesToEntry(ItemJournalLine,Item."No.",ItemLedgerEntry."Entry No.");

      // Exercise: Post Revalaution Journal with new Unit Cost for production item.
      NewUnitCost :=
        UpdateRevaluedUnitCost(
          RevaluationItemJournalBatch."Journal Template Name",RevaluationItemJournalBatch.Name,Item."No.",OldUnitCost);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Verify: Verify Cost Amount (Actual) for both positive and negative entries in Item Ledger Entry.
      ExpectedCostAmount := NewUnitCost * Quantity;
      VerifyItemLedgerEntryCostAmt(ItemLedgerEntry."Document No.",ExpectedCostAmount);
      VerifyItemLedgerEntryCostAmt(NegLedgerEntryDocNo,-ExpectedCostAmount);
    END;

    [Test]
    PROCEDURE PerEntryRevaluationCanBePostedIfNoPartialRevaluation@2();
    VAR
      Item@1000 : Record 27;
      NewUnitCost@1003 : Decimal;
    BEGIN
      Initialize;

      CreateItemWithInventoryValue(Item);
      NewUnitCost := PostItemLedgerEntryRevaluation(Item);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      Item.FIND('=');
      Assert.AreEqual(NewUnitCost,Item."Unit Cost",CostMustBeEqualErr);
    END;

    [Test]
    PROCEDURE PerEntryRevaluationCannotBePostedAfterPartialRevaluation@10();
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1001 : Record 83;
      ItemLedgerEntry@1004 : Record 32;
    BEGIN
      Initialize;

      CreateItemWithInventoryValue(Item);
      PostItemRevaluation(Item,WORKDATE);

      CreateRevaluationJournal(ItemJournalLine);
      SelectPurchItemLedgEntry(ItemLedgerEntry,Item."No.");
      ASSERTERROR UpdateRevalAppliesToEntry(ItemJournalLine,Item."No.",ItemLedgerEntry."Entry No.");

      Assert.ExpectedError(PerEntryRevaluationErr);
    END;

    [Test]
    PROCEDURE PartialRevaluationCanBePostedAfterPerEntry@21();
    VAR
      Item@1000 : Record 27;
      NewUnitCost@1004 : Decimal;
    BEGIN
      Initialize;

      CreateItemWithInventoryValue(Item);
      PostItemLedgerEntryRevaluation(Item);
      NewUnitCost := PostItemRevaluation(Item,WORKDATE);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      Item.FIND('=');
      Assert.AreEqual(NewUnitCost,Item."Unit Cost",CostMustBeEqualErr);
    END;

    [Test]
    [HandlerFunctions(CalculateStdCostMenuHandler)]
    PROCEDURE OutputRevaluedAndRevertedIncludedInCostAdjustment@31();
    VAR
      ComponentItem@1000 : Record 27;
      ParentItem@1001 : Record 27;
      ProductionOrder@1007 : Record 5405;
      Quantity@1002 : Integer;
      ValuationDate@1003 : Date;
    BEGIN
      // [FEATURE] [Production Order] [Adjust Cost Item Entries]
      // [SCENARIO 378471] "Adjust Cost - Item Entries" job should consider reversed prod. order output when it is revalued on a later date

      Initialize;

      // [GIVEN] Create component item "I1" with "Average" costing method and produced item "I2" which includes "I1" in its prod. BOM, costing method = "Standard"
      CreateItemWithUnitCost(ComponentItem,ComponentItem."Costing Method"::Average,LibraryRandom.RandDec(100,2));
      CreateItemWithProductionBOM(ParentItem,ComponentItem."No.",1);

      Quantity := LibraryRandom.RandInt(10);
      ValuationDate := WORKDATE + LibraryRandom.RandInt(5);
      // [GIVEN] Post income of item "I1" on inventory with unit cost = "C"
      UpdateItemInventory(ComponentItem."No.",'');
      // [GIVEN] Create production order for item "I2" and post output of "X" pcs on workdate
      CreateAndRefreshRelProdOrder(ProductionOrder,ParentItem."No.",Quantity,'');
      PostOutputJournalOnDate(ProductionOrder."No.",ParentItem."No.",Quantity,WORKDATE);

      // [GIVEN] Consume component item "I1"
      PostProdOrderConsumption(ProductionOrder."No.");
      // [GIVEN] Revaluate item "I2" on WORKDATE + 3
      PostItemRevaluation(ParentItem,ValuationDate);
      // [GIVEN] Revert output on WORKDATE + 3 days
      RevertProdOrderOutput(ProductionOrder."No.",ParentItem."No.",ValuationDate);
      // [GIVEN] Post new output on WORKDATE + 3
      PostOutputJournalOnDate(ProductionOrder."No.",ParentItem."No.",Quantity,ValuationDate);

      // [GIVEN] Finish production order
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

      // [WHEN] Run cost adjustment
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ParentItem."No.",ComponentItem."No."),'');

      // [THEN] Total direct cost amount of item "I2" is "X" * "C"
      ComponentItem.FIND;
      VerifyDirectCostAmount(ParentItem."No.",Quantity * ComponentItem."Unit Cost");
    END;

    [Test]
    [HandlerFunctions(CalculateStdCostMenuHandler)]
    PROCEDURE StandardCostVarianceForwardedToAppliedOutboudOutput@231();
    VAR
      ComponentItem@1000 : Record 27;
      ParentItem@1001 : Record 27;
      ProductionOrder@1007 : Record 5405;
      ItemLedgEntryNo@1003 : ARRAY [3] OF Integer;
      I@1002 : Integer;
    BEGIN
      // [FEATURE] [Production Order] [Adjust Cost Item Entries] [Post Inventory Cost to G/L]
      // [SCENARIO 378538] Standard cost variance created during WIP adjustment and forwarded to applied output reversal entry, can be posted to G/L

      Initialize;

      // [GIVEN] Component item "I1" with unit cost 17.33333
      CreateItemWithUnitCost(ComponentItem,ComponentItem."Costing Method"::FIFO,17.33333);

      // [GIVEN] Manufactured item "I2" which includes "I1" as a component
      CreateItemWithProductionBOM(ParentItem,ComponentItem."No.",1);

      // [GIVEN] Create released production order for 5 pcs of item "I2"
      UpdateItemInventory(ComponentItem."No.",'');
      CreateAndRefreshRelProdOrder(ProductionOrder,ParentItem."No.",5,'');

      // [GIVEN] Post production order consumption and output of 5 pcs
      PostProdOrderConsumption(ProductionOrder."No.");
      PostOutputJournalOnDate(ProductionOrder."No.",ParentItem."No.",5,WORKDATE);

      // [GIVEN] Post 3 additional output entries, 2 pcs each
      FOR I := 1 TO 3 DO
        ItemLedgEntryNo[I] := PostOutputJournalFindEntry(ProductionOrder."No.",ParentItem."No.",2,WORKDATE);

      // [GIVEN] Revert extra output with fixed cost application
      RevertProdOrderOutputEntry(ProductionOrder."No.",ParentItem."No.",-2,ItemLedgEntryNo[2]);
      RevertProdOrderOutputEntry(ProductionOrder."No.",ParentItem."No.",-2,ItemLedgEntryNo[3]);
      RevertProdOrderOutputEntry(ProductionOrder."No.",ParentItem."No.",-2,ItemLedgEntryNo[1]);

      // [GIVEN] Revaluate item "I1". New unit cost = 17.335
      RevaluateItem(ComponentItem,0.002);

      // [GIVEN] Finish production order and run cost adjustment for item "I1"
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");
      LibraryCosting.AdjustCostItemEntries(ParentItem."No.",'');

      // [WHEN] Post inventory cost to G/L
      LibraryCosting.PostInvtCostToGL(FALSE,WORKDATE,'');

      // [THEN] All actual cost amounts are posted to G/L
      VerifyActualCostPostedToGL(ProductionOrder."No.");
    END;

    [Test]
    PROCEDURE AppliesToEntryInRevaluationJournalWithDeletedItem@51();
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1001 : Record 83;
      ItemLedgerEntry@1002 : Record 32;
      RevaluationJournal@1003 : TestPage 5803;
      PostingDate@1005 : Date;
    BEGIN
      // [FEATURE] [Applies-to Entry]
      // [SCENARIO 359734] It should be possible to post revaluation of an item ledger entry when there are ILE's with blank "Item No."

      Initialize;

      // [GIVEN] Item "I1" with average costing method
      CreateItemWithCostingMethod(Item,Item."Costing Method"::Average);

      // [GIVEN] Purchase item in a closed accounting period. This is required to be able to delete the item later
      PostingDate := LibraryFiscalYear.GetLastPostingDate(TRUE);
      PostItemJournalLine(
        ItemJournalLine."Entry Type"::Purchase,Item."No.",LibraryRandom.RandDec(100,2),'',LibraryRandom.RandDec(100,2),PostingDate);

      // [GIVEN] Run "Adjust Cost - Item Entries" job to make revaluation possible
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // [GIVEN] Calculate inventory value for item "I1" and post revaluation per item
      CreateRevaluationJournal(ItemJournalLine);
      CalcInventoryValueOnDate(Item,ItemJournalLine,PostingDate);
      UpdateRevaluedUnitCost(
        ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",
        LibraryRandom.RandDecInRange(200,300,2));
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // [GIVEN] Sell all stock of item "I1"
      Item.CALCFIELDS(Inventory);
      PostItemJournalLine(ItemJournalLine."Entry Type"::Sale,Item."No.",Item.Inventory,'',LibraryRandom.RandDec(100,2),PostingDate);

      // [GIVEN] Adjust cost of item "I1" and delete the item
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
      Item.FIND;
      Item.DELETE(TRUE);

      // [GIVEN] Create item "I2" with average costing method and post an inbound item ledger entry for "I2"
      CreateItemWithCostingMethod(Item,Item."Costing Method"::Average);
      PostItemJournalLine(
        ItemJournalLine."Entry Type"::Purchase,Item."No.",LibraryRandom.RandDec(100,2),'',LibraryRandom.RandDec(100,2),PostingDate);

      // [GIVEN] Create a revaluation journal line for item "I2"
      CreateRevaluationJournal(ItemJournalLine);
      RevaluationJournal.OPENEDIT;
      RevaluationJournal.GOTORECORD(ItemJournalLine);
      RevaluationJournal."Item No.".SETVALUE(Item."No.");

      SelectPurchItemLedgEntry(ItemLedgerEntry,Item."No.");

      // [WHEN] Set the "Applies-to Entry" in the journal line
      RevaluationJournal."Applies-to Entry".SETVALUE(ItemLedgerEntry."Entry No.");

      // [THEN] Entry No. is validated
      RevaluationJournal.Quantity.ASSERTEQUALS(ItemLedgerEntry.Quantity);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE ExpectedCostNotIncludedInAvgCostCalculationForItemWithAvgCostingMethod@57();
    VAR
      Location@1000 : Record 14;
      Item@1001 : Record 27;
      PurchaseHeader@1004 : Record 38;
      ItemJournalLine@1005 : Record 83;
      PostingDate@1007 : Date;
      UnitCost@1002 : ARRAY [3] OF Decimal;
      Qty@1003 : Decimal;
      i@1006 : Integer;
    BEGIN
      // [FEATURE] [Calculate Inventory Value] [Average Costing Method] [Unit Cost]
      // [SCENARIO 209978] Expected cost should not be included in average cost calculation for item with Costing Method = Average.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,
        InventorySetup."Average Cost Calc. Type"::"Item & Location & Variant",InventorySetup."Average Cost Period"::Day);

      // [GIVEN] Item with Costing Method = Average.
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Average,0);

      // [GIVEN] Two purchase orders "P1" and "P2" for the item.
      // [GIVEN] "P1" is received and invoiced, "P2" is received but not invoiced.
      Qty := LibraryRandom.RandInt(10);
      FOR i := 1 TO 2 DO
        UnitCost[i] := LibraryRandom.RandDec(100,2);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);

      PostingDate := LibraryFiscalYear.GetFirstPostingDate(FALSE);
      LibraryPatterns.POSTPurchaseOrder(PurchaseHeader,Item,Location.Code,'',Qty,PostingDate,UnitCost[1],TRUE,TRUE);
      LibraryPatterns.POSTPurchaseOrder(PurchaseHeader,Item,Location.Code,'',Qty,PostingDate,UnitCost[2],TRUE,FALSE);

      // [WHEN] Calculate inventory value in revaluation journal for the item.
      CreateRevaluationJournalAndCalcInventoryValueByLocAndVar(Item);

      // [THEN] Unit Cost on the revaluation journal line is equal to the direct unit cost in "P1".
      FilterRevaluationJournalLine(ItemJournalLine,Item."No.",Location.Code);
      VerifyRevaluationJournalLine(ItemJournalLine,Qty,UnitCost[1]);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE TransferRelatedToNotInvoicedPurchNotIncludedInAvgCostCalculationWithFilterOnSourceLoc@59();
    VAR
      FromLocation@1009 : Record 14;
      ToLocation@1008 : Record 14;
      Item@1006 : Record 27;
      ItemJournalLine@1003 : Record 83;
      UnitCost@1002 : ARRAY [3] OF Decimal;
      Qty@1001 : Decimal;
    BEGIN
      // [FEATURE] [Calculate Inventory Value] [Average Costing Method] [Unit Cost] [Transfer]
      // [SCENARIO 209978] Calculate inventory value run with a filter by location should exclude from average cost calculation not posted purchases and outbound transfers applied to them.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,
        InventorySetup."Average Cost Calc. Type"::"Item & Location & Variant",InventorySetup."Average Cost Period"::Day);

      // [GIVEN] Item with Costing Method = Average.
      // [GIVEN] Received not invoiced purchase "P1" on location "L1".
      // [GIVEN] Transfer of the received quantity from location "L1" to "L2".
      // [GIVEN] Received and invoiced purchase "P2" on location "L1".
      CreateAvgCostItemAndPostPurchasesAndTransfer(Item,FromLocation,ToLocation,Qty,UnitCost);

      // [WHEN] Calculate inventory value in revaluation journal for the item and location filter = "L1".
      Item.SETRANGE("Location Filter",FromLocation.Code);
      CreateRevaluationJournalAndCalcInventoryValueByLocAndVar(Item);

      // [THEN] Unit Cost on the revaluation journal line is equal to the direct unit cost in "P2".
      FilterRevaluationJournalLine(ItemJournalLine,Item."No.",FromLocation.Code);
      VerifyRevaluationJournalLine(ItemJournalLine,Qty,UnitCost[2]);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE TransferRelatedToNotInvoicedPurchNotIncludedInAvgCostCalculationWithFilterOnDestLoc@60();
    VAR
      FromLocation@1005 : Record 14;
      ToLocation@1004 : Record 14;
      Item@1003 : Record 27;
      ItemJournalLine@1002 : Record 83;
      UnitCost@1001 : ARRAY [3] OF Decimal;
      Qty@1000 : Decimal;
    BEGIN
      // [FEATURE] [Calculate Inventory Value] [Average Costing Method] [Unit Cost] [Transfer]
      // [SCENARIO 209978] Calculate inventory value run with a filter by location should exclude from average cost calculation inbound transfers applied to not posted purchases.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,
        InventorySetup."Average Cost Calc. Type"::"Item & Location & Variant",InventorySetup."Average Cost Period"::Day);

      // [GIVEN] Item with Costing Method = Average.
      // [GIVEN] Received not invoiced purchase "P1" on location "L1".
      // [GIVEN] Transfer of the received quantity from location "L1" to "L2".
      // [GIVEN] Received and invoiced purchase "P2" on location "L2".
      CreateAvgCostItemAndPostPurchasesAndTransfer(Item,FromLocation,ToLocation,Qty,UnitCost);

      // [WHEN] Calculate inventory value in revaluation journal for the item and location filter = "L2".
      Item.SETFILTER("Location Filter",ToLocation.Code);
      CreateRevaluationJournalAndCalcInventoryValueByLocAndVar(Item);

      // [THEN] Unit Cost on the revaluation journal line is equal to the direct unit cost in "P2".
      FilterRevaluationJournalLine(ItemJournalLine,Item."No.",ToLocation.Code);
      VerifyRevaluationJournalLine(ItemJournalLine,Qty,UnitCost[3]);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE TransferRelatedToNotInvoicedPurchNotIncludedInAvgCostCalculationWithNoLocFilter@62();
    VAR
      FromLocation@1005 : Record 14;
      ToLocation@1004 : Record 14;
      Item@1003 : Record 27;
      ItemJournalLine@1002 : Record 83;
      UnitCost@1001 : ARRAY [3] OF Decimal;
      Qty@1000 : Decimal;
    BEGIN
      // [FEATURE] [Calculate Inventory Value] [Average Costing Method] [Unit Cost] [Transfer]
      // [SCENARIO 209978] Calculate inventory value run without location filter should exclude from average cost calculation not invoiced purchases and transfers applied to them.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,
        InventorySetup."Average Cost Calc. Type"::"Item & Location & Variant",InventorySetup."Average Cost Period"::Day);

      // [GIVEN] Item with Costing Method = Average.
      // [GIVEN] Received not invoiced purchase "P1" on location "L1".
      // [GIVEN] Transfer of the received quantity from location "L1" to "L2".
      // [GIVEN] Received and invoiced purchase "P2" on location "L1".
      // [GIVEN] Received and invoiced purchase "P3" on location "L2".
      CreateAvgCostItemAndPostPurchasesAndTransfer(Item,FromLocation,ToLocation,Qty,UnitCost);

      // [WHEN] Calculate inventory value in revaluation journal for the item with no location filter.
      CreateRevaluationJournalAndCalcInventoryValueByLocAndVar(Item);

      // [THEN] Unit Cost on the revaluation journal line with location "L1" is equal to the direct unit cost in "P2".
      FilterRevaluationJournalLine(ItemJournalLine,Item."No.",FromLocation.Code);
      VerifyRevaluationJournalLine(ItemJournalLine,Qty,UnitCost[2]);

      // [THEN] Unit Cost on the revaluation journal line with location "L2" is equal to the direct unit cost in "P3".
      FilterRevaluationJournalLine(ItemJournalLine,Item."No.",ToLocation.Code);
      VerifyRevaluationJournalLine(ItemJournalLine,Qty,UnitCost[3]);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AvgCostOnWorkdateDoesNotIncludeActualCostPostedOnLaterDate@63();
    VAR
      Location@1009 : Record 14;
      Item@1006 : Record 27;
      PurchaseHeader@1005 : Record 38;
      ItemJournalLine@1003 : Record 83;
      UnitCost@1002 : ARRAY [2] OF Decimal;
      Qty@1001 : ARRAY [2] OF Decimal;
      i@1000 : Integer;
    BEGIN
      // [FEATURE] [Calculate Inventory Value] [Average Costing Method] [Unit Cost]
      // [SCENARIO 209978] Average cost calculation should include only actual cost posted no later than the revaluation date.
      Initialize;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,
        InventorySetup."Average Cost Calc. Type"::"Item & Location & Variant",InventorySetup."Average Cost Period"::Day);

      // [GIVEN] Item with Costing Method = Average.
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Average,0);

      // [GIVEN] Partially posted purchase order on WORKDATE.
      // [GIVEN] Received quantity = invoiced quantity = "q". Full quantity of the purchase line = "Q".
      // [GIVEN] Direct Unit Cost on the purchase line = "X".
      FOR i := 1 TO ARRAYLEN(Qty) DO BEGIN
        Qty[i] := LibraryRandom.RandInt(10);
        UnitCost[i] := LibraryRandom.RandDec(100,2);
      END;
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      LibraryPatterns.POSTPurchaseOrderPartially(
        PurchaseHeader,Item,Location.Code,'',Qty[1] + Qty[2],LibraryFiscalYear.GetFirstPostingDate(FALSE),
        UnitCost[1],TRUE,Qty[1],TRUE,Qty[1]);

      // [GIVEN] Direct Unit Cost on the purchase line is updated to "Y".
      // [GIVEN] Remaining quantity ("Q" - "q") in the purchase is received and invoiced.
      UpdatePostingDateAndVendorInvoiceNoOnPurchaseHeader(PurchaseHeader);
      UpdateDirectUnitCostOnPurchaseLine(PurchaseHeader,UnitCost[2]);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // [WHEN] Calculate inventory value in revaluation journal for the item.
      CreateRevaluationJournalAndCalcInventoryValueByLocAndVar(Item);

      // [THEN] Unit Cost on the revaluation journal line is equal to "X".
      FilterRevaluationJournalLine(ItemJournalLine,Item."No.",Location.Code);
      VerifyRevaluationJournalLine(ItemJournalLine,Qty[1],UnitCost[1]);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE CalculateInventoryValueForLocationAndVariantWithSpecialCharacters@48();
    VAR
      Item@1001 : Record 27;
      Location@1010 : Record 14;
      ItemVariant@1002 : Record 5401;
      ItemJournalLine@1005 : Record 83;
      UnitCost@1000 : Decimal;
      Qty@1003 : Decimal;
    BEGIN
      // [SCENARIO 200674] Inventory value can be calculated in revaluation journal when item variant code and location code contain filtering symbols ">", "<", "="

      Initialize;
      ExecuteUIHandlers;

      // [GIVEN] Set "Average Cost Calc. Type" = "Item & Location & Variant"
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,
        InventorySetup."Average Cost Calc. Type"::"Item & Location & Variant",InventorySetup."Average Cost Period"::Day);

      // [GIVEN] Item "I" with "Average" costing method
      UnitCost := LibraryRandom.RandIntInRange(100,200);
      Qty := LibraryRandom.RandInt(100);
      CreateItemWithUnitCost(Item,Item."Costing Method"::Average,UnitCost);

      // [GIVEN] Location with a code containing a special character "L>"
      Location.INIT;
      Location.VALIDATE(Code,COPYSTR(LibraryUtility.GenerateGUID,1,MAXSTRLEN(Location.Code) - 1) + '>');
      Location.INSERT(TRUE);
      LibraryInventory.UpdateInventoryPostingSetup(Location);

      // [GIVEN] Item variant with a code containing a special character "V="
      ItemVariant.INIT;
      ItemVariant.VALIDATE("Item No.",Item."No.");
      ItemVariant.VALIDATE(Code,COPYSTR(LibraryUtility.GenerateGUID,1,MAXSTRLEN(ItemVariant.Code) - 1) + '=');
      ItemVariant.INSERT(TRUE);

      // [GIVEN] Post item stock for item "I", variant "V=", on location "L>". Quantity = "Q", Unit cost = "C"
      LibraryInventory.CreateItemJournalLineInItemTemplate(ItemJournalLine,Item."No.",Location.Code,'',Qty);
      ItemJournalLine.VALIDATE("Variant Code",ItemVariant.Code);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // [WHEN] Calculate inventory value for item "I"
      CreateRevaluationJournal(ItemJournalLine);
      CalcInventoryValueWithLocationAndVariant(Item,ItemJournalLine,WORKDATE,TRUE,TRUE);

      // [THEN] Calculated unit cost = "C", calculated inventory value = "C" * "Q"
      ItemJournalLine.SETRANGE("Item No.",Item."No.");
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.TESTFIELD("Unit Cost (Calculated)",UnitCost);
      ItemJournalLine.TESTFIELD("Inventory Value (Calculated)",UnitCost * Qty);
    END;

    LOCAL PROCEDURE Initialize@4();
    VAR
      LibraryERMCountryData@1004 : Codeunit 131305;
    BEGIN
      IF isInitialized THEN
        EXIT;

      GeneralLedgerSetup.GET;

      // Setup Demonstration data.
      LibraryERMCountryData.CreateVATData;
      NoSeriesSetup;
      OutputJournalSetup;
      RevaluationJournalSetup;
      LibraryERMCountryData.UpdateGeneralLedgerSetup;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.UpdateLocalData;
      isInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE NoSeriesSetup@44();
    BEGIN
      SalesReceivablesSetup.GET;
      SalesReceivablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesReceivablesSetup.MODIFY(TRUE);

      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      PurchasesPayablesSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE OutputJournalSetup@144();
    BEGIN
      CLEAR(OutputItemJournalTemplate);
      OutputItemJournalTemplate.INIT;
      LibraryInventory.SelectItemJournalTemplateName(OutputItemJournalTemplate,OutputItemJournalTemplate.Type::Output);
      OutputItemJournalTemplate.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      OutputItemJournalTemplate.MODIFY(TRUE);

      CLEAR(OutputItemJournalBatch);
      OutputItemJournalBatch.INIT;
      LibraryInventory.SelectItemJournalBatchName(
        OutputItemJournalBatch,OutputItemJournalTemplate.Type,OutputItemJournalTemplate.Name);
      OutputItemJournalBatch.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      OutputItemJournalBatch.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE RevaluationJournalSetup@86();
    BEGIN
      CLEAR(RevaluationItemJournalTemplate);
      RevaluationItemJournalTemplate.INIT;
      LibraryInventory.SelectItemJournalTemplateName(RevaluationItemJournalTemplate,RevaluationItemJournalTemplate.Type::Revaluation);

      CLEAR(RevaluationItemJournalBatch);
      RevaluationItemJournalBatch.INIT;
      LibraryInventory.SelectItemJournalBatchName(RevaluationItemJournalBatch,RevaluationItemJournalTemplate.Type,
        RevaluationItemJournalTemplate.Name);
    END;

    LOCAL PROCEDURE ClearJournal@134(ItemJournalTemplate@1002 : Record 82;ItemJournalBatch@1001 : Record 233);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CLEAR(ItemJournalLine);
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalTemplate.Name);
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.DELETEALL;
    END;

    LOCAL PROCEDURE CreateItem@29(ItemCostingMethod@1002 : 'FIFO,LIFO,Specific,Average,Standard';InventoryPostingGroup@1003 : Code[10]) : Code[20];
    VAR
      Item@1001 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Inventory Posting Group",InventoryPostingGroup);

      IF ItemCostingMethod = ItemCostingMethod::Standard THEN BEGIN
        Item.VALIDATE("Costing Method",Item."Costing Method"::Standard);
        Item.VALIDATE("Standard Cost",LibraryRandom.RandDec(50,2));
        Item.VALIDATE("Last Direct Cost",Item."Standard Cost");
      END ELSE BEGIN
        Item.VALIDATE("Costing Method",ItemCostingMethod);
        Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(50,2));
        Item.VALIDATE("Last Direct Cost",Item."Unit Cost");
      END;
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateItemWithCostingMethod@70(VAR Item@1000 : Record 27;CostingMethod@1001 : Option);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Costing Method",CostingMethod);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemWithInventoryValue@41(VAR Item@1000 : Record 27);
    VAR
      LocationCode@1001 : Code[10];
      InventoryPostingGroup@1002 : Code[10];
      ItemNo@1003 : Code[20];
    BEGIN
      LocationCode := CreateLocationCode(InventoryPostingGroup);
      ItemNo := CreateItem(Item."Costing Method"::Average,InventoryPostingGroup);
      Item.GET(ItemNo);
      UpdateItemInventory(Item."No.",LocationCode);
    END;

    LOCAL PROCEDURE CreateItemWithProductionBOM@98(VAR ParentItem@1000 : Record 27;ChildItemNo@1003 : Code[20];QtyPer@1005 : Decimal);
    VAR
      ProductionBOMHeader@1001 : Record 99000771;
      CalculateStandardCost@1004 : Codeunit 5812;
    BEGIN
      LibraryInventory.CreateItem(ParentItem);

      WITH ParentItem DO BEGIN
        CreateProductionBOM(ProductionBOMHeader,ChildItemNo,"Base Unit of Measure",QtyPer);
        VALIDATE("Costing Method","Costing Method"::Standard);
        VALIDATE("Production BOM No.",ProductionBOMHeader."No.");
        VALIDATE("Replenishment System","Replenishment System"::"Prod. Order");
        MODIFY(TRUE);

        CalculateStandardCost.CalcItem("No.",FALSE);
      END;
    END;

    LOCAL PROCEDURE CreateItemWithUnitCost@43(VAR Item@1000 : Record 27;CostingMethod@1001 : Option;UnitCost@1002 : Decimal);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Costing Method",CostingMethod);
      Item.VALIDATE("Unit Cost",UnitCost);
      Item.VALIDATE("Last Direct Cost",UnitCost);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemInventory@25(ItemNo@1004 : Code[20];LocationCode@1005 : Code[10]);
    VAR
      ItemJournalLine@1003 : Record 83;
      Item@1006 : Record 27;
    BEGIN
      // Create Item Journal to populate Item Quantity.
      Item.GET(ItemNo);
      PostItemJournalLine(
        ItemJournalLine."Entry Type"::Purchase,ItemNo,LibraryRandom.RandInt(10) + 10,LocationCode,Item."Unit Cost",WORKDATE);
    END;

    LOCAL PROCEDURE CreateLocationsForTransfer@69(VAR FromLocation@1000 : Record 14;VAR ToLocation@1001 : Record 14;VAR InTransitLocation@1002 : Record 14);
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(FromLocation);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(ToLocation);
      LibraryWarehouse.CreateInTransitLocation(InTransitLocation);
    END;

    LOCAL PROCEDURE CreatePurchaseOrder@13(VAR PurchaseHeader@1001 : Record 38;ItemNo@1000 : Code[20];ItemNo2@1003 : Code[20];Qty@1002 : Decimal;LocationCode@1006 : Code[10];ProductionComponents@1004 : Boolean);
    VAR
      PurchaseLine@1007 : Record 39;
      DocumentType@1005 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,DocumentType::Order,'');
      PurchaseHeader.VALIDATE("Location Code",LocationCode);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Qty);
      IF ProductionComponents THEN
        LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo2,Qty);
    END;

    LOCAL PROCEDURE CreateLocationCode@19(VAR InventoryPostingGroup@1001 : Code[10]) : Code[10];
    VAR
      Location@1000 : Record 14;
      InventoryPostingGroupRec@1002 : Record 94;
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      InventoryPostingGroupRec.FINDFIRST;
      InventoryPostingGroup := InventoryPostingGroupRec.Code;
      EXIT(Location.Code);
    END;

    LOCAL PROCEDURE PurchaseOrderInvoiceLessQty@14(PurchaseDocumentNo@1000 : Code[20];InvoiceQty@1002 : Decimal);
    VAR
      PurchaseLine@1001 : Record 39;
    BEGIN
      PurchaseLine.SETRANGE("Document Type",PurchaseLine."Document Type"::Order);
      PurchaseLine.SETRANGE("Document No.",PurchaseDocumentNo);
      PurchaseLine.FINDFIRST;
      PurchaseLine.VALIDATE("Qty. to Invoice",InvoiceQty);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateProductionBOM@50(VAR ProductionBOMHeader@1000 : Record 99000771;ChildItemNo@1003 : Code[20];UOMCode@1001 : Code[10];QtyPer@1004 : Decimal);
    VAR
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UOMCode);
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ChildItemNo,QtyPer);

      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRevaluationJournal@1(VAR ItemJournalLine@1000 : Record 83);
    BEGIN
      ClearJournal(RevaluationItemJournalTemplate,RevaluationItemJournalBatch);
      LibraryInventory.CreateItemJnlLineWithNoItem(
        ItemJournalLine,RevaluationItemJournalBatch,RevaluationItemJournalBatch."Journal Template Name",
        RevaluationItemJournalBatch.Name,ItemJournalLine."Entry Type"::"Positive Adjmt.");
      ItemJournalLine.VALIDATE("Value Entry Type",ItemJournalLine."Value Entry Type"::Revaluation);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRevaluationJournalAndCalcInventoryValueByLocAndVar@94(VAR Item@1000 : Record 27);
    VAR
      ItemJournalLine@1001 : Record 83;
    BEGIN
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
      CreateRevaluationJournal(ItemJournalLine);
      CalcInventoryValueWithLocationAndVariant(Item,ItemJournalLine,LibraryFiscalYear.GetFirstPostingDate(FALSE),TRUE,TRUE);
    END;

    LOCAL PROCEDURE CalcInventoryValue@15(VAR Item@1000 : Record 27;VAR ItemJournalLine@1001 : Record 83);
    BEGIN
      CalcInventoryValueOnDate(Item,ItemJournalLine,WORKDATE);
    END;

    LOCAL PROCEDURE CalcInventoryValueOnDate@92(VAR Item@1001 : Record 27;VAR ItemJournalLine@1000 : Record 83;PostingDate@1002 : Date);
    BEGIN
      CalcInventoryValueWithLocationAndVariant(Item,ItemJournalLine,PostingDate,FALSE,FALSE);
    END;

    LOCAL PROCEDURE CalcInventoryValueWithLocationAndVariant@87(VAR Item@1002 : Record 27;VAR ItemJournalLine@1001 : Record 83;PostingDate@1000 : Date;ByLocation@1003 : Boolean;ByVariant@1004 : Boolean);
    VAR
      CalculatePer@1006 : 'Item Ledger Entry,Item';
      CalculationBase@1005 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
    BEGIN
      Item.SETRECFILTER;
      LibraryCosting.CalculateInventoryValue(
        ItemJournalLine,Item,PostingDate,ItemJournalLine."Document No.",CalculatePer::Item,
        ByLocation,ByVariant,TRUE,CalculationBase::" ",FALSE);
    END;

    LOCAL PROCEDURE UpdateRevaluedUnitCost@24(JournalTemplateName@1002 : Text[10];JournalTemplateBatch@1003 : Text[10];ItemNo@1000 : Code[20];OldUnitCost@1004 : Decimal) : Decimal;
    VAR
      ItemJournalLine@1001 : Record 83;
    BEGIN
      ItemJournalLine.SETRANGE("Journal Template Name",JournalTemplateName);
      ItemJournalLine.SETRANGE("Journal Batch Name",JournalTemplateBatch);
      ItemJournalLine.SETRANGE("Item No.",ItemNo);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE("Unit Cost (Revalued)",OldUnitCost + LibraryRandom.RandDec(50,2));
      ItemJournalLine.MODIFY(TRUE);
      EXIT(ItemJournalLine."Unit Cost (Revalued)");
    END;

    LOCAL PROCEDURE CreateSalesOrder@22(VAR SalesHeader@1001 : Record 36;ItemNo@1000 : Code[20];RevaluedQuantity@1004 : Decimal;LocationCode@1010 : Code[10];ByLocation@1008 : Boolean);
    VAR
      SalesLine@1002 : Record 37;
      SalesLine2@1012 : Record 37;
      ItemLedgerEntry@1011 : Record 32;
      DocumentType@1005 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,DocumentType::Order,'');
      IF ByLocation THEN BEGIN
        ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
        ItemLedgerEntry.SETRANGE("Document Type",ItemLedgerEntry."Document Type"::"Transfer Receipt");
        ItemLedgerEntry.SETFILTER(Quantity,'>0');
        ItemLedgerEntry.FINDFIRST;
        LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,RevaluedQuantity - ItemLedgerEntry.Quantity);
        SalesLine.VALIDATE("Location Code",LocationCode);
        LibrarySales.CreateSalesLine(SalesLine2,SalesHeader,SalesLine2.Type::Item,ItemNo,ItemLedgerEntry.Quantity);
        SalesLine.VALIDATE("Location Code",ItemLedgerEntry."Location Code");
      END ELSE BEGIN
        LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,RevaluedQuantity);
        SalesLine.VALIDATE("Location Code",LocationCode);
      END;
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE TransferQtyDiffLocation@32(ItemNo@1000 : Code[20];FromLocation@1001 : Code[10]);
    VAR
      TransferHeader@1002 : Record 5740;
      TransferLine@1004 : Record 5741;
      Location@1003 : Record 14;
      InventoryPostingGroup@1005 : Code[10];
    BEGIN
      // Create a Transfer Order to Transfer a Random Quantity to a Different Location.
      Location.SETRANGE("Use As In-Transit",TRUE);
      Location.FINDFIRST;
      LibraryWarehouse.CreateTransferHeader(TransferHeader,FromLocation,CreateLocationCode(InventoryPostingGroup),Location.Code);
      LibraryWarehouse.CreateTransferLine(TransferHeader,TransferLine,ItemNo,LibraryRandom.RandInt(5));
      LibraryWarehouse.PostTransferOrder(TransferHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE CreateRoutingSetup@119(VAR RoutingNo@1000 : Code[20]);
    VAR
      CapacityUnitOfMeasure@1005 : Record 99000780;
      WorkCenterGroup@1004 : Record 99000756;
      WorkCenter@1006 : Record 99000754;
      MachineCenter@1007 : Record 99000758;
      ShopCalendarCode@1003 : Code[10];
      WorkCenterNo@1001 : Code[20];
    BEGIN
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarWorkingDays;
      LibraryManufacturing.CreateWorkCenterGroup(WorkCenterGroup);
      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,CapacityUnitOfMeasure.Type::Minutes);

      // Create Work Center and Machine Center for Routing.
      CreateWorkCenter(ShopCalendarCode,WorkCenterNo,WorkCenter."Flushing Method"::Manual);
      CalculateWorkCntrCalendar(WorkCenterNo);
      CreateMachineCenter(
        MachineCenter,WorkCenterNo,MachineCenter."Flushing Method"::Manual,
        LibraryRandom.RandInt(5),LibraryRandom.RandDec(10,2),
        LibraryRandom.RandInt(5),1);  // Capacity Value important for test.
      CalculateMachineCntrCalendar(MachineCenter."No.");
      CreateRouting(WorkCenterNo,MachineCenter."No.",RoutingNo);
    END;

    LOCAL PROCEDURE CreateWorkCenter@33(ShopCalendarCode@1000 : Code[10];VAR WorkCenterNo@1007 : Code[20];FlushingMethod@1008 : Option);
    VAR
      WorkCenter@1001 : Record 99000754;
    BEGIN
      // Create Work Center with required fields where Capacity value : 1,  important for test.
      LibraryManufacturing.CreateWorkCenter(WorkCenter);
      WorkCenter.VALIDATE("Flushing Method",FlushingMethod);
      WorkCenter.VALIDATE("Direct Unit Cost",LibraryRandom.RandDec(10,2));
      WorkCenter.VALIDATE("Indirect Cost %",LibraryRandom.RandInt(5));
      WorkCenter.VALIDATE("Overhead Rate",LibraryRandom.RandInt(5));
      WorkCenter.VALIDATE(Capacity,1);
      WorkCenter.VALIDATE("Shop Calendar Code",ShopCalendarCode);
      WorkCenter.MODIFY(TRUE);
      WorkCenterNo := WorkCenter."No.";
    END;

    LOCAL PROCEDURE CreateMachineCenter@8(VAR MachineCenter@1000 : Record 99000758;WorkCenterNo@1002 : Code[20];FlushingMethod@1004 : Option;Capacity@1005 : Decimal;DirectUnitCost@1006 : Decimal;IndirectCostPercentage@1001 : Decimal;OverheadRate@1007 : Decimal);
    BEGIN
      // Create Machine Center with required fields.
      LibraryManufacturing.CreateMachineCenter(MachineCenter,WorkCenterNo,Capacity);
      MachineCenter.VALIDATE(Name,MachineCenter."No.");
      MachineCenter.VALIDATE("Direct Unit Cost",DirectUnitCost);
      MachineCenter.VALIDATE("Indirect Cost %",IndirectCostPercentage);
      MachineCenter.VALIDATE("Overhead Rate",OverheadRate);
      MachineCenter.VALIDATE("Flushing Method",FlushingMethod);
      MachineCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRouting@30(WorkCenterNo@1004 : Code[20];MachineCenterNo@1005 : Code[20];VAR RoutingNo@1002 : Code[20]);
    VAR
      RoutingHeader@1001 : Record 99000763;
      RoutingLine@1006 : Record 99000764;
    BEGIN
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);
      LibraryManufacturing.CreateRoutingLineSetup(
        RoutingLine,RoutingHeader,WorkCenterNo,
        COPYSTR(LibraryUtility.GenerateRandomCode(RoutingLine.FIELDNO("Operation No."),DATABASE::"Routing Line"),1,
          MAXSTRLEN(RoutingLine."Operation No.")),LibraryRandom.RandInt(5),LibraryRandom.RandInt(5));
      RoutingLine.Type := RoutingLine.Type::"Machine Center";
      LibraryManufacturing.CreateRoutingLineSetup(
        RoutingLine,RoutingHeader,MachineCenterNo,
        COPYSTR(LibraryUtility.GenerateRandomCode(RoutingLine.FIELDNO("Operation No."),DATABASE::"Routing Line"),1,
          MAXSTRLEN(RoutingLine."Operation No.")),LibraryRandom.RandInt(5),LibraryRandom.RandInt(5));

      // Certify Routing after Routing lines creation.
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
      RoutingNo := RoutingHeader."No.";
    END;

    LOCAL PROCEDURE CreateProdItemWithBOM@115(VAR Item@1000 : Record 27;ItemCostingMethod@1001 : Option;ItemNo@1002 : Code[20];ItemNo2@1003 : Code[20];InventoryPostingGroup@1004 : Code[10];RoutingNo@1008 : Code[20]);
    VAR
      ProductionBOMHeader@1005 : Record 99000771;
    BEGIN
      // Create Production BOM.
      LibraryManufacturing.CreateCertifProdBOMWithTwoComp(ProductionBOMHeader,ItemNo,ItemNo2,LibraryRandom.RandInt(5));

      // Create Parent item and attach Production BOM.
      CreateProductionItem(
        Item,ItemCostingMethod,Item."Reordering Policy"::"Lot-for-Lot",
        Item."Flushing Method"::Manual,RoutingNo,ProductionBOMHeader."No.",InventoryPostingGroup);
    END;

    LOCAL PROCEDURE CreateProductionItem@28(VAR Item@1008 : Record 27;ItemCostingMethod@1001 : 'Standard,Average';ItemReorderPolicy@1002 : Option;FlushingMethod@1003 : Option;RoutingNo@1004 : Code[20];ProductionBOMNo@1005 : Code[20];InventoryPostingGroup@1000 : Code[10]);
    BEGIN
      // Create Item with required fields where random values not important for test.
      LibraryManufacturing.CreateItemManufacturing(
        Item,ItemCostingMethod,LibraryRandom.RandDec(10,2),ItemReorderPolicy,FlushingMethod,RoutingNo,ProductionBOMNo);
      Item.VALIDATE("Inventory Posting Group",InventoryPostingGroup);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CalculateMachineCntrCalendar@26(MachineCenterNo@1002 : Code[20]);
    VAR
      MachineCenter@1001 : Record 99000758;
    BEGIN
      // Calculate Calendar for Machine Center with dates having a difference of 1 Month.
      MachineCenter.GET(MachineCenterNo);
      LibraryManufacturing.CalculateMachCenterCalendar(MachineCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<1M>',WORKDATE));
    END;

    LOCAL PROCEDURE CalculateWorkCntrCalendar@18(WorkCenterNo@1004 : Code[20]);
    VAR
      WorkCenter@1003 : Record 99000754;
    BEGIN
      // Calculate Calendar for Work Center with dates having a difference of 1 Month.
      WorkCenter.GET(WorkCenterNo);
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<1M>',WORKDATE));
    END;

    LOCAL PROCEDURE CreateAndRefreshRelProdOrder@123(VAR ProductionOrder@1003 : Record 5405;ItemNo@1000 : Code[20];Qty@1001 : Decimal;LocationCode@1002 : Code[10]);
    BEGIN
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,ItemNo,Qty);
      ProductionOrder.VALIDATE("Location Code",LocationCode);
      ProductionOrder.MODIFY(TRUE);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateAvgCostItemAndPostPurchasesAndTransfer@100(VAR Item@1006 : Record 27;VAR FromLocation@1009 : Record 14;VAR ToLocation@1008 : Record 14;VAR Qty@1001 : Decimal;VAR UnitCost@1002 : ARRAY [3] OF Decimal);
    VAR
      InTransitLocation@1007 : Record 14;
      PurchaseHeader@1005 : Record 38;
      TransferHeader@1004 : Record 5740;
      PostingDate@1003 : Date;
      i@1000 : Integer;
    BEGIN
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Average,0);
      CreateLocationsForTransfer(FromLocation,ToLocation,InTransitLocation);

      Qty := LibraryRandom.RandInt(10);
      FOR i := 1 TO ARRAYLEN(UnitCost) DO
        UnitCost[i] := LibraryRandom.RandDec(100,2);

      PostingDate := LibraryFiscalYear.GetFirstPostingDate(FALSE);

      LibraryPatterns.POSTPurchaseOrder(PurchaseHeader,Item,FromLocation.Code,'',Qty,PostingDate,UnitCost[1],TRUE,FALSE);
      LibraryPatterns.POSTTransferOrder(
        TransferHeader,Item,FromLocation,ToLocation,InTransitLocation,'',Qty,PostingDate,PostingDate,TRUE,TRUE);

      LibraryPatterns.POSTPurchaseOrder(PurchaseHeader,Item,FromLocation.Code,'',Qty,PostingDate,UnitCost[2],TRUE,TRUE);
      LibraryPatterns.POSTPurchaseOrder(PurchaseHeader,Item,ToLocation.Code,'',Qty,PostingDate,UnitCost[3],TRUE,TRUE);
    END;

    LOCAL PROCEDURE FilterRevaluationJournalLine@73(VAR ItemJournalLine@1000 : Record 83;ItemNo@1001 : Code[20];LocationCode@1002 : Code[10]);
    BEGIN
      ItemJournalLine.SETRANGE("Item No.",ItemNo);
      ItemJournalLine.SETRANGE("Location Code",LocationCode);
    END;

    LOCAL PROCEDURE FindProdOrderOutputEntry@108(VAR ItemLedgerEntry@1000 : Record 32;ProdOrderNo@1001 : Code[20];ItemNo@1002 : Code[20]);
    BEGIN
      WITH ItemLedgerEntry DO BEGIN
        SETRANGE("Item No.",ItemNo);
        SETRANGE("Entry Type","Entry Type"::Output);
        SETRANGE("Order No.",ProdOrderNo);
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE PostItemJournalLine@56(EntryType@1006 : Option;ItemNo@1003 : Code[20];Qty@1004 : Decimal;LocationCode@1005 : Code[10];UnitAmount@1007 : Decimal;PostingDate@1008 : Date);
    VAR
      ItemJournalTemplate@1000 : Record 82;
      ItemJournalBatch@1001 : Record 233;
      ItemJournalLine@1002 : Record 83;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type::Item,ItemJournalTemplate.Name);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,EntryType,ItemNo,Qty);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.VALIDATE("Unit Amount",UnitAmount);
      ItemJournalLine.VALIDATE("Posting Date",PostingDate);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE PostItemLedgerEntryRevaluation@46(Item@1000 : Record 27) : Decimal;
    VAR
      ItemJournalLine@1001 : Record 83;
      ItemLedgerEntry@1002 : Record 32;
    BEGIN
      CreateRevaluationJournal(ItemJournalLine);
      SelectPurchItemLedgEntry(ItemLedgerEntry,Item."No.");
      UpdateRevalAppliesToEntry(ItemJournalLine,Item."No.",ItemLedgerEntry."Entry No.");

      EXIT(PostRevaluationJournalLine(Item,ItemJournalLine));
    END;

    LOCAL PROCEDURE PostItemRevaluation@49(Item@1000 : Record 27;PostingDate@1001 : Date) : Decimal;
    VAR
      ItemJournalLine@1004 : Record 83;
    BEGIN
      CreateRevaluationJournal(ItemJournalLine);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
      CalcInventoryValueOnDate(Item,ItemJournalLine,PostingDate);

      EXIT(PostRevaluationJournalLine(Item,ItemJournalLine));
    END;

    LOCAL PROCEDURE PostOutputJournalOnDate@113(ProdOrderNo@1002 : Code[20];ItemNo@1001 : Code[20];Quantity@1003 : Decimal;PostingDate@1004 : Date);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CreateOutputJournal(ItemJournalLine,ItemNo,ProdOrderNo,Quantity);
      ItemJournalLine.VALIDATE("Posting Date",PostingDate);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE PostOutputJournalFindEntry@55(ProdOrderNo@1003 : Code[20];ItemNo@1002 : Code[20];Quantity@1001 : Decimal;PostingDate@1000 : Date) : Integer;
    VAR
      ItemLedgerEntry@1004 : Record 32;
    BEGIN
      PostOutputJournalOnDate(ProdOrderNo,ItemNo,Quantity,PostingDate);

      WITH ItemLedgerEntry DO BEGIN
        SETRANGE("Order Type","Order Type"::Production);
        SETRANGE("Order No.",ProdOrderNo);
        SETRANGE("Item No.",ItemNo);
        SETRANGE("Entry Type","Entry Type"::Output);
        FINDLAST;

        EXIT("Entry No.");
      END;
    END;

    LOCAL PROCEDURE PostProdOrderConsumption@61(ProdOrderNo@1002 : Code[20]);
    VAR
      ItemJournalTemplate@1000 : Record 82;
      ItemJournalBatch@1001 : Record 233;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Consumption);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      LibraryManufacturing.CalculateConsumption(ProdOrderNo,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE PostProductionJournal@37(VAR ProductionOrder@1000 : Record 5405);
    VAR
      ProdOrderLine@1002 : Record 5406;
      ProductionJournalMgt@1001 : Codeunit 5510;
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderLine.FINDFIRST;
      ProductionJournalMgt.Handling(ProductionOrder,ProdOrderLine."Line No.");
    END;

    LOCAL PROCEDURE PostRevaluationJournalLine@54(Item@1000 : Record 27;ItemJournalLine@1001 : Record 83) : Decimal;
    VAR
      NewUnitCost@1002 : Decimal;
    BEGIN
      NewUnitCost :=
        UpdateRevaluedUnitCost(
          ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name",Item."No.",Item."Unit Cost");

      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      EXIT(NewUnitCost);
    END;

    LOCAL PROCEDURE RevaluateItem@261(VAR Item@1001 : Record 27;UnitCostDiff@1002 : Decimal);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CreateRevaluationJournal(ItemJournalLine);
      CalcInventoryValueOnDate(Item,ItemJournalLine,WORKDATE);
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalLine."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalLine."Journal Batch Name");
      ItemJournalLine.FINDLAST;
      ItemJournalLine.VALIDATE("Unit Cost (Revalued)",ItemJournalLine."Unit Cost (Calculated)" + UnitCostDiff);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE RevertProdOrderOutput@107(ProdOrderNo@1000 : Code[20];ItemNo@1001 : Code[20];PostingDate@1002 : Date);
    VAR
      ItemLedgerEntry@1003 : Record 32;
      ItemJournalLine@1004 : Record 83;
    BEGIN
      FindProdOrderOutputEntry(ItemLedgerEntry,ProdOrderNo,ItemNo);

      CreateOutputJournal(ItemJournalLine,ItemNo,ProdOrderNo,-ItemLedgerEntry.Quantity);
      ItemJournalLine.VALIDATE("Posting Date",PostingDate);
      ItemJournalLine.MODIFY(TRUE);
      UpdateAppliesToEntry(ItemJournalLine,ItemLedgerEntry."Entry No.");
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE RevertProdOrderOutputEntry@242(ProdOrderNo@1000 : Code[20];ItemNo@1001 : Code[20];Qty@1002 : Decimal;ApplToEntryNo@1004 : Integer);
    VAR
      ItemJournalLine@1003 : Record 83;
    BEGIN
      CreateOutputJournal(ItemJournalLine,ItemNo,ProdOrderNo,Qty);
      ItemJournalLine.VALIDATE("Posting Date",WORKDATE);
      ItemJournalLine.MODIFY(TRUE);
      UpdateAppliesToEntry(ItemJournalLine,ApplToEntryNo);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE SelectItemLedgerEntry@64(VAR ItemLedgerEntry@1000 : Record 32;ItemNo@1001 : Code[20]);
    BEGIN
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::Output);
      ItemLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE SelectPurchItemLedgEntry@47(VAR ItemLedgerEntry@1002 : Record 32;ItemNo@1001 : Code[20]);
    BEGIN
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::Purchase);
      ItemLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE CreateOutputJournal@68(VAR ItemJournalLine@1000 : Record 83;ItemNo@1001 : Code[20];ProductionOrderNo@1002 : Code[20];Quantity@1003 : Decimal);
    VAR
      NoSeriesManagement@1004 : Codeunit 396;
    BEGIN
      ClearJournal(OutputItemJournalTemplate,OutputItemJournalBatch);
      LibraryManufacturing.CreateOutputJournal(
        ItemJournalLine,OutputItemJournalTemplate,OutputItemJournalBatch,ItemNo,ProductionOrderNo);
      ItemJournalLine.VALIDATE("Output Quantity",Quantity);
      ItemJournalLine.VALIDATE(
        "Document No.",NoSeriesManagement.GetNextNo(OutputItemJournalBatch."No. Series",ItemJournalLine."Posting Date",FALSE));
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateAppliesToEntry@137(VAR ItemJournalLine@1000 : Record 83;AppliesToEntry@1001 : Integer);
    BEGIN
      ItemJournalLine.VALIDATE("Applies-to Entry",AppliesToEntry);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateRevalAppliesToEntry@95(VAR ItemJournalLine@1000 : Record 83;ItemNo@1001 : Code[20];AppliesToEntry@1002 : Integer);
    BEGIN
      ItemJournalLine.VALIDATE("Value Entry Type",ItemJournalLine."Value Entry Type"::Revaluation);
      ItemJournalLine.VALIDATE("Item No.",ItemNo);
      UpdateAppliesToEntry(ItemJournalLine,AppliesToEntry);
    END;

    LOCAL PROCEDURE UpdatePostingDateAndVendorInvoiceNoOnPurchaseHeader@122(VAR PurchaseHeader@1000 : Record 38);
    BEGIN
      WITH PurchaseHeader DO BEGIN
        FIND;
        LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);
        VALIDATE("Vendor Invoice No.",LibraryUtility.GenerateGUID);
        VALIDATE("Posting Date",LibraryRandom.RandDateFrom(LibraryFiscalYear.GetFirstPostingDate(FALSE),10));
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE UpdateDirectUnitCostOnPurchaseLine@124(PurchaseHeader@1000 : Record 38;NewUnitCost@1001 : Decimal);
    VAR
      PurchaseLine@1002 : Record 39;
    BEGIN
      WITH PurchaseLine DO BEGIN
        SETRANGE("Document Type",PurchaseHeader."Document Type");
        SETRANGE("Document No.",PurchaseHeader."No.");
        FINDFIRST;
        VALIDATE("Direct Unit Cost",NewUnitCost);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE VerifyActualCostPostedToGL@58(ProdOrderNo@1001 : Code[20]);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      WITH ValueEntry DO BEGIN
        SETRANGE("Order Type","Order Type"::Production);
        SETRANGE("Order No.",ProdOrderNo);
        SETRANGE("Item Ledger Entry Type","Item Ledger Entry Type"::Output);
        FINDSET;
        REPEAT
          TESTFIELD("Cost Posted to G/L","Cost Amount (Actual)");
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE VerifyDirectCostAmount@117(ItemNo@1001 : Code[20];ExpectedAmount@1002 : Decimal);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      WITH ValueEntry DO BEGIN
        SETRANGE("Item No.",ItemNo);
        SETRANGE("Entry Type","Entry Type"::"Direct Cost");
        CALCSUMS("Cost Amount (Actual)");
        TESTFIELD("Cost Amount (Actual)",ExpectedAmount);
      END;
    END;

    LOCAL PROCEDURE VerifyRevaluedInventory@16(Item@1004 : Record 27);
    VAR
      ItemJournalLine@1003 : Record 83;
    BEGIN
      Item.CALCFIELDS(Inventory);
      ItemJournalLine.SETRANGE("Item No.",Item."No.");
      ItemJournalLine.FINDFIRST;
      Assert.AreEqual(Item.Inventory,ItemJournalLine.Quantity,ErrMessageQtyMustBeEqual);
    END;

    LOCAL PROCEDURE VerifyRevaluationJournalLine@67(VAR ItemJournalLine@1000 : Record 83;Qty@1003 : Decimal;UnitCost@1004 : Decimal);
    BEGIN
      WITH ItemJournalLine DO BEGIN
        FINDFIRST;
        TESTFIELD(Quantity,Qty);
        TESTFIELD("Unit Cost (Calculated)",UnitCost);
        TESTFIELD("Inventory Value (Calculated)",Qty * UnitCost);
      END;
    END;

    LOCAL PROCEDURE VerifyItemCost@35(ProductionItemNo@1000 : Code[20];NewUnitCost@1001 : Decimal);
    VAR
      Item@1002 : Record 27;
    BEGIN
      Item.GET(ProductionItemNo);
      Assert.AreNearlyEqual(NewUnitCost,Item."Standard Cost",GeneralLedgerSetup."Amount Rounding Precision",CostMustBeEqualErr);
    END;

    LOCAL PROCEDURE VerifyValueEntry@20(Qty@1007 : Integer;ItemNo@1000 : Code[20];CostBeforeReval@1004 : Decimal;CostAfterReval@1005 : Decimal;AdjustedRevalCost@1006 : Decimal;InitialInvt@1011 : Decimal;InvtExistBeforePurchase@1001 : Boolean;IsTransfer@1009 : Boolean);
    BEGIN
      // Verify Cost for Revaluation Entries.
      VerifyValueEntryRevaluation(Qty,ItemNo,AdjustedRevalCost,InitialInvt,InvtExistBeforePurchase);

      // Verify Cost for all posted Entries.
      IF NOT IsTransfer THEN
        VerifyValueEntryTotal(Qty,ItemNo,CostBeforeReval,CostAfterReval,AdjustedRevalCost,InitialInvt,InvtExistBeforePurchase);
    END;

    LOCAL PROCEDURE VerifyValueEntryRevaluation@23(Qty@1007 : Integer;ItemNo@1000 : Code[20];AdjustedRevaluationCost@1006 : Decimal;InitialInventory@1002 : Decimal;InventoryExistBeforePurchase@1001 : Boolean);
    VAR
      ExpectedCostPostedGLRevalue@1010 : Decimal;
    BEGIN
      ExpectedCostPostedGLRevalue :=
        CalcPurchaseInvoiceCost(Qty,AdjustedRevaluationCost,InitialInventory,InventoryExistBeforePurchase);
      Assert.AreNearlyEqual(
        -ExpectedCostPostedGLRevalue,ActualValueEntriesCostPostedGL(ItemNo,TRUE,FALSE),GeneralLedgerSetup."Amount Rounding Precision",
        CostMustBeEqualErr);
    END;

    LOCAL PROCEDURE VerifyValueEntryTotal@17(Qty@1000 : Integer;ItemNo@1002 : Code[20];CostBeforeReval@1003 : Decimal;CostAfterReval@1004 : Decimal;AdjustedRevalCost@1005 : Decimal;InitialInvt@1006 : Decimal;InvtExistBeforePurchase@1007 : Boolean);
    VAR
      ExpectedCostPostedGL@1008 : Decimal;
    BEGIN
      ExpectedCostPostedGL :=
        CalcPurchaseInvoiceCost(Qty,CostBeforeReval,InitialInvt,InvtExistBeforePurchase) -
        CalcPurchaseInvoiceCost(Qty,AdjustedRevalCost,InitialInvt,InvtExistBeforePurchase) - Qty * CostAfterReval;
      Assert.AreNearlyEqual(
        ExpectedCostPostedGL,ActualValueEntriesCostPostedGL(ItemNo,FALSE,FALSE),GeneralLedgerSetup."Amount Rounding Precision",
        CostMustBeEqualErr);
    END;

    LOCAL PROCEDURE VerifyValueEntryComponentItem@36(Qty@1007 : Integer;ItemNo@1000 : Code[20];CostBeforeReval@1004 : Decimal;CostAfterReval@1005 : Decimal;AdjustedRevalCost@1006 : Decimal);
    BEGIN
      // Verify Cost for Revaluation Entries.
      VerifyValueEntryRevaluation(Qty,ItemNo,AdjustedRevalCost,0,FALSE);

      // Verify Cost for all posted Entries.
      VerifyValueEntryProdTotal(Qty,ItemNo,CostBeforeReval,CostAfterReval,AdjustedRevalCost);
    END;

    LOCAL PROCEDURE VerifyValueEntryProdTotal@52(Qty@1000 : Integer;ItemNo@1001 : Code[20];CostBeforeReval@1002 : Decimal;CostAfterReval@1003 : Decimal;AdjustedRevalCost@1004 : Decimal);
    VAR
      ExpectedCostPostedGL@1005 : Decimal;
    BEGIN
      ExpectedCostPostedGL :=
        CalcPurchaseInvoiceCost(Qty,CostBeforeReval,0,FALSE) -
        CalcPurchaseInvoiceCost(Qty,AdjustedRevalCost,0,FALSE) -
        CalcConsumptionAmount(ItemNo,CostAfterReval);
      Assert.AreNearlyEqual(
        ExpectedCostPostedGL,ActualValueEntriesCostPostedGL(ItemNo,FALSE,FALSE),GeneralLedgerSetup."Amount Rounding Precision",
        CostMustBeEqualErr);
    END;

    LOCAL PROCEDURE VerifyValueEntryLessInvoice@6(ItemNo@1006 : Code[20];CostBeforeReval@1005 : Decimal;AdjustedRevalCost@1003 : Decimal;InitialInvt@1002 : Decimal;PurchaseQty@1000 : Decimal;InvoiceQty@1009 : Decimal);
    VAR
      ExpectedCostPostedGL@1010 : Decimal;
    BEGIN
      // Verify Cost for Revaluation Entries.
      ExpectedCostPostedGL :=
        (CostBeforeReval * InvoiceQty) / (CostBeforeReval * PurchaseQty) * (InitialInvt - PurchaseQty) * AdjustedRevalCost;
      Assert.AreNearlyEqual(
        -ExpectedCostPostedGL,ActualValueEntriesCostPostedGL(ItemNo,TRUE,FALSE),GeneralLedgerSetup."Amount Rounding Precision",
        CostMustBeEqualErr);
    END;

    LOCAL PROCEDURE VerifyValueEntryRevalTwice@42(ItemNo@1000 : Code[20];CostBeforeReval@1004 : Decimal;AdjustedRevalCost@1002 : Decimal;AdjustedRevalCost2@1005 : Decimal;CostAfterReval@1003 : Decimal;PurchSalesQty@1006 : Decimal;InvoiceQty@1007 : Decimal);
    VAR
      ExpectedCostPostedGL@1008 : Decimal;
    BEGIN
      // Verify Cost for all posted Entries.
      ExpectedCostPostedGL :=
        InvoiceQty * (CostBeforeReval + AdjustedRevalCost) +
        (CostBeforeReval * InvoiceQty) / (CostBeforeReval * PurchSalesQty) * (PurchSalesQty * AdjustedRevalCost2) -
        PurchSalesQty * CostAfterReval;
      Assert.AreNearlyEqual(
        ExpectedCostPostedGL,ActualValueEntriesCostPostedGL(ItemNo,FALSE,FALSE),GeneralLedgerSetup."Amount Rounding Precision",
        CostMustBeEqualErr);
    END;

    LOCAL PROCEDURE VerifyValueEntryRevalNoSales@53(ItemNo@1006 : Code[20];CostBeforeReval@1005 : Decimal;AdjustedRevalCost@1004 : Decimal;AdjustedRevalCost2@1003 : Decimal;PurchQty@1001 : Decimal;InvoiceQty@1000 : Decimal);
    VAR
      ExpectedCostPostedGL@1007 : Decimal;
    BEGIN
      // Verify Cost for all posted Entries.
      ExpectedCostPostedGL :=
        InvoiceQty * (CostBeforeReval + AdjustedRevalCost) +
        ((CostBeforeReval * InvoiceQty) / (CostBeforeReval * PurchQty)) * (PurchQty * AdjustedRevalCost2);
      Assert.AreNearlyEqual(
        ExpectedCostPostedGL,ActualValueEntriesCostPostedGL(ItemNo,FALSE,FALSE),GeneralLedgerSetup."Amount Rounding Precision",
        CostMustBeEqualErr);
    END;

    LOCAL PROCEDURE ActualValueEntriesCostPostedGL@85(ItemNo@1001 : Code[20];RevaluationFilter@1003 : Boolean;PositiveEntry@1004 : Boolean) CostPostedGL : Decimal;
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      IF RevaluationFilter THEN
        ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::Revaluation);
      ValueEntry.SETRANGE("Item No.",ItemNo);
      IF PositiveEntry THEN
        ValueEntry.SETFILTER("Cost Posted to G/L",'>0');
      ValueEntry.FINDSET;
      REPEAT
        CostPostedGL += ValueEntry."Cost Posted to G/L";
      UNTIL ValueEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE CalcPurchaseInvoiceCost@27(Qty@1002 : Integer;UnitCost@1004 : Decimal;InitialInventory@1007 : Decimal;InventoryExistBeforePurchase@1008 : Boolean) : Decimal;
    VAR
      QtyFromItemJournal@1009 : Decimal;
    BEGIN
      IF InventoryExistBeforePurchase THEN BEGIN
        QtyFromItemJournal := InitialInventory - Qty;
        EXIT(Qty * UnitCost + QtyFromItemJournal * UnitCost);
      END;
      EXIT(Qty * UnitCost);
    END;

    LOCAL PROCEDURE CalcConsumptionAmount@38(ItemNo@1000 : Code[20];UnitCost@1001 : Decimal) : Decimal;
    VAR
      ProdOrderComponent@1002 : Record 5407;
    BEGIN
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderComponent.SETRANGE("Item No.",ItemNo);
      ProdOrderComponent.FINDFIRST;
      ProdOrderComponent.CALCFIELDS("Act. Consumption (Qty)");
      EXIT(ProdOrderComponent."Act. Consumption (Qty)" * UnitCost);
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntryCostAmt@147(DocumentNo@1000 : Code[20];ExpectedCostAmount@1001 : Decimal);
    VAR
      ItemLedgerEntry@1002 : Record 32;
    BEGIN
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::Output);
      ItemLedgerEntry.SETRANGE("Document No.",DocumentNo);
      ItemLedgerEntry.FINDFIRST;
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      Assert.AreEqual(ExpectedCostAmount,ItemLedgerEntry."Cost Amount (Actual)",ErrMsgCostAmount);
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@12(ConfirmText@1000 : Text[1024];VAR Confirm@1001 : Boolean);
    BEGIN
      Confirm := TRUE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@80(Message@1000 : Text[1024]);
    BEGIN
    END;

    [ModalPageHandler]
    PROCEDURE ProdJournalPageHandler@39(VAR ProductionJournal@1000 : Page 5510;VAR Response@1001 : Action);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      ItemJournalLine.SETRANGE("Order Type",ItemJournalLine."Order Type"::Production);
      ItemJournalLine.SETRANGE("Order No.",ProductionOrderNo);
      ItemJournalLine.FINDSET;
      REPEAT
        CODEUNIT.RUN(CODEUNIT::"Item Jnl.-Post Batch",ItemJournalLine);
      UNTIL ItemJournalLine.NEXT = 0;
    END;

    [StrMenuHandler]
    PROCEDURE CalculateStdCostMenuHandler@34(Option@1000 : Text[1024];VAR Choice@1001 : Integer;Instruction@1002 : Text[1024]);
    BEGIN
      // Calculate Standard Cost for All Level when Costing Method Standard.
      Choice := 2;
    END;

    LOCAL PROCEDURE ExecuteUIHandlers@78();
    BEGIN
      // Generate dummy messages.
      MESSAGE(ExpectedMsg);
      IF CONFIRM(ExpectedCostPostingConfirm) THEN ;
    END;

    BEGIN
    {
      // [FEATURE] [Revaluation] [SCM]
      Test for Inventory Revaluation:
       1. Test Revaluation Standard Costing : Post full Purchase Order, Revaluation, and Post full Sales Order.
       2. Test Revaluation Standard Costing : Post Purchase Order as Receive, Post full Sales Order,
          Post Purchase Order with Less Quantity as Invoice, and Revaluation.
       3. Test Revaluation Standard Costing : Post Purchase Order 1 as Receive, Revaluation, Post Purchase Order 2 as Receive,
          Re-open and Post Purchase Order with Less Quantity as Invoice, and Revaluation.
       4. Test Revaluation Standard Costing : Post Purchase Order as Receive, Revaluation,
          Post Purchase Order with Less Quantity as Invoice, Revaluation, and Post full Sales Order.
       5. Test Revaluation Average Costing  : Post full Purchase Order, Revaluation, and Post full Sales Order.
       6. Test Revaluation Standard Costing : Post full Purchase Order, Revaluation of component items, Create Production Order,
          Revaluation of finished item, and Finish Production Order.
       7. Test Revaluation on Output pushes cost to the applied negative Output entry.
       8. Verify that Per Entry revaluation on an average costed item can be posted correctly if there is no partial revaluation.
       9. Verify error message when trying to post a per entry revaluation after a partial revaluation on an average costed item.
       10. Verify that partial revaluation on an average costed item can be posted correctly ater posting per entry revaluation.

      This test code unit replaces Manual Test Suite (19917) Case - 1.
      TFS_TS_ID = 19917
      Covers Test cases:
        TC1553 TFS_TC_ID = 6202

      This test code unit replaces Manual Test Suite (19925) Case - 2.
      TFS_TS_ID = 19925
      Covers Test cases:
        TC1590 TFS_TC_ID = 6175

      This test code unit replaces Manual Test Suite (19924,19925) Case - 3.
      TFS_TS_ID = 19924,19925
      Covers Test cases:
        TC1583 TFS_TC_ID = 6169
        TC1588 TFS_TC_ID = 6173

      This test code unit replaces Manual Test Suite (19924,19926) Case - 4.
      TFS_TS_ID = 19924,19926
      Covers Test cases:
        TC1584 TFS_TC_ID = 6170
        TC1585 TFS_TC_ID = 6171
        TC1594 TFS_TC_ID = 6178

      This test code unit replaces Manual Test Suite (19926) Case - 5.
      TFS_TS_ID = 19926
      Covers Test cases:
        TC1596 TFS_TC_ID = 4009

      This test code unit replaces Manual Test Suite (19920) Case - 6.
      TFS_TS_ID = 19920,19921
      Covers Test cases:
        TC1564 TFS_TC_ID = 6209
        TC1567 TFS_TC_ID = 4006

      Covers Test cases:
      -------------------------------------------------------------------------
       Test Function Name                TFS ID
      -------------------------------------------------------------------------
       FIFORevalProduction               241721

       PerEntryRevaluationCanBePostedIfNoPartialRevaluation            86010
       PerEntryRevaluationCannotBePostedAfterPartialRevaluation        86010
       PartialRevaluationCanBePostedAfterPerEntry                      86010
    }
    END.
  }
}

