OBJECT Codeunit 134263 Test Bank Payment Application
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      LibraryERM@1000 : Codeunit 131300;
      LibrarySales@1002 : Codeunit 130509;
      LibraryPurch@1006 : Codeunit 130512;
      LibraryInventory@1003 : Codeunit 132201;
      LibraryDim@1005 : Codeunit 131001;
      LibraryRandom@1007 : Codeunit 130440;
      LibrarySetupStorage@1009 : Codeunit 131009;
      Assert@1004 : Codeunit 130000;
      Initialized@1001 : Boolean;

    [Test]
    PROCEDURE TestPmtWithDim@13();
    VAR
      BankAcc@1004 : Record 270;
      BankAccRecon@1003 : Record 273;
      CustLedgEntry@1000 : Record 21;
      DimValue@1005 : Record 349;
      DimValue2@1001 : Record 349;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      CreateCustAndPostSalesInvoice(CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      GetGlobalDim1CodeValue(DimValue);
      GetGlobalDim2CodeValue(DimValue2);
      BankAcc.VALIDATE("Global Dimension 1 Code",DimValue.Code);
      BankAcc.VALIDATE("Global Dimension 2 Code",DimValue2.Code);
      BankAcc.MODIFY(TRUE);

      // Create Bank Rec Header
      LibraryERM.CreateBankAccReconciliation(
        BankAccRecon,BankAcc."No.",BankAccRecon."Statement Type"::"Payment Application");

      Assert.AreEqual(BankAccRecon."Shortcut Dimension 1 Code",BankAcc."Global Dimension 1 Code",'');
      Assert.AreEqual(BankAccRecon."Shortcut Dimension 2 Code",BankAcc."Global Dimension 2 Code",'');
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE TestPmtWithDim2@7();
    VAR
      BankAcc@1004 : Record 270;
      BankAccRecon@1003 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1000 : Record 21;
      DimValue@1005 : Record 349;
      DimValue2@1001 : Record 349;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      CreateCustAndPostSalesInvoice(CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      // Create Bank Rec Header
      LibraryERM.CreateBankAccReconciliation(
        BankAccRecon,BankAcc."No.",BankAccRecon."Statement Type"::"Payment Application");
      LibraryERM.CreateBankAccReconciliationLn(BankAccReconLine,BankAccRecon);

      GetGlobalDim1CodeValue(DimValue);
      GetGlobalDim2CodeValue(DimValue2);

      BankAccRecon.VALIDATE("Shortcut Dimension 1 Code",DimValue.Code);
      BankAccRecon.VALIDATE("Shortcut Dimension 2 Code",DimValue2.Code);
      BankAccRecon.MODIFY(TRUE);

      BankAccRecon.FIND;
      Assert.AreEqual(BankAccRecon."Shortcut Dimension 1 Code",DimValue.Code,'');
      Assert.AreEqual(BankAccRecon."Shortcut Dimension 2 Code",DimValue2.Code,'');

      BankAccReconLine.FIND;
      Assert.AreEqual(BankAccReconLine."Shortcut Dimension 1 Code",DimValue.Code,'');
      Assert.AreEqual(BankAccReconLine."Shortcut Dimension 2 Code",DimValue2.Code,'');
    END;

    [Test]
    PROCEDURE TestPmtWithDim3@25();
    VAR
      BankAcc@1004 : Record 270;
      BankAccRecon@1003 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1000 : Record 21;
      DimValue@1005 : Record 349;
      DimValue2@1001 : Record 349;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      CreateCustAndPostSalesInvoice(CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      // Create Bank Rec Header
      LibraryERM.CreateBankAccReconciliation(
        BankAccRecon,BankAcc."No.",BankAccRecon."Statement Type"::"Payment Application");
      LibraryERM.CreateBankAccReconciliationLn(BankAccReconLine,BankAccRecon);

      GetGlobalDim1CodeValue(DimValue);
      GetGlobalDim2CodeValue(DimValue2);

      BankAccReconLine.VALIDATE("Shortcut Dimension 1 Code",DimValue.Code);
      BankAccReconLine.VALIDATE("Shortcut Dimension 2 Code",DimValue2.Code);
      BankAccReconLine.MODIFY(TRUE);

      BankAccReconLine.FIND;
      Assert.AreEqual(BankAccReconLine."Shortcut Dimension 1 Code",DimValue.Code,'');
      Assert.AreEqual(BankAccReconLine."Shortcut Dimension 2 Code",DimValue2.Code,'');
    END;

    [Test]
    PROCEDURE TestPmtWithBlockedDim@14();
    VAR
      BankAcc@1003 : Record 270;
      BankAccRecon@1002 : Record 273;
      CustLedgEntry@1001 : Record 21;
      DimValue@1000 : Record 349;
      DimValue2@1004 : Record 349;
      BankAccReconLine@1006 : Record 274;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      CreateCustAndPostSalesInvoice(CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      GetGlobalDim1CodeValue(DimValue);
      GetGlobalDim2CodeValue(DimValue2);
      BankAcc.VALIDATE("Global Dimension 1 Code",DimValue.Code);
      BankAcc.VALIDATE("Global Dimension 2 Code",DimValue2.Code);
      BankAcc.MODIFY(TRUE);

      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amount");

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // Block the dimension
      BlockDimValue(DimValue);
      ASSERTERROR LibraryERM.PostBankAccReconciliation(BankAccRecon);

      UnblockDimValue(DimValue);

      // Block the dimension
      BlockDimValue(DimValue2);
      ASSERTERROR LibraryERM.PostBankAccReconciliation(BankAccRecon);

      UnblockDimValue(DimValue2);
    END;

    [Test]
    PROCEDURE TestPmtWithBlockedDimComb@32();
    VAR
      BankAcc@1003 : Record 270;
      BankAccRecon@1002 : Record 273;
      CustLedgEntry@1001 : Record 21;
      DimValue@1000 : Record 349;
      DimValue2@1004 : Record 349;
      BankAccReconLine@1006 : Record 274;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      CreateCustAndPostSalesInvoice(CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      GetGlobalDim1CodeValue(DimValue);
      GetGlobalDim2CodeValue(DimValue2);
      BankAcc.VALIDATE("Global Dimension 1 Code",DimValue.Code);
      BankAcc.VALIDATE("Global Dimension 2 Code",DimValue2.Code);
      BankAcc.MODIFY(TRUE);

      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amount");

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // Exercise
      BlockDimCombination(DimValue."Dimension Code",DimValue2."Dimension Code");
      ASSERTERROR LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify: posting fails due to Dim combination blocked

      // Tear Down
      UnblockDimCombination(DimValue."Dimension Code",DimValue2."Dimension Code");

      // Verify: posting should succeed is Dim Comb is not blocked
      LibraryERM.PostBankAccReconciliation(BankAccRecon);
    END;

    [Test]
    PROCEDURE TestPmtApplnMultipleLines@15();
    VAR
      Cust@1000 : Record 18;
      CustLedgEntry@1001 : Record 21;
      CustLedgEntry2@1002 : Record 21;
      BankAcc@1008 : Record 270;
      BankAccRecon@1007 : Record 273;
      BankAccReconLine@1003 : Record 274;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      LibrarySales.CreateCustomer(Cust);
      CreateSalesInvoiceAndPost(Cust,CustLedgEntry,'');
      CreateSalesInvoiceAndPost(Cust,CustLedgEntry2,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amount" + CustLedgEntry2."Remaining Amount");

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry2);

      BankAccReconLine.FIND;
      Assert.AreEqual(0,BankAccReconLine.Difference,'');

      // Verify: posting should succeed is Dim Comb is not blocked
      LibraryERM.PostBankAccReconciliation(BankAccRecon);
    END;

    [Test]
    PROCEDURE TestPmtApplnAmt@17();
    VAR
      CustLedgEntry@1004 : Record 21;
      BankAcc@1002 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1000 : Record 274;
      AppliedPmtEntry@1003 : Record 1294;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      CreateCustAndPostSalesInvoice(CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amount");

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      AppliedPmtEntry.SETRANGE("Account Type",AppliedPmtEntry."Account Type"::Customer);
      AppliedPmtEntry.SETRANGE("Account No.",CustLedgEntry."Customer No.");
      AppliedPmtEntry.FINDFIRST;
      COMMIT;

      // Should be possible to reduce
      AppliedPmtEntry.VALIDATE("Applied Amount",AppliedPmtEntry."Applied Amount" / 2);

      // Should not bt possible to zero
      ASSERTERROR AppliedPmtEntry.VALIDATE("Applied Amount",0);

      // Should be possible to change sign
      ASSERTERROR AppliedPmtEntry.VALIDATE("Applied Amount",-AppliedPmtEntry."Applied Amount");

      // Tear Down

      // Verify: posting should succeed
      LibraryERM.PostBankAccReconciliation(BankAccRecon);
    END;

    [Test]
    PROCEDURE TestRemaingAmtPmtWithDiscMultipleAppln@36();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
      CustLedgEntry2@1009 : Record 21;
      Cust@1003 : Record 18;
      PmtTerms@1004 : Record 3;
      PmtReconJnl@1010 : TestPage 1290;
      StmtAmt@1006 : Decimal;
      i@1007 : Integer;
      RemStmtAmt@1008 : Decimal;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      LibrarySales.CreateCustomer(Cust);
      LibraryERM.CreatePaymentTermsDiscount(PmtTerms,FALSE);
      Cust.VALIDATE("Payment Terms Code",PmtTerms.Code);
      Cust.MODIFY(TRUE);

      // Create Two payments
      CreateSalesInvoiceAndPost(Cust,CustLedgEntry,'');
      CreateSalesInvoiceAndPost(Cust,CustLedgEntry2,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      // Create Bank Rec Line
      StmtAmt :=
        (CustLedgEntry."Remaining Amount" - CustLedgEntry."Remaining Pmt. Disc. Possible") +
        (CustLedgEntry2."Remaining Amount" - CustLedgEntry2."Remaining Pmt. Disc. Possible");

      RemStmtAmt := StmtAmt;
      FOR i := 3 DOWNTO 1 DO BEGIN
        CreateBankPmtReconcWithLine(
          BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,ROUND(RemStmtAmt / i));

        // Create Bank Rec Line - Application
        IF i <> 1 THEN
          ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);
        IF i <> 3 THEN
          ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry2);

        RemStmtAmt -= BankAccReconLine."Statement Amount";

        // Verify Statement To Rem Amt Difference corresponds to Cust Ledger Remaining Amounts
        CustLedgEntry.CALCFIELDS("Remaining Amount");
        CustLedgEntry2.CALCFIELDS("Remaining Amount");
        OpenPmtReconJnl(BankAccRecon,PmtReconJnl);
        PmtReconJnl.FIRST;
        CASE i OF
          3:
            PmtReconJnl.StatementToRemAmtDifference.ASSERTEQUALS(
              PmtReconJnl."Statement Amount".ASDECIMAL - CustLedgEntry."Remaining Amount");
          2:
            PmtReconJnl.StatementToRemAmtDifference.ASSERTEQUALS(
              PmtReconJnl."Statement Amount".ASDECIMAL -
              (CustLedgEntry."Remaining Amount" - CustLedgEntry."Remaining Pmt. Disc. Possible") -
              CustLedgEntry2."Remaining Amount");
          1:
            PmtReconJnl.StatementToRemAmtDifference.ASSERTEQUALS(
              PmtReconJnl."Statement Amount".ASDECIMAL -
              (CustLedgEntry2."Remaining Amount" - CustLedgEntry2."Remaining Pmt. Disc. Possible"));
        END;
        // Post
        LibraryERM.PostBankAccReconciliation(BankAccRecon);
      END;
      // Verify
      VerifyCustLedgEntry(CustLedgEntry."Customer No.");
      VerifyBankLedgEntry(BankAcc."No.",StmtAmt);
    END;

    [Test]
    PROCEDURE TestPmtApplnMultipleCust@18();
    VAR
      CustLedgEntry@1004 : Record 21;
      CustLedgEntry2@1003 : Record 21;
      BankAcc@1002 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1000 : Record 274;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      CreateCustAndPostSalesInvoice(CustLedgEntry,'');
      CreateCustAndPostSalesInvoice(CustLedgEntry2,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amount" + CustLedgEntry2."Remaining Amount");

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // Should not be possible to add the same entry twice
      ASSERTERROR ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // Should not be possible to add add from a different customer
      ASSERTERROR ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry2);
    END;

    [Test]
    PROCEDURE TestPostPmtWithoutRecLine@4();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      CustLedgEntry@1005 : Record 21;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      CreateCustAndPostSalesInvoice(CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      // Create Bank Rec Header
      LibraryERM.CreateBankAccReconciliation(
        BankAccRecon,BankAcc."No.",BankAccRecon."Statement Type"::"Payment Application");

      // Post
      ASSERTERROR LibraryERM.PostBankAccReconciliation(BankAccRecon);
      // Verify
    END;

    [Test]
    PROCEDURE TestPostPmtWithoutAppln@3();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      CreateCustAndPostSalesInvoice(CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amount");

      // Post
      ASSERTERROR LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify
    END;

    [Test]
    PROCEDURE TestPostPmtWithAppln@2();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      CreateCustAndPostSalesInvoice(CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amount");

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // Post
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify
      VerifyCustLedgEntry(CustLedgEntry."Customer No.");
      VerifyBankLedgEntry(BankAcc."No.",CustLedgEntry."Remaining Amount");
    END;

    [Test]
    PROCEDURE TestPostPmtWithDiscAppln@33();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
      Cust@1003 : Record 18;
      PmtTerms@1004 : Record 3;
      StmtAmt@1006 : Decimal;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      LibrarySales.CreateCustomer(Cust);
      LibraryERM.CreatePaymentTermsDiscount(PmtTerms,FALSE);
      Cust.VALIDATE("Payment Terms Code",PmtTerms.Code);
      Cust.MODIFY(TRUE);

      CreateSalesInvoiceAndPost(Cust,CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      StmtAmt := CustLedgEntry."Remaining Amount" - CustLedgEntry."Remaining Pmt. Disc. Possible";
      CreateBankPmtReconcWithLine(BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,StmtAmt);

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);
      BankAccReconLine.FIND;
      Assert.AreEqual(0,BankAccReconLine.Difference,'');

      // Post
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify
      VerifyCustLedgEntry(CustLedgEntry."Customer No.");
      VerifyBankLedgEntry(BankAcc."No.",StmtAmt);
    END;

    [Test]
    PROCEDURE TestPostPmtWithDiscMultipleAppln@38();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
      Cust@1003 : Record 18;
      PmtTerms@1004 : Record 3;
      StmtAmt@1006 : Decimal;
      i@1007 : Integer;
      RemStmtAmt@1008 : Decimal;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      LibrarySales.CreateCustomer(Cust);
      LibraryERM.CreatePaymentTermsDiscount(PmtTerms,FALSE);
      Cust.VALIDATE("Payment Terms Code",PmtTerms.Code);
      Cust.MODIFY(TRUE);

      CreateSalesInvoiceAndPost(Cust,CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      // Create Bank Rec Header
      LibraryERM.CreateBankAccReconciliation(
        BankAccRecon,BankAcc."No.",BankAccRecon."Statement Type"::"Payment Application");

      // Create Bank Rec Line
      StmtAmt := CustLedgEntry."Remaining Amount" - CustLedgEntry."Remaining Pmt. Disc. Possible";

      RemStmtAmt := StmtAmt;
      FOR i := 3 DOWNTO 1 DO BEGIN
        LibraryERM.CreateBankAccReconciliationLn(BankAccReconLine,BankAccRecon);
        BankAccReconLine.VALIDATE("Transaction Date",WORKDATE);
        BankAccReconLine.VALIDATE(Description,'Hello World');
        BankAccReconLine.VALIDATE("Statement Amount",ROUND(RemStmtAmt / i));
        BankAccReconLine.MODIFY(TRUE);

        // Create Bank Rec Line - Application
        ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

        RemStmtAmt -= BankAccReconLine."Statement Amount";
      END;

      // Post
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify
      VerifyCustLedgEntry(CustLedgEntry."Customer No.");
      VerifyBankLedgEntry(BankAcc."No.",StmtAmt);
    END;

    [Test]
    PROCEDURE TestPostPmtWithNoDiscAppln@31();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
      Cust@1003 : Record 18;
      PmtTerms@1004 : Record 3;
      StmtAmt@1006 : Decimal;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      LibrarySales.CreateCustomer(Cust);
      LibraryERM.CreatePaymentTermsDiscount(PmtTerms,FALSE);
      Cust.VALIDATE("Payment Terms Code",PmtTerms.Code);
      Cust.MODIFY(TRUE);

      CreateSalesInvoiceAndPost(Cust,CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      // Create Bank Rec Header
      LibraryERM.CreateBankAccReconciliation(
        BankAccRecon,BankAcc."No.",BankAccRecon."Statement Type"::"Payment Application");
      LibraryERM.CreateBankAccReconciliationLn(BankAccReconLine,BankAccRecon);

      // Create Bank Rec Line
      StmtAmt := CustLedgEntry."Remaining Amount";

      BankAccReconLine.VALIDATE("Transaction Date",CALCDATE('<1D>',CustLedgEntry."Pmt. Discount Date"));
      BankAccReconLine.VALIDATE(Description,'Hello World');
      BankAccReconLine.VALIDATE("Statement Amount",StmtAmt);
      BankAccReconLine.MODIFY(TRUE);

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // Post
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify
      VerifyCustLedgEntry(CustLedgEntry."Customer No.");
      VerifyBankLedgEntry(BankAcc."No.",StmtAmt);
    END;

    [Test]
    PROCEDURE TestPostPmtWithVendAppln@26();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      VendLedgEntry@1005 : Record 25;
    BEGIN
      Initialize;

      // Create purchase Invoice and Post
      CreateVendAndPostPurchInvoice(VendLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      VendLedgEntry.CALCFIELDS("Remaining Amount");
      CreateBankPmtReconcWithLine(BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,VendLedgEntry."Remaining Amount");

      // Create Bank Rec Line - Application
      ApplyVendLedgEntry(BankAccReconLine,VendLedgEntry);

      // Post
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify
      VerifyVendLedgEntry(VendLedgEntry."Vendor No.");
      VerifyBankLedgEntry(BankAcc."No.",VendLedgEntry."Remaining Amount");
    END;

    [Test]
    PROCEDURE TestPostPmtWithFCYInvAppln@12();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
      Curr@1006 : Record 4;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      Curr.GET(LibraryERM.CreateCurrencyWithExchangeRate(WORKDATE,10,10));

      CreateCustAndPostSalesInvoice(CustLedgEntry,Curr.Code);

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      CustLedgEntry.CALCFIELDS("Remaining Amt. (LCY)");
      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amt. (LCY)");

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // Post
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify
      VerifyCustLedgEntry(CustLedgEntry."Customer No.");
      VerifyBankLedgEntry(BankAcc."No.",CustLedgEntry."Remaining Amt. (LCY)");
    END;

    [Test]
    PROCEDURE TestPostPmtWithFCYPayAppln@10();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
      Curr@1006 : Record 4;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      Curr.GET(LibraryERM.CreateCurrencyWithExchangeRate(WORKDATE,10,10));

      CreateCustAndPostSalesInvoice(CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);
      BankAcc.VALIDATE("Currency Code",Curr.Code);
      BankAcc.MODIFY(TRUE);

      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amount");

      // Create Bank Rec Line - Application
      ASSERTERROR ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // Post
      // ASSERTERROR CODEUNIT.RUN(CODEUNIT::"Bank Acc. Reconciliation Post",BankAccRecon);

      // Verify
    END;

    [Test]
    PROCEDURE TestPostPmtWithFCYDiscAppln@35();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
      Cust@1003 : Record 18;
      PmtTerms@1004 : Record 3;
      Curr@1007 : Record 4;
      StmtAmt@1006 : Decimal;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      Curr.GET(LibraryERM.CreateCurrencyWithExchangeRate(WORKDATE,10,10));

      LibrarySales.CreateCustomer(Cust);
      LibraryERM.CreatePaymentTermsDiscount(PmtTerms,FALSE);
      Cust.VALIDATE("Payment Terms Code",PmtTerms.Code);
      Cust.MODIFY(TRUE);

      CreateSalesInvoiceAndPost(Cust,CustLedgEntry,Curr.Code);

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      // Create Bank Rec Line
      CustLedgEntry.CALCFIELDS("Remaining Amt. (LCY)","Remaining Amount");
      StmtAmt :=
        CustLedgEntry."Remaining Amt. (LCY)" -
        ROUND(
          CustLedgEntry."Remaining Pmt. Disc. Possible" *
          ROUND(CustLedgEntry."Remaining Amt. (LCY)" / CustLedgEntry."Remaining Amount"));
      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,StmtAmt);

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      BankAccReconLine.FIND;
      Assert.AreEqual(0,BankAccReconLine.Difference,'');

      // Post
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify
      VerifyCustLedgEntry(CustLedgEntry."Customer No.");
      VerifyBankLedgEntry(BankAcc."No.",StmtAmt);
    END;

    [Test]
    PROCEDURE TestPostPmtWithLCYInvAndFCYPayAppln@11();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
      Curr@1006 : Record 4;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      Curr.GET(LibraryERM.CreateCurrencyWithExchangeRate(WORKDATE,10,10));

      LibraryERM.CreateCurrencyWithExchangeRate(WORKDATE,10,10);

      CreateCustAndPostSalesInvoice(CustLedgEntry,Curr.Code);

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);
      BankAcc.VALIDATE("Currency Code",Curr.Code);
      BankAcc.MODIFY(TRUE);

      // Create Bank Rec Line
      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amount");

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // Post
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify
      VerifyCustLedgEntry(CustLedgEntry."Customer No.");
      VerifyBankLedgEntry(BankAcc."No.",CustLedgEntry."Remaining Amount");
    END;

    [Test]
    PROCEDURE TestPostPmtWithDiscFCYInvAndLCYPayAppln@24();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
      Curr@1006 : Record 4;
      Cust@1003 : Record 18;
      PmtTerms@1004 : Record 3;
      StmtAmt@1007 : Decimal;
    BEGIN
      Initialize;

      // Create Sales Invoice and Post
      LibrarySales.CreateCustomer(Cust);
      LibraryERM.CreatePaymentTermsDiscount(PmtTerms,FALSE);
      Cust.VALIDATE("Payment Terms Code",PmtTerms.Code);
      Cust.MODIFY(TRUE);

      Curr.GET(LibraryERM.CreateCurrencyWithExchangeRate(WORKDATE,10,10));
      LibraryERM.CreateCurrencyWithExchangeRate(WORKDATE,10,10);
      CreateSalesInvoiceAndPost(Cust,CustLedgEntry,'');

      // create Bank Acc
      LibraryERM.CreateBankAccount(BankAcc);

      // Create Bank Rec Line
      StmtAmt := CustLedgEntry."Remaining Amount" - CustLedgEntry."Remaining Pmt. Disc. Possible";
      CreateBankPmtReconcWithLine(BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,StmtAmt);

      // Create Bank Rec Line - Application
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // Post
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // Verify
      VerifyCustLedgEntry(CustLedgEntry."Customer No.");
      VerifyBankLedgEntry(BankAcc."No.",StmtAmt);
    END;

    [Test]
    PROCEDURE TestGetAmountToleranceRangeToleranceAmountType@34();
    VAR
      BankAccount@1000 : Record 270;
      BankAccRecon@1006 : Record 273;
      BankAccReconLine@1005 : Record 274;
      ToleranceAmount@1001 : Decimal;
      Amount@1002 : Decimal;
      MinAmount@1003 : Decimal;
      MaxAmount@1004 : Decimal;
    BEGIN
      Initialize;

      // Setup
      LibraryERM.CreateBankAccount(BankAccount);
      BankAccount.VALIDATE("Match Tolerance Type",BankAccount."Match Tolerance Type"::Amount);
      ToleranceAmount := LibraryRandom.RandDecInRange(1,1000,2);
      BankAccount.VALIDATE("Match Tolerance Value",ToleranceAmount);
      BankAccount.MODIFY;
      Amount := 2 * ToleranceAmount;

      CreateBankPmtReconcWithLine(BankAccount,BankAccRecon,BankAccReconLine,WORKDATE,Amount);

      // Execute
      BankAccReconLine.GetAmountRangeForTolerance(MinAmount,MaxAmount);

      // Verify
      Assert.AreEqual(ToleranceAmount,MinAmount,'MinAmount was not set to a correct value');
      Assert.AreEqual(3 * ToleranceAmount,MaxAmount,'Max Amount was not set to a correct value');
    END;

    [Test]
    PROCEDURE TestGetAmountToleranceRangeToleranceAmountTypeForNegativeAmount@52();
    VAR
      BankAccRecon@1006 : Record 273;
      BankAccReconLine@1005 : Record 274;
      BankAccount@1000 : Record 270;
      ToleranceAmount@1001 : Decimal;
      Amount@1002 : Decimal;
      MinAmount@1003 : Decimal;
      MaxAmount@1004 : Decimal;
    BEGIN
      Initialize;

      // Setup
      LibraryERM.CreateBankAccount(BankAccount);
      BankAccount.VALIDATE("Match Tolerance Type",BankAccount."Match Tolerance Type"::Amount);
      ToleranceAmount := LibraryRandom.RandDecInRange(1,1000,2);
      BankAccount.VALIDATE("Match Tolerance Value",ToleranceAmount);
      BankAccount.MODIFY;
      Amount := -2 * ToleranceAmount;

      CreateBankPmtReconcWithLine(BankAccount,BankAccRecon,BankAccReconLine,WORKDATE,Amount);

      // Execute
      BankAccReconLine.GetAmountRangeForTolerance(MinAmount,MaxAmount);

      // Verify
      Assert.AreEqual(-ToleranceAmount,MaxAmount,'MinAmount was not set to a correct value');
      Assert.AreEqual(-3 * ToleranceAmount,MinAmount,'Max Amount was not set to a correct value');
    END;

    [Test]
    PROCEDURE TestGetAmountToleranceRangeToleranceAmountGreaterThanTheAmount@54();
    VAR
      BankAccRecon@1006 : Record 273;
      BankAccReconLine@1005 : Record 274;
      BankAccount@1000 : Record 270;
      ToleranceAmount@1001 : Decimal;
      Amount@1002 : Decimal;
      MinAmount@1003 : Decimal;
      MaxAmount@1004 : Decimal;
    BEGIN
      Initialize;

      // Setup
      LibraryERM.CreateBankAccount(BankAccount);
      BankAccount.VALIDATE("Match Tolerance Type",BankAccount."Match Tolerance Type"::Amount);
      ToleranceAmount := LibraryRandom.RandDecInRange(1,1000,2);
      BankAccount.VALIDATE("Match Tolerance Value",ToleranceAmount);
      BankAccount.MODIFY;
      Amount := ROUND(ToleranceAmount / 3,LibraryERM.GetAmountRoundingPrecision);

      CreateBankPmtReconcWithLine(BankAccount,BankAccRecon,BankAccReconLine,WORKDATE,Amount);

      // Execute
      BankAccReconLine.GetAmountRangeForTolerance(MinAmount,MaxAmount);

      // Verify
      Assert.AreEqual(0,MinAmount,'MinAmount was not set to a correct value');
      Assert.AreEqual(ToleranceAmount + Amount,MaxAmount,'Max Amount was not set to a correct value');
    END;

    [Test]
    PROCEDURE TestGetAmountToleranceRangeToleranceAmountGreaterThanTheNegativeAmount@63();
    VAR
      BankAccRecon@1006 : Record 273;
      BankAccReconLine@1005 : Record 274;
      BankAccount@1000 : Record 270;
      ToleranceAmount@1001 : Decimal;
      Amount@1002 : Decimal;
      MinAmount@1003 : Decimal;
      MaxAmount@1004 : Decimal;
    BEGIN
      Initialize;

      // Setup
      LibraryERM.CreateBankAccount(BankAccount);
      BankAccount.VALIDATE("Match Tolerance Type",BankAccount."Match Tolerance Type"::Amount);
      ToleranceAmount := LibraryRandom.RandDecInRange(1,1000,2);
      BankAccount.VALIDATE("Match Tolerance Value",ToleranceAmount);
      BankAccount.MODIFY;
      Amount := -ROUND(ToleranceAmount / 3,LibraryERM.GetAmountRoundingPrecision);

      CreateBankPmtReconcWithLine(BankAccount,BankAccRecon,BankAccReconLine,WORKDATE,Amount);

      // Execute
      BankAccReconLine.GetAmountRangeForTolerance(MinAmount,MaxAmount);

      // Verify
      Assert.AreEqual(0,MaxAmount,'MinAmount was not set to a correct value');
      Assert.AreEqual(-ToleranceAmount + Amount,MinAmount,'Max Amount was not set to a correct value');
    END;

    [Test]
    PROCEDURE TestPercentageTypeToleranceAmountFromBankAccount@67();
    VAR
      BankAccRecon@1008 : Record 273;
      BankAccReconLine@1007 : Record 274;
      BankAccount@1000 : Record 270;
      TolerancePct@1001 : Integer;
      Amount@1002 : Decimal;
      MinAmount@1003 : Decimal;
      MaxAmount@1004 : Decimal;
    BEGIN
      // [FEATURE] [UT] [Payment Tolerance]
      // [SCENARIO] Minimum and Maximum correctly calculated when "Match Tolerance Type" is Percentage, Amount is positive and "Tolerance Percent" is defined
      // [TFS 381097] Amount Range is correctly calculated when "Match Tolerance Type" is Percentage

      Initialize;

      // Setup
      LibraryERM.CreateBankAccount(BankAccount);
      BankAccount.VALIDATE("Match Tolerance Type",BankAccount."Match Tolerance Type"::Percentage);
      TolerancePct := LibraryRandom.RandIntInRange(2,80);
      BankAccount.VALIDATE("Match Tolerance Value",TolerancePct);
      BankAccount.MODIFY;
      Amount := LibraryRandom.RandDecInRange(1,1000,2);

      CreateBankPmtReconcWithLine(BankAccount,BankAccRecon,BankAccReconLine,WORKDATE,Amount);

      // Execute
      BankAccReconLine.GetAmountRangeForTolerance(MinAmount,MaxAmount);

      // Verify
      VerifyMinMaxAmounts(Amount,TolerancePct,MinAmount,MaxAmount);
    END;

    [Test]
    PROCEDURE TestPercentageTypeToleranceAmountFromBankAccountWithNegativeAmount@71();
    VAR
      BankAccRecon@1008 : Record 273;
      BankAccReconLine@1007 : Record 274;
      BankAccount@1000 : Record 270;
      TolerancePct@1001 : Integer;
      Amount@1002 : Decimal;
      MinAmount@1003 : Decimal;
      MaxAmount@1004 : Decimal;
    BEGIN
      // [FEATURE] [UT] [Payment Tolerance]
      // [SCENARIO] Minimum and Maximum correctly calculated when "Match Tolerance Type" is Percentage, Amount is negative and "Tolerance Percent" is defined

      Initialize;

      // Setup
      LibraryERM.CreateBankAccount(BankAccount);
      BankAccount.VALIDATE("Match Tolerance Type",BankAccount."Match Tolerance Type"::Percentage);
      TolerancePct := LibraryRandom.RandIntInRange(2,80);
      BankAccount.VALIDATE("Match Tolerance Value",TolerancePct);
      BankAccount.MODIFY;
      Amount := -LibraryRandom.RandDecInRange(1,1000,2);

      CreateBankPmtReconcWithLine(BankAccount,BankAccRecon,BankAccReconLine,WORKDATE,Amount);

      // Execute
      BankAccReconLine.GetAmountRangeForTolerance(MinAmount,MaxAmount);

      // Verify
      VerifyMinMaxAmounts(Amount,TolerancePct,MaxAmount,MinAmount);
    END;

    [Test]
    PROCEDURE TestPercentageTypeToleranceAmountFromBankAccountZeroPercentage@76();
    VAR
      BankAccRecon@1008 : Record 273;
      BankAccReconLine@1007 : Record 274;
      BankAccount@1000 : Record 270;
      Amount@1002 : Decimal;
      MinAmount@1003 : Decimal;
      MaxAmount@1004 : Decimal;
    BEGIN
      // [FEATURE] [UT] [Payment Tolerance]
      // [SCENARIO] Minimum and Maximum correctly calculated when "Match Tolerance Type" is Percentage, Amount is positive and "Tolerance Percent" is zero

      Initialize;

      // Setup
      LibraryERM.CreateBankAccount(BankAccount);
      BankAccount.VALIDATE("Match Tolerance Type",BankAccount."Match Tolerance Type"::Percentage);
      BankAccount.VALIDATE("Match Tolerance Value",0);
      BankAccount.MODIFY;
      Amount := LibraryRandom.RandDecInRange(1,1000,2);

      CreateBankPmtReconcWithLine(BankAccount,BankAccRecon,BankAccReconLine,WORKDATE,Amount);

      // Execute
      BankAccReconLine.GetAmountRangeForTolerance(MinAmount,MaxAmount);

      // Verify
      VerifyMinMaxAmounts(Amount,0,MinAmount,MaxAmount);
    END;

    [Test]
    PROCEDURE TestPercentageTypeToleranceAmountFromBankAccountZeroPercentageWithNegativeAmount@78();
    VAR
      BankAccRecon@1008 : Record 273;
      BankAccReconLine@1007 : Record 274;
      BankAccount@1000 : Record 270;
      Amount@1002 : Decimal;
      MinAmount@1003 : Decimal;
      MaxAmount@1004 : Decimal;
    BEGIN
      // [FEATURE] [UT] [Payment Tolerance]
      // [SCENARIO] Minimum and Maximum correctly calculated when "Match Tolerance Type" is Percentage, Amount is negative and "Tolerance Percent" is zero

      Initialize;

      // Setup
      LibraryERM.CreateBankAccount(BankAccount);
      BankAccount.VALIDATE("Match Tolerance Type",BankAccount."Match Tolerance Type"::Percentage);
      BankAccount.VALIDATE("Match Tolerance Value",0);
      BankAccount.MODIFY;
      Amount := -LibraryRandom.RandDecInRange(1,1000,2);

      CreateBankPmtReconcWithLine(BankAccount,BankAccRecon,BankAccReconLine,WORKDATE,Amount);

      // Execute
      BankAccReconLine.GetAmountRangeForTolerance(MinAmount,MaxAmount);

      // Verify
      VerifyMinMaxAmounts(Amount,0,MinAmount,MaxAmount);
    END;

    [Test]
    PROCEDURE PostedSourceCodeAfterReconPaymentApplication@37();
    VAR
      Customer@1004 : Record 18;
      CustLedgEntry@1005 : Record 21;
      BankAccount@1002 : Record 270;
      BankAccReconciliation@1001 : Record 273;
      BankAccReconLine@1003 : Record 274;
      SourceCode@1000 : Record 230;
    BEGIN
      // [FEATURE] [Source Code]
      // [SCENARIO 379544] Source Code Setup "Payment Reconciliation Journal" value is used as "Source Code" when post reconcicliation with "Statement Type" = "Payment Application"
      Initialize;

      // [GIVEN] SourceCodeSetup."Payment Reconciliation Journal" = "X"
      LibraryERM.CreateSourceCode(SourceCode);
      UpdateSourceCodeSetupForPmtReconJnl(SourceCode.Code);

      // [GIVEN] Posted sales invoice
      LibrarySales.CreateCustomer(Customer);
      CreateSalesInvoiceAndPost(Customer,CustLedgEntry,'');

      // [GIVEN] Payment Reconciliation Journal (bank "Statement Type" = "Payment Application") with applied invoice ledger entry
      LibraryERM.CreateBankAccount(BankAccount);
      CreateBankPmtReconcWithLine(
        BankAccount,BankAccReconciliation,BankAccReconLine,WORKDATE,CustLedgEntry."Remaining Amount");
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // [WHEN] Post application
      LibraryERM.PostBankAccReconciliation(BankAccReconciliation);

      // [THEN] Created GLRegister."Source Code" = GLEntry."Source Code" = "X"
      VerifyLastGLRegisterSourceCode(SourceCode.Code);
    END;

    [Test]
    PROCEDURE UT_RemaingAmtAfterPostingOnBankAccReconLine@39();
    VAR
      BankAcc@1000 : Record 270;
      BankAccRecon@1001 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1005 : Record 21;
      Cust@1003 : Record 18;
      AppliedPaymentEntry@1011 : Record 1294;
      RemainingAmountAfterPosting@1014 : Decimal;
      DifferenceStatementAmtToApplEntryAmount@1013 : Decimal;
    BEGIN
      // [SCENARIO 380959] "Remaining Amount After Posting" calculated as "Remaining Amount" of Ledger Entry minus "Statement Amount" on Bank Account Reconciliation Line

      Initialize;

      // [GIVEN] Sales Invoice "X" with Amount = 100
      LibrarySales.CreateCustomer(Cust);
      CreateSalesInvoiceAndPost(Cust,CustLedgEntry,'');

      // [GIVEN] Bank Account Reconciliation Line with "Statement Amount" = 30
      LibraryERM.CreateBankAccount(BankAcc);
      CreateBankPmtReconcWithLine(
        BankAcc,BankAccRecon,BankAccReconLine,WORKDATE,ROUND(CustLedgEntry."Remaining Amount" / LibraryRandom.RandIntInRange(3,5)));

      // [GIVEN] Apply Sales Invoice "X" to Bank Account Reconciliation Line
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // [WHEN] Calculate Applied Payment Data by function GetAppliedPmtData in Bank Account Reconciliation table
      BankAccReconLine.GetAppliedPmtData(
        AppliedPaymentEntry,RemainingAmountAfterPosting,DifferenceStatementAmtToApplEntryAmount,'');

      // [THEN] "Remaining Amount After Posting" = 70 ("Invoice Amount" - "Remaining Amount")
      Assert.AreEqual(CustLedgEntry."Remaining Amount" - BankAccReconLine."Statement Amount",RemainingAmountAfterPosting,'');
    END;

    [Test]
    PROCEDURE SalesApplyPmtInLCYToInvoiceInFCYWithDiffCurrencyExchangeRate@42();
    VAR
      BankAcc@1004 : Record 270;
      BankAccRecon@1003 : Record 273;
      BankAccReconLine@1002 : Record 274;
      CustLedgEntry@1001 : Record 21;
      CurrencyCode@1000 : Code[10];
    BEGIN
      // [FEATURE] [Sales] [Currency]
      // [SCENARIO 381276] Payment in local currency should be applied to Sales Invoice in foreign currency with different exchange rate

      Initialize;

      // [GIVEN] Currency "X" with "Posting Date" = 01.01 and "Exchange Rate" = 1/100
      // [GIVEN] Currency "X" with "Posting Date" = 02.01 and "Exchange Rate" = 1/99
      CurrencyCode := SetupCurrencyWithExchRates;

      // [GIVEN] Sales Invoice with "Posting Date" = 01.01, "Currency Code" = "X" and Amount = 10 ("Amount (LCY)" = 1000)
      CreateCustAndPostSalesInvoice(CustLedgEntry,CurrencyCode);

      // [GIVEN] Bank Account Reconciliation in local currency, "Posting Date" = 02.01 and Amount = 1000
      LibraryERM.CreateBankAccount(BankAcc);
      CustLedgEntry.CALCFIELDS("Remaining Amt. (LCY)");
      CreateBankPmtReconcWithLine(BankAcc,BankAccRecon,BankAccReconLine,WORKDATE + 1,CustLedgEntry."Remaining Amt. (LCY)");
      BankAccReconLine.MODIFY(TRUE);

      // [GIVEN] Sales Invoice applied to Bank Account Reconciliation
      ApplyCustLedgEntry(BankAccReconLine,CustLedgEntry);

      // [WHEN] Post Bank Account Reconciliation
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // [THEN] Sales Invoice fully applied to Payment
      CustLedgEntry.FIND;
      CustLedgEntry.TESTFIELD(Open,FALSE);
    END;

    [Test]
    PROCEDURE PurchApplyPmtInLCYToInvoiceInFCYWithDiffCurrencyExchangeRate@44();
    VAR
      BankAcc@1004 : Record 270;
      BankAccRecon@1003 : Record 273;
      BankAccReconLine@1002 : Record 274;
      VendLedgEntry@1001 : Record 25;
      CurrencyCode@1000 : Code[10];
    BEGIN
      // [FEATURE] [Purchase] [Currency]
      // [SCENARIO 381276] Payment in local currency should be applied to Purchase Invoice in foreign currency with different exchange rate

      Initialize;

      // [GIVEN] Currency "X" with "Posting Date" = 01.01 and "Exchange Rate" = 1/100
      // [GIVEN] Currency "X" with "Posting Date" = 02.01 and "Exchange Rate" = 1/99
      CurrencyCode := SetupCurrencyWithExchRates;

      // [GIVEN] Purchase Invoice with "Posting Date" = 01.01, "Currency Code" = "X" and Amount = 10 ("Amount (LCY)" = 1000)
      CreateVendAndPostPurchInvoice(VendLedgEntry,CurrencyCode);

      // [GIVEN] Bank Account Reconciliation in local currency, "Posting Date" = 02.01 and Amount = 1000
      LibraryERM.CreateBankAccount(BankAcc);
      VendLedgEntry.CALCFIELDS("Remaining Amt. (LCY)");
      CreateBankPmtReconcWithLine(BankAcc,BankAccRecon,BankAccReconLine,WORKDATE + 1,VendLedgEntry."Remaining Amt. (LCY)");
      BankAccReconLine.MODIFY(TRUE);

      // [GIVEN] Purchase Invoice applied to Bank Account Reconciliation
      ApplyVendLedgEntry(BankAccReconLine,VendLedgEntry);

      // [WHEN] Post Bank Account Reconciliation
      LibraryERM.PostBankAccReconciliation(BankAccRecon);

      // [THEN] Purchase Invoice fully applied to Payment
      VendLedgEntry.FIND;
      VendLedgEntry.TESTFIELD(Open,FALSE);
    END;

    LOCAL PROCEDURE Initialize@27();
    VAR
      LibraryERMCountryData@1004 : Codeunit 131305;
    BEGIN
      LibrarySetupStorage.Restore;
      IF Initialized THEN
        EXIT;
      Initialized := TRUE;
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralLedgerSetup;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.UpdatePurchasesPayablesSetup;
      UpdateCustPostingGrp;
      LibrarySetupStorage.Save(DATABASE::"Source Code Setup");
      COMMIT;
    END;

    LOCAL PROCEDURE GetGlobalDim1CodeValue@66(VAR DimValue@1001 : Record 349);
    VAR
      Dimension@1002 : Record 348;
    BEGIN
      IF LibraryERM.GetGlobalDimensionCode(1) = '' THEN BEGIN
        LibraryDim.CreateDimension(Dimension);
        LibraryERM.SetGlobalDimensionCode(1,Dimension.Code);
        LibraryDim.CreateDimensionValue(DimValue,Dimension.Code);
      END ELSE BEGIN
        DimValue.SETRANGE("Dimension Code",LibraryERM.GetGlobalDimensionCode(1));
        DimValue.SETRANGE("Dimension Value Type",DimValue."Dimension Value Type"::Standard);
        DimValue.SETRANGE(Blocked,FALSE);
        DimValue.FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE GetGlobalDim2CodeValue@16(VAR DimValue@1001 : Record 349);
    VAR
      Dimension@1002 : Record 348;
    BEGIN
      IF LibraryERM.GetGlobalDimensionCode(2) = '' THEN BEGIN
        LibraryDim.CreateDimension(Dimension);
        LibraryERM.SetGlobalDimensionCode(2,Dimension.Code);
        LibraryDim.CreateDimensionValue(DimValue,Dimension.Code);
      END ELSE BEGIN
        DimValue.SETRANGE("Dimension Code",LibraryERM.GetGlobalDimensionCode(2));
        DimValue.SETRANGE("Dimension Value Type",DimValue."Dimension Value Type"::Standard);
        DimValue.SETRANGE(Blocked,FALSE);
        DimValue.FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE BlockDimValue@75(VAR DimValue@1000 : Record 349);
    BEGIN
      DimValue.VALIDATE(Blocked,TRUE);
      DimValue.MODIFY(TRUE);
      COMMIT;
    END;

    LOCAL PROCEDURE UnblockDimValue@74(VAR DimValue@1000 : Record 349);
    BEGIN
      DimValue.VALIDATE(Blocked,FALSE);
      DimValue.MODIFY(TRUE);
      COMMIT;
    END;

    LOCAL PROCEDURE BlockDimCombination@21(DimCode1@1000 : Code[20];DimCode2@1001 : Code[20]);
    VAR
      DimCombination@1002 : Record 350;
    BEGIN
      WITH DimCombination DO BEGIN
        INIT;
        VALIDATE("Dimension 1 Code",DimCode1);
        VALIDATE("Dimension 2 Code",DimCode2);
        VALIDATE("Combination Restriction","Combination Restriction"::Blocked);
        INSERT;
      END;
      COMMIT;
    END;

    LOCAL PROCEDURE UnblockDimCombination@22(DimCode1@1001 : Code[20];DimCode2@1000 : Code[20]);
    VAR
      DimCombination@1002 : Record 350;
    BEGIN
      DimCombination.GET(DimCode1,DimCode2);
      DimCombination.DELETE(TRUE);
      COMMIT;
    END;

    LOCAL PROCEDURE CreateBankPmtReconcWithLine@46(BankAcc@1002 : Record 270;VAR BankAccRecon@1001 : Record 273;VAR BankAccReconLine@1000 : Record 274;TransactionDate@1004 : Date;StmtLineAmt@1003 : Decimal);
    BEGIN
      CLEAR(BankAccRecon);
      CLEAR(BankAccReconLine);

      // Create Bank Rec Header
      LibraryERM.CreateBankAccReconciliation(
        BankAccRecon,BankAcc."No.",BankAccRecon."Statement Type"::"Payment Application");
      LibraryERM.CreateBankAccReconciliationLn(BankAccReconLine,BankAccRecon);

      // Create Bank Rec Line
      BankAccReconLine.VALIDATE("Transaction Date",TransactionDate);
      BankAccReconLine.VALIDATE(Description,'Hello World');
      BankAccReconLine.VALIDATE("Statement Amount",StmtLineAmt);
      BankAccReconLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateCustAndPostSalesInvoice@1(VAR CustLedgEntry@1000 : Record 21;CurrencyCode@1008 : Code[10]);
    VAR
      Cust@1004 : Record 18;
    BEGIN
      LibrarySales.CreateCustomer(Cust);
      CreateSalesInvoiceAndPost(Cust,CustLedgEntry,CurrencyCode);
    END;

    LOCAL PROCEDURE CreateSalesInvoiceAndPost@29(VAR Cust@1000 : Record 18;VAR CustLedgEntry@1006 : Record 21;CurrencyCode@1005 : Code[10]);
    VAR
      SalesHeader@1003 : Record 36;
      SalesLine@1002 : Record 37;
      Item@1001 : Record 27;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Invoice,Cust."No.");
      SalesHeader.VALIDATE("Currency Code",CurrencyCode);
      SalesHeader.MODIFY(TRUE);

      LibraryInventory.CreateItem(Item);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,Item."No.",1);
      SalesLine.VALIDATE("Unit Price",100);
      SalesLine.MODIFY(TRUE);

      CustLedgEntry.SETRANGE("Customer No.",Cust."No.");
      CustLedgEntry.SETRANGE("Document Type",CustLedgEntry."Document Type"::Invoice);
      CustLedgEntry.SETRANGE("Document No.",LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE));
      CustLedgEntry.FINDFIRST;
      CustLedgEntry.CALCFIELDS("Remaining Amount");
    END;

    LOCAL PROCEDURE CreateVendAndPostPurchInvoice@23(VAR VendLedgEntry@1000 : Record 25;CurrencyCode@1008 : Code[10]);
    VAR
      Vend@1004 : Record 23;
    BEGIN
      LibraryPurch.CreateVendor(Vend);
      CreatePurchInvoiceAndPost(Vend,VendLedgEntry,CurrencyCode);
    END;

    LOCAL PROCEDURE CreatePurchInvoiceAndPost@20(VAR Vend@1000 : Record 23;VAR VendLedgEntry@1006 : Record 25;CurrencyCode@1005 : Code[10]);
    VAR
      PurchHeader@1003 : Record 38;
      PurchLine@1002 : Record 39;
      Item@1001 : Record 27;
    BEGIN
      LibraryPurch.CreatePurchHeader(PurchHeader,PurchHeader."Document Type"::Invoice,Vend."No.");
      PurchHeader.VALIDATE("Currency Code",CurrencyCode);
      PurchHeader.MODIFY(TRUE);

      LibraryInventory.CreateItem(Item);
      LibraryPurch.CreatePurchaseLine(PurchLine,PurchHeader,PurchLine.Type::Item,Item."No.",1);
      PurchLine.VALIDATE("Direct Unit Cost",100);
      PurchLine.MODIFY(TRUE);

      VendLedgEntry.SETRANGE("Vendor No.",Vend."No.");
      VendLedgEntry.SETRANGE("Document Type",VendLedgEntry."Document Type"::Invoice);
      VendLedgEntry.SETRANGE("Document No.",LibraryPurch.PostPurchaseDocument(PurchHeader,TRUE,TRUE));
      VendLedgEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE UpdateSourceCodeSetupForPmtReconJnl@41(NewSourceCode@1001 : Code[10]);
    VAR
      SourceCodeSetup@1000 : Record 242;
    BEGIN
      WITH SourceCodeSetup DO BEGIN
        GET;
        VALIDATE("Payment Reconciliation Journal",NewSourceCode);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE SetupCurrencyWithExchRates@47() : Code[10];
    VAR
      Currency@1001 : Record 4;
      CurrExchRateAmount@1000 : Decimal;
    BEGIN
      LibraryERM.CreateCurrency(Currency);
      Currency.VALIDATE("Realized Gains Acc.",LibraryERM.CreateGLAccountNo);
      Currency.VALIDATE("Realized Losses Acc.",LibraryERM.CreateGLAccountNo);
      Currency.MODIFY(TRUE);
      CurrExchRateAmount := LibraryRandom.RandDec(100,2);
      LibraryERM.CreateExchangeRate(Currency.Code,WORKDATE,1 / CurrExchRateAmount,1 / CurrExchRateAmount);
      LibraryERM.CreateExchangeRate(Currency.Code,WORKDATE + 1,1 / (CurrExchRateAmount - 1),1 / (CurrExchRateAmount - 1));
      EXIT(Currency.Code);
    END;

    LOCAL PROCEDURE ApplyCustLedgEntry@5(BankAccReconLine@1002 : Record 274;CustLedgEntry@1001 : Record 21);
    VAR
      AppliedPmtEntry@1000 : Record 1294;
    BEGIN
      WITH AppliedPmtEntry DO BEGIN
        CLEAR(AppliedPmtEntry);
        TransferFromBankAccReconLine(BankAccReconLine);

        VALIDATE("Account Type","Account Type"::Customer);
        VALIDATE("Account No.",CustLedgEntry."Customer No.");
        VALIDATE("Applies-to Entry No.",CustLedgEntry."Entry No.");
        INSERT(TRUE);
        COMMIT;
      END;
    END;

    LOCAL PROCEDURE ApplyVendLedgEntry@28(BankAccReconLine@1002 : Record 274;VendLedgEntry@1001 : Record 25);
    VAR
      AppliedPaymentEntry@1000 : Record 1294;
    BEGIN
      WITH AppliedPaymentEntry DO BEGIN
        CLEAR(AppliedPaymentEntry);
        TransferFromBankAccReconLine(BankAccReconLine);

        VALIDATE("Account Type","Account Type"::Vendor);
        VALIDATE("Account No.",VendLedgEntry."Vendor No.");
        VALIDATE("Applies-to Entry No.",VendLedgEntry."Entry No.");
        INSERT(TRUE);
        COMMIT;
      END;
    END;

    LOCAL PROCEDURE VerifyCustLedgEntry@6(CustNo@1000 : Code[20]);
    VAR
      CustLedgEntry@1001 : Record 21;
    BEGIN
      CustLedgEntry.SETRANGE("Customer No.",CustNo);
      CustLedgEntry.FINDSET;
      REPEAT
        Assert.IsTrue(NOT CustLedgEntry.Open,'Entry is closed');
      UNTIL CustLedgEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyVendLedgEntry@30(VendNo@1000 : Code[20]);
    VAR
      VendLedgEntry@1001 : Record 25;
    BEGIN
      VendLedgEntry.SETRANGE("Vendor No.",VendNo);
      VendLedgEntry.FINDSET;
      REPEAT
        Assert.IsTrue(NOT VendLedgEntry.Open,'Entry is closed');
      UNTIL VendLedgEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyBankLedgEntry@19(BankAccNo@1000 : Code[20];ExpAmt@1003 : Decimal);
    VAR
      BankAccLedgEntry@1001 : Record 271;
      TotalAmt@1002 : Decimal;
    BEGIN
      BankAccLedgEntry.SETRANGE("Bank Account No.",BankAccNo);
      BankAccLedgEntry.FINDSET;
      REPEAT
        TotalAmt += BankAccLedgEntry.Amount;
      UNTIL BankAccLedgEntry.NEXT = 0;

      Assert.AreEqual(ExpAmt,TotalAmt,'')
    END;

    LOCAL PROCEDURE VerifyLastGLRegisterSourceCode@48(ExpectedSourceCode@1002 : Code[10]);
    VAR
      GLRegister@1000 : Record 45;
      GLEntry@1001 : Record 17;
    BEGIN
      GLRegister.FINDLAST;
      Assert.AreEqual(ExpectedSourceCode,GLRegister."Source Code",GLRegister.FIELDCAPTION("Source Code"));

      WITH GLEntry DO BEGIN
        SETRANGE("Entry No.",GLRegister."From Entry No.",GLRegister."To Entry No.");
        FINDSET;
        REPEAT
          Assert.AreEqual(ExpectedSourceCode,"Source Code",FIELDCAPTION("Source Code"));
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE VerifyMinMaxAmounts@43(Amount@1000 : Decimal;TolerancePct@1001 : Decimal;MinAmount@1003 : Decimal;MaxAmount@1002 : Decimal);
    BEGIN
      Assert.AreEqual(ROUND(Amount - Amount * TolerancePct / 100),MinAmount,'Min Amount was not set to a correct value');
      Assert.AreEqual(ROUND(Amount + Amount * TolerancePct / 100),MaxAmount,'Max Amount was not set to a correct value');
    END;

    LOCAL PROCEDURE UpdateCustPostingGrp@8();
    VAR
      CustPostingGroup@1000 : Record 92;
      GLAcc@1001 : Record 15;
    BEGIN
      LibraryERM.CreateGLAccount(GLAcc);
      WITH CustPostingGroup DO
        IF FINDSET THEN
          REPEAT
            IF "Payment Disc. Debit Acc." = '' THEN BEGIN
              VALIDATE("Payment Disc. Debit Acc.",GLAcc."No.");
              MODIFY(TRUE);
            END;
            IF "Payment Disc. Credit Acc." = '' THEN BEGIN
              VALIDATE("Payment Disc. Credit Acc.",GLAcc."No.");
              MODIFY(TRUE);
            END;
          UNTIL NEXT = 0;
    END;

    LOCAL PROCEDURE OpenPmtReconJnl@40(BankAccRecon@1001 : Record 273;VAR PmtReconJnl@1000 : TestPage 1290);
    VAR
      PmtReconciliationJournals@1002 : TestPage 1294;
    BEGIN
      PmtReconciliationJournals.OPENVIEW;
      PmtReconciliationJournals.GOTORECORD(BankAccRecon);
      PmtReconJnl.TRAP;
      PmtReconciliationJournals.EditJournal.INVOKE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@9(Question@1000 : Text;VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    BEGIN
    {
      // [FEATURE] [Bank Payment Application]
    }
    END.
  }
}

