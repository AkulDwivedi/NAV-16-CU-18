OBJECT Codeunit 136907 Resource
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            IsInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      ItemJournalTemplate@1026 : Record 82;
      ItemJournalBatch@1025 : Record 233;
      LocationWhite@1033 : Record 14;
      Assert@1002 : Codeunit 130000;
      LibraryJob@1003 : Codeunit 131920;
      LibraryCosting@1019 : Codeunit 132200;
      LibraryInventory@1014 : Codeunit 132201;
      LibraryItemTracking@1010 : Codeunit 130502;
      LibraryMarketing@1007 : Codeunit 131900;
      LibraryPurchase@1017 : Codeunit 130512;
      LibraryResource@1011 : Codeunit 130511;
      LibrarySales@1006 : Codeunit 130509;
      LibraryService@1001 : Codeunit 131902;
      LibraryUtility@1013 : Codeunit 131000;
      LibraryFixedAsset@1029 : Codeunit 131330;
      LibraryWarehouse@1034 : Codeunit 132204;
      LibraryDimension@1035 : Codeunit 131001;
      LibraryVariableStorage@1004 : Codeunit 131004;
      LibraryRandom@1015 : Codeunit 130440;
      IsInitialized@1000 : Boolean;
      WantToCreateContactQst@1005 : TextConst '@@@="%1 = Contact No., %2 = Contact Name";ENU=Do you want to create a contact %1 %2 as a customer using a customer template?';
      WantToCreateContractQst@1009 : TextConst 'ENU=Do you want to create the contract using a contract template?';
      CannotModifyBaseUnitOfMeasureErr@1040 : TextConst '@@@=%1 Table name (Item Unit of measure), %2 Value of Measure (KG, PCS...), %3 Item ID, %4 Base unit of Measure;ENU=You cannot modify %1 %2 for resource %3 because it is the resource''s %4.';
      BaseUnitOfMeasureQtyMustBeOneErr@1012 : TextConst '@@@="%1 Name of Unit of measure (e.g. BOX, PCS, KG...), %2 Qty. of %1 per base unit of measure ";ENU=The quantity per base unit of measure must be 1. %1 is set up with %2 per unit of measure.';
      JobTaskTypeErr@1018 : TextConst 'ENU=Job Task Type must be equal to ''Posting''  in Job Task:';
      JobLedgerEntryUpdatedMsg@1020 : TextConst 'ENU=The job ledger entry item costs have now been updated to equal the related item ledger entry actual costs.';
      WantToPostJournalLinesQst@1021 : TextConst 'ENU=Do you want to post the journal lines?';
      JournalLinesPostedMsg@1022 : TextConst 'ENU=The journal lines were successfully posted.';
      NoJobLedgerEntriesUpdatedMsg@1023 : TextConst 'ENU=There were no job ledger entries that needed to be updated.';
      JobPlanningLineMustBeEmptyMsg@1027 : TextConst 'ENU=Job Planning Line must be empty.';
      PurchaseLineTypeErr@1028 : TextConst 'ENU="Job No. must not be specified when Type = Charge (Item) in Purchase Line"';
      JobNoErr@1030 : TextConst '@@@="%1 = Document Type Value, %2 = Document No. Value, %3 = Line No. Value";ENU="Job No. must not be specified when Type = Fixed Asset in Purchase Line Document Type=''%1'',Document No.=''%2'',Line No.=''%3''"';
      QuantityMustBeSameMsg@1032 : TextConst 'ENU=Quantity must be same.';
      AdjustedJobLedgerEntryExistMsg@1031 : TextConst 'ENU=Adjusted Job ledger entry exist.';
      ItemAnalysisViewEntryMustNotExistMsg@1036 : TextConst 'ENU=Item Analysis View entry must not exist.';
      WantToUndoConsumptionQst@1024 : TextConst 'ENU=Do you want to undo consumption of the selected shipment line(s)?';
      TemplateCodeErr@1037 : TextConst 'ENU=Unexpected Template Code';
      JobPlanningLineCountErr@1038 : TextConst 'ENU=%1 count should be greater than %2';
      JobPlanningLineFilterErr@1039 : TextConst 'ENU=Entry count of %1 with filter %2 is invalid';
      DaysTok@1008 : TextConst 'ENU=day(s)';
      JobLedgEntryExistsErr@1016 : TextConst 'ENU=Incorrect Job Ledger Entry exists.';

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE ErrorOnDoingCreateAsCustomerOnContact@10();
    VAR
      Contact@1000 : Record 5050;
      TemplateCode@1001 : Code[10];
    BEGIN
      // Setup. Create Contact.
      Initialize;
      LibraryMarketing.CreateContact(Contact);
      LibraryVariableStorage.Enqueue(WantToCreateContactQst);  // Enqueue for Confirm Handler.
      LibraryVariableStorage.Enqueue(FALSE);  // Enqueue for Confirm Handler.

      // Exercise.
      TemplateCode := Contact.ChooseCustomerTemplate;

      // Verify.
      Assert.AreEqual('',TemplateCode,TemplateCodeErr);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ServiceContractTemplateListPageHandler,ContractLineSelectionPageHandler)]
    PROCEDURE SelectContractLinesOnServiceContract@1();
    VAR
      ServiceContractHeader@1000 : Record 5965;
      ServiceItem@1004 : Record 5940;
    BEGIN
      // Setup: Create Customer and Service Item. Create Service Contract.
      Initialize;
      CreateServiceContractHeader(ServiceContractHeader,ServiceItem);

      // Exercise.
      OpenSelectContractLinesFromServiceContractPage(ServiceContractHeader."Contract No.");

      // Verify.
      VerifyServiceContractLine(ServiceContractHeader,ServiceItem."No.");
    END;

    [Test]
    PROCEDURE ErrorOnDeletingResourceBaseUnitOfMeasure@12();
    VAR
      Resource@1000 : Record 156;
      ResourceUnitOfMeasure@1002 : Record 205;
    BEGIN
      // Setup: Create Resource.
      Initialize;
      LibraryResource.CreateResourceNew(Resource);
      ResourceUnitOfMeasure.GET(Resource."No.",Resource."Base Unit of Measure");

      // Exercise.
      ASSERTERROR ResourceUnitOfMeasure.DELETE(TRUE);

      // Verify.
      Assert.ExpectedError(
        STRSUBSTNO(
          CannotModifyBaseUnitOfMeasureErr,ResourceUnitOfMeasure.TABLECAPTION,ResourceUnitOfMeasure.Code,Resource."No.",
          Resource.FIELDCAPTION("Base Unit of Measure")));
    END;

    [Test]
    PROCEDURE ErrorOnRenamingResourceBaseUnitOfMeasure@7();
    VAR
      Resource@1002 : Record 156;
      SalesLine@1000 : Record 37;
      ResourceUnitOfMeasure@1001 : Record 205;
      UnitOfMeasure@1003 : Record 204;
    BEGIN
      // Setup: Create Resource. Create and post Sales Order. Create Unit of Measure code.
      Initialize;
      LibraryResource.CreateResourceNew(Resource);
      CreateAndPostSalesOrder(
        '',SalesLine.Type::Resource,Resource."No.",LibraryRandom.RandDec(10,2));
      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      ResourceUnitOfMeasure.GET(Resource."No.",Resource."Base Unit of Measure");

      // Exercise.
      ASSERTERROR ResourceUnitOfMeasure.RENAME(Resource."No.",UnitOfMeasure.Code);

      // Verify.
      Assert.ExpectedError(
        STRSUBSTNO(
          CannotModifyBaseUnitOfMeasureErr,ResourceUnitOfMeasure.TABLECAPTION,Resource."Base Unit of Measure",Resource."No.",
          Resource.FIELDCAPTION("Base Unit of Measure")));
    END;

    [Test]
    PROCEDURE ToDoForContactWithSalesPerson@13();
    BEGIN
      // Setup.
      Initialize;
      ToDoForContact(FALSE);
    END;

    [Test]
    PROCEDURE ToDoForContactWithSalesPersonAndTeamCode@15();
    BEGIN
      // Setup.
      Initialize;
      ToDoForContact(TRUE);  // UpdateTeamCode as TRUE.
    END;

    LOCAL PROCEDURE ToDoForContact@4(UpdateTeamCode@1008 : Boolean);
    VAR
      Contact@1000 : Record 5050;
      TeamSalesperson@1001 : Record 5084;
      Team@1004 : Record 5083;
      ToDo@1002 : Record 5080;
      ToDoList@1006 : TestPage 5096;
    BEGIN
      // Create Contact. Create Team and Team Salesperson.
      LibraryMarketing.CreateContact(Contact);
      LibraryMarketing.CreateTeam(Team);
      LibraryMarketing.CreateTeamSalesperson(TeamSalesperson,Team.Code,Contact."Salesperson Code");

      // Exercise.
      CreateToDo(ToDo,Contact);

      // Verify.
      VerifyToDo(Contact,ToDo."No.");

      IF UpdateTeamCode THEN BEGIN
        // Exercise.
        OpenToDoCardFromContactCardAndUpdateTeamCode(ToDoList,Contact."No.",Team.Code);

        // Verify.
        ToDoList."Team Code".ASSERTEQUALS(Team.Code);
      END;
    END;

    [Test]
    PROCEDURE ErrorOnUpdatingJobTaskNoOnPurchaseOrderLine@5();
    VAR
      JobTask@1001 : Record 1001;
    BEGIN
      // Setup.
      Initialize;
      ErrorOnUpdatingJobTaskTypeOnPurchaseLine(JobTask."Job Task Type"::Total);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE UpdateJobItemCostReportAfterPostPurchaseOrder@11();
    VAR
      PurchaseHeader@1007 : Record 38;
      PurchaseLine@1006 : Record 39;
      Item@1000 : Record 27;
      JobTask@1003 : Record 1001;
      JobLedgerEntry@1005 : Record 169;
      Quantity@1009 : Decimal;
      DirectUnitCost@1001 : Decimal;
      DocumentNo@1002 : Code[20];
      DocumentNo2@1004 : Code[20];
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Job ledger entries contain correct values after running Update Job Item Cost batch report and posting Purchase Orders.

      // Setup: Create Item with Average Costing method. Create Job and Job Task. Post Purchase Orders with different Direct Unit cost. Run Adjust Cost Item entries batch job.
      Initialize;
      Quantity := LibraryRandom.RandInt(10);
      DirectUnitCost := Quantity + LibraryRandom.RandInt(10);  // Greater value required for Direct Unit Cost.
      CreateItemWithCostingMethod(Item,Item."Costing Method"::Average);
      CreateJobWithJobTask(JobTask);
      DocumentNo :=
        CreateAndPostPurchaseOrderWithJob(
          PurchaseHeader,PurchaseLine,JobTask,Item."No.",Quantity,Quantity,Quantity,PurchaseLine."Job Line Type"::Schedule,TRUE);
      // Validating Direct Unit Cost as Quantity and post as invoice.
      DocumentNo2 :=
        CreateAndPostPurchaseOrderWithJob(
          PurchaseHeader,PurchaseLine,JobTask,Item."No.",Quantity,Quantity,DirectUnitCost,
          PurchaseLine."Job Line Type"::Schedule,TRUE);  // post as invoice.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Exercise.
      LibraryVariableStorage.Enqueue(JobLedgerEntryUpdatedMsg);  // Enqueue for MessageHandler.
      LibraryJob.RunUpdateJobItemCost(JobTask."Job No.");

      // Verify.
      VerifyJobLedgerEntry(
        JobTask."Job No.",DocumentNo,JobLedgerEntry."Line Type"::Schedule,Item."Base Unit of Measure",Quantity,
        (Quantity + DirectUnitCost) / 2,Quantity,0);  // Calculated value required for Unit Cost.
      VerifyJobLedgerEntry(
        JobTask."Job No.",DocumentNo2,JobLedgerEntry."Line Type"::Schedule,Item."Base Unit of Measure",DirectUnitCost,
        (Quantity + DirectUnitCost) / 2,Quantity,0);  // Calculated value required for Unit Cost.
    END;

    [Test]
    PROCEDURE GetReceiptLinesOnPurchaseInvoiceWithJob@18();
    VAR
      Item@1004 : Record 27;
      JobPlanningLine@1007 : Record 1003;
      JobTask@1000 : Record 1001;
      PurchaseHeader@1003 : Record 38;
      PurchaseLine@1002 : Record 39;
      PurchaseLine2@1005 : Record 39;
      DocumentNo@1001 : Code[20];
    BEGIN
      // Setup: Create Item. Create Job and Job Task. Create and post Purchase Order with two lines with different Job Line Type.
      Initialize;
      LibraryInventory.CreateItem(Item);
      CreateJobWithJobTask(JobTask);
      CreateAndPostPurchaseOrderWithMultipleLines(PurchaseHeader,PurchaseLine,PurchaseLine2,JobTask,Item."No.");

      // Exercise.
      DocumentNo := CreateAndPostPurchaseInvoiceWithGetReceiptLines(PurchaseHeader."Buy-from Vendor No.",PurchaseHeader."No.");

      // Verify.
      VerifyJobPlanningLine(PurchaseLine,JobPlanningLine."Line Type"::Schedule,FALSE,PurchaseLine.Quantity);
      VerifyJobPlanningLine(PurchaseLine2,JobPlanningLine."Line Type"::Schedule,TRUE,PurchaseLine2.Quantity);  // MoveNext as TRUE.
      VerifyJobPlanningLine(PurchaseLine2,JobPlanningLine."Line Type"::Contract,FALSE,PurchaseLine2.Quantity);
      VerifyJobLedgerEntry(
        JobTask."Job No.",DocumentNo,PurchaseLine."Job Line Type",Item."Base Unit of Measure",PurchaseLine."Direct Unit Cost",
        PurchaseLine."Direct Unit Cost",PurchaseLine.Quantity,0);
      VerifyJobLedgerEntry(
        JobTask."Job No.",DocumentNo,PurchaseLine2."Job Line Type",Item."Base Unit of Measure",PurchaseLine2."Direct Unit Cost",
        PurchaseLine2."Direct Unit Cost",PurchaseLine2.Quantity,0);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE UpdateJobItemCostWithPOAndStandardCosting@58();
    VAR
      Item@1004 : Record 27;
      ItemUnitOfMeasure@1003 : Record 5404;
      JobTask@1002 : Record 1001;
      Quantity@1001 : Decimal;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Adjustment Job ledger entry does not gets created after Update Job Item Cost batch job with Standard Costing.

      // Setup.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,2);
      AdjustCostItemEntriesWithJobAndStandardCosting(Item,ItemUnitOfMeasure,JobTask,Quantity);

      // Exercise.
      LibraryVariableStorage.Enqueue(NoJobLedgerEntriesUpdatedMsg);  // Enqueue for Message Handler.
      LibraryJob.RunUpdateJobItemCost(JobTask."Job No.");

      // Verify: Adjustment Job ledger entry does not exist.
      VerifyAdjustedJobLedgerEntryExist(JobTask."Job No.",Item."No.",Item."Base Unit of Measure",FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AdjustCostItemEntriesWithDiffUOMAndStandardCosting@59();
    VAR
      Item@1004 : Record 27;
      ItemUnitOfMeasure@1003 : Record 5404;
      JobTask@1002 : Record 1001;
      Quantity@1001 : Decimal;
      OldAutomaticUpdateJobItemCost@1000 : Boolean;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Adjustment Job ledger entry does not gets created after Adjust Cost Item Entries with different UOM and Standard Costing.

      // Setup.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,2);
      AdjustCostItemEntriesWithJobAndStandardCosting(Item,ItemUnitOfMeasure,JobTask,Quantity);
      LibraryVariableStorage.Enqueue(NoJobLedgerEntriesUpdatedMsg);  // Enqueue for Message Handler.
      LibraryJob.RunUpdateJobItemCost(JobTask."Job No.");

      // Exercise: Update Automatic Update Job Item cost on Jobs Setup. Create and post Job Journal. Run Adjust Cost Item entries batch job.
      OldAutomaticUpdateJobItemCost := UpdateAutomaticUpdateJobItemCostOnJobsSetup(TRUE);
      CreateAndPostJobJournalLine(JobTask,Item."No.",ItemUnitOfMeasure.Code,Quantity,0,FALSE);  // Value 0 required for Unit Cost.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Verify: Adjustment Job ledger entry does not exist.
      VerifyAdjustedJobLedgerEntryExist(JobTask."Job No.",Item."No.",ItemUnitOfMeasure.Code,FALSE);

      // Tear Down.
      UpdateAutomaticUpdateJobItemCostOnJobsSetup(OldAutomaticUpdateJobItemCost);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingPageHandler,EnterQuantityToCreatePageHandler,ItemTrackingSummaryPageHandler,MessageHandler,ConfirmHandler)]
    PROCEDURE UpdateJobItemCostWithPOAndSpecificCosting@40();
    VAR
      Item@1004 : Record 27;
      ItemUnitOfMeasure@1003 : Record 5404;
      JobTask@1002 : Record 1001;
      Quantity@1001 : Decimal;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Adjustment Job ledger entry gets created after Update Job Item Cost batch job with Specific Costing and Serial Tracking.

      // Setup.
      Initialize;
      Quantity := LibraryRandom.RandInt(10);
      AdjustCostItemEntriesWithJobAndSpecificCosting(Item,ItemUnitOfMeasure,JobTask,Quantity);

      // Exercise.
      LibraryVariableStorage.Enqueue(JobLedgerEntryUpdatedMsg);  // Enqueue for Message Handler.
      LibraryJob.RunUpdateJobItemCost(JobTask."Job No.");

      // Verify: Adjustment Job ledger entry exist.
      VerifyAdjustedJobLedgerEntryExist(JobTask."Job No.",Item."No.",Item."Base Unit of Measure",TRUE);  // TRUE for Entry Exist.
    END;

    [Test]
    [HandlerFunctions(ItemTrackingPageHandler,EnterQuantityToCreatePageHandler,ItemTrackingSummaryPageHandler,MessageHandler,ConfirmHandler)]
    PROCEDURE AdjustCostItemEntriesWithDiffUOMAndSpecificCosting@39();
    VAR
      Item@1004 : Record 27;
      ItemUnitOfMeasure@1003 : Record 5404;
      JobTask@1002 : Record 1001;
      Quantity@1001 : Decimal;
      OldAutomaticUpdateJobItemCost@1000 : Boolean;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Adjustment Job ledger entry gets created after Adjust Cost Item Entries with different UOM, Specific Costing and Serial Tracking.

      // Setup.
      Initialize;
      Quantity := LibraryRandom.RandInt(10);
      AdjustCostItemEntriesWithJobAndSpecificCosting(Item,ItemUnitOfMeasure,JobTask,Quantity);
      LibraryVariableStorage.Enqueue(JobLedgerEntryUpdatedMsg);  // Enqueue for Message Handler.
      LibraryJob.RunUpdateJobItemCost(JobTask."Job No.");

      // Exercise: Update Automatic Update Job Item cost on Jobs Setup. Create and post Job Journal. Run Adjust Cost Item entries batch job.
      OldAutomaticUpdateJobItemCost := UpdateAutomaticUpdateJobItemCostOnJobsSetup(TRUE);
      CreateAndPostJobJournalLine(
        JobTask,Item."No.",ItemUnitOfMeasure.Code,Quantity / ItemUnitOfMeasure."Qty. per Unit of Measure",
        Item."Unit Cost" + 50,TRUE);  // Calculated values required for Quantity and Direct Unit Cost. TRUE for Tracking.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Verify: Adjustment Job ledger entry exist.
      VerifyAdjustedJobLedgerEntryExist(JobTask."Job No.",Item."No.",ItemUnitOfMeasure.Code,TRUE);  // TRUE for Entry Exist.

      // Tear Down.
      UpdateAutomaticUpdateJobItemCostOnJobsSetup(OldAutomaticUpdateJobItemCost);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE UpdateJobItemCostWithPOAndAverageCosting@44();
    VAR
      Item@1000 : Record 27;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Adjustment Job ledger entry gets created after Update Job Item Cost batch job with Average Costing.

      // Setup.
      Initialize;
      UpdateJobItemCostWithPOAndCostingMethod(Item."Costing Method"::Average);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AdjustCostItemEntriesWithDiffUOMAndAverageCosting@43();
    VAR
      Item@1000 : Record 27;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Adjustment Job ledger entry gets created after Adjust Cost Item Entries with different UOM and Average Costing.

      // Setup.
      Initialize;
      AdjustCostItemWithMultipleUOMAndCostingMethod(Item."Costing Method"::Average);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE UpdateJobItemCostWithPOAndFIFOCosting@50();
    VAR
      Item@1000 : Record 27;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Adjustment Job ledger entry gets created after Update Job Item Cost batch job with FIFO Costing.

      // Setup.
      Initialize;
      UpdateJobItemCostWithPOAndCostingMethod(Item."Costing Method"::FIFO);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE AdjustCostItemEntriesWithDiffUOMAndFIFOCosting@49();
    VAR
      Item@1000 : Record 27;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Adjustment Job ledger entry gets created after Adjust Cost Item Entries with different UOM and FIFO Costing.

      // Setup.
      Initialize;
      AdjustCostItemWithMultipleUOMAndCostingMethod(Item."Costing Method"::FIFO);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE UpdateJobItemCostWithPOAndLIFOCosting@52();
    VAR
      Item@1000 : Record 27;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Adjustment Job ledger entry gets created after Update Job Item Cost batch job with LIFO Costing.

      // Setup.
      Initialize;
      UpdateJobItemCostWithPOAndCostingMethod(Item."Costing Method"::LIFO);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE AdjustCostItemEntriesWithDiffUOMAndLIFOCosting@51();
    VAR
      Item@1000 : Record 27;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Adjustment Job ledger entry gets created after Adjust Cost Item Entries with different UOM and LIFO Costing.

      // Setup.
      Initialize;
      AdjustCostItemWithMultipleUOMAndCostingMethod(Item."Costing Method"::LIFO);
    END;

    LOCAL PROCEDURE AdjustCostItemWithMultipleUOMAndCostingMethod@48(CostingMethod@1011 : Option);
    VAR
      Item@1000 : Record 27;
      ItemUnitOfMeasure@1002 : Record 5404;
      JobTask@1001 : Record 1001;
      Quantity@1004 : Decimal;
      OldAutomaticUpdateJobItemCost@1009 : Boolean;
    BEGIN
      // Adjust Cost Item Entries with Job and Costing Method.
      Quantity := LibraryRandom.RandDec(10,2);
      AdjustCostItemEntriesWithJobAndCostingMethod(Item,ItemUnitOfMeasure,JobTask,CostingMethod,Quantity);
      LibraryVariableStorage.Enqueue(JobLedgerEntryUpdatedMsg);  // Enqueue for Message Handler.
      LibraryJob.RunUpdateJobItemCost(JobTask."Job No.");

      // Exercise: Update Automatic Update Job Item cost on Jobs Setup. Create and post Job Journal. Run Adjust Cost Item entries batch job.
      OldAutomaticUpdateJobItemCost := UpdateAutomaticUpdateJobItemCostOnJobsSetup(TRUE);
      CreateAndPostJobJournalLine(JobTask,Item."No.",ItemUnitOfMeasure.Code,Quantity,Item."Unit Cost" + 50,FALSE);  // Greater value required for Unit Cost.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Verify: Adjusted Job ledger entry exist.
      VerifyAdjustedJobLedgerEntryExist(JobTask."Job No.",Item."No.",ItemUnitOfMeasure.Code,TRUE);  // TRUE for Entry Exist.

      // Tear Down.
      UpdateAutomaticUpdateJobItemCostOnJobsSetup(OldAutomaticUpdateJobItemCost);
    END;

    LOCAL PROCEDURE UpdateJobItemCostWithPOAndCostingMethod@90(CostingMethod@1003 : Option);
    VAR
      Item@1001 : Record 27;
      ItemUnitOfMeasure@1002 : Record 5404;
      JobTask@1004 : Record 1001;
      Quantity@1000 : Decimal;
    BEGIN
      // Adjust Cost Item Entries with Job and Costing Method.
      Quantity := LibraryRandom.RandDec(10,2);
      AdjustCostItemEntriesWithJobAndCostingMethod(Item,ItemUnitOfMeasure,JobTask,CostingMethod,Quantity);

      // Exercise.
      LibraryVariableStorage.Enqueue(JobLedgerEntryUpdatedMsg);  // Enqueue for Message Handler.
      LibraryJob.RunUpdateJobItemCost(JobTask."Job No.");

      // Verify: Adjusted Job ledger entry exist.
      VerifyAdjustedJobLedgerEntryExist(JobTask."Job No.",Item."No.",Item."Base Unit of Measure",TRUE);  // TRUE for Entry Exist.
    END;

    [Test]
    PROCEDURE JobPlngLinesAfterShippingPurchOrdWithPartialQty@55();
    VAR
      JobPlanningLine@1005 : Record 1003;
      PurchaseHeader@1003 : Record 38;
      PurchaseLine@1004 : Record 39;
    BEGIN
      // Setup.
      Initialize;

      // Exercise.
      CreateAndReceivePurchaseOrderWithJob(PurchaseHeader,PurchaseLine);

      // Verify.
      VerifyEmptyJobPlanningLines(PurchaseLine,JobPlanningLine."Line Type"::Schedule);
      VerifyEmptyJobPlanningLines(PurchaseLine,JobPlanningLine."Line Type"::Contract);
      VerifyEmptyJobPlanningLines(PurchaseLine,JobPlanningLine."Line Type"::"Both Schedule and Contract");
    END;

    [Test]
    PROCEDURE JobPlngLinesAfterInvoicingPurchOrdWithPartialQty@54();
    VAR
      JobPlanningLine@1003 : Record 1003;
      PurchaseHeader@1002 : Record 38;
      PurchaseLine@1001 : Record 39;
    BEGIN
      // Setup: Create and receive Purchase Order with Job.
      Initialize;
      CreateAndReceivePurchaseOrderWithJob(PurchaseHeader,PurchaseLine);

      // Exercise.
      PostPurchaseOrder(PurchaseHeader,FALSE);

      // Verify.
      VerifyJobPlanningLine(PurchaseLine,JobPlanningLine."Line Type"::Schedule,FALSE,PurchaseLine.Quantity / 2);
      VerifyJobPlanningLine(PurchaseLine,JobPlanningLine."Line Type"::Contract,FALSE,PurchaseLine.Quantity / 2);
    END;

    [Test]
    PROCEDURE JobPlngLinesAfterInvoicingPurchaseOrder@53();
    VAR
      JobPlanningLine@1003 : Record 1003;
      PurchaseHeader@1002 : Record 38;
      PurchaseLine@1001 : Record 39;
    BEGIN
      // Setup: Create and receive Purchase Order with Job. Post Purchase Order as Invoice.
      Initialize;
      CreateAndReceivePurchaseOrderWithJob(PurchaseHeader,PurchaseLine);
      PostPurchaseOrder(PurchaseHeader,FALSE);

      // Exercise.
      PostPurchaseOrder(PurchaseHeader,TRUE);  // Post as Ship and Invoice.

      // Verify.
      VerifyJobPlanningLine(PurchaseLine,JobPlanningLine."Line Type"::Schedule,TRUE,PurchaseLine.Quantity / 2);  // MoveNext as True.
      VerifyJobPlanningLine(PurchaseLine,JobPlanningLine."Line Type"::Contract,TRUE,PurchaseLine.Quantity / 2);  // MoveNext as True.
    END;

    [Test]
    PROCEDURE PurchaseReturnOrderUsingCopyDocumentWithJob@69();
    VAR
      Item@1001 : Record 27;
      JobTask@1002 : Record 1001;
      Quantity@1000 : Decimal;
    BEGIN
      // Setup: Create Item. Create Job with Job Task.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryInventory.CreateItem(Item);
      CreateJobWithJobTask(JobTask);

      // Exercise.
      CopyDocumentUsingPurchaseOrderWithJob(JobTask,Item."No.",Quantity);

      // Verify.
      VerifyPurchaseReturnOrder(JobTask,Item."No.",Quantity);
    END;

    [Test]
    PROCEDURE PostPurchaseReturnOrderUsingCopyDocumentWithJob@68();
    VAR
      Item@1002 : Record 27;
      ItemLedgerEntry@1003 : Record 32;
      JobTask@1001 : Record 1001;
      Quantity@1000 : Decimal;
    BEGIN
      // Setup.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryInventory.CreateItem(Item);
      CreateJobWithJobTask(JobTask);
      CopyDocumentUsingPurchaseOrderWithJob(JobTask,Item."No.",Quantity);

      // Exercise.
      UpdateQuantityAndPostPurchaseReturnOrder(Item."No.",Quantity / 2);  // Partial posting required.

      // Verify.
      VerifyItemLedgerEntry(
        ItemLedgerEntry."Entry Type"::Purchase,ItemLedgerEntry."Document Type"::"Purchase Receipt",FALSE,Item."No.",
        Quantity,0,0);  // Value 0 for Remaining Quantity.
      VerifyItemLedgerEntry(
        ItemLedgerEntry."Entry Type"::Purchase,ItemLedgerEntry."Document Type"::"Purchase Return Shipment",FALSE,Item."No.",
        -Quantity / 2,0,0);  // Value 0 for Remaining Quantity.
    END;

    [Test]
    PROCEDURE ErrorOnUpdatingEndTotalJobTaskTypeOnPurchaseLine@62();
    VAR
      JobTask@1004 : Record 1001;
    BEGIN
      // Setup.
      Initialize;
      ErrorOnUpdatingJobTaskTypeOnPurchaseLine(JobTask."Job Task Type"::"End-Total");
    END;

    [Test]
    PROCEDURE ErrorOnUpdatingBeginTotalJobTaskTypeOnPurchaseLine@63();
    VAR
      JobTask@1003 : Record 1001;
    BEGIN
      // Setup.
      Initialize;
      ErrorOnUpdatingJobTaskTypeOnPurchaseLine(JobTask."Job Task Type"::"Begin-Total");
    END;

    LOCAL PROCEDURE ErrorOnUpdatingJobTaskTypeOnPurchaseLine@64(JobTaskType@1004 : Option);
    VAR
      Item@1003 : Record 27;
      JobTask@1002 : Record 1001;
      PurchaseHeader@1001 : Record 38;
      PurchaseLine@1000 : Record 39;
    BEGIN
      // Create Job and Job Task. Update Job Task Type on Job Task. Create Item.
      CreateJobWithJobTask(JobTask);
      UpdateJobTaskTypeOnJobTask(JobTask,JobTaskType);
      LibraryInventory.CreateItem(Item);

      // Exercise.
      ASSERTERROR CreatePurchaseOrderWithJob(
          PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,Item."No.",LibraryRandom.RandDec(10,2),PurchaseLine.Quantity,
          JobTask."Job No.",JobTask."Job Task No.",LibraryRandom.RandDec(10,2),PurchaseLine."Job Line Type"::Schedule);

      // Verify.
      Assert.ExpectedError(JobTaskTypeErr);
    END;

    [Test]
    PROCEDURE ErrorOnUpdatingJobNoOnPurchaseLineForChargeItem@61();
    VAR
      Vendor@1001 : Record 23;
      JobTask@1003 : Record 1001;
      PurchaseHeader@1004 : Record 38;
      PurchaseLine@1005 : Record 39;
      ItemCharge@1006 : Record 5800;
    BEGIN
      // Setup: Create Vendor. Create Job and Job Task line. Create Item Charge.
      Initialize;
      LibraryPurchase.CreateVendor(Vendor);
      CreateJobWithJobTask(JobTask);
      LibraryInventory.CreateItemCharge(ItemCharge);

      // Exercise.
      ASSERTERROR CreatePurchaseOrderWithJob(
          PurchaseHeader,PurchaseLine,PurchaseLine.Type::"Charge (Item)",ItemCharge."No.",LibraryRandom.RandDec(10,2),
          PurchaseLine.Quantity,JobTask."Job No.",JobTask."Job Task No.",LibraryRandom.RandDec(10,2),
          PurchaseLine."Job Line Type"::Schedule);

      // Verify.
      Assert.ExpectedError(PurchaseLineTypeErr);
    END;

    [Test]
    PROCEDURE ErrorOnUpdatingJobNoOnPurchaseLineForFixedAsset@93();
    VAR
      JobTask@1000 : Record 1001;
      FixedAsset@1001 : Record 5600;
      PurchaseHeader@1002 : Record 38;
      PurchaseLine@1003 : Record 39;
    BEGIN
      // Setup: Create Job with Job Task. Create Fixed Asset.
      Initialize;
      CreateJobWithJobTask(JobTask);
      LibraryFixedAsset.CreateFixedAsset(FixedAsset);

      // Exercise.
      ASSERTERROR CreatePurchaseOrderWithJob(
          PurchaseHeader,PurchaseLine,PurchaseLine.Type::"Fixed Asset",FixedAsset."No.",LibraryRandom.RandDec(10,2),
          PurchaseLine.Quantity,JobTask."Job No.",JobTask."Job Task No.",LibraryRandom.RandDec(10,2),
          PurchaseLine."Job Line Type"::Schedule);

      // Verify.
      Assert.ExpectedError(STRSUBSTNO(JobNoErr,PurchaseLine."Document Type",PurchaseLine."Document No.",PurchaseLine."Line No."));
    END;

    [Test]
    [HandlerFunctions(ItemTrackingPageHandler,EnterQuantityToCreatePageHandler,MessageHandler)]
    PROCEDURE UpdateJobItemCostWithPartialPOAndSpecificCosting@79();
    VAR
      Item@1001 : Record 27;
      JobTask@1002 : Record 1001;
      PurchaseHeader@1004 : Record 38;
      PurchaseLine@1005 : Record 39;
      OldAutomaticUpdateJobItemCost@1003 : Boolean;
      DocumentNo@1006 : Code[20];
      DocumentNo2@1007 : Code[20];
      Quantity@1000 : Decimal;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Job Ledger Entry contains correct values after Update Job Item Cost and Adjust Cost Item Entries with Specific Costing Method.

      // Setup: Create Item with Serial Item Tracking. Update Unit Price and Costing Method on Item. Create Job with Job Task. Update Automatic Update Job Item Cost on Jobs Setup. Create and Post Partial Purchase Order with job.
      Initialize;
      Quantity := LibraryRandom.RandInt(10);
      CreateItemWithSerialItemTracking(Item);
      UpdateUnitPriceAndCostingMethodOnItem(Item,Item."Costing Method"::Specific);
      CreateJobWithJobTask(JobTask);
      OldAutomaticUpdateJobItemCost := UpdateAutomaticUpdateJobItemCostOnJobsSetup(TRUE);
      CreatePurchaseOrderWithJob(
        PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,Item."No.",Quantity * 2,
        Quantity,JobTask."Job No.",JobTask."Job Task No.",0,
        PurchaseLine."Job Line Type"::Schedule);  // Large Quantity Value Required. Use 0 for DirectUnitCost.
      UpdateUnitPriceAndAssignTrackingOnPurchaseLine(PurchaseLine,Item."Unit Price" * 2);  // Calculated Value Required for Unit Price.
      DocumentNo := LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);  // Receive and Invoice as TRUE.
      DocumentNo2 :=
        UpdateUnitPriceAndPostPurchaseOrder(
          PurchaseHeader,PurchaseLine,Item."Unit Price" / 2);  // Calculated Value Required for Unit Price.

      // Exercise.
      UpdateJobItemCostAfterAdjustCostItemEntries(Item."No.",JobTask."Job No.");

      // Verify.
      VerifyJobLedgerEntryForSerial(Item,JobTask,DocumentNo,Quantity);
      VerifyJobLedgerEntryForSerial(Item,JobTask,DocumentNo2,Quantity);

      // Tear Down.
      UpdateAutomaticUpdateJobItemCostOnJobsSetup(OldAutomaticUpdateJobItemCost);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE UpdateJobItemCostWithMultiplePOAndLIFOCosting@80();
    VAR
      Item@1001 : Record 27;
      JobTask@1002 : Record 1001;
      PurchaseLine@1005 : Record 39;
      ItemUnitOfMeasure@1007 : Record 5404;
      OldAutomaticUpdateJobItemCost@1003 : Boolean;
      DocumentNo@1006 : Code[20];
      DocumentNo2@1008 : Code[20];
      Quantity@1000 : Decimal;
    BEGIN
      // [FEATURE] [Update Job Item Cost]
      // [SCENARIO] Job Ledger Entry contains correct values after Update Job Item Cost and Adjust Cost Item Entries with Different UOM and LIFO Costing Method.

      // Setup: Create Item with Multiple Unit of Measure. Update Unit Price and Costing Method on Item. Create Job with Job Task. Update Automatic Update Job Item Cost on Jobs Setup. Create and Post Multiple Purchase Orders.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,2);
      CreateItemWithMultipleUnitOfMeasure(Item,ItemUnitOfMeasure);
      UpdateUnitPriceAndCostingMethodOnItem(Item,Item."Costing Method"::LIFO);
      CreateJobWithJobTask(JobTask);
      OldAutomaticUpdateJobItemCost := UpdateAutomaticUpdateJobItemCostOnJobsSetup(TRUE);
      DocumentNo :=
        CreateAndPostPurchaseOrderWithDifferentUOM(
          PurchaseLine,Item."No.",Quantity,Quantity,JobTask."Job No.",JobTask."Job Task No.",ItemUnitOfMeasure.Code);
      DocumentNo2 :=
        CreateAndPostPurchaseOrderWithDifferentUnitPrice(
          Item."No.",Quantity / 2,JobTask."Job No.",JobTask."Job Task No.",
          Item."Unit Price" / 2);  // Calculated Value Required for Quantity and Unit Price.

      // Exercise.
      UpdateJobItemCostAfterAdjustCostItemEntries(Item."No.",JobTask."Job No.");
      // Verify.
      VerifyJobLedgerEntry(
        JobTask."Job No.",DocumentNo,PurchaseLine."Job Line Type",Item."Base Unit of Measure",0,0,0,
        Item."Unit Price");  // Use 0 for DirectUnitCost, Unit Cost and Total Cost (LCY).
      VerifyJobLedgerEntryDoesNotExist(
        JobTask."Job No.",DocumentNo,PurchaseLine."Job Line Type",ItemUnitOfMeasure.Code);
      // Use 0 for DirectUnitCost, Unit Cost and Total Cost (LCY). Calculated Value Required for Unit Price.
      VerifyJobLedgerEntry(
        JobTask."Job No.",DocumentNo2,PurchaseLine."Job Line Type",Item."Base Unit of Measure",0,0,0,
        Item."Unit Price");  // Use 0 for DirectUnitCost, Unit Cost and Total Cost (LCY).

      // Tear Down.
      UpdateAutomaticUpdateJobItemCostOnJobsSetup(OldAutomaticUpdateJobItemCost);
    END;

    [Test]
    PROCEDURE GetSourceDocumentsOnWhseShipmentWithMultipleItems@114();
    VAR
      Item@1001 : Record 27;
      Item2@1002 : Record 27;
      SalesHeader@1003 : Record 36;
      SalesLine@1004 : Record 37;
      WarehouseShipmentHeader@1006 : Record 7320;
      WarehouseSourceFilter@1007 : Record 5771;
      Quantity@1000 : Decimal;
    BEGIN
      // Setup: Create Multiple Items. Create and Release Sales Order with Multiple Items. Create Warehouse Shipment Header with Location.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryInventory.CreateItem(Item);
      LibraryInventory.CreateItem(Item2);
      CreateSalesOrder(SalesHeader,'',SalesLine.Type::Item,Item."No.",Quantity,LocationWhite.Code);
      CreateSalesLineWithLocationCode(SalesHeader,SalesLine,SalesLine.Type::Item,Item2."No.",Quantity,LocationWhite.Code);
      LibrarySales.ReleaseSalesDocument(SalesHeader);
      CreateWarehouseShipmentHeaderWithLocation(WarehouseShipmentHeader,LocationWhite.Code);

      // Exercise.
      LibraryWarehouse.GetSourceDocumentsShipment(WarehouseShipmentHeader,WarehouseSourceFilter,LocationWhite.Code);

      // Verify.
      VerifyWarehouseShipmentLine(SalesHeader."No.",Item."No.",Quantity);
      VerifyWarehouseShipmentLine(SalesHeader."No.",Item2."No.",Quantity);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE UpdateItemAnalysisViewAfterPostJobJournal@81();
    VAR
      Customer@1002 : Record 18;
      Item@1000 : Record 27;
      ItemAnalysisViewEntry@1004 : Record 7154;
      JobTask@1003 : Record 1001;
      ItemAnalysisViewCode@1001 : Code[10];
    BEGIN
      // Setup: Create Item, Customer with Default Dimension. Create Job with Job Task. Create and Post Job Journal Line.
      Initialize;
      LibraryInventory.CreateItem(Item);
      ItemAnalysisViewCode := CreateCustomerWithDefaultDimension(Customer);
      CreateJobWithJobTask(JobTask);
      CreateAndPostJobJournalLine(JobTask,Item."No.",Item."Base Unit of Measure",LibraryRandom.RandDec(100,2),0,FALSE);  // Use 0 for UnitCost.

      // Exercise.
      UpdateItemAnalysisView(ItemAnalysisViewCode);

      // Verify.
      FilterItemAnalysisViewEntry(ItemAnalysisViewEntry,Item."No.");
      Assert.IsTrue(ItemAnalysisViewEntry.ISEMPTY,ItemAnalysisViewEntryMustNotExistMsg);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE UpdateItemAnalysisViewAfterPostSalesOrder@83();
    VAR
      Customer@1004 : Record 18;
      Item@1003 : Record 27;
      JobTask@1001 : Record 1001;
      SalesLine@1005 : Record 37;
      ItemAnalysisViewCode@1000 : Code[10];
      Quantity@1002 : Decimal;
    BEGIN
      // Setup: Create Item, Customer with Default Dimension. Create Job with Job Task. Create and Post Job Journal Line. Create and post Sales Order.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryInventory.CreateItem(Item);
      ItemAnalysisViewCode := CreateCustomerWithDefaultDimension(Customer);
      CreateJobWithJobTask(JobTask);
      CreateAndPostJobJournalLine(JobTask,Item."No.",Item."Base Unit of Measure",Quantity,0,FALSE);  // Use 0 for UnitCost.
      CreateAndPostSalesOrder(Customer."No.",SalesLine.Type::Item,Item."No.",Quantity);

      // Exercise.
      UpdateItemAnalysisView(ItemAnalysisViewCode);

      // Verify.
      VerifyItemAnalysisViewEntry(Item."No.",-Quantity);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE UndoConsumptionAfterPostServiceOrder@56();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1003 : Record 32;
      ServiceHeaderNo@1002 : Code[20];
      Quantity@1001 : Decimal;
    BEGIN
      // [FEATURE] [Undo Service Consumption]
      // [SCENARIO] Post Service Order with Quantity = Q, "Qty. to Ship" = Q/2, undo consumption, ILEs contain positive and negative adjustments of Service Shipment with Quantity = Q/2.

      // Setup: Create Item with Unit Cost. Create and Post Item Journal Line. Create and Post Service Order.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,2);
      CreateItemWithUnitCost(Item);
      CreateAndPostItemJournalLine(Item."No.",Quantity);
      ServiceHeaderNo := CreateAndPostServiceOrder(Item."No.",Quantity);

      // Exercise: Undo Consumption.
      UndoServiceConsumption(ServiceHeaderNo);

      // Verify: Verify Item Ledger Entry.
      VerifyItemLedgerEntry(
        ItemLedgerEntry."Entry Type"::"Negative Adjmt.",ItemLedgerEntry."Document Type"::"Service Shipment",FALSE,Item."No.",
        -Quantity / 2,0,-Item."Unit Price" * (Quantity / 2));  // Open as FALSE. Use 0 for Remaining Quantity.
      VerifyItemLedgerEntry(
        ItemLedgerEntry."Entry Type"::"Positive Adjmt.",ItemLedgerEntry."Document Type"::"Service Shipment",TRUE,Item."No.",
        Quantity / 2,Quantity / 2,Item."Unit Price" * (Quantity / 2));  // Open as TRUE.
    END;

    [Test]
    PROCEDURE ResourceGetUOMFilter@36();
    VAR
      ResourceUnitOfMeasure@1001 : Record 205;
      Resource@1002 : Record 156;
      Filter@1004 : Text;
      Count@1005 : Integer;
      JobTaskNo@1000 : Code[20];
    BEGIN
      // UT for Resource.GetUnitOfMeasureFilter function

      // Initialize
      // Char '(' will be used as part filter and should be correctly interpreted
      Count := CreateJobPlanningLinesWithDifferentUOMCode(DaysTok,ResourceUnitOfMeasure,JobTaskNo);

      // Excercise
      Filter := Resource.GetUnitOfMeasureFilter(ResourceUnitOfMeasure."Resource No.",ResourceUnitOfMeasure.Code);

      // Verify
      VerifyResourceGetUnitOfMeasureFilter(JobTaskNo,Count,Filter);
    END;

    [Test]
    PROCEDURE ValidateBaseUnitOfMeasure_ExistingBUoM@103();
    VAR
      Res@1000 : Record 156;
      ResUnitOfMeasure@1002 : Record 205;
      UnitOfMeasure@1003 : Record 204;
    BEGIN
      // Verify that existing item unit of measure can be used as item's base unit of measure

      // Setup: create item, unit of measure, item unit of measure
      Initialize;

      LibraryResource.CreateResourceNew(Res);

      CreateUoM_and_ResUoM(UnitOfMeasure,ResUnitOfMeasure,Res);

      // Exercise: validate Base Unit of Measure
      Res.VALIDATE("Base Unit of Measure",UnitOfMeasure.Code);

      // Verify: Base Unit of Measure is updated
      VerifyBaseUnitOfMeasure(Res,UnitOfMeasure.Code);
    END;

    [Test]
    PROCEDURE ValidateBaseUnitOfMeasure_NonExistingBUoM@101();
    VAR
      Item@1000 : Record 27;
      UnitOfMeasure@1003 : Record 204;
      ItemUnitOfMeasure@1002 : Record 5404;
      NewUnitOfMeasureCode@1001 : Code[10];
    BEGIN
      // Verify that non existing item unit of measure can be used as item's base unit of measure
      // and this unit of measure is created during the validation

      // Setup: create item, unit of measure, item unit of measure
      Initialize;

      Item.INIT;
      Item.INSERT(TRUE);

      NewUnitOfMeasureCode := CreateNewUnitOfMeasureCode;
      UnitOfMeasure.INIT;
      UnitOfMeasure.Code := NewUnitOfMeasureCode;
      UnitOfMeasure.INSERT;

      // Exercise: validate Base Unit of Measure with non-existent item unit of measure
      Item.VALIDATE("Base Unit of Measure",NewUnitOfMeasureCode);

      // Verify: new Item Unit of Measure is created
      ItemUnitOfMeasure.GET(Item."No.",NewUnitOfMeasureCode);
      ItemUnitOfMeasure.TESTFIELD("Qty. per Unit of Measure",1);
    END;

    [Test]
    PROCEDURE SelectExistingUnitOfMeasureAsBaseUnitOfMeasure@99();
    VAR
      Res@1003 : Record 156;
      FirstUnitOfMeasure@1002 : Record 204;
      SecondUnitOfMeasure@1004 : Record 204;
      ResUnitOfMeasure@1001 : Record 205;
    BEGIN
      Initialize;

      Res.INIT;
      Res.INSERT(TRUE);

      CreateUoM_and_ResUoM(FirstUnitOfMeasure,ResUnitOfMeasure,Res);
      CreateUoM_and_ResUoM(SecondUnitOfMeasure,ResUnitOfMeasure,Res);

      Res.VALIDATE("Base Unit of Measure",FirstUnitOfMeasure.Code);
      Res.MODIFY(TRUE);
      VerifyBaseUnitOfMeasureSetAndResUnitOfMeasureInserted(Res,FirstUnitOfMeasure,2);

      // Test setting with existing to other
      Res.VALIDATE("Base Unit of Measure",SecondUnitOfMeasure.Code);
      Res.MODIFY(TRUE);
      VerifyBaseUnitOfMeasureSetAndResUnitOfMeasureInserted(Res,SecondUnitOfMeasure,2);
    END;

    [Test]
    PROCEDURE SelectingBaseUnitOfMeasureInsertsResUnitOfMeasure@97();
    VAR
      Res@1003 : Record 156;
      FirstUnitOfMeasure@1002 : Record 204;
      SecondUnitOfMeasure@1000 : Record 204;
    BEGIN
      Initialize;

      Res.INIT;
      Res.INSERT(TRUE);

      LibraryInventory.CreateUnitOfMeasureCode(FirstUnitOfMeasure);
      LibraryInventory.CreateUnitOfMeasureCode(SecondUnitOfMeasure);

      Res.VALIDATE("Base Unit of Measure",FirstUnitOfMeasure.Code);
      Res.MODIFY(TRUE);
      VerifyBaseUnitOfMeasureSetAndResUnitOfMeasureInserted(Res,FirstUnitOfMeasure,1);

      Res.VALIDATE("Base Unit of Measure",SecondUnitOfMeasure.Code);
      Res.MODIFY(TRUE);
      VerifyBaseUnitOfMeasureSetAndResUnitOfMeasureInserted(Res,SecondUnitOfMeasure,2);
    END;

    [Test]
    PROCEDURE RemoveBaseUnitOfMeasureFromRes@92();
    VAR
      Item@1002 : Record 27;
      UnitOfMeasure@1001 : Record 204;
      ItemUnitOfMeasure@1000 : Record 5404;
    BEGIN
      Initialize;

      Item.INIT;
      Item.INSERT(TRUE);

      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);

      Item.VALIDATE("Base Unit of Measure",UnitOfMeasure.Code);
      Item.MODIFY(TRUE);

      Item.VALIDATE("Base Unit of Measure",'');
      Item.MODIFY(TRUE);

      Assert.AreEqual('',Item."Base Unit of Measure",'Base unit of measure was not removed from item');
      Assert.IsTrue(ItemUnitOfMeasure.GET(Item."No.",UnitOfMeasure.Code),'Item unit of measure is should be present');
    END;

    [Test]
    PROCEDURE SelectingUoMForBaseUoMThatHasQtyGreaterThanOneWillTriggerError@133();
    VAR
      Res@1002 : Record 156;
      UnitOfMeasure@1001 : Record 204;
      UnitOfMeasureQtyGreaterThanOne@1003 : Record 204;
      ResUnitOfMeasure@1000 : Record 205;
    BEGIN
      Initialize;

      Res.INIT;
      Res.INSERT(TRUE);

      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      CreateUoM_and_ResUoM(UnitOfMeasureQtyGreaterThanOne,ResUnitOfMeasure,Res);
      ResUnitOfMeasure.GET(Res."No.",UnitOfMeasureQtyGreaterThanOne.Code);
      ResUnitOfMeasure."Qty. per Unit of Measure" := LibraryRandom.RandIntInRange(2,1000);
      ResUnitOfMeasure.MODIFY(TRUE);

      Res.VALIDATE("Base Unit of Measure",UnitOfMeasure.Code);
      Res.MODIFY(TRUE);

      ASSERTERROR Res.VALIDATE("Base Unit of Measure",UnitOfMeasureQtyGreaterThanOne.Code);
      Assert.ExpectedError(
        STRSUBSTNO(BaseUnitOfMeasureQtyMustBeOneErr,UnitOfMeasureQtyGreaterThanOne.Code,ResUnitOfMeasure."Qty. per Unit of Measure"));
    END;

    [Test]
    PROCEDURE CannotRenameBaseUnitOfMeasureFromResUnitOfMeasuresRecord@84();
    VAR
      Item@1004 : Record 27;
      FirstUnitOfMeasure@1003 : Record 204;
      SecondUnitOfMeasure@1002 : Record 204;
      ItemUnitOfMeasure@1000 : Record 5404;
    BEGIN
      Initialize;

      Item.INIT;
      Item.INSERT(TRUE);

      LibraryInventory.CreateUnitOfMeasureCode(FirstUnitOfMeasure);
      LibraryInventory.CreateUnitOfMeasureCode(SecondUnitOfMeasure);

      Item.VALIDATE("Base Unit of Measure",FirstUnitOfMeasure.Code);
      Item.MODIFY(TRUE);

      ItemUnitOfMeasure.GET(Item."No.",FirstUnitOfMeasure.Code);
      ASSERTERROR ItemUnitOfMeasure.RENAME(Item."No.",SecondUnitOfMeasure.Code);
      Assert.ExpectedError('cannot modify');
    END;

    [Test]
    PROCEDURE CannotDeleteBaseUnitOfMeasureFromResUnitOfMeasuresRecord@67();
    VAR
      Item@1003 : Record 27;
      UnitOfMeasure@1002 : Record 204;
      ItemUnitOfMeasure@1000 : Record 5404;
    BEGIN
      Initialize;

      Item.INIT;
      Item.INSERT(TRUE);

      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);

      Item.VALIDATE("Base Unit of Measure",UnitOfMeasure.Code);
      Item.MODIFY(TRUE);

      ItemUnitOfMeasure.GET(Item."No.",UnitOfMeasure.Code);
      ASSERTERROR ItemUnitOfMeasure.DELETE(TRUE);
      Assert.ExpectedError('modify');
    END;

    [Test]
    PROCEDURE RenameResUnitOfMeasure@38();
    VAR
      Res@1000 : Record 156;
      ResUnitOfMeasure@1002 : Record 205;
      UnitOfMeasure@1003 : Record 204;
      NewUnitOfMeasureCode@1001 : Code[10];
    BEGIN
      // Verify that rename of item unit of measure caused update of Item."Base Unit of Measure"
      // because it has ValidateTableRelation=No

      // Setup: create item, unit of measure, item unit of measure
      Initialize;

      Res.INIT;
      Res.INSERT(TRUE);

      CreateUoM_and_ResUoM(UnitOfMeasure,ResUnitOfMeasure,Res);

      Res.VALIDATE("Base Unit of Measure",ResUnitOfMeasure.Code);
      Res.MODIFY;

      NewUnitOfMeasureCode := CreateNewUnitOfMeasureCode;
      COMMIT;

      // Exercise: rename unit of measure assigned to Item (and Item Unit of Measure)
      UnitOfMeasure.RENAME(NewUnitOfMeasureCode);

      // Verify: Base Unit of Measure is updated
      Res.GET(Res."No.");
      VerifyBaseUnitOfMeasure(Res,NewUnitOfMeasureCode);
    END;

    [Test]
    PROCEDURE CanInsertTwoResourcesOnSameLocation@30();
    VAR
      Resource@1001 : ARRAY [2] OF Record 156;
      ResourceLocation@1000 : Record 5952;
      Location@1002 : Record 14;
      I@1003 : Integer;
    BEGIN
      // [FEATURE] [Location]
      // [SCENARIO 380436] It should be possible to allocate two resources on the same location, the same date
      Initialize;

      // [GIVEN] Location "L"
      LibraryWarehouse.CreateLocation(Location);

      // [GIVEN] Create resource "R1" and resource location for resource "R1" on location "L"
      // [WHEN] Create resource "R2" and resource location for resource "R2" on location "L"
      FOR I := 1 TO ARRAYLEN(Resource) DO BEGIN
        LibraryResource.CreateResourceNew(Resource[I]);
        CreateResourceLocation(ResourceLocation,Resource[I]."No.",Location.Code,WORKDATE);
      END;

      // [THEN] Two resource locations are created
      ResourceLocation.SETRANGE("Location Code",Location.Code);
      Assert.RecordCount(ResourceLocation,ARRAYLEN(Resource));
    END;

    [Test]
    PROCEDURE CanInsertResourceInDifferentLocationsDifferentDates@121();
    VAR
      Location@1000 : ARRAY [2] OF Record 14;
      Resource@1001 : Record 156;
      ResourceLocation@1002 : Record 5952;
      I@1003 : Integer;
    BEGIN
      // [FEATURE] [Location]
      // [SCENARIO 380436] It should be possible to allocate one resource on different locations on different dates
      Initialize;

      // [GIVEN] Resource "R"
      LibraryResource.CreateResourceNew(Resource);

      // [GIVEN] Create location "L1" and resource location for resource "R" on location "L1"
      // [WHEN] Create location "L2" and resource location for resource "R" on location "L2"
      FOR I := 1 TO ARRAYLEN(Location) DO BEGIN
        LibraryWarehouse.CreateLocation(Location[I]);
        CreateResourceLocation(ResourceLocation,Resource."No.",Location[I].Code,WORKDATE + I);
      END;

      // [THEN] Two resource locations are created
      ResourceLocation.SETRANGE("Resource No.",Resource."No.");
      Assert.RecordCount(ResourceLocation,ARRAYLEN(Location));
    END;

    [Test]
    PROCEDURE UnitPriceResLedgerEntryAfterPostSalesInvoiceSalesLineQuantityPositive@122();
    VAR
      SalesHeader@1000 : Record 36;
      SalesLine@1001 : Record 37;
      DocNo@1005 : Code[20];
      ResNo@1006 : Code[20];
      UnitPrice@1002 : ARRAY [2] OF Decimal;
    BEGIN
      // [FEATURE] [Credit Memo]
      // [SCENARIO 210924] Value of "Unit Price" of Resource Ledger Entry must be positive when Quantity of Sales Line of Sales Credit Memo is positive
      Initialize;

      // [GIVEN] Sales Credit Memo with Resource Sales Ivoice line with Quanity > 0
      ResNo := LibraryResource.CreateResourceNo;
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::"Credit Memo",LibrarySales.CreateCustomerNo);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Resource,ResNo,LibraryRandom.RandIntInRange(5,10));
      UnitPrice[1] := SalesLine."Unit Price";
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Resource,ResNo,LibraryRandom.RandIntInRange(5,10));
      UnitPrice[2] := SalesLine."Unit Price";

      // [WHEN] Post Sales Credit Memo
      DocNo := LibrarySales.PostSalesDocument(SalesHeader,FALSE,FALSE);

      // [THEN] "Res. Ledger Entry"."Unit Price" > 0
      VerifyUnitPriceResLedgerEntry(DocNo,ResNo,UnitPrice);
    END;

    [Test]
    PROCEDURE UnitPriceResLedgerEntryAfterPostSalesInvoiceSalesLineQuantityNegative@146();
    VAR
      SalesHeader@1000 : Record 36;
      SalesLine@1001 : Record 37;
      DocNo@1005 : Code[20];
      ResNo@1006 : Code[20];
      UnitPrice@1002 : ARRAY [2] OF Decimal;
    BEGIN
      // [FEATURE] [Credit Memo]
      // [SCENARIO 210924] Value of "Unit Price" of Resource Ledger Entry must be positive when Quantity of Sales Line of Sales Credit Memo is Negative
      Initialize;

      // [GIVEN] Sales Credit Memo with Resource Sales Ivoice line with Quanity > 0 and Resource Sales Invoice line with Quantity < 0
      ResNo := LibraryResource.CreateResourceNo;
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::"Credit Memo",LibrarySales.CreateCustomerNo);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Resource,ResNo,LibraryRandom.RandIntInRange(50,100));
      UnitPrice[1] := SalesLine."Unit Price";
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Resource,ResNo,-LibraryRandom.RandIntInRange(5,10));
      UnitPrice[2] := SalesLine."Unit Price";

      // [WHEN] Post Sales Credit Memo
      DocNo := LibrarySales.PostSalesDocument(SalesHeader,FALSE,FALSE);

      // [THEN] "Res. Ledger Entry"."Unit Price" > 0
      VerifyUnitPriceResLedgerEntry(DocNo,ResNo,UnitPrice);
    END;

    [Test]
    PROCEDURE UnitPriceResLedgerEntryAfterPostSalesInvoiceSalesLineUnitPriceNegative@118();
    VAR
      SalesHeader@1000 : Record 36;
      SalesLine@1001 : Record 37;
      DocNo@1005 : Code[20];
      ResNo@1006 : Code[20];
      UnitPrice@1002 : ARRAY [2] OF Decimal;
    BEGIN
      // [FEATURE] [Invoice]
      // [SCENARIO 217415] Value of "Unit Price" of Resource Ledger Entry must be negative when Unit Price of Sales Line of Sales Invoice is negative
      Initialize;

      // [GIVEN] Sales Invoice with two Resource Sales Invoice line
      ResNo := LibraryResource.CreateResourceNo;
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Invoice,LibrarySales.CreateCustomerNo);

      // [GIVEN] First sales line has positive "Unit Price" = 100
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Resource,ResNo,LibraryRandom.RandIntInRange(5,10));
      UnitPrice[1] := SalesLine."Unit Price";

      // [GIVEN] Second sales line has negative "Unit Price" = -100
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Resource,ResNo,SalesLine.Quantity);
      SalesLine.VALIDATE("Unit Price",-SalesLine."Unit Price");
      SalesLine.MODIFY(TRUE);
      UnitPrice[2] := SalesLine."Unit Price";

      // [WHEN] Post Sales Invoice
      DocNo := LibrarySales.PostSalesDocument(SalesHeader,FALSE,FALSE);

      // [THEN] "Res. Ledger Entry" for second sales line has "Unit Price" = -100
      VerifyUnitPriceResLedgerEntry(DocNo,ResNo,UnitPrice);
    END;

    LOCAL PROCEDURE Initialize@42();
    VAR
      LibraryERMCountryData@1000 : Codeunit 131305;
    BEGIN
      LibraryVariableStorage.Clear;
      IF IsInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.CreateGeneralPostingSetupData;
      NoSeriesSetup;
      CreateItemJournalTemplateAndBatch;
      LocationSetup;

      IsInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE CreateFullWarehouseSetup@91(VAR Location@1000 : Record 14);
    VAR
      WarehouseEmployee@1001 : Record 7301;
    BEGIN
      LibraryWarehouse.CreateFullWMSLocation(Location,2);  // Value used for number of bin per zone.
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,Location.Code,TRUE);
    END;

    LOCAL PROCEDURE LocationSetup@86();
    VAR
      WarehouseEmployee@1000 : Record 7301;
    BEGIN
      WarehouseEmployee.DELETEALL(TRUE);
      CreateFullWarehouseSetup(LocationWhite);  // Location: White.
    END;

    LOCAL PROCEDURE NoSeriesSetup@31();
    VAR
      PurchasesPayablesSetup@1003 : Record 312;
      SalesSetup@1001 : Record 311;
      JobsSetup@1002 : Record 315;
    BEGIN
      SalesSetup.GET;
      SalesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.MODIFY(TRUE);

      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      PurchasesPayablesSetup.MODIFY(TRUE);

      JobsSetup.GET;
      JobsSetup.VALIDATE("Job Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      JobsSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE AdjustCostItemEntriesWithJobAndCostingMethod@24(VAR Item@1000 : Record 27;VAR ItemUnitOfMeasure@1001 : Record 5404;VAR JobTask@1003 : Record 1001;CostingMethod@1002 : Option;Quantity@1004 : Decimal);
    BEGIN
      // Create Item with Costing Method and Item Unit of Measure. Create Job and Job Task. Create and post Job Journal and Purchase Order. Run Adjust Cost Item entries batch job.
      CreateItemWithCostingMethodAndUOM(Item,ItemUnitOfMeasure,CostingMethod);
      CreateJobWithJobTask(JobTask);
      CreateAndPostJobJournalLine(JobTask,Item."No.",Item."Base Unit of Measure",Quantity,Item."Unit Cost",FALSE);
      CreateAndPostPurchaseOrder(
        Item."No.",Quantity * 2,Item."Unit Cost" + LibraryRandom.RandDec(10,2),
        Item."Base Unit of Measure",FALSE);  // Calculated values required for Quantity and Direct Unit Cost.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
    END;

    LOCAL PROCEDURE AdjustCostItemEntriesWithJobAndSpecificCosting@106(VAR Item@1000 : Record 27;VAR ItemUnitOfMeasure@1001 : Record 5404;VAR JobTask@1002 : Record 1001;Quantity@1003 : Decimal);
    BEGIN
      // Create Item with Serial Tracking, Specific Costing Method and Item Unit of Measure. Create Job and Job Task. Create and post Job Journal and Purchase Order. Run Adjust Cost Item entries batch job.
      CreateItemWithCostingMethodAndUOM(Item,ItemUnitOfMeasure,Item."Costing Method"::Specific);
      CreateJobWithJobTask(JobTask);
      CreateAndPostItemJournalLineWithSerialTracking(JobTask,Item."No.",Quantity);
      CreateAndPostJobJournalLine(
        JobTask,Item."No.",Item."Base Unit of Measure",Quantity,Item."Unit Cost",TRUE);  // TRUE for Tracking.
      CreateAndPostPurchaseOrder(
        Item."No.",Quantity,Item."Unit Cost" + LibraryRandom.RandDec(10,2),
        Item."Base Unit of Measure",TRUE);  // Greater value required for Direct Unit Cost. TRUE for Tracking.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
    END;

    LOCAL PROCEDURE AdjustCostItemEntriesWithJobAndStandardCosting@98(VAR Item@1000 : Record 27;VAR ItemUnitOfMeasure@1001 : Record 5404;VAR JobTask@1002 : Record 1001;Quantity@1003 : Decimal);
    BEGIN
      // Create Item with Standard Costing Method and Item Unit of Measure. Create Job and Job Task. Create and post Job Journal and Purchase Order. Run Adjust Cost Item entries batch job.
      CreateItemWithCostingMethodAndUOM(Item,ItemUnitOfMeasure,Item."Costing Method"::Standard);
      CreateJobWithJobTask(JobTask);
      CreateAndPostJobJournalLine(JobTask,Item."No.",Item."Base Unit of Measure",Quantity,0,FALSE);  // Value 0 required for Unit Cost.
      CreateAndPostPurchaseOrder(Item."No.",Quantity,0,Item."Base Unit of Measure",FALSE);  // Value 0 required for Direct Unit Cost.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
    END;

    LOCAL PROCEDURE CreateCustomerWithDefaultDimension@100(VAR Customer@1000 : Record 18) : Code[10];
    VAR
      AnalysisLineTemplate@1002 : Record 7112;
      AnalysisLine@1003 : Record 7114;
      DefaultDimension@1004 : Record 352;
      ItemAnalysisView@1001 : Record 7152;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      ItemAnalysisView.FINDFIRST;
      AnalysisLineTemplate.SETRANGE("Item Analysis View Code",ItemAnalysisView.Code);
      AnalysisLineTemplate.FINDFIRST;
      AnalysisLine.SETRANGE("Analysis Line Template Name",AnalysisLineTemplate.Name);
      AnalysisLine.FINDFIRST;
      LibraryDimension.CreateDefaultDimensionCustomer(
        DefaultDimension,Customer."No.",ItemAnalysisView."Dimension 1 Code",AnalysisLine.Range);
      EXIT(ItemAnalysisView.Code);
    END;

    LOCAL PROCEDURE CreateAndPostItemJournalLine@102(ItemNo@1001 : Code[20];Quantity@1002 : Decimal);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,ItemJournalLine."Entry Type"::Purchase,ItemNo,Quantity);
      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateAndPostItemJournalLineWithSerialTracking@41(JobTask@1003 : Record 1001;ItemNo@1005 : Code[20];Quantity@1004 : Decimal);
    VAR
      ItemJournalLine@1000 : Record 83;
      ItemTrackingMode@1001 : 'SelectEntries,AssignSerialNo';
    BEGIN
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,ItemJournalLine."Entry Type"::Purchase,ItemNo,Quantity);
      ItemJournalLine.VALIDATE("Job No.",JobTask."Job No.");
      ItemJournalLine.VALIDATE("Job Task No.",JobTask."Job Task No.");
      ItemJournalLine.MODIFY(TRUE);
      LibraryVariableStorage.Enqueue(ItemTrackingMode::AssignSerialNo);  // Enqueue for ItemTrackingPageHandler.
      LibraryVariableStorage.Enqueue(Quantity);  // Enqueue for EnterQtyToCreatePageHandler.
      ItemJournalLine.OpenItemTrackingLines(FALSE);
      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateAndPostJobJournalLine@29(JobTask@1004 : Record 1001;ItemNo@1001 : Code[20];UnitOfMeasureCode@1002 : Code[10];Quantity@1003 : Decimal;UnitCost@1005 : Decimal;Tracking@1006 : Boolean);
    VAR
      JobJournalLine@1000 : Record 210;
      ItemTrackingMode@1007 : 'SelectEntries,AssignSerialNo';
    BEGIN
      LibraryJob.CreateJobJournalLine(JobJournalLine."Line Type"::"Both Schedule and Contract",JobTask,JobJournalLine);
      JobJournalLine.VALIDATE(Type,JobJournalLine.Type::Item);
      JobJournalLine.VALIDATE("No.",ItemNo);
      JobJournalLine.VALIDATE("Unit of Measure Code",UnitOfMeasureCode);
      JobJournalLine.VALIDATE(Quantity,Quantity);
      IF UnitCost <> 0 THEN
        JobJournalLine.VALIDATE("Unit Cost (LCY)",UnitCost);
      JobJournalLine.MODIFY(TRUE);
      IF Tracking THEN BEGIN
        LibraryVariableStorage.Enqueue(ItemTrackingMode::SelectEntries);  // Enqueue for ItemTrackingPageHandler.
        JobJournalLine.OpenItemTrackingLines(FALSE);
      END;
      LibraryVariableStorage.Enqueue(WantToPostJournalLinesQst);  // Enqueue for ConfirmHandler.
      LibraryVariableStorage.Enqueue(TRUE);  // Enqueue for ConfirmHandler.
      LibraryVariableStorage.Enqueue(JournalLinesPostedMsg);  // Enqueue for MessageHandler.
      LibraryJob.PostJobJournal(JobJournalLine);
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrder@35(ItemNo@1002 : Code[20];Quantity@1003 : Decimal;DirectUnitCost@1005 : Decimal;UnitOfMeasureCode@1004 : Code[10];Tracking@1006 : Boolean);
    VAR
      PurchaseHeader@1001 : Record 38;
      PurchaseLine@1000 : Record 39;
      ItemTrackingMode@1007 : 'SelectEntries,AssignSerialNo';
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity);
      PurchaseLine.VALIDATE("Direct Unit Cost",DirectUnitCost);
      PurchaseLine.VALIDATE("Unit of Measure Code",UnitOfMeasureCode);
      PurchaseLine.MODIFY(TRUE);
      IF Tracking THEN BEGIN
        LibraryVariableStorage.Enqueue(ItemTrackingMode::AssignSerialNo);  // Enqueue for ItemTrackingPageHandler.
        LibraryVariableStorage.Enqueue(Quantity);  // Enqueue for EnterQtyToCreatePageHandler.
        PurchaseLine.OpenItemTrackingLines;
      END;
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);  // Post as Receive and Invoice.
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseInvoiceWithGetReceiptLines@34(VendorNo@1002 : Code[20];OrderNo@1001 : Code[20]) : Code[20];
    VAR
      PurchaseHeader@1000 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Invoice,VendorNo);
      GetReceiptLines(PurchaseHeader,OrderNo);
      EXIT(LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE));  // Post as Receive and Invoice.
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrderWithJob@17(VAR PurchaseHeader@1004 : Record 38;VAR PurchaseLine@1003 : Record 39;JobTask@1000 : Record 1001;ItemNo@1002 : Code[20];Quantity@1001 : Decimal;QuantityToReceive@1006 : Decimal;DirectUnitCost@1005 : Decimal;JobLineType@1007 : Option;PostAsInvoice@1008 : Boolean) : Code[20];
    BEGIN
      CreatePurchaseOrderWithJob(
        PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,ItemNo,Quantity,QuantityToReceive,JobTask."Job No.",
        JobTask."Job Task No.",DirectUnitCost,JobLineType);
      EXIT(LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,PostAsInvoice));  // Receive as True.
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrderWithMultipleLines@21(VAR PurchaseHeader@1001 : Record 38;VAR PurchaseLine@1005 : Record 39;VAR PurchaseLine2@1003 : Record 39;JobTask@1004 : Record 1001;ItemNo@1002 : Code[20]);
    VAR
      Vendor@1000 : Record 23;
      Quantity@1006 : Decimal;
    BEGIN
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryPurchase.CreateVendor(Vendor);
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,Vendor."No.");
      CreatePurchaseLineWithJob(
        PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity,Quantity,JobTask."Job No.",JobTask."Job Task No.",
        PurchaseLine."Job Line Type"::Schedule,LibraryRandom.RandInt(10));
      CreatePurchaseLineWithJob(
        PurchaseLine2,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,PurchaseLine.Quantity + Quantity,
        PurchaseLine.Quantity + Quantity,JobTask."Job No.",JobTask."Job Task No.",
        PurchaseLine2."Job Line Type"::"Both Schedule and Contract",
        PurchaseLine."Direct Unit Cost" + LibraryRandom.RandInt(10));  // Greater values required for Quantity and Direct Unit Cost.
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);  // Post as Receive.
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrderWithDifferentUnitPrice@94(ItemNo@1001 : Code[20];Quantity@1002 : Decimal;JobNo@1003 : Code[20];JobTaskNo@1004 : Code[20];UnitPrice@1006 : Decimal) DocumentNo : Code[20];
    VAR
      PurchaseLine@1005 : Record 39;
      PurchaseHeader@1000 : Record 38;
    BEGIN
      CreatePurchaseOrderWithJob(
        PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,ItemNo,Quantity,Quantity,JobNo,JobTaskNo,0,
        PurchaseLine."Job Line Type"::Schedule);  // Use 0 for DirectUnitCost.
      PurchaseLine.VALIDATE("Unit Price (LCY)",UnitPrice);
      PurchaseLine.MODIFY(TRUE);
      DocumentNo := LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);  // Post as Receive and Invoice.
    END;

    LOCAL PROCEDURE CreateAndPostSalesOrder@14(CustomerNo@1002 : Code[20];Type@1003 : Option;No@1001 : Code[20];Quantity@1004 : Decimal);
    VAR
      SalesHeader@1000 : Record 36;
    BEGIN
      CreateSalesOrder(SalesHeader,CustomerNo,Type,No,Quantity,'');
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);  // Post as SHIP and INVOICE.
    END;

    LOCAL PROCEDURE CreateAndPostServiceOrder@120(ItemNo@1005 : Code[20];Quantity@1006 : Decimal) : Code[20];
    VAR
      Customer@1000 : Record 18;
      ServiceItem@1002 : Record 5940;
      ServiceItemLine@1003 : Record 5901;
      ServiceHeader@1001 : Record 5900;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      LibraryService.CreateServiceHeader(ServiceHeader,ServiceHeader."Document Type"::Order,Customer."No.");
      LibraryService.CreateServiceItem(ServiceItem,ServiceHeader."Customer No.");
      LibraryService.CreateServiceItemLine(ServiceItemLine,ServiceHeader,ServiceItem."No.");
      CreateServiceLine(ServiceHeader,ItemNo,ServiceItemLine."Line No.",Quantity);
      LibraryService.PostServiceOrder(ServiceHeader,TRUE,TRUE,FALSE);  // Ship and Consume as TRUE.
      EXIT(ServiceHeader."No.");
    END;

    LOCAL PROCEDURE CreateAndReceivePurchaseOrderWithJob@128(VAR PurchaseHeader@1002 : Record 38;VAR PurchaseLine@1003 : Record 39);
    VAR
      Item@1000 : Record 27;
      JobTask@1001 : Record 1001;
      Quantity@1004 : Decimal;
    BEGIN
      LibraryInventory.CreateItem(Item);
      CreateJobWithJobTask(JobTask);
      Quantity := LibraryRandom.RandDec(100,2);
      CreateAndPostPurchaseOrderWithJob(
        PurchaseHeader,PurchaseLine,JobTask,Item."No.",Quantity,Quantity / 2,LibraryRandom.RandDec(10,2),
        PurchaseLine."Job Line Type"::"Both Schedule and Contract",FALSE);
    END;

    LOCAL PROCEDURE CreateItemJournalTemplateAndBatch@47();
    BEGIN
      ItemJournalTemplate.SETRANGE(Recurring,FALSE);
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      ItemJournalTemplate.VALIDATE("No. Series",'');
      ItemJournalTemplate.MODIFY(TRUE);

      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      ItemJournalBatch.VALIDATE("No. Series",'');
      ItemJournalBatch.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemUnitOfMeasure@74(VAR ItemUnitOfMeasure@1000 : Record 5404;ItemNo@1001 : Code[20]);
    BEGIN
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,ItemNo,LibraryRandom.RandInt(5) + 1);
    END;

    LOCAL PROCEDURE CreateItemWithCostingMethod@27(VAR Item@1000 : Record 27;CostingMethod@1001 : Option);
    BEGIN
      LibraryInventory.CreateItem(Item);
      UpdateCostingMethodOnItem(Item,CostingMethod);
    END;

    LOCAL PROCEDURE CreateItemWithCostingMethodAndUOM@88(VAR Item@1001 : Record 27;VAR ItemUnitOfMeasure@1002 : Record 5404;CostingMethod@1000 : Option);
    BEGIN
      CreateItemWithCostingMethod(Item,CostingMethod);
      CreateItemUnitOfMeasure(ItemUnitOfMeasure,Item."No.");
      IF CostingMethod = Item."Costing Method"::Standard THEN
        Item.VALIDATE("Standard Cost",LibraryRandom.RandDec(10,2))
      ELSE
        Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(10,2));
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemWithMultipleUnitOfMeasure@82(VAR Item@1000 : Record 27;VAR ItemUnitOfMeasure@1001 : Record 5404);
    BEGIN
      LibraryInventory.CreateItem(Item);
      CreateItemUnitOfMeasure(ItemUnitOfMeasure,Item."No.");
    END;

    LOCAL PROCEDURE CreateItemWithSerialItemTracking@95(VAR Item@1001 : Record 27);
    VAR
      ItemTrackingCode@1000 : Record 6502;
    BEGIN
      LibraryItemTracking.CreateItemTrackingCode(ItemTrackingCode,TRUE,FALSE);
      LibraryInventory.CreateTrackedItem(Item,'',LibraryUtility.GetGlobalNoSeriesCode,ItemTrackingCode.Code);
    END;

    LOCAL PROCEDURE CreateItemWithUnitCost@19(VAR Item@1000 : Record 27);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(10,2));
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateJobWithJobTask@20(VAR JobTask@1000 : Record 1001);
    VAR
      Job@1001 : Record 167;
    BEGIN
      LibraryJob.CreateJob(Job);
      LibraryJob.CreateJobTask(Job,JobTask);
    END;

    LOCAL PROCEDURE CreateJobPlanningLines@113(JobTask@1005 : Record 1001;ResourceNo@1000 : Code[20];UOMCode@1001 : Code[10]) Count : Integer;
    VAR
      JobPlanningLine@1003 : Record 1003;
      Index@1002 : Integer;
    BEGIN
      Count := LibraryRandom.RandIntInRange(5,10);
      FOR Index := 1 TO Count DO
        CreateJobPlanningLine(JobTask,ResourceNo,UOMCode,JobPlanningLine);

      EXIT(Count);
    END;

    LOCAL PROCEDURE CreateJobPlanningLine@96(JobTask@1001 : Record 1001;ResourceNo@1003 : Code[20];UOMCode@1002 : Code[10];VAR JobPlanningLine@1000 : Record 1003);
    BEGIN
      WITH JobPlanningLine DO BEGIN
        LibraryJob.CreateJobPlanningLine("Line Type"::Schedule,Type::Resource,JobTask,JobPlanningLine);
        "Unit of Measure Code" := UOMCode;
        VALIDATE("No.",ResourceNo);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateJobPlanningLinesWithDifferentUOMCode@108(UOMCode@1001 : Code[10];VAR ResourceUnitOfMeasure@1004 : Record 205;VAR JobTaskNo@1000 : Code[20]) Count : Integer;
    VAR
      JobTask@1003 : Record 1001;
      UnitOfMeasure@1002 : Record 204;
    BEGIN
      CreateJobWithJobTask(JobTask);

      CreateResourceUnitOfMeasure(
        ResourceUnitOfMeasure,
        LibraryUtility.GenerateRandomCode(UnitOfMeasure.FIELDNO(Code),DATABASE::"Unit of Measure"),
        TRUE);
      CreateJobPlanningLines(JobTask,ResourceUnitOfMeasure."Resource No.",ResourceUnitOfMeasure.Code);

      CreateResourceUnitOfMeasure(ResourceUnitOfMeasure,UOMCode,TRUE);
      Count := CreateJobPlanningLines(JobTask,ResourceUnitOfMeasure."Resource No.",ResourceUnitOfMeasure.Code);
      JobTaskNo := JobTask."Job Task No.";
      EXIT(Count);
    END;

    LOCAL PROCEDURE CreatePurchaseOrderWithJob@16(VAR PurchaseHeader@1001 : Record 38;VAR PurchaseLine@1007 : Record 39;Type@1000 : Option;ItemNo@1002 : Code[20];Quantity@1003 : Decimal;QuantityToReceive@1008 : Decimal;JobNo@1004 : Code[20];JobTaskNo@1005 : Code[20];DirectUnitCost@1006 : Decimal;JobLineType@1009 : Option);
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      CreatePurchaseLineWithJob(
        PurchaseLine,PurchaseHeader,Type,ItemNo,Quantity,QuantityToReceive,JobNo,JobTaskNo,JobLineType,DirectUnitCost);
    END;

    LOCAL PROCEDURE CreatePurchaseLineWithJob@23(VAR PurchaseLine@1001 : Record 39;PurchaseHeader@1000 : Record 38;Type@1008 : Option;ItemNo@1005 : Code[20];Quantity@1006 : Decimal;QuantityToReceive@1009 : Decimal;JobNo@1002 : Code[20];JobTaskNo@1003 : Code[20];JobLineType@1004 : Option;DirectUnitCost@1007 : Decimal);
    BEGIN
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,Type,ItemNo,Quantity);
      PurchaseLine.VALIDATE("Qty. to Receive",QuantityToReceive);
      PurchaseLine.VALIDATE("Job No.",JobNo);
      PurchaseLine.VALIDATE("Job Task No.",JobTaskNo);
      PurchaseLine.VALIDATE("Job Line Type",JobLineType);
      PurchaseLine.VALIDATE("Direct Unit Cost",DirectUnitCost);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrderWithDifferentUOM@89(VAR PurchaseLine@1000 : Record 39;ItemNo@1002 : Code[20];Quantity@1003 : Decimal;QuantityToReceive@1007 : Decimal;JobNo@1004 : Code[20];JobTaskNo@1005 : Code[20];ItemUnitOfMeasureCode@1006 : Code[10]) : Code[20];
    VAR
      PurchaseHeader@1001 : Record 38;
      PurchaseLine2@1008 : Record 39;
    BEGIN
      CreatePurchaseOrderWithJob(
        PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,ItemNo,Quantity,QuantityToReceive,JobNo,JobTaskNo,0,
        PurchaseLine."Job Line Type"::Schedule);// Use 0 for DirectUnitCost.
      CreatePurchaseLineWithJob(
        PurchaseLine2,PurchaseHeader,PurchaseLine2.Type::Item,ItemNo,Quantity,QuantityToReceive,JobNo,JobTaskNo,
        PurchaseLine2."Job Line Type"::Schedule,0);  // Use 0 for DirectUnitCost.
      PurchaseLine2.VALIDATE("Unit of Measure Code",ItemUnitOfMeasureCode);
      PurchaseLine2.MODIFY(TRUE);
      EXIT(LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE));  // Receive and Invoice as TRUE.
    END;

    LOCAL PROCEDURE CreateResourceLocation@66(VAR ResourceLocation@1003 : Record 5952;ResourceNo@1000 : Code[20];LocationCode@1001 : Code[10];StartingDate@1002 : Date);
    BEGIN
      WITH ResourceLocation DO BEGIN
        VALIDATE("Location Code",LocationCode);
        VALIDATE("Starting Date",StartingDate);
        VALIDATE("Resource No.",ResourceNo);
        INSERT(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateResourceUnitOfMeasure@37(VAR ResourceUnitOfMeasure@1004 : Record 205;UOMCode@1001 : Code[10];RelatedToBaseUnitOfMeas@1003 : Boolean);
    VAR
      Resource@1000 : Record 156;
      UnitOfMeasure@1002 : Record 204;
    BEGIN
      WITH UnitOfMeasure DO BEGIN
        INIT;
        Code := UOMCode;
        INSERT(TRUE);
      END;

      WITH Resource DO BEGIN
        INIT;
        VALIDATE("No.",LibraryUtility.GenerateRandomCode(FIELDNO("No."),DATABASE::Resource));
        INSERT(TRUE);
      END;

      WITH ResourceUnitOfMeasure DO BEGIN
        INIT;
        VALIDATE("Resource No.",Resource."No.");
        VALIDATE(Code,UOMCode);
        VALIDATE("Related to Base Unit of Meas.",RelatedToBaseUnitOfMeas);
        INSERT(TRUE);
      END;

      Resource.VALIDATE("Base Unit of Measure",UOMCode);
      Resource.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesLineWithLocationCode@119(VAR SalesHeader@1000 : Record 36;VAR SalesLine@1001 : Record 37;Type@1005 : Option;No@1002 : Code[20];Quantity@1003 : Decimal;LocationCode@1004 : Code[10]);
    BEGIN
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,Type,No,Quantity);
      SalesLine.VALIDATE("Location Code",LocationCode);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesOrder@117(VAR SalesHeader@1000 : Record 36;CustomerNo@1006 : Code[20];Type@1004 : Option;No@1001 : Code[20];Quantity@1002 : Decimal;LocationCode@1003 : Code[10]);
    VAR
      SalesLine@1005 : Record 37;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CustomerNo);
      CreateSalesLineWithLocationCode(SalesHeader,SalesLine,Type,No,Quantity,LocationCode);
    END;

    LOCAL PROCEDURE CreateServiceContractHeader@8(VAR ServiceContractHeader@1003 : Record 5965;VAR ServiceItem@1001 : Record 5940);
    VAR
      Customer@1000 : Record 18;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      LibraryService.CreateServiceItem(ServiceItem,Customer."No.");
      LibraryVariableStorage.Enqueue(WantToCreateContractQst);  // Enqueue for Confirm Handler.
      LibraryVariableStorage.Enqueue(TRUE);  // Enqueue for Confirm Handler.
      LibraryService.CreateServiceContractHeader(ServiceContractHeader,ServiceContractHeader."Contract Type"::Contract,Customer."No.");
    END;

    LOCAL PROCEDURE CreateServiceLine@129(VAR ServiceHeader@1001 : Record 5900;ItemNo@1002 : Code[20];ServiceItemLineNo@1003 : Integer;Quantity@1004 : Decimal);
    VAR
      ServiceLine@1000 : Record 5902;
    BEGIN
      LibraryService.CreateServiceLine(ServiceLine,ServiceHeader,ServiceLine.Type::Item,ItemNo);
      ServiceLine.VALIDATE("Service Item Line No.",ServiceItemLineNo);
      ServiceLine.VALIDATE(Quantity,Quantity);
      ServiceLine.VALIDATE("Qty. to Ship",Quantity / 2);  // Enter Partial Quantity to Ship.
      ServiceLine.VALIDATE("Qty. to Consume",ServiceLine."Qty. to Ship");
      ServiceLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateToDo@32(VAR ToDo@1000 : Record 5080;Contact@1001 : Record 5050);
    BEGIN
      LibraryMarketing.CreateToDo(ToDo);
      ToDo.VALIDATE(Date,WORKDATE);
      ToDo.VALIDATE("Contact No.",Contact."No.");
      ToDo.VALIDATE("Salesperson Code",Contact."Salesperson Code");
      ToDo.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateWarehouseShipmentHeaderWithLocation@123(VAR WarehouseShipmentHeader@1000 : Record 7320;LocationCode@1001 : Code[10]);
    BEGIN
      LibraryWarehouse.CreateWarehouseShipmentHeader(WarehouseShipmentHeader);
      WarehouseShipmentHeader.VALIDATE("Location Code",LocationCode);
      WarehouseShipmentHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateUoM_and_ResUoM@111(VAR UnitOfMeasure@1001 : Record 204;VAR ResUnitOfMeasure@1002 : Record 205;Res@1000 : Record 156);
    BEGIN
      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      LibraryResource.CreateResourceUnitOfMeasure(ResUnitOfMeasure,Res."No.",UnitOfMeasure.Code,1);
    END;

    LOCAL PROCEDURE CreateNewUnitOfMeasureCode@112() : Code[10];
    VAR
      RefUnitOfMeasure@1000 : Record 204;
    BEGIN
      EXIT(LibraryUtility.GenerateRandomCode(RefUnitOfMeasure.FIELDNO(Code),DATABASE::"Unit of Measure"));
    END;

    LOCAL PROCEDURE CopyDocumentUsingPurchaseOrderWithJob@71(JobTask@1004 : Record 1001;ItemNo@1000 : Code[20];Quantity@1001 : Decimal);
    VAR
      PurchaseHeader@1002 : Record 38;
      PurchaseLine@1006 : Record 39;
      DocumentNo@1003 : Code[20];
      DocumentType@1005 : 'Quote,Blanket Order,Order,Invoice,Return Order,Credit Memo,Posted Receipt,Posted Invoice,Posted Return Shipment,Posted Credit Memo';
    BEGIN
      DocumentNo :=
        CreateAndPostPurchaseOrderWithJob(
          PurchaseHeader,PurchaseLine,JobTask,ItemNo,Quantity,Quantity,Quantity,
          PurchaseLine."Job Line Type"::Schedule,TRUE);  // Invoice as True.
      LibraryPurchase.CreatePurchHeader(
        PurchaseHeader,PurchaseHeader."Document Type"::"Return Order",PurchaseHeader."Buy-from Vendor No.");
      LibraryPurchase.CopyPurchaseDocument(PurchaseHeader,DocumentType::"Posted Invoice",DocumentNo,FALSE,TRUE);  // TRUE for RecalculateLines.
    END;

    LOCAL PROCEDURE GetReceiptLines@195(PurchaseHeader@1001 : Record 38;OrderNo@1000 : Code[20]);
    VAR
      PurchRcptHeader@1004 : Record 120;
      PurchRcptLine@1003 : Record 121;
      PurchGetReceipt@1002 : Codeunit 74;
    BEGIN
      PurchRcptHeader.SETRANGE("Order No.",OrderNo);
      PurchRcptHeader.FINDFIRST;
      PurchRcptLine.SETRANGE("Document No.",PurchRcptHeader."No.");
      PurchGetReceipt.SetPurchHeader(PurchaseHeader);
      PurchGetReceipt.CreateInvLines(PurchRcptLine);
    END;

    LOCAL PROCEDURE FilterItemAnalysisViewEntry@107(VAR ItemAnalysisViewEntry@1001 : Record 7154;ItemNo@1000 : Code[20]);
    BEGIN
      ItemAnalysisViewEntry.SETRANGE("Item Ledger Entry Type",ItemAnalysisViewEntry."Item Ledger Entry Type"::Sale);
      ItemAnalysisViewEntry.SETRANGE("Entry Type",ItemAnalysisViewEntry."Entry Type"::"Direct Cost");
      ItemAnalysisViewEntry.SETRANGE("Item No.",ItemNo);
    END;

    LOCAL PROCEDURE FilterJobPlanningLine@46(VAR JobPlanningLine@1000 : Record 1003;PurchaseLine@1001 : Record 39;LineType@1002 : Option);
    BEGIN
      JobPlanningLine.SETRANGE("Job No.",PurchaseLine."Job No.");
      JobPlanningLine.SETRANGE("Job Task No.",PurchaseLine."Job Task No.");
      JobPlanningLine.SETRANGE("No.",PurchaseLine."No.");
      JobPlanningLine.SETRANGE("Line Type",LineType);
    END;

    LOCAL PROCEDURE FindItemLedgerEntry@78(VAR ItemLedgerEntry@1000 : Record 32;EntryType@1002 : Option;ItemNo@1001 : Code[20]);
    BEGIN
      ItemLedgerEntry.SETRANGE("Entry Type",EntryType);
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindJobLedgerEntry@163(VAR JobLedgerEntry@1000 : Record 169;JobNo@1001 : Code[20];DocumentNo@1002 : Code[20]);
    BEGIN
      JobLedgerEntry.SETRANGE("Job No.",JobNo);
      JobLedgerEntry.SETRANGE("Document No.",DocumentNo);
      JobLedgerEntry.FINDSET;
    END;

    LOCAL PROCEDURE FindPurchaseLine@75(VAR PurchaseLine@1000 : Record 39;ItemNo@1001 : Code[20]);
    BEGIN
      PurchaseLine.SETRANGE(Type,PurchaseLine.Type::Item);
      PurchaseLine.SETRANGE("No.",ItemNo);
      PurchaseLine.FINDFIRST;
    END;

    LOCAL PROCEDURE OpenSelectContractLinesFromServiceContractPage@6(ContractNo@1001 : Code[20]);
    VAR
      ServiceContract@1000 : TestPage 6050;
    BEGIN
      ServiceContract.OPENEDIT;
      ServiceContract.FILTER.SETFILTER("Contract No.",ContractNo);
      ServiceContract.SelectContractLines.INVOKE;
    END;

    LOCAL PROCEDURE OpenToDoCardFromContactCardAndUpdateTeamCode@28(VAR ToDoList@1001 : TestPage 5096;ContactNo@1003 : Code[20];TeamCode@1004 : Code[10]);
    VAR
      ContactCard@1000 : TestPage 5050;
      ToDoCard@1002 : TestPage 5098;
    BEGIN
      ContactCard.OPENEDIT;
      ContactCard.FILTER.SETFILTER("No.",ContactNo);
      ToDoList.TRAP;
      ContactCard."Page To-do List".INVOKE;
      ToDoCard.TRAP;
      ToDoList."Page To-do Card".INVOKE;
      ToDoCard."Team Code".SETVALUE(TeamCode);
      ToDoCard.OK.INVOKE;
    END;

    LOCAL PROCEDURE PostPurchaseOrder@60(PurchaseHeader@1001 : Record 38;IsShipAndInvoice@1002 : Boolean);
    BEGIN
      PurchaseHeader.FIND;
      PurchaseHeader.VALIDATE("Vendor Invoice No.",LibraryUtility.GenerateGUID);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,IsShipAndInvoice,TRUE);  // Post as Invoice.
    END;

    LOCAL PROCEDURE UndoServiceConsumption@147(OrderNo@1001 : Code[20]);
    VAR
      ServiceShipmentLine@1000 : Record 5991;
    BEGIN
      LibraryVariableStorage.Enqueue(WantToUndoConsumptionQst);  // Enqueue for ConfirmHandler.
      LibraryVariableStorage.Enqueue(TRUE);  // Enqueue for ConfirmHandler.
      ServiceShipmentLine.SETRANGE("Order No.",OrderNo);
      CODEUNIT.RUN(CODEUNIT::"Undo Service Consumption Line",ServiceShipmentLine);
    END;

    LOCAL PROCEDURE UpdateAutomaticUpdateJobItemCostOnJobsSetup@33(NewAutomaticUpdateJobItemCost@1001 : Boolean) OldAutomaticUpdateJobItemCost : Boolean;
    VAR
      JobsSetup@1000 : Record 315;
    BEGIN
      JobsSetup.GET;
      OldAutomaticUpdateJobItemCost := JobsSetup."Automatic Update Job Item Cost";
      JobsSetup.VALIDATE("Automatic Update Job Item Cost",NewAutomaticUpdateJobItemCost);
      JobsSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCostingMethodOnItem@70(VAR Item@1001 : Record 27;CostingMethod@1000 : Option);
    VAR
      ItemTrackingCode@1002 : Record 6502;
    BEGIN
      IF CostingMethod = Item."Costing Method"::Specific THEN BEGIN
        LibraryItemTracking.CreateItemTrackingCode(ItemTrackingCode,TRUE,FALSE);
        Item.VALIDATE("Item Tracking Code",ItemTrackingCode.Code);
        Item.VALIDATE("Serial Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      END;
      Item.VALIDATE("Costing Method",CostingMethod);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemAnalysisView@105(ItemAnalysisViewCode@1000 : Code[10]);
    VAR
      ItemAnalysisViewList@1001 : TestPage 7151;
    BEGIN
      ItemAnalysisViewList.OPENEDIT;
      ItemAnalysisViewList.FILTER.SETFILTER(Code,ItemAnalysisViewCode);
      ItemAnalysisViewList."Codeunit Update Item Analysis View".INVOKE;
    END;

    LOCAL PROCEDURE UpdateJobItemCostAfterAdjustCostItemEntries@143(ItemNo@1000 : Code[20];JobNo@1001 : Code[20]);
    BEGIN
      LibraryVariableStorage.Enqueue(NoJobLedgerEntriesUpdatedMsg);  // Enqueue for MessageHandler.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');
      LibraryJob.RunUpdateJobItemCost(JobNo);
    END;

    LOCAL PROCEDURE UpdateJobTaskTypeOnJobTask@65(VAR JobTask@1000 : Record 1001;JobTaskType@1001 : Option);
    BEGIN
      JobTask.VALIDATE("Job Task Type",JobTaskType);
      JobTask.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateQuantityAndPostPurchaseReturnOrder@73(ItemNo@1000 : Code[20];Quantity@1001 : Decimal);
    VAR
      PurchaseLine@1002 : Record 39;
      PurchaseHeader@1003 : Record 38;
    BEGIN
      FindPurchaseLine(PurchaseLine,ItemNo);
      UpdateQuantityOnPurchaseLine(PurchaseLine,Quantity);
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      PurchaseHeader.VALIDATE("Vendor Cr. Memo No.",LibraryUtility.GenerateGUID);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);  // Receive and Invoice as TRUE.
    END;

    LOCAL PROCEDURE UpdateQuantityOnPurchaseLine@77(VAR PurchaseLine@1000 : Record 39;Quantity@1001 : Decimal);
    BEGIN
      PurchaseLine.VALIDATE(Quantity,Quantity);
      PurchaseLine.VALIDATE("Return Qty. to Ship",Quantity);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateUnitPriceAndCostingMethodOnItem@87(VAR Item@1000 : Record 27;CostingMethod@1001 : Option);
    BEGIN
      Item.VALIDATE("Unit Price",LibraryRandom.RandDec(10,2));
      UpdateCostingMethodOnItem(Item,CostingMethod);
    END;

    LOCAL PROCEDURE UpdateUnitPriceAndAssignTrackingOnPurchaseLine@110(VAR PurchaseLine@1000 : Record 39;UnitPrice@1001 : Decimal);
    VAR
      ItemTrackingMode@1002 : 'SelectEntries,AssignSerialNo';
    BEGIN
      PurchaseLine.VALIDATE("Unit Price (LCY)",UnitPrice);
      PurchaseLine.MODIFY(TRUE);
      LibraryVariableStorage.Enqueue(ItemTrackingMode::AssignSerialNo);  // Enqueue for ItemTrackingPageHandler.
      LibraryVariableStorage.Enqueue(PurchaseLine."Qty. to Receive");  // Enqueue for EnterQtyToCreatePageHandler.
      PurchaseLine.OpenItemTrackingLines;
    END;

    LOCAL PROCEDURE UpdateUnitPriceAndPostPurchaseOrder@153(VAR PurchaseHeader@1000 : Record 38;VAR PurchaseLine@1001 : Record 39;UnitPrice@1002 : Decimal) : Code[20];
    VAR
      ItemTrackingMode@1003 : 'SelectEntries,AssignSerialNo';
    BEGIN
      LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);
      PurchaseHeader.VALIDATE("Vendor Invoice No.",LibraryUtility.GenerateGUID);
      PurchaseHeader.MODIFY(TRUE);
      PurchaseLine.FIND;
      PurchaseLine.VALIDATE("Unit Price (LCY)",UnitPrice);
      PurchaseLine.MODIFY(TRUE);
      LibraryVariableStorage.Enqueue(ItemTrackingMode::AssignSerialNo);  // Enqueue for ItemTrackingPageHandler.
      LibraryVariableStorage.Enqueue(PurchaseLine."Qty. to Receive");  // Enqueue for EnterQtyToCreatePageHandler.
      PurchaseLine.OpenItemTrackingLines;
      EXIT(LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE));  // Receive and Invoice as TRUE.
    END;

    LOCAL PROCEDURE VerifyAdjustedJobLedgerEntryExist@45(JobNo@1000 : Code[20];ItemNo@1001 : Code[20];UnitOfMeasureCode@1003 : Code[10];EntryExist@1004 : Boolean);
    VAR
      JobLedgerEntry@1002 : Record 169;
    BEGIN
      JobLedgerEntry.SETRANGE("Job No.",JobNo);
      JobLedgerEntry.SETRANGE("No.",ItemNo);
      JobLedgerEntry.SETRANGE("Unit of Measure Code",UnitOfMeasureCode);
      JobLedgerEntry.SETRANGE(Adjusted,TRUE);
      Assert.AreEqual(JobLedgerEntry.FINDFIRST,EntryExist,AdjustedJobLedgerEntryExistMsg);
    END;

    LOCAL PROCEDURE VerifyEmptyJobPlanningLines@57(PurchaseLine@1001 : Record 39;LineType@1000 : Option);
    VAR
      JobPlanningLine@1002 : Record 1003;
    BEGIN
      FilterJobPlanningLine(JobPlanningLine,PurchaseLine,LineType);
      Assert.IsTrue(JobPlanningLine.ISEMPTY,JobPlanningLineMustBeEmptyMsg);
    END;

    LOCAL PROCEDURE VerifyItemAnalysisViewEntry@137(ItemNo@1001 : Code[20];Quantity@1002 : Decimal);
    VAR
      ItemAnalysisViewEntry@1000 : Record 7154;
    BEGIN
      FilterItemAnalysisViewEntry(ItemAnalysisViewEntry,ItemNo);
      ItemAnalysisViewEntry.FINDFIRST;
      ItemAnalysisViewEntry.TESTFIELD(Quantity,Quantity);
    END;

    LOCAL PROCEDURE VerifyPurchaseReturnOrder@72(JobTask@1001 : Record 1001;ItemNo@1002 : Code[20];Quantity@1003 : Decimal);
    VAR
      PurchaseLine@1000 : Record 39;
    BEGIN
      FindPurchaseLine(PurchaseLine,ItemNo);
      PurchaseLine.TESTFIELD("Job No.",JobTask."Job No.");
      PurchaseLine.TESTFIELD("Job Task No.",JobTask."Job Task No.");
      PurchaseLine.TESTFIELD(Quantity,Quantity);
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntry@85(EntryType@1001 : Option;DocumentType@1006 : Option;Open@1003 : Boolean;ItemNo@1002 : Code[20];Quantity@1004 : Decimal;RemainingQuantity@1005 : Decimal;CostAmountActual@1007 : Decimal);
    VAR
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      ItemLedgerEntry.SETRANGE("Document Type",DocumentType);
      ItemLedgerEntry.SETRANGE(Open,Open);
      FindItemLedgerEntry(ItemLedgerEntry,EntryType,ItemNo);
      ItemLedgerEntry.TESTFIELD(Quantity,Quantity);
      ItemLedgerEntry.TESTFIELD("Remaining Quantity",RemainingQuantity);
      ItemLedgerEntry.TESTFIELD("Invoiced Quantity",Quantity);
      ItemLedgerEntry.TESTFIELD("Cost Amount (Actual)",CostAmountActual);
    END;

    LOCAL PROCEDURE VerifyJobLedgerEntry@22(JobNo@1004 : Code[20];DocumentNo@1005 : Code[20];LineType@1006 : Option;UnitOfMeasureCode@1007 : Code[10];DirectUnitCost@1001 : Decimal;UnitCost@1002 : Decimal;Quantity@1003 : Decimal;UnitPrice@1008 : Decimal);
    VAR
      JobLedgerEntry@1000 : Record 169;
    BEGIN
      JobLedgerEntry.SETRANGE("Line Type",LineType);
      JobLedgerEntry.SETRANGE("Unit of Measure Code",UnitOfMeasureCode);
      FindJobLedgerEntry(JobLedgerEntry,JobNo,DocumentNo);
      JobLedgerEntry.TESTFIELD("Direct Unit Cost (LCY)",DirectUnitCost);
      JobLedgerEntry.TESTFIELD("Unit Cost (LCY)",UnitCost);
      JobLedgerEntry.TESTFIELD("Total Cost (LCY)",UnitCost * Quantity);  // Calculated value required for Total Cost.
      JobLedgerEntry.TESTFIELD("Unit Price",UnitPrice);
    END;

    LOCAL PROCEDURE VerifyJobLedgerEntryDoesNotExist@115(JobNo@1004 : Code[20];DocumentNo@1005 : Code[20];LineType@1006 : Option;UnitOfMeasureCode@1007 : Code[10]);
    VAR
      JobLedgerEntry@1000 : Record 169;
    BEGIN
      JobLedgerEntry.SETRANGE("Line Type",LineType);
      JobLedgerEntry.SETRANGE("Unit of Measure Code",UnitOfMeasureCode);
      JobLedgerEntry.SETRANGE("Job No.",JobNo);
      JobLedgerEntry.SETRANGE("Document No.",DocumentNo);
      Assert.IsTrue(JobLedgerEntry.ISEMPTY,JobLedgEntryExistsErr);
    END;

    LOCAL PROCEDURE VerifyJobLedgerEntryForSerial@161(Item@1001 : Record 27;JobTask@1002 : Record 1001;DocumentNo@1004 : Code[20];TotalQuantity@1007 : Decimal);
    VAR
      JobLedgerEntry@1000 : Record 169;
      Quantity@1006 : Decimal;
    BEGIN
      JobLedgerEntry.SETRANGE("Entry Type",JobLedgerEntry."Entry Type"::Usage);
      JobLedgerEntry.SETRANGE(Type,JobLedgerEntry.Type::Item);
      JobLedgerEntry.SETRANGE("No.",Item."No.");
      JobLedgerEntry.SETRANGE("Job Task No.",JobTask."Job Task No.");
      FindJobLedgerEntry(JobLedgerEntry,JobTask."Job No.",DocumentNo);
      REPEAT
        JobLedgerEntry.TESTFIELD("Serial No.");
        JobLedgerEntry.TESTFIELD("Unit Price",Item."Unit Price");
        JobLedgerEntry.TESTFIELD(Quantity,1);  // Value Required for Serial.
        Quantity += JobLedgerEntry.Quantity;
      UNTIL JobLedgerEntry.NEXT = 0;
      Assert.AreEqual(TotalQuantity,Quantity,QuantityMustBeSameMsg);
    END;

    LOCAL PROCEDURE VerifyJobPlanningLine@9(PurchaseLine@1006 : Record 39;LineType@1002 : Option;MoveNext@1001 : Boolean;Quantity@1003 : Decimal);
    VAR
      JobPlanningLine@1000 : Record 1003;
    BEGIN
      FilterJobPlanningLine(JobPlanningLine,PurchaseLine,LineType);
      JobPlanningLine.FINDSET;
      IF MoveNext THEN
        JobPlanningLine.NEXT;
      JobPlanningLine.TESTFIELD(Quantity,Quantity);
      JobPlanningLine.TESTFIELD("Unit Cost (LCY)",PurchaseLine."Unit Cost (LCY)");
    END;

    LOCAL PROCEDURE VerifyServiceContractLine@26(ServiceContractHeader@1001 : Record 5965;ServiceItemNo@1002 : Code[20]);
    VAR
      ServiceContractLine@1000 : Record 5964;
    BEGIN
      ServiceContractLine.SETRANGE("Contract Type",ServiceContractHeader."Contract Type");
      ServiceContractLine.SETRANGE("Contract No.",ServiceContractHeader."Contract No.");
      ServiceContractLine.FINDFIRST;
      ServiceContractLine.TESTFIELD("Service Item No.",ServiceItemNo);
    END;

    LOCAL PROCEDURE VerifyToDo@25(Contact@1001 : Record 5050;No@1002 : Code[20]);
    VAR
      ToDo@1000 : Record 5080;
    BEGIN
      ToDo.GET(No);
      ToDo.TESTFIELD("Contact No.",Contact."No.");
      ToDo.TESTFIELD("Salesperson Code",Contact."Salesperson Code");
    END;

    LOCAL PROCEDURE VerifyWarehouseShipmentLine@126(SourceNo@1001 : Code[20];ItemNo@1002 : Code[20];Quantity@1003 : Decimal);
    VAR
      WarehouseShipmentLine@1000 : Record 7321;
    BEGIN
      WarehouseShipmentLine.SETRANGE("Source Document",WarehouseShipmentLine."Source Document"::"Sales Order");
      WarehouseShipmentLine.SETRANGE("Source No.",SourceNo);
      WarehouseShipmentLine.SETRANGE("Item No.",ItemNo);
      WarehouseShipmentLine.FINDFIRST;
      WarehouseShipmentLine.TESTFIELD(Quantity,Quantity);
    END;

    LOCAL PROCEDURE VerifyResourceGetUnitOfMeasureFilter@130(JobTaskNo@1001 : Code[20];UOMCodeLineCount@1002 : Integer;Filter@1003 : Text);
    VAR
      JobPlanningLine@1000 : Record 1003;
    BEGIN
      WITH JobPlanningLine DO BEGIN
        SETRANGE("Job Task No.",JobTaskNo);
        Assert.IsTrue(UOMCodeLineCount < COUNT,STRSUBSTNO(JobPlanningLineCountErr,TABLECAPTION,UOMCodeLineCount));
        SETFILTER("Unit of Measure Code",Filter);
        Assert.AreEqual(UOMCodeLineCount,COUNT,STRSUBSTNO(JobPlanningLineFilterErr,TABLECAPTION,GETFILTERS));
      END;
    END;

    LOCAL PROCEDURE VerifyBaseUnitOfMeasure@109(Res@1000 : Record 156;BaseUnitOfMeasureCode@1001 : Code[10]);
    BEGIN
      Res.TESTFIELD("Base Unit of Measure",BaseUnitOfMeasureCode);
    END;

    LOCAL PROCEDURE VerifyBaseUnitOfMeasureSetAndResUnitOfMeasureInserted@116(Res@1000 : Record 156;ExpectedBaseUnitOfMeasure@1001 : Record 204;ExpectedUnitsOfMeasureCount@1002 : Integer);
    VAR
      ResUnitOfMeasure@1003 : Record 205;
    BEGIN
      ResUnitOfMeasure.SETFILTER("Resource No.",Res."No.");
      Assert.AreEqual(ExpectedUnitsOfMeasureCount,ResUnitOfMeasure.COUNT,'Wrong number of Units of measure was found on the item');
      ResUnitOfMeasure.SETFILTER(Code,ExpectedBaseUnitOfMeasure.Code);

      Assert.IsTrue(ResUnitOfMeasure.FINDFIRST,'Cannot get Item unit of measure for specified code');
      Assert.AreEqual(1,ResUnitOfMeasure."Qty. per Unit of Measure",'Qty. per Unit of Measure should be set to 1');
      Assert.AreEqual(Res."Base Unit of Measure",ResUnitOfMeasure.Code,'Base unit of measure was not set by validate');
    END;

    LOCAL PROCEDURE VerifyUnitPriceResLedgerEntry@148(DocNo@1000 : Code[20];ResNo@1001 : Code[20];UnitPrice@1003 : ARRAY [2] OF Decimal);
    VAR
      ResLedgerEntry@1002 : Record 203;
    BEGIN
      ResLedgerEntry.SETRANGE("Document No.",DocNo);
      ResLedgerEntry.SETRANGE("Resource No.",ResNo);
      Assert.RecordCount(ResLedgerEntry,2);
      ResLedgerEntry.FINDSET;
      ResLedgerEntry.TESTFIELD("Unit Price",UnitPrice[1]);
      ResLedgerEntry.NEXT;
      ResLedgerEntry.TESTFIELD("Unit Price",UnitPrice[2]);
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@76(ConfirmMessage@1000 : Text[1024];VAR Reply@1001 : Boolean);
    VAR
      DequeueVariable@1003 : Variant;
      LocalMessage@1004 : Text[1024];
    BEGIN
      LibraryVariableStorage.Dequeue(DequeueVariable);
      LocalMessage := DequeueVariable;
      Assert.IsTrue(STRPOS(ConfirmMessage,LocalMessage) > 0,ConfirmMessage);
      LibraryVariableStorage.Dequeue(DequeueVariable);
      Reply := DequeueVariable;
    END;

    [ModalPageHandler]
    PROCEDURE ContractLineSelectionPageHandler@3(VAR ContractLineSelection@1000 : TestPage 6057);
    BEGIN
      ContractLineSelection.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE EnterQuantityToCreatePageHandler@243(VAR EnterQuantityToCreate@1000 : TestPage 6513);
    VAR
      DequeueVariable@1001 : Variant;
      QtyToCreate@1002 : Decimal;
    BEGIN
      LibraryVariableStorage.Dequeue(DequeueVariable);
      QtyToCreate := DequeueVariable;
      EnterQuantityToCreate.QtyToCreate.SETVALUE(QtyToCreate);
      EnterQuantityToCreate.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemTrackingPageHandler@125(VAR ItemTrackingLines@1000 : TestPage 6510);
    VAR
      DequeueVariable@1004 : Variant;
      ItemTrackingMode@1003 : 'SelectEntries,AssignSerialNo';
    BEGIN
      LibraryVariableStorage.Dequeue(DequeueVariable);
      ItemTrackingMode := DequeueVariable;
      CASE ItemTrackingMode OF
        ItemTrackingMode::SelectEntries:
          ItemTrackingLines."Select Entries".INVOKE;
        ItemTrackingMode::AssignSerialNo:
          ItemTrackingLines."Assign Serial No.".INVOKE;
      END;
      ItemTrackingLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemTrackingSummaryPageHandler@124(VAR ItemTrackingSummary@1000 : TestPage 6500);
    BEGIN
      ItemTrackingSummary.OK.INVOKE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@104(Message@1000 : Text[1024]);
    VAR
      DequeueVariable@1002 : Variant;
      LocalMessage@1001 : Text[1024];
    BEGIN
      LibraryVariableStorage.Dequeue(DequeueVariable);
      LocalMessage := DequeueVariable;
      Assert.IsTrue(STRPOS(Message,LocalMessage) > 0,Message);
    END;

    [ModalPageHandler]
    PROCEDURE ServiceContractTemplateListPageHandler@2(VAR ServiceContractTemplateList@1000 : TestPage 6056);
    BEGIN
      ServiceContractTemplateList.OK.INVOKE;
    END;

    BEGIN
    {
      // [FEATURE] [Job] [Resource]
       1. Test and verify the error on invoking No on Confirm message for Create as Customer on Contact.
       2. Test and verify the functionality of Select Contract lines on Service Contract.
       3. Test and verify the error on deleting Resource Unit of Measure.
       4. Test and verify the error on renaming Resource Unit of Measure after posting Sales Order.
       5. Test and verify the functionality of creating To-do for Contact with Salesperson.
       6. Test and verify Team Code gets updated on To-do card of the Contact with Salesperson.
       7. Test and verify error on updating Job Task No. with type Total on Purchase line.
       8. Test and verify Job ledger entries after running Update Job Item Cost batch report and posting Purchase Orders.
       9. Test and verify Job ledger entries and Job planning lines after Get receipt lines on Purchase Invoice.
      10. Test and verify that Adjustment Job ledger entry does not gets created after Update Job Item Cost batch job with Standard Costing.
      11. Test and verify that Adjustment Job ledger entry does not gets created after Adjust Cost Item Entries with different UOM and Standard Costing.
      12. Test and verify that Adjustment Job ledger entry gets created after Update Job Item Cost batch job with Specific Costing and Serial Tracking.
      13. Test and verify that Adjustment Job ledger entry gets created after Adjust Cost Item Entries with different UOM, Specific Costing and Serial Tracking.
      14. Test and verify that Adjustment Job ledger entry gets created after Update Job Item Cost batch job with Average Costing.
      15. Test and verify that Adjustment Job ledger entry gets created after Adjust Cost Item Entries with different UOM and Average Costing.
      16. Test and verify that Adjustment Job ledger entry gets created after Update Job Item Cost batch job with FIFO Costing.
      17. Test and verify that Adjustment Job ledger entry gets created after Adjust Cost Item Entries with different UOM and FIFO Costing.
      18. Test and verify that Adjustment Job ledger entry gets created after Update Job Item Cost batch job with LIFO Costing.
      19. Test and verify that Adjustment Job ledger entry gets created after Adjust Cost Item Entries with different UOM and LIFO Costing.
      20. Test and verify no Job Ledger Entry after ship Purchase Order with partial quantity.
      21. Test and verify Job Ledger Entry after invoice Purchase Order with partial quantity.
      22. Test and verify Job Ledger Entry after invoice Purchase Order.
      23. Test and verify Purchase Return Order using copy document with job.
      24. Test and verify Item Ledger Entry after post Purchase Return Order.
      25. Test and verify error on updating End-Total Job Task Type on Purchase line.
      26. Test and verify error on updating Begin-Total Job Task Type on Purchase line.
      27. Test and verify error on updating Job No. with type Charge associated to a Job Task Line on Purchase line.
      28. Test and verify error on updating Job No on Purchase Line for Fixed Asset.
      29. Test and verify Job Ledger Entry after Update Job Item Cost and Adjust Cost Item Entries with Specific Costing Method.
      30. Test and verify Job Ledger Entry after Update Job Item Cost and Adjust Cost Item Entries with Different UOM and LIFO Costing Method.
      31. Test and verify Warehouse Shipment Lines after Get Source Documents on Warehouse Shipment with Multiple Items.
      32. Test and verify Empty Item Analysis View Entry after Update Item Analysis View and Post Job Journal with Default Customer Dimension.
      33. Test and verify Item Analysis View Entry after Update Item Analysis View and Post Sales Order with Default Customer Dimension.
      34. Test and verify Item Ledger Entry after Post Service Order as Ship and Consume with Undo Consumption.
      35. Test filter application with () sumbols.

      Covers Test Cases for WI - 324408
      ----------------------------------------------------------------------------------------------------
      Test Function Name                                                                            TFS ID
      ----------------------------------------------------------------------------------------------------
      ErrorOnDoingCreateAsCustomerOnContact                                                         298992
      SelectContractLinesOnServiceContract                                                          291733
      ErrorOnDeletingResourceBaseUnitOfMeasure, ErrorOnRenamingResourceBaseUnitOfMeasure            314000
      ToDoForContactWithSalesPerson, ToDoForContactWithSalesPersonAndTeamCode                       311405

      Covers Test Cases for WI - 324409
      ----------------------------------------------------------------------------------------------------
      Test Function Name                                                                            TFS ID
      ----------------------------------------------------------------------------------------------------
      ErrorOnUpdatingJobTaskNoOnPurchaseOrderLine                                                   141698
      UpdateJobItemCostReportAfterPostPurchaseOrder                                                 141685
      GetReceiptLinesOnPurchaseInvoiceWithJob                                                       141704

      Covers Test Cases for WI - 326130
      ----------------------------------------------------------------------------------------------------
      Test Function Name                                                                            TFS ID
      ----------------------------------------------------------------------------------------------------
      UpdateJobItemCostWithPOAndStandardCosting, AdjustCostItemEntriesWithDiffUOMAndStandardCosting 141689
      UpdateJobItemCostWithPOAndSpecificCosting, AdjustCostItemEntriesWithDiffUOMAndSpecificCosting 141690
      UpdateJobItemCostWithPOAndAverageCosting, AdjustCostItemEntriesWithDiffUOMAndAverageCosting   141693
      UpdateJobItemCostWithPOAndFIFOCosting, AdjustCostItemEntriesWithDiffUOMAndFIFOCosting         141692
      UpdateJobItemCostWithPOAndLIFOCosting, AdjustCostItemEntriesWithDiffUOMAndLIFOCosting         141691

      Covers Test Cases for WI - 326131
      -----------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                  TFS ID
      -----------------------------------------------------------------------------------------------------------
      JobPlngLinesAfterShippingPurchOrdWithPartialQty, JobPlngLinesAfterInvoicingPurchOrdWithPartialQty   141703
      JobPlngLinesAfterInvoicingPurchaseOrder

      Covers Test Cases for WI - 326134
      -----------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                  TFS ID
      -----------------------------------------------------------------------------------------------------------
      PurchaseReturnOrderUsingCopyDocumentWithJob, PostPurchaseReturnOrderUsingCopyDocumentWithJob        317347
      ErrorOnUpdatingEndTotalJobTaskTypeOnPurchaseLine                                                    141697
      ErrorOnUpdatingBeginTotalJobTaskTypeOnPurchaseLine                                                  141699
      ErrorOnUpdatingJobNoOnPurchaseLineForChargeItem                                                     141696

      Covers Test Cases for WI - 326136
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                            TFS ID
      -----------------------------------------------------------------------------------------------------
      ErrorOnUpdatingJobNoOnPurchaseLineForFixedAsset                                               141701
      UpdateJobItemCostWithPartialPOAndSpecificCosting                                              141686
      UpdateJobItemCostWithMultiplePOAndLIFOCosting                                                 141687
      GetSourceDocumentsOnWhseShipmentWithMultipleItems                                             143093
      UpdateItemAnalysisViewAfterPostJobJournal, UpdateItemAnalysisViewAfterPostSalesOrder          145228

      Covers Test Cases for WI - 331254
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                            TFS ID
      -----------------------------------------------------------------------------------------------------
      UndoConsumptionAfterPostServiceOrder                                                          299627

      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                            TFS ID
      -----------------------------------------------------------------------------------------------------
      UndoConsumptionAfterPostServiceOrder                                                          73815
    }
    END.
  }
}

