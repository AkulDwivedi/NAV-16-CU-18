OBJECT Codeunit 137101 SCM Kitting
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      ItemJournalBatch@1017 : Record 233;
      ItemJournalTemplate@1016 : Record 82;
      LocationBlack@1022 : Record 14;
      LocationRed@1023 : Record 14;
      Assert@1007 : Codeunit 130000;
      LibraryAssembly@1002 : Codeunit 132207;
      LibraryCosting@1019 : Codeunit 132200;
      LibraryERM@1018 : Codeunit 131300;
      LibraryFiscalYear@1035 : Codeunit 131302;
      LibraryInventory@1015 : Codeunit 132201;
      LibraryResource@1009 : Codeunit 130511;
      LibrarySales@1013 : Codeunit 130509;
      LibraryPurchase@1042 : Codeunit 130512;
      LibraryUtility@1003 : Codeunit 131000;
      LibrarySetupStorage@1045 : Codeunit 131009;
      LibraryVariableStorage@1014 : Codeunit 131004;
      LibraryRandom@1000 : Codeunit 130440;
      LibraryWarehouse@1021 : Codeunit 132204;
      LibraryManufacturing@1025 : Codeunit 132202;
      LibraryDimension@1036 : Codeunit 131001;
      isInitialized@1001 : Boolean;
      TypeMustBeError@1006 : TextConst '@@@="%1 = Expected Type, %2 = Parent Item No., %3 =  Line No., %4 = Actual Type";ENU="Type must be equal to ''%1''  in BOM Component: Parent Item No.=%2, Line No.=%3. Current value is ''%4''."';
      ItemNotBOMError@1008 : TextConst 'ENU=Item %1 is not a BOM.';
      TypeMustBeEqualToItemError@1011 : TextConst 'ENU="Type must be equal to ''Item''  in Assembly Line: Document Type=Order,"';
      ItemNotOnInventoryError@1010 : TextConst 'ENU=You have insufficient quantity of Item %1 on inventory.';
      AssemblyOrderNosError@1012 : TextConst 'ENU="Assembly Order Nos. must have a value in Assembly Setup: Primary Key=. It cannot be zero or empty."';
      OrderCanNotCreatedError@1004 : TextConst 'ENU=Order %1 cannot be created, because it already exists or has been posted.';
      NothingToPostError@1005 : TextConst 'ENU=There is nothing to post.';
      ResetAssemblyLines@1020 : TextConst 'ENU=This assembly order may have customized lines. Are you sure that you want to reset the lines according to the assembly BOM?';
      AssemblyHeaderDoesNotExistError@1024 : TextConst 'ENU=The Assembly Header does not exist.';
      PostJournalLinesConfirm@1027 : TextConst 'ENU=Do you want to post the journal lines?';
      JournalLinesSuccessfullyPosted@1026 : TextConst 'ENU=The journal lines were successfully posted.';
      AutomaticCostPostingMessage@1028 : TextConst 'ENU=The field Automatic Cost Posting should not be set to Yes if field Use Legacy G/L Entry Locking in General Ledger Setup table is set to No because of possibility of deadlocks.';
      UnadjustedValueEntriesNotCoveredMessage@1029 : TextConst 'ENU=Some unadjusted value entries will not be covered with the new setting. You must run the Adjust Cost - Item Entries batch job once to adjust these.';
      FileName@1030 : TextConst 'ENU=%1.pdf';
      AssemblyOrderMustBeDeleted@1031 : TextConst 'ENU=Assembly Order must be deleted.';
      CannotDeleteItemError@1034 : TextConst 'ENU=You cannot delete Item %1 because it has ledger entries in a fiscal year that has not been closed yet.';
      ItemEntriesNotAdjustedError@1032 : TextConst 'ENU=There are item entries that have not been adjusted for item %1.';
      AmountMustBeSame@1033 : TextConst 'ENU=Amount must be same.';
      UpdateDimConfirmQst@1037 : TextConst 'ENU=Do you want to update the Dimensions on the lines';
      BeforeWorkDateMsg@1038 : TextConst 'ENU=is before work date %1 in one or more of the assembly lines';
      CalcStandardCostMsg@1039 : TextConst 'ENU=One or more subassemblies on the assembly list';
      PostingDateLaterErr@1040 : TextConst 'ENU=Posting Date on Assembly Order %1 must not be later than the Posting Date on Sales Order %2';
      UndoShipmentConfirmationMsg@1041 : TextConst 'ENU=Do you really want to undo the selected Shipment lines?';
      AppliesToEntryErr@1043 : TextConst 'ENU=Applies-to Entry on ILE should be equal to Appl. -to Item Entry on Assembly Line';
      CostAmountErr@1044 : TextConst 'ENU=Cost Amount (Actual) was adjusted incorrectly';

    [Test]
    PROCEDURE ErrorOnUpdateFixedResourceUsageTypeWithItemType@42();
    VAR
      BOMComponent@1000 : Record 90;
    BEGIN
      // Setup.
      Initialize;
      ErrorOnUpdateFixedResourceUsageTypeOnAssemblyBOM(BOMComponent.Type::Item);
    END;

    [Test]
    PROCEDURE ErrorOnUpdateFixedResourceUsageTypeWithBlankType@69();
    VAR
      BOMComponent@1000 : Record 90;
    BEGIN
      // Setup.
      Initialize;
      ErrorOnUpdateFixedResourceUsageTypeOnAssemblyBOM(BOMComponent.Type::" ");
    END;

    LOCAL PROCEDURE ErrorOnUpdateFixedResourceUsageTypeOnAssemblyBOM@71(Type@1002 : Option);
    VAR
      Item@1001 : Record 27;
      BOMComponent@1000 : Record 90;
    BEGIN
      // Setup Assembly Item.
      CreateAssemblyItem(Item);

      // Exercise.
      ASSERTERROR UpdateFixedResourceUsageTypeOnAssemblyBOM(BOMComponent,Item."No.",Type);

      // Verify.
      Assert.ExpectedError(
        STRSUBSTNO(TypeMustBeError,BOMComponent.Type::Resource,BOMComponent."Parent Item No.",BOMComponent."Line No.",BOMComponent.Type));
    END;

    [Test]
    PROCEDURE CalculateStandardCostAfterCopyAssemblyBOM@1();
    BEGIN
      // Setup.
      Initialize;
      CalcStandardCostAndUnitPriceAfterCopyAssemblyBOM(FALSE);  // Use Calculate Unit Price as False.
    END;

    [Test]
    PROCEDURE CalculateUnitPriceAfterCopyAssemblyBOM@14();
    BEGIN
      // Setup.
      Initialize;
      CalcStandardCostAndUnitPriceAfterCopyAssemblyBOM(TRUE);  // Use Calculate Unit Price as True.
    END;

    LOCAL PROCEDURE CalcStandardCostAndUnitPriceAfterCopyAssemblyBOM@8(CalculateUnitPrice@1008 : Boolean);
    VAR
      Item@1007 : Record 27;
      Item2@1006 : Record 27;
      AssemblyBOM@1005 : TestPage 36;
      MaterialCost@1004 : Decimal;
      CapacityCost@1003 : Decimal;
      CapacityOverhead@1002 : Decimal;
    BEGIN
      // Setup Assembly Item. Copy Assembly BOM. Add Resource to Assembly BOM.
      CreateAssemblyItem(Item);
      LibraryAssembly.CreateItem(
        Item2,Item2."Costing Method"::Standard,Item2."Replenishment System"::Assembly,Item."Gen. Prod. Posting Group",
        Item."Inventory Posting Group");
      CopyAssemblyBOM(Item."No.",Item2."No.");
      AddResourceToAssemblyBOM(Item2,FALSE);  // Use False for without Resource Price.

      // Exercise.
      CalculateStandardCostOnAssemblyBOM(AssemblyBOM,Item2."No.");

      // Verify.
      Assert.AreNearlyEqual(
        LibraryAssembly.CalcExpectedStandardCost(MaterialCost,CapacityCost,CapacityOverhead,Item2."No."),
        AssemblyBOM."Assembly Item - Details"."Standard Cost".ASDECIMAL,LibraryERM.GetAmountRoundingPrecision,AmountMustBeSame);

      IF CalculateUnitPrice THEN BEGIN
        // Exercise.
        AssemblyBOM.CalcUnitPrice.INVOKE;

        // Verify.
        Assert.AreNearlyEqual(
          LibraryAssembly.CalcExpectedPrice(Item2."No."),AssemblyBOM."Assembly Item - Details"."Unit Price".ASDECIMAL,
          LibraryERM.GetAmountRoundingPrecision,AmountMustBeSame);
      END;
    END;

    [Test]
    PROCEDURE ErrorOnExplodeAssemblyBOMWithResourceType@20();
    VAR
      BOMComponent@1000 : Record 90;
    BEGIN
      // Setup.
      Initialize;
      ErrorOnExplodeAssemblyBOM(BOMComponent.Type::Resource);
    END;

    [Test]
    PROCEDURE ErrorOnExplodeAssemblyBOMWithBlankType@51();
    VAR
      BOMComponent@1000 : Record 90;
    BEGIN
      // Setup.
      Initialize;
      ErrorOnExplodeAssemblyBOM(BOMComponent.Type::" ");
    END;

    [Test]
    PROCEDURE ErrorOnExplodeAssemblyBOMWithItemType@63();
    VAR
      BOMComponent@1000 : Record 90;
    BEGIN
      // Setup.
      Initialize;
      ErrorOnExplodeAssemblyBOM(BOMComponent.Type::Item);
    END;

    LOCAL PROCEDURE ErrorOnExplodeAssemblyBOM@46(Type@1002 : Option);
    VAR
      Item@1001 : Record 27;
      BOMComponent@1000 : Record 90;
    BEGIN
      // Setup Assembly Item.
      CreateAssemblyItem(Item);

      // Exercise.
      ASSERTERROR ExplodeAssemblyBOM(BOMComponent,Item."No.",Type);

      // Verify.
      IF Type = BOMComponent.Type::Item THEN
        Assert.ExpectedError(STRSUBSTNO(ItemNotBOMError,BOMComponent."No."))
      ELSE
        Assert.ExpectedError(
          STRSUBSTNO(TypeMustBeError,BOMComponent.Type::Item,BOMComponent."Parent Item No.",BOMComponent."Line No.",BOMComponent.Type));
    END;

    [Test]
    PROCEDURE ExplodeAssemblyBOMComponent@2();
    VAR
      BOMComponent@1002 : Record 90;
      Item@1000 : Record 27;
      Item2@1001 : Record 27;
      QuantityPer@1003 : Decimal;
    BEGIN
      // Setup: Setup two Assembly Item. Add Assembly Item to Assembly BOM.
      Initialize;
      CreateAssemblyItem(Item);
      CreateAssemblyItem(Item2);
      QuantityPer := LibraryRandom.RandInt(5);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,Item2."No.",Item."No.",'',BOMComponent."Resource Usage Type",QuantityPer,TRUE);  // Use Base Unit of Measure as True and Variant Code as blank.

      // Exercise.
      BOMComponent.SETRANGE("No.",Item2."No.");
      ExplodeAssemblyBOM(BOMComponent,Item."No.",BOMComponent.Type::Item);

      // Verify.
      VerifyBOMComponentAfterExplodeBOM(Item."No.",Item2."No.",QuantityPer);
    END;

    [Test]
    PROCEDURE CalculateStandardCostWithResourcePrice@6();
    BEGIN
      // Setup.
      Initialize;
      CalculateStandardCostAndUnitPriceWithResourcePrice(FALSE);  // Use Calculate Unit Price as False.
    END;

    [Test]
    PROCEDURE CalculateUnitPriceWithResourcePrice@15();
    BEGIN
      // Setup.
      Initialize;
      CalculateStandardCostAndUnitPriceWithResourcePrice(TRUE);  // Use Calculate Unit Price as True.
    END;

    LOCAL PROCEDURE CalculateStandardCostAndUnitPriceWithResourcePrice@7(CalculateUnitPrice@1007 : Boolean);
    VAR
      Item@1006 : Record 27;
      AssemblyBOM@1005 : TestPage 36;
      MaterialCost@1003 : Decimal;
      CapacityCost@1002 : Decimal;
      CapacityOverhead@1001 : Decimal;
    BEGIN
      // Setup Assembly Item. Add Resource to Assembly BOM.
      CreateAssemblyItem(Item);
      AddResourceToAssemblyBOM(Item,TRUE);  // Use True for with Resource Price.

      // Exercise.
      CalculateStandardCostOnAssemblyBOM(AssemblyBOM,Item."No.");

      // Verify.
      Assert.AreNearlyEqual(
        LibraryAssembly.CalcExpectedStandardCost(MaterialCost,CapacityCost,CapacityOverhead,Item."No."),
        AssemblyBOM."Assembly Item - Details"."Standard Cost".ASDECIMAL,LibraryERM.GetAmountRoundingPrecision,AmountMustBeSame);

      IF CalculateUnitPrice THEN BEGIN
        // Exercise.
        AssemblyBOM.CalcUnitPrice.INVOKE;

        // Verify.
        Assert.AreNearlyEqual(
          LibraryAssembly.CalcExpectedPrice(Item."No."),AssemblyBOM."Assembly Item - Details"."Unit Price".ASDECIMAL,
          LibraryERM.GetAmountRoundingPrecision,AmountMustBeSame);
      END;
    END;

    [Test]
    PROCEDURE AssemblyOrderWithBOMComponents@17();
    BEGIN
      // Setup.
      Initialize;
      AssemblyOrderOfItemWithBOMComponents(FALSE,FALSE);
    END;

    [Test]
    PROCEDURE AssemblyListFromAssemblyOrderForItem@22();
    BEGIN
      // Setup.
      Initialize;
      AssemblyOrderOfItemWithBOMComponents(TRUE,FALSE);  // AssemblyListForItem as TRUE.
    END;

    [Test]
    PROCEDURE ErrorOnInvokingAssemblyListForResource@26();
    BEGIN
      // Setup.
      Initialize;
      AssemblyOrderOfItemWithBOMComponents(TRUE,TRUE);  // AssemblyListForItem and AssemblyListForResource as TRUE.
    END;

    LOCAL PROCEDURE AssemblyOrderOfItemWithBOMComponents@13(AssemblyListForItem@1011 : Boolean;AssemblyListForResource@1012 : Boolean);
    VAR
      AssemblyHeader@1004 : Record 900;
      AssemblyLine@1005 : Record 901;
      BOMComponent@1002 : Record 90;
      Item@1001 : Record 27;
      Item2@1000 : Record 27;
      Item3@1003 : Record 27;
      AssemblyBOM@1013 : TestPage 36;
    BEGIN
      // Create Assembly Items and create their BOM components.
      CreateAssemblyItemsAndBOMComponentsSetup(Item,Item2,Item3);

      // Exercise.
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',LibraryRandom.RandDec(10,2),'');

      // Verify.
      VerifyAssemblyLine(Item."No.",AssemblyHeader.Quantity);

      IF AssemblyListForItem THEN BEGIN
        // Exercise.
        BOMComponent.SETRANGE("Assembly BOM",FALSE);
        FindBOMComponent(BOMComponent,Item."No.",BOMComponent.Type::Item);
        ShowAssemblyListFromAssemblyLine(AssemblyBOM,AssemblyHeader."No.",BOMComponent."No.");

        // Verify.
        AssemblyBOM."No.".ASSERTEQUALS('');
      END;

      IF AssemblyListForResource THEN BEGIN
        // Exercise.
        FindBOMComponent(BOMComponent,Item."No.",BOMComponent.Type::Resource);
        FindAssemblyOrderLine(AssemblyLine,AssemblyHeader."No.",BOMComponent."No.");
        ASSERTERROR AssemblyLine.ShowAssemblyList;

        // Verify.
        Assert.ExpectedError(TypeMustBeEqualToItemError);
      END;
    END;

    [Test]
    PROCEDURE ErrorOnCreatingAssemblyOrderWithBlankNoSeries@12();
    VAR
      AssemblyOrder@1002 : TestPage 900;
    BEGIN
      // Setup: Update blank Assembly Order Nos. on Assembly Setup. Create Assembly Order by page.
      Initialize;
      UpdateAssemblyOrderNosOnAssemblySetup('');
      AssemblyOrder.OPENNEW;

      // Exercise.
      ASSERTERROR AssemblyOrder."No.".ASSISTEDIT;

      // Verify.
      Assert.ExpectedError(AssemblyOrderNosError);
    END;

    [Test]
    PROCEDURE AssemblyOrderByPage@10();
    VAR
      AssemblyOrder@1002 : TestPage 900;
      AssemblyOrderNo@1003 : Code[20];
    BEGIN
      // Setup: Get Next No. from Assembly Order No. Series. Create Assembly Order by page.
      Initialize;
      AssemblyOrderNo := GetNextNoFromAssemblyOrderNoSeries;
      AssemblyOrder.OPENNEW;

      // Exercise.
      AssemblyOrder."Item No.".ACTIVATE;

      // Verify.
      AssemblyOrder."No.".ASSERTEQUALS(AssemblyOrderNo);
    END;

    [Test]
    [HandlerFunctions(PostedSalesDocumentLinesPageHandler)]
    PROCEDURE PostSalesReturnOrderForAssemblyItem@33();
    BEGIN
      // Setup.
      Initialize;
      PostAssemblyOrderAfterPostSalesReturnOrder(FALSE);
    END;

    [Test]
    [HandlerFunctions(PostedSalesDocumentLinesPageHandler)]
    PROCEDURE ErrorOnPostingAssemblyOrderAfterPostSalesReturnOrder@35();
    BEGIN
      // Setup.
      Initialize;
      PostAssemblyOrderAfterPostSalesReturnOrder(TRUE);  // Assembly Order as TRUE.
    END;

    LOCAL PROCEDURE PostAssemblyOrderAfterPostSalesReturnOrder@16(AssemblyOrder@1008 : Boolean);
    VAR
      AssemblyHeader@1004 : Record 900;
      BOMComponent@1007 : Record 90;
      Item@1000 : Record 27;
      SalesHeader@1001 : Record 36;
      SalesLine@1002 : Record 37;
      GeneralPostingSetup@1005 : Record 252;
    BEGIN
      // Create and post Sales Order for Assembly Item. Create Sales Return Order using Get Posted Doc Lines to Reverse.
      CreateAssemblyItem(Item);
      CreateAndPostSalesOrder(SalesLine,WORKDATE,Item."No.",LibraryRandom.RandDec(10,2),FALSE);
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::"Return Order",SalesLine."Sell-to Customer No.");
      SalesHeader.GetPstdDocLinesToRevere;
      GeneralPostingSetup.GET(SalesLine."Gen. Bus. Posting Group",SalesLine."Gen. Prod. Posting Group");
      LibraryERM.SetGeneralPostingSetupSalesAccounts(GeneralPostingSetup);
      GeneralPostingSetup.MODIFY;

      // Exercise.
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);  // Post as RECEIVE and INVOICE.

      // Verify.
      VerifySalesCreditMemoLine(SalesLine);

      IF AssemblyOrder THEN BEGIN
        // Exercise.
        LibraryAssembly.CreateAssemblyHeader(
          AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',SalesLine.Quantity,'');
        FindBOMComponent(BOMComponent,Item."No.",BOMComponent.Type::Item);

        // Verify.
        LibraryAssembly.PostAssemblyHeader(AssemblyHeader,STRSUBSTNO(ItemNotOnInventoryError,BOMComponent."No."));
      END;
    END;

    [Test]
    PROCEDURE AssemblyListFromAssemblyOrderForAssemblyItem@27();
    VAR
      AssemblyHeader@1004 : Record 900;
      BOMComponent@1002 : Record 90;
      Item@1001 : Record 27;
      Item2@1000 : Record 27;
      Item3@1003 : Record 27;
      AssemblyBOM@1011 : TestPage 36;
    BEGIN
      // Create Assembly Items and create their BOM components. Create Assembly Order.
      Initialize;
      CreateAssemblyItemsAndBOMComponentsSetup(Item,Item2,Item3);
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',LibraryRandom.RandDec(10,2),'');

      // Exercise.
      ShowAssemblyListFromAssemblyLine(AssemblyBOM,AssemblyHeader."No.",Item2."No.");
      BOMComponent.SETRANGE("No.",Item3."No.");
      FindBOMComponent(BOMComponent,Item2."No.",BOMComponent.Type::Item);

      // Verify.
      VerifyAssemblyBOM(AssemblyBOM,BOMComponent);
    END;

    [Test]
    PROCEDURE ComponentItemDetailsOfAssemblyItem@30();
    VAR
      Item@1000 : Record 27;
      ComponentItem@1004 : Record 27;
      AssemblyBOM@1001 : TestPage 36;
    BEGIN
      // Setup: Create Assembly Item. Find BOM Component.
      Initialize;
      CreateAssemblyItem(Item);
      GetItemFromBOMComponent(ComponentItem,Item."No.");

      // Exercise.
      OpenAssemblyBOMFromItemCard(AssemblyBOM,Item."No.");

      // Verify.
      AssemblyBOM.FILTER.SETFILTER("No.",ComponentItem."No.");
      VerifyComponentDetailsOnAssemblyBOM(
        AssemblyBOM,ComponentItem."No.",FORMAT(ComponentItem."Unit Price",0,'<Precision,2><Standard Format,0>'),
        FORMAT(ComponentItem."Unit Cost",0,'<Precision,2><Standard Format,0>'),'','','');  // Value required for test. FORMAT required for test page verification.
    END;

    [Test]
    PROCEDURE ComponentResourceDetailsOfAssemblyItem@43();
    VAR
      Item@1000 : Record 27;
      Resource@1004 : Record 156;
      AssemblyBOM@1001 : TestPage 36;
    BEGIN
      // Setup: Create Assembly Item. Find BOM Component.
      Initialize;
      CreateAssemblyItem(Item);
      GetResourceFromBOMComponent(Resource,Item."No.");

      // Exercise.
      OpenAssemblyBOMFromItemCard(AssemblyBOM,Item."No.");

      // Verify.
      AssemblyBOM.FILTER.SETFILTER("No.",Resource."No.");
      VerifyComponentDetailsOnAssemblyBOM(
        AssemblyBOM,'','','',Resource."No.",FORMAT(Resource.Type),FORMAT(Resource."Unit Cost",0,'<Precision,2><Standard Format,0>'));  // Value required for test. FORMAT required for test page verification.
    END;

    [Test]
    PROCEDURE PostAssemblyOrderUsingDimensionAndMultipleUOM@58();
    BEGIN
      // Setup.
      Initialize;
      PostAsmOrderWithDimAndMultipleUOM(FALSE);  // Use False for AssemblyOrderError.
    END;

    [Test]
    PROCEDURE ErrorOnCreatingAsmOrderWithPstdAsmOrderNoUsingDim@57();
    BEGIN
      // Setup.
      Initialize;
      PostAsmOrderWithDimAndMultipleUOM(TRUE);  // Use True for AssemblyOrderError.
    END;

    LOCAL PROCEDURE PostAsmOrderWithDimAndMultipleUOM@55(AssemblyOrderError@1006 : Boolean);
    VAR
      AssemblyHeader@1005 : Record 900;
      AssemblyItem@1004 : Record 27;
      ItemUnitOfMeasure@1003 : Record 5404;
      TempAssemblyLine@1002 : TEMPORARY Record 901;
      Resource@1007 : Record 156;
      Quantity@1001 : Decimal;
    BEGIN
      // Update Stock out Warning on Assembly setup. Create Assembly Item setup with Dimension. Create and post Item Journal Line.
      Quantity := CreateAssemblyItemSetupWithDimension(AssemblyItem,ItemUnitOfMeasure,Resource);
      CreateAndPostItemJournalLine(ItemUnitOfMeasure."Item No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.

      // Exercise.
      CreateAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,AssemblyItem."No.",Quantity,100,100,TRUE);  // Use 100 for full Quantity to Assemble and True for Update All Components.

      // Verify.
      LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyResEntries(TempAssemblyLine,AssemblyHeader);

      IF AssemblyOrderError THEN BEGIN
        // Exercise.
        ASSERTERROR CreateAssemblyOrder(AssemblyHeader."No.");

        // Verify.
        Assert.ExpectedError(STRSUBSTNO(OrderCanNotCreatedError,AssemblyHeader."No."));
      END;
    END;

    [Test]
    PROCEDURE ErrorOnPostingAsmOrderBeforeExplodeAsmListWithDim@54();
    BEGIN
      // Setup.
      Initialize;
      PostAsmOrderWithExplodeAsmListAndDim(FALSE);  // Use False for ExplodeAssemblyList.
    END;

    [Test]
    PROCEDURE PostAsmOrderAfterExplodeAsmListWithDimension@52();
    BEGIN
      // Setup.
      Initialize;
      PostAsmOrderWithExplodeAsmListAndDim(TRUE);  // Use True for ExplodeAssemblyList.
    END;

    LOCAL PROCEDURE PostAsmOrderWithExplodeAsmListAndDim@50(ExplodeAssemblyList@1010 : Boolean);
    VAR
      AssemblyHeader@1009 : Record 900;
      AssemblyLine@1008 : Record 901;
      AssemblyItem@1006 : Record 27;
      AssemblyComponentItem@1005 : Record 27;
      ComponentItem@1004 : Record 27;
      ItemUnitOfMeasure@1003 : Record 5404;
      TempAssemblyLine@1002 : TEMPORARY Record 901;
      Resource@1011 : Record 156;
      Quantity@1001 : Decimal;
    BEGIN
      // Update Stock out Warning on Assembly setup. Create Assembly Item Setup with Dimension. Create and post Item Journal Line. Add Assembly Component Item to Assembly List.
      Quantity := CreateAssemblyItemSetupWithDimension(AssemblyItem,ItemUnitOfMeasure,Resource);
      CreateAndPostItemJournalLine(ItemUnitOfMeasure."Item No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.
      AddAssemblyComponentItemWithDimension(AssemblyComponentItem,ComponentItem,AssemblyItem."No.",Quantity);
      CreateAndPostItemJournalLine(ComponentItem."No.",Quantity * Quantity * Quantity,'');  // Value required for Inventory.

      // Exercise.
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,AssemblyItem."No.",'',Quantity,'');

      // Verify.
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,STRSUBSTNO(ItemNotOnInventoryError,AssemblyComponentItem."No."));

      IF ExplodeAssemblyList THEN BEGIN
        // Exercise.
        FindAssemblyOrderLine(AssemblyLine,AssemblyHeader."No.",AssemblyComponentItem."No.");
        AssemblyLine.ExplodeAssemblyList;
        PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,100,TRUE);  // Use 100 for full Quantity to Assemble and True for Update All Components.

        // Verify.
        LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
        LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
        LibraryAssembly.VerifyResEntries(TempAssemblyLine,AssemblyHeader);
      END;
    END;

    [Test]
    PROCEDURE ErrorOnPostingAsmOrderAfterDeleteAsmLinesUsingDim@49();
    VAR
      AssemblyHeader@1001 : Record 900;
      AssemblyLine@1000 : Record 901;
      AssemblyItem@1002 : Record 27;
      ItemUnitOfMeasure@1005 : Record 5404;
      Resource@1003 : Record 156;
      Quantity@1007 : Decimal;
    BEGIN
      // Setup: Update Stock out Warning on Assembly setup. Create Assembly Item setup with Dimension. Create and post Item Journal Line. Create Assembly Order.
      Initialize;
      Quantity := CreateAssemblyItemSetupWithDimension(AssemblyItem,ItemUnitOfMeasure,Resource);
      CreateAndPostItemJournalLine(ItemUnitOfMeasure."Item No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,AssemblyItem."No.",'',Quantity,'');

      // Exercise.
      LibraryAssembly.DeleteAssemblyLine(AssemblyLine.Type::Item,AssemblyHeader."No.");
      LibraryAssembly.DeleteAssemblyLine(AssemblyLine.Type::Resource,AssemblyHeader."No.");

      // Verify.
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,STRSUBSTNO(NothingToPostError));
    END;

    [Test]
    PROCEDURE CalculateStandardCostWithSalesDiscount@48();
    BEGIN
      // Setup.
      Initialize;
      CalcStandardCostAndUnitPriceWithSalesPriceAndDisc(FALSE,FALSE);  // Use False for WithSalesPrice and CalculateUnitPrice.
    END;

    [Test]
    PROCEDURE CalculateUnitPriceWithSalesDiscount@47();
    BEGIN
      // Setup.
      Initialize;
      CalcStandardCostAndUnitPriceWithSalesPriceAndDisc(FALSE,TRUE);  // Use False for WithSalesPrice and  True for CalculateUnitPrice.
    END;

    [Test]
    PROCEDURE CalculateStandardCostWithSalesPrice@44();
    BEGIN
      // Setup.
      Initialize;
      CalcStandardCostAndUnitPriceWithSalesPriceAndDisc(TRUE,FALSE);  // Use True for WithSalesPrice and  False for CalculateUnitPrice.
    END;

    [Test]
    PROCEDURE CalculateUnitPriceWithSalesPrice@40();
    BEGIN
      // Setup.
      Initialize;
      CalcStandardCostAndUnitPriceWithSalesPriceAndDisc(TRUE,TRUE);  // Use True for WithSalesPrice and CalculateUnitPrice.
    END;

    LOCAL PROCEDURE CalcStandardCostAndUnitPriceWithSalesPriceAndDisc@38(WithSalesPrice@1012 : Boolean;CalculateUnitPrice@1011 : Boolean);
    VAR
      Item@1009 : Record 27;
      AssemblyBOM@1005 : TestPage 36;
      MaterialCost@1003 : Decimal;
      CapacityCost@1002 : Decimal;
      CapacityOverhead@1001 : Decimal;
    BEGIN
      // Setup Assembly Item. Add  Item to Assembly BOM.
      CreateAssemblyItem(Item);
      AddItemToAssemblyBOM(Item,WithSalesPrice);

      // Exercise.
      CalculateStandardCostOnAssemblyBOM(AssemblyBOM,Item."No.");

      // Verify.
      Assert.AreNearlyEqual(
        LibraryAssembly.CalcExpectedStandardCost(MaterialCost,CapacityCost,CapacityOverhead,Item."No."),
        AssemblyBOM."Assembly Item - Details"."Standard Cost".ASDECIMAL,LibraryERM.GetAmountRoundingPrecision,AmountMustBeSame);

      IF CalculateUnitPrice THEN BEGIN
        // Exercise.
        AssemblyBOM.CalcUnitPrice.INVOKE;

        // Verify.
        Assert.AreNearlyEqual(
          LibraryAssembly.CalcExpectedPrice(Item."No."),AssemblyBOM."Assembly Item - Details"."Unit Price".ASDECIMAL,
          LibraryERM.GetAmountRoundingPrecision,AmountMustBeSame);
      END;
    END;

    [Test]
    PROCEDURE PostPartialAsmOrderUsingDimensionAndMultipleUOM@68();
    VAR
      AssemblyItem@1000 : Record 27;
      ItemUnitOfMeasure@1001 : Record 5404;
      AssemblyHeader@1003 : Record 900;
      TempAssemblyLine@1004 : TEMPORARY Record 901;
      Resource@1006 : Record 156;
      Quantity@1002 : Decimal;
    BEGIN
      // Setup: Create Assembly Item setup with Dimension. Create and post Item Journal Line.
      Initialize;
      Quantity := CreateAssemblyItemSetupWithDimension(AssemblyItem,ItemUnitOfMeasure,Resource);
      CreateAndPostItemJournalLine(ItemUnitOfMeasure."Item No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.

      // Exercise.
      CreateAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,AssemblyItem."No.",Quantity,50,0,FALSE);  // Use 50 for Partial Quantity to Assemble, 0 for Quantity to Consume.

      // Verify.
      LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyResEntries(TempAssemblyLine,AssemblyHeader);
    END;

    [Test]
    PROCEDURE PostPartialAssemblyOrderUsingDifferentPostingDate@70();
    VAR
      AssemblyItem@1002 : Record 27;
      ItemUnitOfMeasure@1003 : Record 5404;
      AssemblyHeader@1004 : Record 900;
      TempAssemblyLine@1005 : TEMPORARY Record 901;
      Resource@1007 : Record 156;
      Quantity@1001 : Decimal;
    BEGIN
      // Setup: Create Assembly Item setup with Dimension. Create and post Item Journal Line. Create and Post Assembly Order. Modify Posting Date on Assembly Header.
      Initialize;
      Quantity := CreateAssemblyItemSetupWithDimension(AssemblyItem,ItemUnitOfMeasure,Resource);
      CreateAndPostItemJournalLine(ItemUnitOfMeasure."Item No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.
      CreateAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,AssemblyItem."No.",Quantity,60,60,FALSE);  // Use 60 for Partial Quantity to Assemble and Quantity to Consume.
      UpdatePostingDateOnAssemblyHeader(AssemblyHeader,TempAssemblyLine);

      // Exercise.
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify.
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyResEntries(TempAssemblyLine,AssemblyHeader);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE UpdateUnitCostAfterPartialPosting@73();
    VAR
      AssemblyItem@1002 : Record 27;
      ItemUnitOfMeasure@1003 : Record 5404;
      AssemblyHeader@1004 : Record 900;
      TempAssemblyLine@1005 : TEMPORARY Record 901;
      Resource@1008 : Record 156;
      Quantity@1001 : Decimal;
    BEGIN
      // Setup: Create Assembly Item setup with Dimension. Create and post Item Journal Line. Create and Post Assembly Order. Refresh Assembly Order.
      Initialize;
      Quantity := CreateAssemblyItemSetupWithDimension(AssemblyItem,ItemUnitOfMeasure,Resource);
      UpdateAverageCostingMethodOnAssemblyItem(AssemblyItem);
      CreateAndPostItemJournalLine(ItemUnitOfMeasure."Item No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.
      CreateAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,AssemblyItem."No.",Quantity,60,60,FALSE);  // Use 60 for Partial Quantity to Assemble and Quantity to Consume.
      RefreshAssemblyOrder(AssemblyHeader);

      // Exercise.
      AssemblyHeader.UpdateUnitCost;

      // Verify.
      VerifyStatisticsPage(AssemblyHeader,ItemUnitOfMeasure."Item No.",Resource."No.");
    END;

    [Test]
    PROCEDURE PostPartialAsmOrderWithFixedResourceUsageType@74();
    BEGIN
      // Setup.
      Initialize;
      PostPartialAsmOrderAfterDeletingComponentItemLine(TRUE);  // Update Resource as TRUE.
    END;

    [Test]
    PROCEDURE PostPartialAsmOrderWithoutFixedResourceUsageType@75();
    BEGIN
      // Setup.
      Initialize;
      PostPartialAsmOrderAfterDeletingComponentItemLine(FALSE);  // Update Resource as FALSE.
    END;

    LOCAL PROCEDURE PostPartialAsmOrderAfterDeletingComponentItemLine@126(UpdateResource@1006 : Boolean);
    VAR
      AssemblyItem@1005 : Record 27;
      ItemUnitOfMeasure@1004 : Record 5404;
      Resource@1003 : Record 156;
      AssemblyHeader@1002 : Record 900;
      TempAssemblyLine@1001 : TEMPORARY Record 901;
      Quantity@1000 : Decimal;
    BEGIN
      // create Assembly Item setup with Dimension. Create and post Item Journal Line. Delete Assembly Item Line. Update Fixed Resource Usage Type on Resource.
      Quantity := CreateAssemblyItemSetupWithDimension(AssemblyItem,ItemUnitOfMeasure,Resource);
      CreateAndPostItemJournalLine(ItemUnitOfMeasure."Item No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.
      DeleteAssemblyLine(AssemblyHeader,AssemblyItem."No.",Quantity);
      IF UpdateResource THEN
        UpdateFixedResourceUsageTypeOnAssemblyLine(AssemblyHeader."No.",Resource."No.");

      // Exercise.
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,60,60,FALSE);  // Use 60 for Partial Quantity to Assemble and Quantity to Consume.

      // Verify.
      LibraryAssembly.VerifyResEntries(TempAssemblyLine,AssemblyHeader);
      LibraryAssembly.VerifyCapEntries(TempAssemblyLine,AssemblyHeader);
    END;

    [Test]
    PROCEDURE PostAssemblyOrderUsingComponentItemVariant@80();
    VAR
      ItemVariant@1001 : Record 5401;
      AssemblyItem@1002 : Record 27;
      AssemblyHeader@1006 : Record 900;
      TempAssemblyLine@1008 : TEMPORARY Record 901;
      ItemUnitOfMeasure@1009 : Record 5404;
      Quantity@1000 : Decimal;
    BEGIN
      // Setup: Create Assembly Item Setup with Variant. Create and Post Item Journal Line.
      Initialize;
      Quantity := CreateAssemblyItemSetupWithVariant(AssemblyItem,ItemUnitOfMeasure,ItemVariant);
      CreateAndPostItemJournalLine(
        ItemUnitOfMeasure."Item No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",ItemVariant.Code);  // Value required for Inventory using different Unit of Measure Conversion.

      // Exercise.
      CreateAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,AssemblyItem."No.",Quantity,100,100,TRUE);  // Use 100 for full Quantity to Assemble and True for Update All Components.

      // Verify.
      LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyResEntries(TempAssemblyLine,AssemblyHeader);
    END;

    [Test]
    PROCEDURE AssemblyItemDetailsOfAssemblyItem@97();
    VAR
      Item@1000 : Record 27;
      AssemblyBOM@1001 : TestPage 36;
    BEGIN
      // Setup: Create Assembly Item.
      Initialize;
      CreateAssemblyItem(Item);

      // Exercise.
      CalculateStandardCostOnAssemblyBOM(AssemblyBOM,Item."No.");
      AssemblyBOM.CalcUnitPrice.INVOKE;
      Item.FIND;

      // Verify.
      Assert.AreNearlyEqual(
        Item."Standard Cost",AssemblyBOM."Assembly Item - Details"."Standard Cost".ASDECIMAL,LibraryERM.GetAmountRoundingPrecision,
        AmountMustBeSame);
      Assert.AreNearlyEqual(
        Item."Unit Price",AssemblyBOM."Assembly Item - Details"."Unit Price".ASDECIMAL,LibraryERM.GetAmountRoundingPrecision,
        AmountMustBeSame);
    END;

    [Test]
    PROCEDURE AssemblyOrderWithAssemblyItemVariant@96();
    BEGIN
      // Setup.
      Initialize;
      AssemblyOrderWithVariant(FALSE,FALSE);
    END;

    [Test]
    PROCEDURE AssemblyOrderWithComponentItemVariant@95();
    BEGIN
      // Setup.
      Initialize;
      AssemblyOrderWithVariant(TRUE,FALSE);  // ComponentItemVariant as TRUE.
    END;

    [Test]
    PROCEDURE AssemblyOrderWithResourceVariantError@94();
    BEGIN
      // Setup.
      Initialize;
      AssemblyOrderWithVariant(TRUE,TRUE);  // ComponentItemVariant and ResourceVariant as TRUE.
    END;

    LOCAL PROCEDURE AssemblyOrderWithVariant@93(ComponentItemVariant@1006 : Boolean;ResourceVariant@1007 : Boolean);
    VAR
      AssemblyHeader@1001 : Record 900;
      AssemblyLine@1003 : Record 901;
      BOMComponent@1004 : Record 90;
      ComponentItem@1005 : Record 27;
      Item@1000 : Record 27;
      ItemVariant@1002 : Record 5401;
    BEGIN
      // Create Assembly Item. Create Assembly Order. Create Item Variant.
      CreateAssemblyItem(Item);
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',LibraryRandom.RandDec(10,2),'');
      LibraryInventory.CreateVariant(ItemVariant,Item);

      // Exercise.
      UpdateVariantOnAssemblyHeader(AssemblyHeader,ItemVariant.Code);

      // Verify.
      AssemblyHeader.TESTFIELD("Variant Code",ItemVariant.Code);

      IF ComponentItemVariant THEN BEGIN
        // Exercise.
        GetItemFromBOMComponent(ComponentItem,Item."No.");
        FindAssemblyOrderLine(AssemblyLine,AssemblyHeader."No.",ComponentItem."No.");
        LibraryInventory.CreateVariant(ItemVariant,ComponentItem);
        UpdateVariantOnAssemblyLine(AssemblyLine,ItemVariant.Code);

        // Verify.
        AssemblyLine.TESTFIELD("Variant Code",ItemVariant.Code);
      END;

      IF ResourceVariant THEN BEGIN
        // Exercise.
        FindBOMComponent(BOMComponent,Item."No.",BOMComponent.Type::Resource);
        FindAssemblyOrderLine(AssemblyLine,AssemblyHeader."No.",BOMComponent."No.");
        ASSERTERROR AssemblyLine.VALIDATE("Variant Code",ItemVariant.Code);

        // Verify.
        Assert.ExpectedError(TypeMustBeEqualToItemError);
      END;
    END;

    [Test]
    PROCEDURE AssemblyItemDetailsOfAssemblyOrder@91();
    VAR
      Item@1006 : Record 27;
      AssemblyHeader@1005 : Record 900;
      AssemblyBOM@1002 : TestPage 36;
    BEGIN
      // Setup: Create Assembly Item. Calculate Standard Cost and Unit Price on Assembly BOM page.
      Initialize;
      CreateAssemblyItem(Item);
      CalculateStandardCostOnAssemblyBOM(AssemblyBOM,Item."No.");
      AssemblyBOM.CalcUnitPrice.INVOKE;

      // Exercise.
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',LibraryRandom.RandDec(10,2),'');
      Item.FIND;

      // Verify.
      VerifyAssemblyItemDetailsOnAssemblyOrder(Item,AssemblyHeader."No.");
    END;

    [Test]
    PROCEDURE ComponentItemDetailsOfAssemblyOrder@90();
    VAR
      ComponentItem@1007 : Record 27;
      Item@1006 : Record 27;
      AssemblyHeader@1005 : Record 900;
    BEGIN
      // Setup: Create Assembly Item. Create Assembly Order.
      Initialize;
      CreateAssemblyItem(Item);
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',LibraryRandom.RandDec(10,2),'');

      // Exercise.
      GetItemFromBOMComponent(ComponentItem,Item."No.");

      // Verify.
      VerifyComponentItemDetailsOnAssemblyOrder(ComponentItem,AssemblyHeader."No.");
    END;

    [Test]
    PROCEDURE ComponentResourceDetailsOfAssemblyOrder@88();
    VAR
      Item@1006 : Record 27;
      AssemblyHeader@1005 : Record 900;
      Resource@1003 : Record 156;
    BEGIN
      // Setup: Create Assembly Item. Create Assembly Order.
      Initialize;
      CreateAssemblyItem(Item);
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',LibraryRandom.RandDec(10,2),'');

      // Exercise.
      GetResourceFromBOMComponent(Resource,Item."No.");

      // Verify.
      VerifyComponentResourceDetailsOnAssemblyOrder(Resource,AssemblyHeader."No.");
    END;

    [Test]
    PROCEDURE AssemblyListFromAssemblyOrder@87();
    VAR
      Item@1001 : Record 27;
      AssemblyHeader@1000 : Record 900;
      AssemblyBOM@1002 : TestPage 36;
    BEGIN
      // Setup: Create Assembly Item. Create Assembly Order.
      Initialize;
      CreateAssemblyItem(Item);
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',LibraryRandom.RandDec(10,2),'');

      // Exercise.
      AssemblyBOM.TRAP;
      AssemblyHeader.ShowAssemblyList;

      // Verify.
      VerifyBOMComponentsOnAssemblyBOM(AssemblyBOM,Item."No.");
    END;

    [Test]
    PROCEDURE AssemblyOrderWithQuantityToAssembleAndDimensions@86();
    BEGIN
      // Setup.
      Initialize;
      AssemblyOrderWithDimensions(FALSE);
    END;

    [Test]
    PROCEDURE DeleteAssemblyOrderAfterPartialPostWithDimensions@85();
    BEGIN
      // Setup.
      Initialize;
      AssemblyOrderWithDimensions(TRUE);  // DeleteAssemblyOrder as TRUE.
    END;

    LOCAL PROCEDURE AssemblyOrderWithDimensions@84(DeleteAssemblyOrder@1006 : Boolean);
    VAR
      Item@1001 : Record 27;
      ItemUnitOfMeasure@1005 : Record 5404;
      AssemblyHeader@1000 : Record 900;
      Resource@1002 : Record 156;
    BEGIN
      // Create Assembly Item with Dimensions. Create Assembly Order.
      CreateAssemblyItemSetupWithDimension(Item,ItemUnitOfMeasure,Resource);
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',LibraryRandom.RandInt(10),'');

      // Exercise.
      UpdateQuantityToAssembleOnAssemblyOrder(AssemblyHeader,AssemblyHeader.Quantity / 2);  // Partial Value required for the test.

      // Verify.
      VerifyQuantityToConsumeOnAssemblyLine(Item."No.",AssemblyHeader."Quantity to Assemble");

      IF DeleteAssemblyOrder THEN BEGIN
        // Exercise: Add Components Inventory and Post the Assembly Order. Delete the Assembly Order.
        LibraryAssembly.AddCompInventory(AssemblyHeader,WORKDATE,10 + LibraryRandom.RandDec(10,2));  // Greater value required for the Component Inventory.
        LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
        AssemblyHeader.FIND;
        AssemblyHeader.DELETE(TRUE);
        ASSERTERROR AssemblyHeader.FIND;

        // Verify.
        Assert.ExpectedError(AssemblyHeaderDoesNotExistError);
      END;
    END;

    [Test]
    [HandlerFunctions(ItemSubstitutionEntriesPageHandler)]
    PROCEDURE ItemSubstitutionOnAssemblyOrderWithDimension@112();
    BEGIN
      // Setup.
      Initialize;
      PostAssemblyOrderWithItemSubstitutionAndDimension(FALSE);
    END;

    [Test]
    [HandlerFunctions(ItemSubstitutionEntriesPageHandler)]
    PROCEDURE PostAssemblyOrderWithDimensionAndItemSubstitution@134();
    BEGIN
      // Setup.
      Initialize;
      PostAssemblyOrderWithItemSubstitutionAndDimension(TRUE);  // Use True for PostAssemblyOrder.
    END;

    LOCAL PROCEDURE PostAssemblyOrderWithItemSubstitutionAndDimension@124(PostAssemblyOrder@1006 : Boolean);
    VAR
      AssemblyHeader@1009 : Record 900;
      AssemblyLine@1008 : Record 901;
      AssemblyItem@1007 : Record 27;
      ItemSubstitution@1005 : Record 5715;
      ItemUnitOfMeasure@1004 : Record 5404;
      Resource@1003 : Record 156;
      TempAssemblyLine@1002 : TEMPORARY Record 901;
      Quantity@1000 : Decimal;
    BEGIN
      // Create Assembly Item setup with Dimension. Create Item Substitution. Create and post Item Journal Line. Create Assembly Order.
      Quantity := CreateAssemblyItemSetupWithDimension(AssemblyItem,ItemUnitOfMeasure,Resource);
      LibraryAssembly.CreateItemSubstitution(ItemSubstitution,ItemUnitOfMeasure."Item No.");
      CreateAndPostItemJournalLine(
        ItemSubstitution."Substitute No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,AssemblyItem."No.",'',Quantity,'');

      // Exercise.
      SelectItemSubstitutionOnAssemblyOrder(AssemblyHeader."No.");

      // Verify.
      FindAssemblyOrderLine(AssemblyLine,AssemblyHeader."No.",ItemSubstitution."Substitute No.");
      AssemblyLine.TESTFIELD(Quantity,Quantity * Quantity);  // Value required for Inventory on Assembly Line.

      IF PostAssemblyOrder THEN BEGIN
        // Exercise.
        PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,100,TRUE);  // Use 100 for full Quantity to Assemble and True for Update All Components.

        // Verify.
        LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
        LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
        LibraryAssembly.VerifyResEntries(TempAssemblyLine,AssemblyHeader);
      END;
    END;

    [Test]
    PROCEDURE ReleasedProdOrderAfterlPostedAsmOrderWithDim@111();
    BEGIN
      // Setup.
      Initialize;
      NavigateFinishedProdOrderWithPostedAsmOrderAndDim(FALSE);
    END;

    [Test]
    [HandlerFunctions(ProductionJournalPageHandler,MessageHandler,ConfirmHandler)]
    PROCEDURE NavigateFnshdProdOrderAfterPostedAsmOrderWithDim@148();
    BEGIN
      // Setup.
      Initialize;
      NavigateFinishedProdOrderWithPostedAsmOrderAndDim(TRUE);  // Use True for NavigateOrder.
    END;

    LOCAL PROCEDURE NavigateFinishedProdOrderWithPostedAsmOrderAndDim@139(NavigateOrder@1014 : Boolean);
    VAR
      AssemblyHeader@1013 : Record 900;
      AssemblyItem@1012 : Record 27;
      CapacityLedgerEntry@1011 : Record 5832;
      ItemLedgerEntry@1009 : Record 32;
      ItemUnitOfMeasure@1008 : Record 5404;
      ProductionOrder@1007 : Record 5405;
      Resource@1006 : Record 156;
      TempAssemblyLine@1005 : TEMPORARY Record 901;
      ValueEntry@1004 : Record 5802;
      Navigate@1003 : TestPage 344;
      Quantity@1001 : Decimal;
      ProductionOrderLineNo@1000 : Integer;
    BEGIN
      // Create Assembly Item setup with Dimension. Create and post Item Journal Line.
      Quantity := CreateAssemblyItemSetupWithDimension(AssemblyItem,ItemUnitOfMeasure,Resource);
      CreateAndPostItemJournalLine(ItemUnitOfMeasure."Item No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.
      CreateAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,AssemblyItem."No.",Quantity,100,100,TRUE);  // Use 100 for full Quantity to Assemble and True for Update All Components.

      // Exercise.
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,AssemblyHeader."No.");

      // Verify.
      ProductionOrderLineNo := VerifyReleasedProductionOrderLine(ProductionOrder);

      IF NavigateOrder THEN BEGIN
        // Exercise.
        LibraryManufacturing.OpenProductionJournal(ProductionOrder,ProductionOrderLineNo);
        LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");
        NavigateFinishedProductionOrder(Navigate,ProductionOrder."No.");

        // Verify.
        VerifyNoOfRecordsAfterNavigate(Navigate,ProductionOrder.TABLECAPTION);
        VerifyNoOfRecordsAfterNavigate(Navigate,ItemLedgerEntry.TABLECAPTION);
        VerifyNoOfRecordsAfterNavigate(Navigate,ValueEntry.TABLECAPTION);
        VerifyNoOfRecordsAfterNavigate(Navigate,CapacityLedgerEntry.TABLECAPTION);
      END;
    END;

    [Test]
    PROCEDURE PostAssemblyOrderWithDimAndSameComponentItemTwice@89();
    VAR
      AssemblyHeader@1004 : Record 900;
      AssemblyItem@1002 : Record 27;
      BOMComponent@1006 : Record 90;
      ItemUnitOfMeasure@1003 : Record 5404;
      Resource@1007 : Record 156;
      TempAssemblyLine@1005 : TEMPORARY Record 901;
      Quantity@1001 : Decimal;
    BEGIN
      // Setup: Create Assembly Item setup with Dimension and same Component Item Twice. Create and post Item Journal Line.
      Initialize;
      Quantity := CreateAssemblyItemSetupWithDimension(AssemblyItem,ItemUnitOfMeasure,Resource);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,ItemUnitOfMeasure."Item No.",AssemblyItem."No.",'',BOMComponent."Resource Usage Type",
        Quantity,FALSE);
      CreateAndPostItemJournalLine(
        ItemUnitOfMeasure."Item No.",2 * Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.

      // Exercise.
      CreateAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,AssemblyItem."No.",Quantity,100,100,TRUE);  // Use 100 for full Quantity to Assemble and True for Update All Components.

      // Verify.
      LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyResEntries(TempAssemblyLine,AssemblyHeader);
    END;

    [Test]
    PROCEDURE PostAsmOrderAfterCalcStdCostAndUnitPriceOnAsmBOM@132();
    VAR
      AssemblyItem@1000 : Record 27;
      ItemUnitOfMeasure@1002 : Record 5404;
      AssemblyHeader@1003 : Record 900;
      TempAssemblyLine@1004 : TEMPORARY Record 901;
      Resource@1008 : Record 156;
      AssemblyBOM@1005 : TestPage 36;
      Quantity@1001 : Decimal;
    BEGIN
      // Setup: Create Assembly Item Setup. Calculate Standard Cost and Unit Price on Assembly BOM. Create and Post Item Journal Line. Create Assembly Order and Delete Assembly Item Line.
      Initialize;
      Quantity :=
        CreateAssemblyItemSetup(
          AssemblyItem,ItemUnitOfMeasure,Resource,AssemblyItem."Costing Method"::Standard,AssemblyItem."Costing Method"::Standard);
      CalculateStandardCostOnAssemblyBOM(AssemblyBOM,AssemblyItem."No.");
      AssemblyBOM.CalcUnitPrice.INVOKE;
      CreateAndPostItemJournalLine(ItemUnitOfMeasure."Item No.",Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",'');  // Value required for Inventory using different Unit of Measure Conversion.
      DeleteAssemblyLine(AssemblyHeader,AssemblyItem."No.",Quantity);

      // Exercise.
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,100,TRUE);  // Use 100 for full Quantity to Assemble and True for Update All Components.

      // Verify.
      VerifyPostedAssemblyOrderStatistics(AssemblyHeader."No.",AssemblyItem."No.",Resource."No.");
    END;

    [Test]
    PROCEDURE PostPartialAsmOrderAfterAdjustCostItemEntries@135();
    VAR
      InventorySetup@1002 : Record 313;
      AssemblyHeader@1004 : Record 900;
      AssemblyItem@1001 : Record 27;
      TempAssemblyLine@1007 : TEMPORARY Record 901;
    BEGIN
      // Setup: Update Automatic Cost Posting and Automatic Cost Adjustment on Inventory Setup. Create Initial Setup for Posting Assembly Order with Multiple Component Items. Run Adjust Cost Item Entries Report.
      Initialize;
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(FALSE,InventorySetup."Automatic Cost Adjustment"::Never);
      LibraryERM.SetUseLegacyGLEntryLocking(FALSE);
      CreateInitialSetupForPostAsmOrdWithMultipleItems(AssemblyHeader,AssemblyItem);
      LibraryCosting.AdjustCostItemEntries(AssemblyItem."No.",'');
      LibraryVariableStorage.Enqueue(AutomaticCostPostingMessage);  // Enqueue for MessageHandler.
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(TRUE,InventorySetup."Automatic Cost Adjustment"::Never);  // Automatic Cost Posting as TRUE.
      DeleteAssemblyCommentLine(AssemblyHeader."Document Type",AssemblyHeader."No.");

      // Exercise.
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,70,FALSE);  // Use 100 for full Quantity to Assemble and 70 for Quantity to Consume.

      // Verify.
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
      LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Quantity to Assemble");
    END;

    [Test]
    PROCEDURE PostInvtCostToGLAfterPostAsmOrdWithManualAutoPost@131();
    VAR
      InventorySetup@1001 : Record 313;
      AssemblyHeader@1003 : Record 900;
      AssemblyItem@1002 : Record 27;
      TempAssemblyLine@1008 : TEMPORARY Record 901;
    BEGIN
      // Setup: Update Automatic Cost Posting and Automatic Cost Adjustment on Inventory Setup. Create Initial Setup for Posting Assembly Order with Multiple Component Items. Run Adjust Cost Item Entries Report. Post Assembly Order.
      Initialize;
      LibraryVariableStorage.Enqueue(AutomaticCostPostingMessage);  // Enqueue for MessageHandler.
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(TRUE,InventorySetup."Automatic Cost Adjustment"::Never);  // Automatic Cost Posting as TRUE.
      CreateInitialSetupForPostAsmOrdWithMultipleItems(AssemblyHeader,AssemblyItem);
      LibraryCosting.AdjustCostItemEntries(AssemblyItem."No.",'');
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(FALSE,InventorySetup."Automatic Cost Adjustment"::Never);
      LibraryERM.SetUseLegacyGLEntryLocking(FALSE);
      DeleteAssemblyCommentLine(AssemblyHeader."Document Type",AssemblyHeader."No.");
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,70,FALSE);  // Use 100 for full Quantity to Assemble and 70 for Quantity to Consume.

      // Exercise.
      LibraryAssembly.PostInvtCostToGL(FALSE,AssemblyItem."No.",'',STRSUBSTNO(FileName,TEMPORARYPATH + AssemblyItem."No."));

      // Verify.
      VerifyGLEntry(AssemblyItem,AssemblyHeader."No.");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE PostInvtCostToGLWithManAutoPostAndAutoCostAdjmt@129();
    VAR
      InventorySetup@1000 : Record 313;
      AssemblyHeader@1003 : Record 900;
      AssemblyItem@1002 : Record 27;
      TempAssemblyLine@1009 : TEMPORARY Record 901;
    BEGIN
      // Setup: Update Automatic Cost Posting and Automatic Cost Adjustment on Inventory Setup. Create Initial Setup for Posting Assembly Order with Multiple Component Items. Post Assembly Order.
      Initialize;
      LibraryVariableStorage.Enqueue(UnadjustedValueEntriesNotCoveredMessage);  // Enqueue for MessageHandler.
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(TRUE,InventorySetup."Automatic Cost Adjustment"::Always);  // Automatic Cost Posting as TRUE.
      CreateInitialSetupForPostAsmOrdWithMultipleItems(AssemblyHeader,AssemblyItem);
      LibraryVariableStorage.Enqueue(UnadjustedValueEntriesNotCoveredMessage);  // Enqueue for MessageHandler.
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(FALSE,InventorySetup."Automatic Cost Adjustment"::Always);
      LibraryERM.SetUseLegacyGLEntryLocking(FALSE);
      DeleteAssemblyCommentLine(AssemblyHeader."Document Type",AssemblyHeader."No.");
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,70,FALSE);  // Use 100 for full Quantity to Assemble and 70 for Quantity to Consume.

      // Exercise.
      LibraryAssembly.PostInvtCostToGL(FALSE,AssemblyItem."No.",'',STRSUBSTNO(FileName,TEMPORARYPATH + AssemblyItem."No."));

      // Verify.
      VerifyGLEntry(AssemblyItem,AssemblyHeader."No.");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE PostInvtCostToGLWithManualAutoPostAndManCostAdjmt@127();
    VAR
      InventorySetup@1000 : Record 313;
      AssemblyHeader@1002 : Record 900;
      AssemblyItem@1012 : Record 27;
      TempAssemblyLine@1005 : TEMPORARY Record 901;
    BEGIN
      // Setup: Update Automatic Cost Posting and Automatic Cost Adjustment on Inventory Setup. Create Initial Setup for Posting Assembly Order with Multiple Component Items. Post Assembly Order. Run Adjust Cost Item Entries Report.
      Initialize;
      LibraryVariableStorage.Enqueue(UnadjustedValueEntriesNotCoveredMessage);  // Enqueue for MessageHandler.
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(FALSE,InventorySetup."Automatic Cost Adjustment"::Always);
      CreateInitialSetupForPostAsmOrdWithMultipleItems(AssemblyHeader,AssemblyItem);
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(FALSE,InventorySetup."Automatic Cost Adjustment"::Never);
      DeleteAssemblyCommentLine(AssemblyHeader."Document Type",AssemblyHeader."No.");
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,70,FALSE);  // Use 100 for full Quantity to Assemble and 70 for Quantity to Consume.
      LibraryCosting.AdjustCostItemEntries(AssemblyItem."No.",'');

      // Exercise.
      LibraryAssembly.PostInvtCostToGL(FALSE,AssemblyItem."No.",'',STRSUBSTNO(FileName,TEMPORARYPATH + AssemblyItem."No."));

      // Verify.
      VerifyGLEntry(AssemblyItem,AssemblyHeader."No.");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE PostAssemblyOrderWithAutoCostPostAndAutoCostAdjmt@123();
    VAR
      InventorySetup@1012 : Record 313;
      AssemblyHeader@1001 : Record 900;
      AssemblyItem@1011 : Record 27;
      TempAssemblyLine@1002 : TEMPORARY Record 901;
    BEGIN
      // Setup: Update Automatic Cost Posting and Automatic Cost Adjustment on Inventory Setup. Create Initial Setup for Posting Assembly Order with Multiple Component Items.
      Initialize;
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(TRUE,InventorySetup."Automatic Cost Adjustment"::Never);  // Automatic Cost Posting as TRUE.
      CreateInitialSetupForPostAsmOrdWithMultipleItems(AssemblyHeader,AssemblyItem);
      LibraryVariableStorage.Enqueue(UnadjustedValueEntriesNotCoveredMessage);  // Enqueue for MessageHandler.
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(TRUE,InventorySetup."Automatic Cost Adjustment"::Always);  // Automatic Cost Posting as TRUE.
      DeleteAssemblyCommentLine(AssemblyHeader."Document Type",AssemblyHeader."No.");

      // Exercise.
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,70,FALSE);  // Use 100 for full Quantity to Assemble and 70 for Quantity to Consume.

      // Verify.
      VerifyGLEntry(AssemblyItem,AssemblyHeader."No.");
    END;

    [Test]
    PROCEDURE PostPartialAssemblyOrderWithDimensions@153();
    BEGIN
      // Setup.
      Initialize;
      PartialPostingOfAssemblyOrderWithDimensions(FALSE);
    END;

    [Test]
    PROCEDURE PostRemainingAssemblyOrderWithDimensions@152();
    BEGIN
      // Setup.
      Initialize;
      PartialPostingOfAssemblyOrderWithDimensions(TRUE);  // Post Remaining as TRUE.
    END;

    LOCAL PROCEDURE PartialPostingOfAssemblyOrderWithDimensions@151(PostRemaining@1009 : Boolean);
    VAR
      Item@1003 : Record 27;
      ItemUnitOfMeasure@1002 : Record 5404;
      AssemblyHeader@1001 : Record 900;
      TempAssemblyLine@1008 : TEMPORARY Record 901;
      Resource@1000 : Record 156;
      Quantity@1004 : Decimal;
    BEGIN
      // Create Assembly Item with Dimensions. Create Assembly Order. Add Component Inventory.
      Quantity := CreateAssemblyItemSetupWithDimension(Item,ItemUnitOfMeasure,Resource);
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',Quantity,'');
      LibraryAssembly.AddCompInventory(AssemblyHeader,WORKDATE,Quantity);

      // Exercise.
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,60,60,FALSE);  // Use 60 for Partial Quantity to Assemble and Quantity to Consume.

      // Verify.
      AssemblyHeader.FIND;
      VerifyQuantityOnAssemblyOrder(
        AssemblyHeader,(Quantity * 40) / 100,(TempAssemblyLine.Quantity * 60) / 100,
        TempAssemblyLine.Quantity - TempAssemblyLine."Quantity to Consume");  // Calculated values required for the test.

      IF PostRemaining THEN BEGIN
        // Exercise.
        DeleteAssemblyCommentLine(AssemblyHeader."Document Type",AssemblyHeader."No.");
        PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,40,FALSE);  // Use 100 for Quantity to Assemble and 40 for Quantity to Consume.

        // Verify.
        Assert.IsFalse(AssemblyHeader.FIND,AssemblyOrderMustBeDeleted);
        LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssemblyHeader."Assembled Quantity");
      END;
    END;

    [Test]
    [HandlerFunctions(ReservationPageHandler)]
    PROCEDURE ErrorOnDeletingItemAfterPostReservedSOWithDim@150();
    BEGIN
      // Setup.
      Initialize;
      DeleteItemAfterPostSalesOrderAndAsmOrderWithDim(FALSE);
    END;

    [Test]
    [HandlerFunctions(ReservationPageHandler)]
    PROCEDURE ErrorOnDeletingItemAfterCloseFiscalYearWithDim@149();
    BEGIN
      // Setup.
      Initialize;
      DeleteItemAfterPostSalesOrderAndAsmOrderWithDim(TRUE);  // Close Fiscal Year as TRUE.
    END;

    LOCAL PROCEDURE DeleteItemAfterPostSalesOrderAndAsmOrderWithDim@147(CloseYear@1012 : Boolean);
    VAR
      Item@1007 : Record 27;
      ItemUnitOfMeasure@1006 : Record 5404;
      AssemblyHeader@1005 : Record 900;
      TempAssemblyLine@1003 : TEMPORARY Record 901;
      Resource@1002 : Record 156;
      SalesLine@1011 : Record 37;
      Quantity@1001 : Decimal;
      PostingDate@1013 : Date;
    BEGIN
      // Create Inventory Period. Create Assembly Item with Dimensions. Create and Post Assembly Order. Create and Post Sales Order after reservation.
      PostingDate := CreateFiscalYearAndInventoryPeriod;
      Quantity := CreateAssemblyItemSetupWithDimension(Item,ItemUnitOfMeasure,Resource);
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,PostingDate,Item."No.",'',Quantity,'');
      LibraryAssembly.AddCompInventory(AssemblyHeader,PostingDate,Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure");  // Value required for Component Inventory.
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,100,TRUE);  // Use 100 for full Quantity to Assemble and TRUE for Update all Components.
      CreateAndPostSalesOrder(SalesLine,PostingDate,Item."No.",Quantity,TRUE);  // TRUE for Reserve.

      // Exercise.
      ASSERTERROR Item.DELETE(TRUE);

      // Verify.
      Assert.ExpectedError(STRSUBSTNO(CannotDeleteItemError,Item."No."));

      IF CloseYear THEN BEGIN
        // Exercise.
        LibraryFiscalYear.CloseAccountingPeriod;
        LibraryFiscalYear.CreateFiscalYear;  // New Fiscal Year creation is required to generate the error.
        ASSERTERROR Item.DELETE(TRUE);

        // Verify.
        Assert.ExpectedError(STRSUBSTNO(ItemEntriesNotAdjustedError,Item."No."));
      END;
    END;

    [Test]
    PROCEDURE AdjustCostItemEntriesAfterBlockOrderDimension@146();
    VAR
      BOMComponent@1011 : Record 90;
      ComponentItem@1015 : Record 27;
      Item@1010 : Record 27;
      ItemUnitOfMeasure@1009 : Record 5404;
      AssemblySetup@1012 : Record 905;
      AssemblyHeader@1007 : Record 900;
      TempAssemblyLine@1005 : TEMPORARY Record 901;
      Resource@1004 : Record 156;
      Quantity@1001 : Decimal;
      UnitCost@1016 : Decimal;
      BlockType@1014 : 'Dimension,Dimension Value,Dimension Combination,None';
    BEGIN
      // Setup: Update Copy Component Dimensions from field on Assembly Setup. Create Assembly Item with Dimensions. Create and Post Assembly Order. Block Assembly Order Dimension Combination.
      Initialize;
      UpdateCopyComponentDimensionsOnAssemblySetup(AssemblySetup."Copy Component Dimensions from"::"Order Header");
      Quantity := CreateAssemblyItemSetupWithDimension(Item,ItemUnitOfMeasure,Resource);
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',Quantity,'');
      LibraryAssembly.AddCompInventory(AssemblyHeader,WORKDATE,Quantity * Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure");  // Value required for the Component Inventory.
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,100,100,TRUE);  // Use 100 for full Quantity to Assemble and True for Update All Components.
      FindBOMComponent(BOMComponent,Item."No.",BOMComponent.Type::Item);
      ComponentItem.GET(BOMComponent."No.");
      UnitCost := ComponentItem."Unit Cost";
      LibraryAssembly.BlockOrderDimensions(AssemblyHeader,BlockType::"Dimension Combination",BlockType::None);

      // Exercise.
      LibraryCosting.AdjustCostItemEntries(BOMComponent."No.",'');

      // Verify.
      ComponentItem.TESTFIELD("Unit Cost",UnitCost);
    END;

    [Test]
    PROCEDURE PostAssemblyOrderWithResourceWithoutLocation@145();
    VAR
      Location@1000 : Record 14;
      AssemblyHeader@1001 : Record 900;
      AssemblyLine@1003 : Record 901;
      Resource@1002 : Record 156;
      PostedAssemblyHeader@1004 : Record 910;
      Item@1005 : Record 27;
    BEGIN
      // Setup: Create item, location.
      Initialize;
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      InventorySetupWithLocationMandatory(TRUE);
      LibraryAssembly.CreateResource(Resource,TRUE,'');
      LibraryInventory.CreateItem(Item);

      // Exercise: Create and Post Assembly Order.
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",
        Location.Code,LibraryRandom.RandInt(5),'');
      LibraryAssembly.CreateAssemblyLine(AssemblyHeader,AssemblyLine,AssemblyLine.Type::Resource,Resource."No.",
        LibraryAssembly.GetUnitOfMeasureCode(AssemblyLine.Type::Resource,Resource."No.",TRUE),
        LibraryRandom.RandInt(5),LibraryRandom.RandInt(5),'');
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,''); // Last parameter stands for ExpectedError.

      // Verify: Assembly Order with Resource Line without Location posted successfully.
      FindPostedAssemblyHeader(PostedAssemblyHeader,AssemblyHeader."No.",Item."No.");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE CreateAssemblyOrderFromSalesOrderWithDimension@158();
    VAR
      SalesLine@1003 : Record 37;
      DimensionValue@1006 : Record 349;
      DimensionValue2@1007 : Record 349;
      AssemblyHeader@1012 : Record 900;
    BEGIN
      // Test and verify dimensions are populated on Assembly Order header when this is created from a sales order.
      Initialize;

      // Setup: Create Assembly Item, create dimension values, create sales order with the assembly item
      CreateAsmItemAndSalesOrderWithDimSetup(SalesLine,DimensionValue,DimensionValue2);

      // Exercise: Generate an Assembly order and syncronize the dimension on Sales line to Assembly Header
      UpdateQtyToAssembleOnSalesLine(SalesLine,SalesLine.Quantity);

      // Find the Assembly Header created from the sales line
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,SalesLine."No.");

      // Verify: The dimension values have been populated on Assembly header
      VerifyDimensionOnAssemblyHeader(AssemblyHeader,DimensionValue.Code,DimensionValue2.Code);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE UpdateDimensionOnSalesLineWithAssemblyOrder@185();
    VAR
      SalesLine@1003 : Record 37;
      DimensionValue@1006 : Record 349;
      DimensionValue2@1007 : Record 349;
      AssemblyHeader@1012 : Record 900;
    BEGIN
      // Test and verify dimensions are populated on Assembly Order header when the dimensions on related sales line are updated.
      Initialize;

      // Setup: Create Assembly Item, create dimension values, create sales order with the assembly item
      CreateAsmItemAndSalesOrderWithDimSetup(SalesLine,DimensionValue,DimensionValue2);
      UpdateQtyToAssembleOnSalesLine(SalesLine,SalesLine.Quantity); // Generate an Assembly order from Sales Line

      // Create new Dimension value from Shortcut dimension codes
      CreateShortcutDimensionValue(
        DimensionValue,DimensionValue2,DimensionValue."Dimension Code",DimensionValue2."Dimension Code");

      // Exercise: Update Dimension value on Sales Line
      UpdateDimensionValueOnSalesLine(SalesLine,DimensionValue.Code,DimensionValue2.Code);

      // Find the Assembly Header created from the sales line
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,SalesLine."No.");

      // Verify: The new dimension values have been populated on Assembly header
      VerifyDimensionOnAssemblyHeader(AssemblyHeader,DimensionValue.Code,DimensionValue2.Code);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE CreateAndPostAssemblyOrderFromSalesOrderWithDimension@161();
    VAR
      SalesHeader@1000 : Record 36;
      SalesLine@1003 : Record 37;
      DimensionValue@1006 : Record 349;
      DimensionValue2@1007 : Record 349;
      AssemblyHeader@1012 : Record 900;
      ItemLedgerEntry@1010 : Record 32;
    BEGIN
      // Test and verify dimensions are populated in Item Ledger Entry of Assembly Output Type.
      Initialize;

      // Setup: Create Assembly Item, create dimension values, create sales order with the assembly item
      CreateAsmItemAndSalesOrderWithDimSetup(SalesLine,DimensionValue,DimensionValue2);

      // Generate an Assembly order and syncronize the dimension on Sales line to Assembly Header
      UpdateQtyToAssembleOnSalesLine(SalesLine,SalesLine.Quantity);

      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,SalesLine."No."); // Find the Assembly Header created from the sales line
      LibraryAssembly.AddCompInventory(AssemblyHeader,WORKDATE,LibraryRandom.RandInt(10)); // Add component inventory for assembly item

      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");

      // Exercise: Post sales order as SHIP and INVOICE.
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      FindItemLedgerEntry(ItemLedgerEntry,ItemLedgerEntry."Entry Type"::"Assembly Output",SalesLine."No.");

      // Verify: Dimension values are populated in Item Ledger Entry of Assembly Output Type
      VerifyDimensionOnILE(ItemLedgerEntry,DimensionValue.Code,DimensionValue2.Code);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE InvoiceAssemblyOrderFromSalesOrderAfterPartialInvoiced@168();
    VAR
      SalesHeader@1000 : Record 36;
      SalesLine@1003 : Record 37;
      ItemLedgerEntry@1005 : Record 32;
      ValueEntry@1006 : Record 5802;
      PartialInvoicedQty@1004 : Decimal;
    BEGIN
      Initialize;

      // Setup: Create Assembly Item, Customer and create sales order with the assembly item.
      CreateSalesOrderWithAssemblyItem(SalesLine);

      // Exercise: Post sales order as fully SHIP.
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);

      // Partial invoice the sales order.
      SalesLine.FIND;
      PartialInvoiceSalesOrder(SalesLine,SalesHeader,LibraryRandom.RandDecInDecimalRange(0,SalesLine.Quantity - 0.01,2));

      // Verify: The Invoiced Quantity in the Item Ledger Entries and Sales Invoice Line in Value Entries matche the Quantity Invoiced on the Sales Lines.
      SalesLine.FIND;
      VerifyInvoicedQtyOnItemLedgerEntry(ItemLedgerEntry."Entry Type"::Sale,SalesLine."No.",-SalesLine."Quantity Invoiced");
      FindValueEntry(ValueEntry,ValueEntry."Document Type"::"Sales Invoice",SalesLine."No.");
      VerifyQtyOnValueEntry(ValueEntry,-SalesLine."Quantity Invoiced");
      PartialInvoicedQty := SalesLine."Quantity Invoiced";

      // Exercise and Verify: Invoice others of the sales order and verify no error pops up.
      LibrarySales.PostSalesDocument(SalesHeader,FALSE,TRUE);

      // Verify: The Invoiced Quantity in the Item Ledger Entries and Sales Invoice Line in Value Entries matche the Quantity Invoiced on the Sales Lines.
      VerifyInvoicedQtyOnItemLedgerEntry(ItemLedgerEntry."Entry Type"::Sale,SalesLine."No.",-SalesLine.Quantity);
      VerifyQtyOnValueEntry(ValueEntry,-PartialInvoicedQty);
      ValueEntry.NEXT;
      VerifyQtyOnValueEntry(ValueEntry,-(SalesLine.Quantity - PartialInvoicedQty));
    END;

    [Test]
    PROCEDURE ExplodeAssemblyBOMComponentWithBaseUnitOfMeasureInAssemblyOrder@178();
    BEGIN
      // Test and verify "Explode BOM" in Assembly Order considers current "Quantity" from the line being exploded.
      Initialize;
      ExplodeAssemblyBOMComponentInAssemblyOrder(TRUE); // TRUE indicates using Base of Unit Measure Code when creating Assembly component
    END;

    [Test]
    PROCEDURE ExplodeAssemblyBOMComponentWithOtherUnitOfMeasureInAssemblyOrder@183();
    BEGIN
      // Test and verify "Explode BOM" in Assembly Order considers current "Qty. Per Unit of Measure" from the line being exploded.
      Initialize;
      ExplodeAssemblyBOMComponentInAssemblyOrder(FALSE); // FALSE indicates not using Base of Unit Measure Code when creating Assembly component
    END;

    LOCAL PROCEDURE ExplodeAssemblyBOMComponentInAssemblyOrder@163(UseBaseUnitOfMeasure@1007 : Boolean);
    VAR
      Item@1000 : Record 27;
      Item2@1001 : Record 27;
      BOMComponent@1003 : Record 90;
      AssemblyHeader@1004 : Record 900;
      AssemblyLine@1005 : Record 901;
      AssemblyLine2@1006 : Record 901;
    BEGIN
      // Setup: Create Assembly Item with an Assembly Item as Component, create Assembly Order for the parent Assembly Item
      // Update Quantity Per on the assembly line for child Assembly Item
      CreateAssemblyItemWithAssemblyItemAsComponent(Item,Item2,UseBaseUnitOfMeasure);
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,Item."No.",'',LibraryRandom.RandInt(5),'');
      FindAssemblyOrderLine(AssemblyLine,AssemblyHeader."No.",Item2."No.");
      UpdateQtyPerOnAssemblyLine(AssemblyLine,AssemblyLine."Quantity per" + LibraryRandom.RandInt(5));

      // Exercise: Explode Assembly List for the child Assembly Item
      AssemblyLine.ExplodeAssemblyList;

      // Verify: Find the first exploded Assembly Line and verify Quantity and Cost Amount on it
      FindBOMComponent(BOMComponent,Item2."No.",BOMComponent.Type::Item); // Find the 1st BOM Component for child Assembly Item
      FindAssemblyOrderLine(AssemblyLine2,AssemblyHeader."No.",BOMComponent."No.");
      VerifyQuantityAndCostAmountOnAssemblyLine(
        AssemblyLine2,BOMComponent."Quantity per" * AssemblyLine."Quantity per" * AssemblyLine."Qty. per Unit of Measure",
        AssemblyHeader.Quantity);
    END;

    [Test]
    [HandlerFunctions(CalculateStandardCostMenuHandler,ConfirmHandler)]
    PROCEDURE CalcStandardCostonOnAssemblyItem@170();
    VAR
      AssemblyItem@1000 : Record 27;
      ChildItem@1002 : Record 27;
      ParentItem@1010 : Record 27;
      ProductionBOMHeader@1001 : Record 99000771;
      ProductionBOMLine@1006 : Record 99000772;
      BOMComponent@1007 : Record 90;
      CalculateStandardCost@1008 : Codeunit 5812;
      QuantityPer@1003 : Decimal;
    BEGIN
      // Test and verify Calc. Standard Cost is working on Assembly Item when the Assembly BOM
      // contains the Item whose Production BOM contains another Production BOM.

      // Setup: Create ChildItem as component item for Production BOM.
      Initialize;
      QuantityPer := LibraryRandom.RandInt(5);

      CreateAndUpdateItem(
        ChildItem,ChildItem."Replenishment System"::Purchase,ChildItem."Costing Method"::Standard,
        LibraryRandom.RandInt(10));
      CreateAndCertifyProductionBOM(
        ProductionBOMHeader,ChildItem."Base Unit of Measure",
        ProductionBOMLine.Type::Item,ChildItem."No.",QuantityPer);

      // Create Item.
      CreateAndUpdateItem(ParentItem,ParentItem."Replenishment System"::"Prod. Order",ParentItem."Costing Method"::Standard,0);

      // Create Production BOM that contains a Production BOM. Set Production BOM No. to Item
      CreateCertifiedProductionBOMAndUpdateItem(
        ProductionBOMHeader,ParentItem."No.",ProductionBOMLine.Type::"Production BOM",ProductionBOMHeader."No.",QuantityPer);

      // Create Assembly Item and add Item to Assembly BOM.
      CreateAndUpdateItem(
        AssemblyItem,AssemblyItem."Replenishment System"::Assembly,AssemblyItem."Costing Method"::Standard,0);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,ParentItem."No.",AssemblyItem."No.",'',BOMComponent."Resource Usage Type",
        QuantityPer,TRUE); // Use Base Unit of Measure as True and Variant Code as blank.

      // Exercise: Calculate Standard Cost.
      LibraryVariableStorage.Enqueue(2); // Choose "All Level" when Calculate Standard Cost.
      LibraryVariableStorage.Enqueue(CalcStandardCostMsg);
      CalculateStandardCost.CalcItem(AssemblyItem."No.",TRUE);

      // Verify: Verify Standard Cost calculated correctly without error message.
      // There are three levels of components. Each level has Quantity per. So use third power of QuantityPer.
      VerifyStandardCostOnAssemblyItem(AssemblyItem."No.",POWER(QuantityPer,3) * ChildItem."Standard Cost");
    END;

    [Test]
    PROCEDURE PostAssemblyOrderWithDimensionAfterExplodeBOM@193();
    VAR
      AssemblyItem@1000 : Record 27;
      AssemblyItem2@1001 : Record 27;
      AssemblyHeader@1004 : Record 900;
      AssemblyLine@1003 : Record 901;
    BEGIN
      // Test and verify no error pops up when posting Assembly Order with Dimension after explode BOM.

      // Setup: Create Assembly Items and create their BOM components.
      Initialize;
      CreateTwoAssemblyItemsAndBOMComponentsSetup(AssemblyItem,AssemblyItem2);

      // Create Assembly Order and explode BOM. Add inventory for Component Item.
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,AssemblyItem2."No.",'',LibraryRandom.RandInt(5),'');

      FindAssemblyOrderLine(AssemblyLine,AssemblyHeader."No.",AssemblyItem."No.");
      AssemblyLine.ExplodeAssemblyList;
      LibraryAssembly.AddCompInventory(AssemblyHeader,WORKDATE,LibraryRandom.RandInt(5));

      // Exercise and Verify: Assembly Order can be posted.
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE PostSalesOrderForAssemblyItemWithUpdatedPostingDate@195();
    VAR
      SalesLine@1000 : Record 37;
      SalesHeader@1003 : Record 36;
      AssemblyHeader@1002 : Record 900;
      ItemLedgerEntry@1004 : Record 32;
    BEGIN
      // Test and verify the Posting Date on Assembly order will be updated when the Posting Date on the related Sales Order is updated.

      // Setup: Create Sales Order for Assembly Item and fill Qty. to Assemble to Order
      CreateSalesOrderWithAssemblyItem(SalesLine);

      // Exercise: Update Posting Date on Sales Header
      UpdatePostingDateOnSalesHeader(
        SalesHeader,SalesLine."Document Type",SalesLine."Document No.",
        CALCDATE('<-' + FORMAT(LibraryRandom.RandInt(5)) + 'D>',WORKDATE));

      // Verify: Verify the Posting Date on Assembly Order is updated accordingly
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,SalesLine."No.");
      AssemblyHeader.TESTFIELD("Posting Date",SalesHeader."Posting Date");

      // Exercise: Post Sales Document
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify: Posting Date on Assembly Output Entry equals to the Posting Date of Sales Header
      VerifyPostingDateOnItemLedgerEntry(
        ItemLedgerEntry."Entry Type"::"Assembly Output",SalesLine."No.",SalesHeader."Posting Date");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE ModifyPostingDateOnAssemblyOrder@200();
    VAR
      SalesLine@1002 : Record 37;
      SalesHeader@1001 : Record 36;
      AssemblyOrder@1000 : TestPage 900;
    BEGIN
      // Test and verify the Posting Date on Assembly Order cannot be later than the Posting Date of its related Sales Order

      // Setup: Create Sales Order for Assembly Item and fill Qty. to Assemble to Order
      Initialize;
      CreateSalesOrderWithAssemblyItem(SalesLine);
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");

      // Open the Assembly Order linked to above Sales Order
      AssemblyOrder.OPENEDIT;
      AssemblyOrder.FILTER.SETFILTER("Item No.",SalesLine."No.");

      // Exercise: Modify the Posting Date on Assembly Order to make it later than the Posting Date of Sales Header
      ASSERTERROR AssemblyOrder."Posting Date".SETVALUE(
          CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(5)) + 'D>',SalesHeader."Posting Date"));

      // Verify: Check the error message
      Assert.ExpectedError(STRSUBSTNO(PostingDateLaterErr,AssemblyOrder."No.",SalesHeader."No."));
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE UpdatePostingDateOnSalesHeaderAndCreateSalesLineForAssemblyItem@199();
    VAR
      SalesLine@1000 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Item@1001 : Record 27;
      PostingDate@1003 : Date;
    BEGIN
      // Test and verify the Posting Date on Assembly Order will be the same as the Posting Date on the related Sales Header
      // when the Posting Date on Sales Header is updated before Assembly Order is created.

      // Setup: Create Sales Order for Assembly Item and update Posting Date
      Initialize;
      CreateAssemblyItem(Item);
      PostingDate := CALCDATE('<-' + FORMAT(LibraryRandom.RandInt(5)) + 'D>',WORKDATE);
      CreateSalesOrderWithPostingDate(SalesLine,Item."No.",PostingDate);

      // Exercise: Generate an Assembly Order on Sales Line
      UpdateQtyToAssembleOnSalesLine(SalesLine,SalesLine.Quantity);

      // Verify: Verify the Posting Date on Assembly Order is same as the Posting Date on the related Sales Header
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,SalesLine."No.");
      AssemblyHeader.TESTFIELD("Posting Date",PostingDate);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE ManualCostAdjustmentOnRepostedSalesShipment@225();
    BEGIN
      CostAdjustmentOnRepostedSalesOrderWithDifferentAssemblies(FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE ManualCostAdjustmentOnRepostedSalesShipmentAndInvoice@228();
    BEGIN
      CostAdjustmentOnRepostedSalesOrderWithDifferentAssemblies(TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE AutoCostAdjustmentOnRepostedSalesShipment@241();
    BEGIN
      CostAdjustmentOnRepostedSalesOrderWithDifferentAssemblies(FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE AutoCostAdjustmentOnRepostedSalesShipmentAndInvoice@240();
    BEGIN
      CostAdjustmentOnRepostedSalesOrderWithDifferentAssemblies(TRUE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE UndoSalesShipmentLineWithAssemblyOrder@201();
    VAR
      AsmItemNo@1004 : Code[20];
      Quantity@1002 : Decimal;
      PostedDocumentNo@1000 : Code[20];
    BEGIN
      // Test and verify Sales Shipment Line with Assembly Item can be undone successfully when
      // the component Item on Assembly Order Line haven't been fully consumed.

      // Setup: General preparation for Undo Sales Shipment.
      Initialize;
      PostedDocumentNo := GeneralPreparationForUndoSalesShipmentLineWithAssemblyOrder(AsmItemNo,Quantity);

      // Exercise: Undo Sales Shipment.
      UndoSalesShipmentLine(PostedDocumentNo);

      // Verify: Undo Sales Shipment Line successfully. Check the Quantity is correct.
      VerifySalesShipmentLines(PostedDocumentNo,AsmItemNo,Quantity);
    END;

    [Test]
    [HandlerFunctions(ReservationPageHandler)]
    PROCEDURE AvailabilityOnSalesLineDetailsFactBoxWithReservation@208();
    VAR
      SalesLine@1014 : Record 37;
      Qty@1001 : Decimal;
    BEGIN
      // Setup: Create Item,Positive Adjustment.
      // Excercise: Create Sales Order,Reserve Quantity As Auto Reserve.
      Initialize;
      Qty := LibraryRandom.RandIntInRange(5,10); // Quantity is more than Sales Line Quantity required for test.
      CreateSalesOrderWithReservation(SalesLine,Qty,LibraryRandom.RandInt(5));

      // Verify: Verify the Availability on Sales Line Details FactBox of Sales Order page.
      VerifyAvailabilityOnSalesOrderPage(SalesLine."Document No.",SalesLine."No.",Qty - SalesLine.Quantity);
    END;

    [Test]
    [HandlerFunctions(ReservationPageHandler,AvailabilityWindowHandler)]
    PROCEDURE AssemblyOrderWithReservation@209();
    VAR
      AssemblyHeader@1002 : Record 900;
      ParentItemNo@1000 : Code[20];
    BEGIN
      // Setup: Create Assembly BOM with one Component. Create Assembly Order, Create and post Purchase Order for Component.
      // Reserve for Component from Item Ledger Entry. Create a Purchase Order.
      ParentItemNo := InitSetupForAssemlyOrderAndPurchaseOrder;

      // Exercise: Create another Assembly Order.
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,ParentItemNo,'',LibraryRandom.RandInt(5),'');

      // Verify: Verify values on Assembly Availability of Assembly Order through AvailabilityWindowHandler.
      OpenAssemblyAvailabilityPage(AssemblyHeader."No.");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE PostAssemblyOrderWithApplToItemEntry@206();
    VAR
      AssemblyHeader@1001 : Record 900;
      AssemblyLine@1003 : Record 901;
      ItemLedgerEntry@1004 : Record 32;
    BEGIN
      // Test and verify Appl.-to Item Entry is correct in Item Ledger Entry when Assembly Order is posted.
      // Setup: Create Assembly Item, create Assembly Order, add component inventory for Assembly Order, set Appl.-to Item Entry on Assembly Line.
      Initialize;
      CreateAssemblyItemAndOrderWithCompInventory(AssemblyHeader);

      // Find the 1st Assembly Line of Item Type, set "Appl.-to Item Entry" on Assembly Line to "Positive Adjmt." ILE No. of the component Item.
      UpdateApplToItemEntryOnAssemblyLine(AssemblyLine,AssemblyHeader."Item No.");

      // Exercise.
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify: "Applies-to Entry" field on Item Ledger Entry is correct.
      FindItemLedgerEntry(ItemLedgerEntry,ItemLedgerEntry."Entry Type"::"Assembly Consumption",AssemblyLine."No.");
      Assert.AreEqual(AssemblyLine."Appl.-to Item Entry",ItemLedgerEntry."Applies-to Entry",AppliesToEntryErr);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE CalcInvtValueOnRevaluationJournalAfterUndoPostedAssemblyOrder@217();
    VAR
      ComponentItem@1000 : Record 27;
      ItemJournalLine@1004 : Record 83;
      AssemblyItemNo@1001 : Code[20];
      CalculatePer@1002 : 'Item Ledger Entry,Item';
    BEGIN
      // Test and verify Order Type is correct on Item Journal Line after running "Calc. Inventory Value" from Revaluation Journal for undone posted Assembly Order.

      // Setup: Create Assembly Item with component, create and post Assembly Order, undo the posted Assembly Order.
      Initialize;
      AssemblyItemNo := PostAssemblyOrderAndUndoPost;
      GetItemFromBOMComponent(ComponentItem,AssemblyItemNo);

      // Exercise: Create Revaluation Journal Lines by running "Calc. Inventory Value".
      CreateRevaluationJournal(ComponentItem."No.",CalculatePer::"Item Ledger Entry");

      // Verify: Verify the Order Type on Item Journal Line.
      VerifyOrderTypeOnItemJournalLine(
        ItemJournalLine."Entry Type"::"Assembly Consumption",ComponentItem."No.",ItemJournalLine."Order Type"::Assembly);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ItemLedgerEntriesPageHandler)]
    PROCEDURE ItemJournalApplToUndoneAssemblyConsumptionLine@224();
    VAR
      ComponentItem@1000 : Record 27;
      ItemLedgerEntry@1005 : Record 32;
      AssemblyItemNo@1001 : Code[20];
      EntryType@1002 : Option;
    BEGIN
      // Test and verify Applies-to Entry is correct on Item Ledger Entry after posting Item Journal that apply to undone Assembly Consumption Line from ILE page.

      // Setup: Create Assembly Item with component, create and post Assembly Order, undo the posted Assembly Order.
      Initialize;
      AssemblyItemNo := PostAssemblyOrderAndUndoPost;
      GetItemFromBOMComponent(ComponentItem,AssemblyItemNo);

      ItemLedgerEntry.SETRANGE(Correction,TRUE);
      FindItemLedgerEntry(ItemLedgerEntry,ItemLedgerEntry."Entry Type"::"Assembly Consumption",ComponentItem."No.");

      // Exercise: Create and Post Item Journal Line Appl. to the Undone Assembly Consumption Line.
      LibraryVariableStorage.Enqueue(ItemLedgerEntry."Entry No."); // Enqueue the value for ItemLedgerEntriesPageHandler.
      CreateAndPostItemJournalApplToEntry(EntryType,ComponentItem."No.",RANDOM(10));

      // Verify: Verify the Applies-to Entry on Item Ledger Entry.
      VerifyApplToEntryOnILE(EntryType,ComponentItem."No.",ItemLedgerEntry."Entry No.");
    END;

    [Test]
    [HandlerFunctions(ReservationPageHandler)]
    PROCEDURE InsertSalesLineToFullConsumeItemWithExistingReservation@236();
    VAR
      SalesLine@1014 : Record 37;
      SalesHeader@1003 : Record 36;
      Qty@1001 : Decimal;
      PartialQty@1000 : Decimal;
    BEGIN
      // Setup: Create Item,Positive Adjustment. Create Sales Order with partial Reservation.
      Initialize;
      Qty := LibraryRandom.RandIntInRange(5,10);
      PartialQty := Qty - LibraryRandom.RandInt(5);
      CreateSalesOrderWithReservation(SalesLine,Qty,PartialQty);

      // Exercise: Create another Sales Line and update the Quantity by page. Check Availability window does not pop up.
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,SalesLine."No.",0);
      UpdateQuantityOnSalesLineByPage(SalesHeader."No.",Qty - PartialQty,SalesLine.Quantity); // Required for test.

      // Verify: Verify the Availability on Sales Line Details FactBox of Sales Order page.
      VerifyAvailabilityOnSalesOrderPage(SalesLine."Document No.",SalesLine."No.",0); // Item was full consumed.
    END;

    [Test]
    PROCEDURE SoldAssemblyItemIsCostAdjustedWhenAverageCostHasChanged@255();
    VAR
      ParentItem@1002 : Record 27;
      ComponentItem@1003 : Record 27;
      AssemblyHeader@1007 : Record 900;
      SalesLine@1010 : Record 37;
      ParentItemQuantity@1006 : Decimal;
      ComponentItemQuantity@1005 : Decimal;
      DirectCost1@1001 : Decimal;
      DirectCost2@1000 : Decimal;
    BEGIN
      // [FEATURE] [Assembly] [Adjust Cost]
      // [SCENARIO 363427] Sold Assembly Item using Average costing method is Cost Adjusted when the Average Cost of the period has changed
      Initialize;

      // [GIVEN] Component Item and Parent Item with costing method = "Average"
      ParentItemQuantity := LibraryRandom.RandDec(10,2);
      ComponentItemQuantity := LibraryRandom.RandDec(10,2);
      CreateAssemblyItemAndComponentItem(ParentItem,ComponentItem,ComponentItemQuantity / ParentItemQuantity);

      // [GIVEN] Purchase Order for Component Item with Direct Cost = "X"
      DirectCost1 := LibraryRandom.RandDec(100,2);
      CreatePurchaseOrderWithDirectCost(ComponentItem."No.",ComponentItemQuantity,DirectCost1);

      // [GIVEN] Assembly Oder for Parent Item
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,ParentItem."No.",'',ParentItemQuantity,'');
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // [GIVEN] Sales Order for Parent Item
      CreateAndPostSalesOrder(SalesLine,WORKDATE,ParentItem."No.",ParentItemQuantity,FALSE);

      // [GIVEN] Adjust Cost Item Entries
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ParentItem."No.",ComponentItem."No."),'');

      // [GIVEN] Purchase Order for Component Item with Direct Cost = "Y"
      DirectCost2 := LibraryRandom.RandDec(100,2);
      CreatePurchaseOrderWithDirectCost(ComponentItem."No.",ComponentItemQuantity,DirectCost2);

      // [WHEN] Run Adjust Cost Item Entries
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ParentItem."No.",ComponentItem."No."),'');

      // [THEN] Both Item Ledger Entries of Parent item has Cost Amount (Actual) adjusted
      VerifyItemLedgerEntries(ParentItem."No.",ComponentItemQuantity * (DirectCost1 + DirectCost2) / 2); // 2 - Number of ILE
    END;

    LOCAL PROCEDURE Initialize@4();
    VAR
      LibraryERMCountryData@1000 : Codeunit 131305;
    BEGIN
      LibrarySetupStorage.Restore;
      LibraryVariableStorage.Clear;
      IF isInitialized THEN
        EXIT;
      UpdateStockOutWarningOnAssemblySetup(FALSE);
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.CreateGeneralPostingSetupData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.UpdateSalesReceivablesSetup;
      NoSeriesSetup;
      LocationSetup;
      LibraryAssembly.SetupItemJournal(ItemJournalTemplate,ItemJournalBatch);

      isInitialized := TRUE;
      COMMIT;
      LibrarySetupStorage.Save(DATABASE::"General Ledger Setup");
      LibrarySetupStorage.Save(DATABASE::"Inventory Setup");
      LibrarySetupStorage.Save(DATABASE::"Assembly Setup");
    END;

    LOCAL PROCEDURE NoSeriesSetup@31();
    VAR
      AssemblySetup@1001 : Record 905;
      SalesSetup@1002 : Record 311;
      ManufacturingSetup@1003 : Record 99000765;
    BEGIN
      AssemblySetup.GET;
      AssemblySetup.VALIDATE("Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.MODIFY(TRUE);

      SalesSetup.GET;
      SalesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.MODIFY(TRUE);

      ManufacturingSetup.GET;
      ManufacturingSetup.VALIDATE("Released Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      ManufacturingSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE LocationSetup@81();
    BEGIN
      CreateAndUpdateLocation(LocationBlack);
      CreateAndUpdateLocation(LocationRed);
    END;

    LOCAL PROCEDURE CostAdjustmentOnRepostedSalesOrderWithDifferentAssemblies@287(Invoice@1003 : Boolean;AutoAdjust@1005 : Boolean);
    VAR
      Item@1000 : Record 27;
      SalesLine@1001 : Record 37;
      ItemLedgerEntry@1008 : Record 32;
      UpdatedCostAmount@1004 : Decimal;
    BEGIN
      // Setup: Create Assembly Item, create Sales Order for Assembly Item, post shipment for sales order, then undo sales shipment.
      Initialize;
      IF AutoAdjust THEN BEGIN
        LibraryVariableStorage.Enqueue(UnadjustedValueEntriesNotCoveredMessage);
        SetupAutomaticCostAdjustment;
      END;
      CreateSalesOrderWithAssemblyItemAndUndoSalesShipment(SalesLine,Item."Costing Method"::Average,AutoAdjust);

      // Update QtyPer on Assembly Line and post sales shipment or "ship and invoice".
      UpdateQtyPerOnAssemblyLineAndPostSalesDocument(SalesLine,TRUE,Invoice);

      // Exercise: Run Adjust Cost - Item Entries batch job for the Assembly Item.
      IF NOT AutoAdjust THEN
        LibraryCosting.AdjustCostItemEntries(SalesLine."No.",'');

      // Verify: Six Item Ledger entries for Assembly Item are generated.
      // For the first four entries, "Cost Amount(Actual)" for these entries should be +/- Standard Cost of Assembly Item.
      // For the last two entries, "Cost Amount(Actual)" for "Assembly Output" should be updated "Cost Amount" of Assembly Order
      // "Cost Amount(Expected)" for "Sales" should be negative of updated "Cost Amount".
      UpdatedCostAmount := CalcPostedAssemblyHeaderActualCostAmount(SalesLine."No.");

      VerifyCostAmountActualForAssemblyOutputAndSaleILE(SalesLine."No.",UpdatedCostAmount);
      VerifyCostAmountInLastILE(ItemLedgerEntry."Entry Type"::"Assembly Output",SalesLine."No.",0,UpdatedCostAmount);

      // Verify Cost Amount of ILE of Sales generated by posting the sales order after updating Qty Per on Assembly line
      IF Invoice THEN
        VerifyCostAmountInLastILE(ItemLedgerEntry."Entry Type"::Sale,SalesLine."No.",0,-UpdatedCostAmount)
      ELSE
        VerifyCostAmountInLastILE(ItemLedgerEntry."Entry Type"::Sale,SalesLine."No.",-UpdatedCostAmount,0);
    END;

    LOCAL PROCEDURE AddAssemblyComponentItemWithDimension@118(VAR AssemblyComponentItem@1000 : Record 27;VAR ComponentItem@1001 : Record 27;AssemblyItemNo@1004 : Code[20];Quantity@1003 : Decimal);
    VAR
      BOMComponent@1002 : Record 90;
    BEGIN
      CreateItemWithDimension(AssemblyComponentItem,AssemblyComponentItem."Replenishment System"::Assembly);
      CreateItemWithDimension(ComponentItem,ComponentItem."Replenishment System"::Purchase);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,ComponentItem."No.",AssemblyComponentItem."No.",'',BOMComponent."Resource Usage Type",
        Quantity,TRUE);  // Use Base Unit of Measure as True.
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,AssemblyComponentItem."No.",AssemblyItemNo,'',BOMComponent."Resource Usage Type",Quantity,TRUE);  // Use Base Unit of Measure as True.
    END;

    LOCAL PROCEDURE AddItemToAssemblyBOM@64(Item@1000 : Record 27;WithSalesPrice@1002 : Boolean);
    VAR
      BOMComponent@1003 : Record 90;
      Item2@1001 : Record 27;
    BEGIN
      IF WithSalesPrice THEN
        CreateItemWithSalesPrice(Item2,Item)
      ELSE
        CreateItemWithSalesLineDiscount(Item2,Item);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,Item2."No.",Item."No.",'',BOMComponent."Resource Usage Type",LibraryRandom.RandInt(5),TRUE);  // Use Base Unit of Measure as True and Variant as blank.
    END;

    LOCAL PROCEDURE AddResourceToAssemblyBOM@28(Item@1001 : Record 27;WithResourcePrice@1003 : Boolean);
    VAR
      BOMComponent@1002 : Record 90;
      Resource@1000 : Record 156;
      ResourcePrice@1004 : Record 201;
    BEGIN
      LibraryAssembly.CreateResource(Resource,FALSE,Item."Gen. Prod. Posting Group");
      IF WithResourcePrice THEN BEGIN
        LibraryResource.CreateResourcePrice(ResourcePrice,ResourcePrice.Type::Resource,Resource."No.",'','');  // Use blank for Work Type and Currency Code.
        ResourcePrice.VALIDATE("Unit Price",Resource."Unit Price" + LibraryRandom.RandDec(100,2));  // Use Different Resource Price.
        ResourcePrice.MODIFY(TRUE);
      END;
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Resource,Resource."No.",Item."No.",'',BOMComponent."Resource Usage Type"::Direct,
        LibraryRandom.RandInt(5),TRUE);  // Use Base Unit of Measure as True and Variant as blank.
    END;

    LOCAL PROCEDURE CalculateDateUsingDefaultSafetyLeadTime@18() : Date;
    VAR
      ManufacturingSetup@1000 : Record 99000765;
    BEGIN
      ManufacturingSetup.GET;
      EXIT(CALCDATE(ManufacturingSetup."Default Safety Lead Time",WORKDATE));
    END;

    LOCAL PROCEDURE CalculateStandardCostOnAssemblyBOM@34(VAR AssemblyBOM@1002 : TestPage 36;ItemNo@1001 : Code[20]);
    BEGIN
      OpenAssemblyBOMFromItemCard(AssemblyBOM,ItemNo);
      AssemblyBOM.CalcStandardCost.INVOKE;
    END;

    LOCAL PROCEDURE CalcPostedAssemblyHeaderActualCostAmount@227(ItemNo@1000 : Code[20]) : Decimal;
    VAR
      PostedAssemblyHeader@1002 : Record 910;
      ActualCosts@1001 : ARRAY [5] OF Decimal;
    BEGIN
      WITH PostedAssemblyHeader DO BEGIN
        SETRANGE("Item No.",ItemNo);
        FINDFIRST;

        CalcActualCosts(ActualCosts);
      END;
      EXIT(ActualCosts[1] + ActualCosts[2] + ActualCosts[3] + ActualCosts[4] + ActualCosts[5]);
    END;

    LOCAL PROCEDURE CopyAssemblyBOM@23(FromParentItemNo@1001 : Code[20];ToParentItemNo@1002 : Code[20]);
    VAR
      BOMComponent@1000 : Record 90;
    BEGIN
      FindBOMComponents(BOMComponent,FromParentItemNo);
      REPEAT
        LibraryAssembly.CreateAssemblyListComponent(
          BOMComponent.Type,BOMComponent."No.",ToParentItemNo,BOMComponent."Variant Code",BOMComponent."Resource Usage Type",
          BOMComponent."Quantity per",TRUE);  // Use Base Unit of Measure as True.
      UNTIL BOMComponent.NEXT = 0;
    END;

    LOCAL PROCEDURE CreateAndPostAssemblyOrder@79(VAR AssemblyHeader@1000 : Record 900;VAR AssemblyLine@1003 : Record 901;AssemblyItemNo@1001 : Code[20];Quantity@1002 : Decimal;HeaderQtyFactor@1006 : Integer;CompQtyFactor@1005 : Integer;UpdateAllComps@1004 : Boolean);
    BEGIN
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,AssemblyItemNo,'',Quantity,'');
      PrepareAndPostAssemblyOrder(AssemblyHeader,AssemblyLine,HeaderQtyFactor,CompQtyFactor,UpdateAllComps);
    END;

    LOCAL PROCEDURE CreateAndPostItemJournalLine@60(ItemNo@1001 : Code[20];Quantity@1002 : Decimal;VariantCode@1003 : Code[10]);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Quantity);
      ItemJournalLine.VALIDATE("Variant Code",VariantCode);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateAndPostSalesOrder@24(VAR SalesLine@1008 : Record 37;PostingDate@1007 : Date;ItemNo@1006 : Code[20];Quantity@1005 : Decimal;Reserve@1004 : Boolean);
    VAR
      Customer@1003 : Record 18;
      SalesHeader@1001 : Record 36;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,Customer."No.");
      SalesHeader.VALIDATE("Posting Date",PostingDate);
      SalesHeader.VALIDATE("Shipment Date",PostingDate);
      SalesHeader.MODIFY(TRUE);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
      IF Reserve THEN
        SalesLine.ShowReservation;
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);  // Post as SHIP and INVOICE.
    END;

    LOCAL PROCEDURE PartialInvoiceSalesOrder@176(VAR SalesLine@1008 : Record 37;VAR SalesHeader@1000 : Record 36;Quantity@1005 : Decimal);
    BEGIN
      SalesLine.VALIDATE("Qty. to Invoice",Quantity);
      SalesLine.MODIFY(TRUE);
      LibrarySales.PostSalesDocument(SalesHeader,FALSE,TRUE);
    END;

    LOCAL PROCEDURE CreateAndRefreshReleasedProductionOrder@114(VAR ProductionOrder@1003 : Record 5405;AssemblyOrderNo@1002 : Code[20]);
    VAR
      Item@1000 : Record 27;
      ReleasedProductionOrder@1001 : TestPage 99000831;
    BEGIN
      LibraryAssembly.CreateItem(Item,Item."Costing Method"::Standard,Item."Replenishment System"::"Prod. Order",'','');
      ReleasedProductionOrder.OPENNEW;
      ReleasedProductionOrder."No.".SETVALUE(AssemblyOrderNo);
      ReleasedProductionOrder."Source No.".SETVALUE(Item."No.");
      ReleasedProductionOrder.Quantity.SETVALUE(LibraryRandom.RandDec(10,2));
      ReleasedProductionOrder.OK.INVOKE;
      ProductionOrder.GET(ProductionOrder.Status::Released,AssemblyOrderNo);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);  // Use True for Calculate Lines, Routings and Components.
    END;

    LOCAL PROCEDURE CreateAndUpdateLocation@82(VAR Location@1000 : Record 14);
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
    END;

    LOCAL PROCEDURE CreateAsmOrderWithMultipleComponentItems@142(VAR AssemblyHeader@1000 : Record 900;ItemNo@1001 : Code[20];Quantity@1002 : Decimal;ItemNo2@1004 : Code[20];BaseUnitofMeasure@1005 : Code[10]);
    VAR
      AssemblyLine@1003 : Record 901;
    BEGIN
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,ItemNo,'',Quantity,'');
      LibraryAssembly.CreateAssemblyLine(
        AssemblyHeader,AssemblyLine,AssemblyLine.Type::Item,ItemNo2,BaseUnitofMeasure,Quantity,Quantity,'');
    END;

    LOCAL PROCEDURE CreateAssemblyItemsAndBOMComponentsSetup@41(VAR Item@1000 : Record 27;VAR Item2@1001 : Record 27;VAR Item3@1002 : Record 27);
    VAR
      BOMComponent@1003 : Record 90;
    BEGIN
      CreateAssemblyItem(Item);
      CreateAssemblyItem(Item2);
      CreateAssemblyItem(Item3);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,Item2."No.",Item."No.",'',BOMComponent."Resource Usage Type",LibraryRandom.RandInt(5),TRUE);  // UseBaseUnitOfMeasure as TRUE.
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,Item3."No.",Item2."No.",'',BOMComponent."Resource Usage Type",LibraryRandom.RandInt(5),TRUE);  // UseBaseUnitOfMeasure as TRUE.
    END;

    LOCAL PROCEDURE CreateAssemblyItemAndBOMComponentSetup@211(VAR ChildItem@1001 : Record 27;VAR ParentItem@1000 : Record 27);
    VAR
      BOMComponent@1003 : Record 90;
    BEGIN
      CreateAndUpdateItem(
        ChildItem,ChildItem."Replenishment System"::Assembly,ChildItem."Costing Method"::FIFO,
        LibraryRandom.RandInt(10));
      CreateAndUpdateItem(
        ParentItem,ParentItem."Replenishment System"::Assembly,ParentItem."Costing Method"::FIFO,
        LibraryRandom.RandInt(10));
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,ChildItem."No.",ParentItem."No.",'',
        BOMComponent."Resource Usage Type",LibraryRandom.RandInt(10),TRUE);  // UseBaseUnitOfMeasure as TRUE.
    END;

    LOCAL PROCEDURE CreateTwoAssemblyItemsAndBOMComponentsSetup@194(VAR Item@1000 : Record 27;VAR AssemblyItem@1001 : Record 27);
    VAR
      DefaultDimension@1002 : Record 352;
      BOMComponent@1003 : Record 90;
    BEGIN
      CreateAssemblyItem(Item);
      CreateAssemblyItem(AssemblyItem);
      UpdateItemDimensionWithValuePosting(
        DefaultDimension,AssemblyItem."No.",DefaultDimension."Value Posting"::"Same Code");
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,Item."No.",AssemblyItem."No.",'',
        BOMComponent."Resource Usage Type",LibraryRandom.RandInt(5),TRUE);
    END;

    LOCAL PROCEDURE CreateAssemblyItemSetup@133(VAR AssemblyItem@1003 : Record 27;VAR ItemUnitOfMeasure@1001 : Record 5404;VAR Resource@1004 : Record 156;AsmItemCostingMethod@1005 : Option;ComponentItemCostingMethod@1006 : Option) Quantity : Decimal;
    VAR
      BOMComponent@1002 : Record 90;
      ComponentItem@1000 : Record 27;
    BEGIN
      LibraryAssembly.CreateItem(ComponentItem,ComponentItemCostingMethod,ComponentItem."Replenishment System"::Purchase,'','');
      ItemUnitOfMeasure.GET(
        ComponentItem."No.",LibraryAssembly.GetUnitOfMeasureCode(BOMComponent.Type::Item,ComponentItem."No.",FALSE));
      LibraryAssembly.CreateItem(AssemblyItem,AsmItemCostingMethod,AssemblyItem."Replenishment System"::Assembly,'','');
      LibraryAssembly.CreateResource(Resource,FALSE,'');
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,ComponentItem."No.",AssemblyItem."No.",'',BOMComponent."Resource Usage Type",Quantity,FALSE);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Resource,Resource."No.",AssemblyItem."No.",'',BOMComponent."Resource Usage Type"::Direct,Quantity,TRUE);  // Use Base Unit of Measure as True.
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::" ",'',AssemblyItem."No.",'',BOMComponent."Resource Usage Type"::Direct,0,FALSE);  // Use 0 for Quantity per.
    END;

    LOCAL PROCEDURE CreateAssemblyItemSetupWithDimension@59(VAR AssemblyItem@1002 : Record 27;VAR ItemUnitOfMeasure@1001 : Record 5404;VAR Resource@1003 : Record 156) Quantity : Decimal;
    VAR
      ComponentItem@1000 : Record 27;
      BOMComponent@1004 : Record 90;
    BEGIN
      CreateItemWithDimension(ComponentItem,ComponentItem."Replenishment System"::Purchase);
      ItemUnitOfMeasure.GET(
        ComponentItem."No.",LibraryAssembly.GetUnitOfMeasureCode(BOMComponent.Type::Item,ComponentItem."No.",FALSE));
      CreateItemWithDimension(AssemblyItem,AssemblyItem."Replenishment System"::Assembly);
      CreateResourceWithDimension(Resource);
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,ComponentItem."No.",AssemblyItem."No.",'',BOMComponent."Resource Usage Type",Quantity,FALSE);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Resource,Resource."No.",AssemblyItem."No.",'',BOMComponent."Resource Usage Type"::Direct,Quantity,TRUE);  // Use Base Unit of Measure as True.
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::" ",'',AssemblyItem."No.",'',BOMComponent."Resource Usage Type"::Direct,0,FALSE);  // Use 0 for Quantity per.
    END;

    LOCAL PROCEDURE CreateAssemblyItemSetupWithVariant@92(VAR AssemblyItem@1004 : Record 27;VAR ItemUnitOfMeasure@1001 : Record 5404;VAR ItemVariant@1003 : Record 5401) Quantity : Decimal;
    VAR
      ComponentItem@1000 : Record 27;
      BOMComponent@1002 : Record 90;
      AssemblyBOM@1005 : TestPage 36;
    BEGIN
      LibraryAssembly.CreateItem(
        ComponentItem,ComponentItem."Costing Method"::Standard,ComponentItem."Replenishment System"::Purchase,'','');
      ItemUnitOfMeasure.GET(
        ComponentItem."No.",LibraryAssembly.GetUnitOfMeasureCode(BOMComponent.Type::Item,ComponentItem."No.",FALSE));
      LibraryInventory.CreateItemVariant(ItemVariant,ComponentItem."No.");
      CreateMultipleStockkeepingUnit(ComponentItem."No.",LocationBlack.Code,LocationRed.Code);
      LibraryAssembly.CreateItem(
        AssemblyItem,AssemblyItem."Costing Method"::Standard,AssemblyItem."Replenishment System"::Assembly,'','');
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,ComponentItem."No.",AssemblyItem."No.",ItemVariant.Code,BOMComponent."Resource Usage Type",
        Quantity,TRUE);
      CalculateStandardCostOnAssemblyBOM(AssemblyBOM,AssemblyItem."No.");
      AssemblyBOM.CalcUnitPrice.INVOKE;
    END;

    LOCAL PROCEDURE CreateAssemblyOrder@61(AssemblyOrderNo@1000 : Code[20]);
    VAR
      AssemblyHeader@1001 : Record 900;
    BEGIN
      AssemblyHeader.INIT;
      AssemblyHeader.VALIDATE("Document Type",AssemblyHeader."Document Type"::Order);
      AssemblyHeader.VALIDATE("No.",AssemblyOrderNo);
      AssemblyHeader.INSERT(TRUE);
    END;

    LOCAL PROCEDURE CreateFiscalYearAndInventoryPeriod@155() PostingDate : Date;
    VAR
      InventoryPeriod@1000 : Record 5814;
    BEGIN
      LibraryFiscalYear.CreateFiscalYear;
      PostingDate := LibraryFiscalYear.GetLastPostingDate(FALSE);
      LibraryInventory.CreateInventoryPeriod(InventoryPeriod,PostingDate);
    END;

    LOCAL PROCEDURE CreateInitialSetupForPostAsmOrdWithMultipleItems@138(VAR AssemblyHeader@1006 : Record 900;VAR AssemblyItem@1007 : Record 27);
    VAR
      ItemUnitOfMeasure@1002 : Record 5404;
      Resource@1003 : Record 156;
      ComponentItem@1005 : Record 27;
      TempAssemblyLine@1008 : TEMPORARY Record 901;
      Quantity@1000 : Decimal;
    BEGIN
      Quantity :=
        CreateAssemblyItemSetup(
          AssemblyItem,ItemUnitOfMeasure,Resource,AssemblyItem."Costing Method"::Average,AssemblyItem."Costing Method"::Average);
      LibraryAssembly.CreateItem(
        ComponentItem,ComponentItem."Costing Method"::Standard,ComponentItem."Replenishment System"::Purchase,'','');
      UpdateInventoryForComponentItems(
        ItemUnitOfMeasure."Item No.",Quantity,ItemUnitOfMeasure."Qty. per Unit of Measure",ComponentItem."No.");
      CreateAsmOrderWithMultipleComponentItems(
        AssemblyHeader,AssemblyItem."No.",Quantity,ComponentItem."No.",ComponentItem."Base Unit of Measure");
      AssemblyHeader.UpdateUnitCost;
      PrepareAndPostAssemblyOrder(AssemblyHeader,TempAssemblyLine,30,30,FALSE);  // Use 30 for Partial Quantity to Assemble and Quantity to Consume.
    END;

    LOCAL PROCEDURE PostAssemblyOrderAndUndoPost@219() : Code[20];
    VAR
      AssemblyHeader@1000 : Record 900;
      PostedAssemblyHeader@1002 : Record 910;
    BEGIN
      CreateAssemblyItemAndOrderWithCompInventory(AssemblyHeader);
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
      FindPostedAssemblyHeader(PostedAssemblyHeader,AssemblyHeader."No.",AssemblyHeader."Item No.");
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,FALSE,'');
      EXIT(AssemblyHeader."Item No.");
    END;

    LOCAL PROCEDURE CreateItemWithDimension@62(VAR Item@1002 : Record 27;ReplenishmentSystem@1000 : Option);
    VAR
      AssemblyLine@1001 : Record 901;
    BEGIN
      LibraryAssembly.CreateItem(Item,Item."Costing Method"::Standard,ReplenishmentSystem,'','');
      LibraryAssembly.AddEntityDimensions(AssemblyLine.Type::Item,Item."No.");
    END;

    LOCAL PROCEDURE CreateItemWithSalesLineDiscount@66(VAR Item2@1000 : Record 27;Item@1001 : Record 27);
    VAR
      SalesLineDiscount@1002 : Record 7004;
    BEGIN
      LibraryAssembly.CreateItem(
        Item2,Item2."Costing Method"::Standard,Item2."Replenishment System"::Purchase,Item."Gen. Prod. Posting Group",
        Item."Inventory Posting Group");
      LibraryERM.CreateLineDiscForCustomer(
        SalesLineDiscount,SalesLineDiscount.Type::Item,Item."No.",SalesLineDiscount."Sales Type"::"All Customers",'',0D,'','','',0);  // Use 0D for Starting Date and 0 for Minimum Quantity.
      SalesLineDiscount.VALIDATE("Line Discount %",LibraryRandom.RandDec(100,2));
      SalesLineDiscount.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemWithSalesPrice@65(VAR Item2@1000 : Record 27;Item@1001 : Record 27);
    VAR
      SalesPrice@1002 : Record 7002;
    BEGIN
      LibraryAssembly.CreateItem(
        Item2,Item2."Costing Method"::Standard,Item2."Replenishment System"::Purchase,Item."Gen. Prod. Posting Group",
        Item."Inventory Posting Group");
      LibraryCosting.CreateSalesPrice(SalesPrice,SalesPrice."Sales Type"::"All Customers",'',Item2."No.",0D,'','','',0);  // Use 0D for Starting Date and 0 for Minimum Quantity.
      SalesPrice.VALIDATE("Unit Price",Item2."Unit Price" + LibraryRandom.RandDec(100,2));  // Use Different Sales Price.
      SalesPrice.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateMultipleStockkeepingUnit@101(ItemNo@1000 : Code[20];LocationCode@1002 : Code[10];LocationCode2@1003 : Code[10]);
    VAR
      Item@1001 : Record 27;
    BEGIN
      Item.SETRANGE("No.",ItemNo);
      Item.SETFILTER("Location Filter",'%1|%2',LocationCode,LocationCode2);
      LibraryInventory.CreateStockKeepingUnit(Item,0,FALSE,FALSE);  // Create Per Option as Zero.
    END;

    LOCAL PROCEDURE CreateResourceWithDimension@67(VAR Resource@1000 : Record 156);
    VAR
      AssemblyLine@1001 : Record 901;
    BEGIN
      LibraryAssembly.CreateResource(Resource,FALSE,'');
      LibraryAssembly.AddEntityDimensions(AssemblyLine.Type::Resource,Resource."No.");
    END;

    LOCAL PROCEDURE CreateShortcutDimensionValue@167(VAR DimensionValue@1000 : Record 349;VAR DimensionValue2@1001 : Record 349;DimensionCode@1003 : Code[20];DimensionCode2@1004 : Code[20]);
    BEGIN
      LibraryDimension.CreateDimensionValue(DimensionValue,DimensionCode);
      LibraryDimension.CreateDimensionValue(DimensionValue2,DimensionCode2);
    END;

    LOCAL PROCEDURE CreateCustomerWithDimension@172(VAR Customer@1004 : Record 18;DimensionCode@1002 : Code[20];DimensionCode2@1005 : Code[20];DimensionValueCode@1000 : Code[20];DimensionValueCode2@1001 : Code[20]);
    VAR
      DefaultDimension@1003 : Record 352;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      LibraryDimension.CreateDefaultDimensionCustomer(DefaultDimension,Customer."No.",DimensionCode,DimensionValueCode);
      LibraryDimension.CreateDefaultDimensionCustomer(DefaultDimension,Customer."No.",DimensionCode2,DimensionValueCode2);
    END;

    LOCAL PROCEDURE CreateSalesOrder@177(VAR SalesLine@1000 : Record 37;CustomerNo@1001 : Code[20];ItemNo@1002 : Code[20];Qty@1004 : Decimal);
    VAR
      SalesHeader@1003 : Record 36;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CustomerNo);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Qty);
    END;

    LOCAL PROCEDURE CreateSalesOrderWithReservation@242(VAR SalesLine@1003 : Record 37;Qty@1000 : Decimal;PartialQty@1001 : Decimal);
    VAR
      Item@1004 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      CreateAndPostItemJournalLine(Item."No.",Qty,'');
      CreateSalesOrder(SalesLine,'',Item."No.",PartialQty);
      SalesLine.ShowReservation;
    END;

    LOCAL PROCEDURE CreatePurchaseOrderWithDirectCost@245(ItemNo@1004 : Code[20];Qty@1003 : Decimal;DirectUnitCost@1002 : Decimal);
    VAR
      PurchaseHeader@1000 : Record 38;
      PurchaseLine@1001 : Record 39;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');

      WITH PurchaseLine DO BEGIN
        LibraryPurchase.CreatePurchaseLine(
          PurchaseLine,PurchaseHeader,Type::Item,ItemNo,Qty);
        VALIDATE("Direct Unit Cost",DirectUnitCost);
        MODIFY;
      END;

      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE CreatePurchaseOrderWithReceiptDate@213(VAR PurchaseLine@1003 : Record 39;ItemNo@1002 : Code[20];Qty@1004 : Decimal);
    VAR
      PurchaseHeader@1000 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchaseDocumentWithItem(
        PurchaseHeader,PurchaseLine,PurchaseHeader."Document Type"::Order,'',ItemNo,Qty,'',WORKDATE);
    END;

    LOCAL PROCEDURE CreateAsmItemAndSalesOrderWithDimSetup@160(VAR SalesLine@1006 : Record 37;VAR DimensionValue@1000 : Record 349;VAR DimensionValue2@1010 : Record 349);
    VAR
      Item@1008 : Record 27;
      Customer@1002 : Record 18;
    BEGIN
      CreateAssemblyItem(Item);

      // Create Dimension value for Shortcut Dimension Code
      CreateShortcutDimensionValue(
        DimensionValue,DimensionValue2,LibraryERM.GetShortcutDimensionCode(1),LibraryERM.GetShortcutDimensionCode(2));

      // Create Customer with default Shortcut dimension
      CreateCustomerWithDimension(
        Customer,LibraryERM.GetShortcutDimensionCode(1),LibraryERM.GetShortcutDimensionCode(2),
        DimensionValue.Code,DimensionValue2.Code);

      // Create Sales Order
      CreateSalesOrder(SalesLine,Customer."No.",Item."No.",LibraryRandom.RandInt(10));
    END;

    LOCAL PROCEDURE CreateSalesOrderWithAssemblyItem@173(VAR SalesLine@1006 : Record 37);
    VAR
      Item@1008 : Record 27;
      Customer@1002 : Record 18;
      AssemblyHeader@1001 : Record 900;
    BEGIN
      // Create Assembly Item, Customer and Sales Order.
      CreateAssemblyItem(Item);
      LibrarySales.CreateCustomer(Customer);
      CreateSalesOrder(SalesLine,Customer."No.",Item."No.",LibraryRandom.RandInt(10));

      // Generate an Assembly order on Sales line to Assembly Header.
      UpdateQtyToAssembleOnSalesLine(SalesLine,SalesLine.Quantity);

      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,SalesLine."No."); // Find the Assembly Header created from the sales line
      LibraryAssembly.AddCompInventory(AssemblyHeader,WORKDATE,LibraryRandom.RandInt(10)); // Add component inventory for assembly item
    END;

    LOCAL PROCEDURE CreateAssemblyItem@162(VAR Item@1000 : Record 27);
    BEGIN
      // Use False for Update Unit Cost and blank for Variant Code.
      LibraryAssembly.SetupAssemblyItem(
        Item,Item."Costing Method"::Standard,Item."Costing Method"::Standard,Item."Replenishment System"::Assembly,'',FALSE,
        LibraryRandom.RandInt(5),LibraryRandom.RandInt(5),
        LibraryRandom.RandInt(5),LibraryRandom.RandInt(5));
    END;

    LOCAL PROCEDURE CreateAssemblyItemAndComponentItem@246(VAR ParentItem@1000 : Record 27;VAR ComponentItem@1001 : Record 27;QuantityPerParent@1002 : Decimal);
    VAR
      BOMComponent@1003 : Record 90;
    BEGIN
      WITH LibraryAssembly DO BEGIN
        CreateItem(ParentItem,ParentItem."Costing Method"::Average,ParentItem."Replenishment System"::Assembly,'','');
        CreateItem(ComponentItem,ComponentItem."Costing Method"::Average,ComponentItem."Replenishment System"::Purchase,'','');
        CreateAssemblyListComponent(
          BOMComponent.Type::Item,ComponentItem."No.",ParentItem."No.",'',BOMComponent."Resource Usage Type",QuantityPerParent,TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateAssemblyItemWithAssemblyItemAsComponent@171(VAR Item@1000 : Record 27;VAR Item2@1001 : Record 27;UseBaseUnitOfMeasure@1004 : Boolean);
    VAR
      BOMComponent@1002 : Record 90;
    BEGIN
      CreateAssemblyItem(Item);
      CreateAssemblyItem(Item2);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,Item2."No.",Item."No.",'',
        BOMComponent."Resource Usage Type",LibraryRandom.RandInt(5),UseBaseUnitOfMeasure); // Use Base Unit of Measure as True and Variant Code as blank.
    END;

    LOCAL PROCEDURE CreateAndUpdateItem@191(VAR Item@1000 : Record 27;ReplenishmentSystem@1001 : Option;CostingMethod@1002 : Option;StandardCost@1003 : Decimal);
    BEGIN
      LibraryInventory.CreateItem(Item);
      WITH Item DO BEGIN
        VALIDATE("Replenishment System",ReplenishmentSystem);
        VALIDATE("Costing Method",CostingMethod);
        VALIDATE("Standard Cost",StandardCost);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateAndCertifyProductionBOM@189(VAR ProductionBOMHeader@1000 : Record 99000771;BaseUnitofMeasure@1007 : Code[10];ProductionBOMLineType@1003 : ' ,Item,Production BOM';CompItemNo@1002 : Code[20];QuantityPer@1004 : Decimal);
    VAR
      ProductionBOMLine@1006 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,BaseUnitofMeasure);
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLineType,CompItemNo,QuantityPer);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateCertifiedProductionBOMAndUpdateItem@188(VAR ProductionBOMHeader@1002 : Record 99000771;ItemNo@1001 : Code[20];ProductionBOMLineType@1004 : ' ,Item,Production BOM';CompItemNo@1003 : Code[20];QuantityPer@1005 : Decimal);
    VAR
      Item@1000 : Record 27;
    BEGIN
      Item.GET(ItemNo);
      CreateAndCertifyProductionBOM(
        ProductionBOMHeader,Item."Base Unit of Measure",ProductionBOMLineType,CompItemNo,QuantityPer);
      UpdateItemWithProdBOMNo(Item."No.",ProductionBOMHeader."No.");
    END;

    LOCAL PROCEDURE CreateSalesOrderWithPostingDate@198(VAR SalesLine@1000 : Record 37;ItemNo@1001 : Code[20];PostingDate@1004 : Date);
    VAR
      SalesHeader@1002 : Record 36;
      Customer@1003 : Record 18;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,Customer."No.");
      SalesHeader.VALIDATE("Posting Date",PostingDate);
      SalesHeader.MODIFY(TRUE);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,LibraryRandom.RandInt(10));
    END;

    LOCAL PROCEDURE CreateSalesOrderWithAssemblyItemAndUndoSalesShipment@222(VAR SalesLine@1000 : Record 37;CostingMethod@1001 : Option;AutoAdjust@1005 : Boolean);
    VAR
      ItemAssembled@1002 : Record 27;
    BEGIN
      CreateSalesOrderWithAssemblyItem(SalesLine);
      ItemAssembled.GET(SalesLine."No.");
      ItemAssembled.VALIDATE("Costing Method",CostingMethod);
      ItemAssembled.MODIFY(TRUE);
      IF NOT AutoAdjust THEN
        LibraryCosting.AdjustCostItemEntries(SalesLine."No.",'');

      UndoSalesShipmentLine(PostSalesDocument(SalesLine."Document Type",SalesLine."Document No.",TRUE,FALSE));
    END;

    LOCAL PROCEDURE CreateAssemblyItemAndOrderWithCompInventory@207(VAR AssemblyHeader@1000 : Record 900);
    VAR
      Item@1001 : Record 27;
    BEGIN
      CreateAssemblyItem(Item);
      LibraryVariableStorage.Enqueue(STRSUBSTNO(BeforeWorkDateMsg,WORKDATE));
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WORKDATE,Item."No.",'',RANDOM(10),'');
      LibraryAssembly.AddCompInventory(AssemblyHeader,AssemblyHeader."Posting Date",RANDOM(10));
    END;

    LOCAL PROCEDURE CreateItemJournalBatch@230(VAR ItemJournalBatch@1002 : Record 233;ItemJournalTemplateType@1000 : Option);
    VAR
      ItemJournalTemplate@1001 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplateType);
      LibraryInventory.CreateItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Name);
    END;

    LOCAL PROCEDURE CreateRevaluationJournal@220(ItemNo@1000 : Code[20];CalculatePer@1001 : Option);
    VAR
      Item@1002 : Record 27;
      ItemJournalBatch@1004 : Record 233;
      ItemJournalTemplate@1005 : Record 82;
      CalculationBase@1003 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
    BEGIN
      CreateItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Type::Revaluation);
      Item.SETRANGE("No.",ItemNo);
      LibraryCosting.CreateRevaluationJournal(
        ItemJournalBatch,Item,WORKDATE,LibraryUtility.GenerateGUID,CalculatePer,FALSE,FALSE,FALSE,CalculationBase::" ",FALSE);
    END;

    LOCAL PROCEDURE CreateAndPostItemJournalApplToEntry@231(VAR EntryType@1003 : Option;ItemNo@1004 : Code[20];Qty@1005 : Decimal);
    VAR
      ItemJournalBatch@1002 : Record 233;
      ItemJournalTemplate@1000 : Record 82;
      ItemJournalLine@1001 : Record 83;
    BEGIN
      CreateItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Type::Item);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",
        ItemJournalBatch.Name,ItemJournalLine."Entry Type"::"Negative Adjmt.",ItemNo,Qty);
      EntryType := ItemJournalLine."Entry Type";
      COMMIT; // Commit required before invoke action in UpdateApplToEntryByPage function.
      UpdateApplToEntryByPage(ItemJournalBatch.Name);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE DeleteAssemblyCommentLine@72(DocumentType@1001 : Option;DocumentNo@1002 : Code[20]);
    VAR
      AssemblyCommentLine@1000 : Record 906;
    BEGIN
      AssemblyCommentLine.SETRANGE("Document Type",DocumentType);
      AssemblyCommentLine.SETRANGE("Document No.",DocumentNo);
      AssemblyCommentLine.DELETEALL(TRUE);
    END;

    LOCAL PROCEDURE DeleteAssemblyLine@77(VAR AssemblyHeader@1000 : Record 900;ItemNo@1001 : Code[20];Quantity@1002 : Decimal);
    VAR
      AssemblyLine@1003 : Record 901;
    BEGIN
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,ItemNo,'',Quantity,'');
      LibraryAssembly.DeleteAssemblyLine(AssemblyLine.Type::Item,AssemblyHeader."No.");
    END;

    LOCAL PROCEDURE ExplodeAssemblyBOM@37(VAR BOMComponent@1000 : Record 90;ParentItemNo@1001 : Code[20];Type@1002 : Option);
    BEGIN
      FindBOMComponent(BOMComponent,ParentItemNo,Type);
      CODEUNIT.RUN(CODEUNIT::"BOM-Explode BOM",BOMComponent);
    END;

    LOCAL PROCEDURE FilterAssemblyOrderLine@109(VAR AssemblyOrder@1000 : TestPage 900;OrderNo@1001 : Code[20];No@1002 : Code[20]);
    BEGIN
      AssemblyOrder.OPENEDIT;
      AssemblyOrder.FILTER.SETFILTER("No.",OrderNo);
      AssemblyOrder.Lines.FILTER.SETFILTER("No.",No);
    END;

    LOCAL PROCEDURE FindAssemblyLine@117(VAR AssemblyLine@1000 : Record 901;VAR BomComponent@1001 : Record 90);
    BEGIN
      AssemblyLine.SETRANGE(Type,BomComponent.Type);
      AssemblyLine.SETRANGE("No.",BomComponent."No.");
      AssemblyLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindAssemblyOrderLine@36(VAR AssemblyLine@1000 : Record 901;DocumentNo@1001 : Code[20];No@1002 : Code[20]);
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyLine."Document Type"::Order);
      AssemblyLine.SETRANGE("Document No.",DocumentNo);
      AssemblyLine.SETRANGE("No.",No);
      AssemblyLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindBOMComponent@3(VAR BOMComponent@1000 : Record 90;ParentItemNo@1001 : Code[20];Type@1002 : Option);
    BEGIN
      BOMComponent.SETRANGE("Parent Item No.",ParentItemNo);
      BOMComponent.SETRANGE(Type,Type);
      BOMComponent.FINDFIRST;
    END;

    LOCAL PROCEDURE FindBOMComponents@11(VAR BOMComponent@1000 : Record 90;ParentItemNo@1001 : Code[20]);
    BEGIN
      BOMComponent.SETRANGE("Parent Item No.",ParentItemNo);
      BOMComponent.FINDSET;
    END;

    LOCAL PROCEDURE FindPostedAssemblyHeader@143(VAR PostedAssemblyHeader@1000 : Record 910;OrderNo@1001 : Code[20];ItemNo@1002 : Code[20]);
    BEGIN
      PostedAssemblyHeader.SETRANGE("Order No.",OrderNo);
      PostedAssemblyHeader.SETRANGE("Item No.",ItemNo);
      PostedAssemblyHeader.FINDFIRST;
    END;

    LOCAL PROCEDURE FindPostedAssemblyResourceLine@144(VAR PostedAssemblyLine@1000 : Record 911;DocumentNo@1001 : Code[20];No@1002 : Code[20]);
    BEGIN
      PostedAssemblyLine.SETRANGE("Document No.",DocumentNo);
      PostedAssemblyLine.SETRANGE(Type,PostedAssemblyLine.Type::Resource);
      PostedAssemblyLine.SETRANGE("No.",No);
      PostedAssemblyLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindAssemblyHeader@181(VAR AssemblyHeader@1003 : Record 900;DocumentType@1000 : Option;ItemNo@1001 : Code[20]);
    BEGIN
      AssemblyHeader.SETRANGE("Document Type",DocumentType);
      AssemblyHeader.SETRANGE("Item No.",ItemNo);
      AssemblyHeader.FINDFIRST;
    END;

    LOCAL PROCEDURE FindItemLedgerEntry@184(VAR ItemLedgerEntry@1003 : Record 32;EntryType@1000 : Option;ItemNo@1001 : Code[20]);
    BEGIN
      FilterOnItemLedgerEntry(ItemLedgerEntry,EntryType,ItemNo);
      ItemLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindLastItemLedgerEntry@298(VAR ItemLedgerEntry@1003 : Record 32;EntryType@1000 : Option;ItemNo@1001 : Code[20]);
    BEGIN
      FilterOnItemLedgerEntry(ItemLedgerEntry,EntryType,ItemNo);
      ItemLedgerEntry.FINDLAST;
    END;

    LOCAL PROCEDURE FilterOnItemLedgerEntry@288(VAR ItemLedgerEntry@1003 : Record 32;EntryType@1000 : Option;ItemNo@1001 : Code[20]);
    BEGIN
      ItemLedgerEntry.SETRANGE("Entry Type",EntryType);
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
    END;

    LOCAL PROCEDURE FindItemJournalLine@223(VAR ItemJournalLine@1003 : Record 83;EntryType@1000 : Option;ItemNo@1001 : Code[20]);
    BEGIN
      ItemJournalLine.SETRANGE("Entry Type",EntryType);
      ItemJournalLine.SETRANGE("Item No.",ItemNo);
      ItemJournalLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindValueEntry@166(VAR ValueEntry@1002 : Record 5802;DocumentType@1001 : Option;ItemNo@1000 : Code[20]);
    BEGIN
      ValueEntry.SETRANGE("Document Type",DocumentType);
      ValueEntry.SETRANGE("Item No.",ItemNo);
      ValueEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE GetItemFromBOMComponent@115(VAR ComponentItem@1001 : Record 27;ItemNo@1002 : Code[20]);
    VAR
      BOMComponent@1000 : Record 90;
    BEGIN
      FindBOMComponent(BOMComponent,ItemNo,BOMComponent.Type::Item);
      ComponentItem.GET(BOMComponent."No.");
    END;

    LOCAL PROCEDURE GetResourceFromBOMComponent@110(VAR Resource@1000 : Record 156;ItemNo@1001 : Code[20]);
    VAR
      BOMComponent@1002 : Record 90;
    BEGIN
      FindBOMComponent(BOMComponent,ItemNo,BOMComponent.Type::Resource);
      Resource.GET(BOMComponent."No.");
    END;

    LOCAL PROCEDURE GetNextNoFromAssemblyOrderNoSeries@19() : Code[20];
    VAR
      AssemblySetup@1001 : Record 905;
      NoSeries@1000 : Record 308;
      NoSeriesManagement@1002 : Codeunit 396;
    BEGIN
      AssemblySetup.GET;
      NoSeries.GET(AssemblySetup."Assembly Order Nos.");
      EXIT(NoSeriesManagement.GetNextNo(NoSeries.Code,WORKDATE,FALSE));
    END;

    LOCAL PROCEDURE GeneralPreparationForUndoSalesShipmentLineWithAssemblyOrder@204(VAR AsmItemNo@1000 : Code[20];VAR Quantity@1004 : Decimal) : Code[20];
    VAR
      AsmItem@1001 : Record 27;
      Customer@1006 : Record 18;
      SalesHeader@1005 : Record 36;
      SalesLine@1007 : Record 37;
      AssemblyHeader@1003 : Record 900;
      AssemblyLine@1002 : Record 901;
    BEGIN
      // Create Assembly Item and Assembly BOM with at least two component Items. Create Sales Order with Assembly Item.
      // Update Quantity to Consume on one Assembly line to zero. Post Sales Order as SHIP.
      LibraryAssembly.SetupAssemblyItem(
        AsmItem,AsmItem."Costing Method"::Standard,AsmItem."Costing Method"::Standard,AsmItem."Replenishment System"::Assembly,
        '',FALSE,LibraryRandom.RandIntInRange(2,5),0,0,LibraryRandom.RandInt(5));
      AsmItemNo := AsmItem."No.";
      LibrarySales.CreateCustomer(Customer);
      CreateSalesOrder(SalesLine,Customer."No.",AsmItem."No.",LibraryRandom.RandInt(10));
      UpdateQtyToAssembleOnSalesLine(SalesLine,SalesLine.Quantity);
      Quantity := SalesLine.Quantity;

      // Update Quantity to Consume on one Assembly line to zero. Post Sales Order as SHIP.
      UpdateQuantityToConsumeOnAssemblyLine(AssemblyLine,SalesLine."No.");
      AssemblyHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");
      LibraryAssembly.AddCompInventory(AssemblyHeader,WORKDATE,LibraryRandom.RandInt(50) + 100); // Large inventory for component items.
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");
      EXIT(LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE));
    END;

    LOCAL PROCEDURE InitSetupForAssemlyOrderAndPurchaseOrder@218() : Code[20];
    VAR
      AssemblyHeader@1002 : Record 900;
      AssemblyLine@1001 : Record 901;
      ChildItem@1005 : Record 27;
      ParentItem@1004 : Record 27;
      PurchaseLine@1003 : Record 39;
      SupplyQty@1006 : Decimal;
    BEGIN
      SupplyQty := LibraryRandom.RandInt(5);
      CreateAssemblyItemAndBOMComponentSetup(ChildItem,ParentItem);
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,ParentItem."No.",'',LibraryRandom.RandInt(5),'');
      LibraryAssembly.AddCompInventory(AssemblyHeader,WORKDATE,SupplyQty); // Add Inventory = AssemblyLine.Quantity + SupplyQty for Component.
      FindAssemblyOrderLine(AssemblyLine,AssemblyHeader."No.",ChildItem."No.");
      AssemblyLine.ShowReservation;

      CreatePurchaseOrderWithReceiptDate(PurchaseLine,ChildItem."No.",LibraryRandom.RandInt(5));
      LibraryVariableStorage.Enqueue(AssemblyLine.Quantity); // Enqueue value to verify Gross Requirement.
      LibraryVariableStorage.Enqueue(PurchaseLine.Quantity); // Enqueue Value to verify Scheduled Receipt.
      LibraryVariableStorage.Enqueue(PurchaseLine.Quantity + SupplyQty); // Enqueue value to verify Inventory (Component on Inventory - Gross Requirement + Scheduled Receipt).
      EXIT(ParentItem."No.");
    END;

    LOCAL PROCEDURE InventorySetupWithLocationMandatory@157(LocationMandatory@1001 : Boolean);
    VAR
      InventorySetup@1000 : Record 313;
    BEGIN
      InventorySetup.GET;
      InventorySetup.VALIDATE("Location Mandatory",LocationMandatory);
      InventorySetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE NavigateFinishedProductionOrder@121(VAR Navigate@1001 : TestPage 344;ProductionOrderNo@1002 : Code[20]);
    VAR
      ProductionOrder@1000 : Record 5405;
    BEGIN
      ProductionOrder.GET(ProductionOrder.Status::Finished,ProductionOrderNo);
      Navigate.TRAP;
      ProductionOrder.Navigate;
    END;

    LOCAL PROCEDURE OpenAssemblyBOMFromItemCard@32(VAR AssemblyBOM@1002 : TestPage 36;ItemNo@1001 : Code[20]);
    VAR
      ItemCard@1000 : TestPage 30;
    BEGIN
      AssemblyBOM.TRAP;
      ItemCard.OPENEDIT;
      ItemCard.FILTER.SETFILTER("No.",ItemNo);
      ItemCard."Page Assembly BOM".INVOKE;
    END;

    LOCAL PROCEDURE OpenAssemblyAvailabilityPage@214(DocumentNo@1001 : Code[20]);
    VAR
      AssemblyOrder@1000 : TestPage 900;
    BEGIN
      AssemblyOrder.OPENVIEW;
      AssemblyOrder.FILTER.SETFILTER("No.",DocumentNo);
      AssemblyOrder.ShowAvailability.INVOKE;
      AssemblyOrder.OK.INVOKE;
    END;

    LOCAL PROCEDURE PrepareAndPostAssemblyOrder@83(VAR AssemblyHeader@1000 : Record 900;VAR AssemblyLine@1001 : Record 901;HeaderQtyFactor@1004 : Integer;CompQtyFactor@1003 : Integer;UpdateAllComps@1002 : Boolean);
    BEGIN
      AssemblyHeader.FIND;
      LibraryAssembly.PrepareOrderPosting(
        AssemblyHeader,AssemblyLine,HeaderQtyFactor,CompQtyFactor,UpdateAllComps,AssemblyHeader."Due Date");
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
    END;

    LOCAL PROCEDURE PostSalesDocument@229(DocumentType@1001 : Option;DocumentNo@1002 : Code[20];Ship@1003 : Boolean;Invoice@1004 : Boolean) : Code[20];
    VAR
      SalesHeader@1000 : Record 36;
    BEGIN
      SalesHeader.GET(DocumentType,DocumentNo);
      EXIT(LibrarySales.PostSalesDocument(SalesHeader,Ship,Invoice));
    END;

    LOCAL PROCEDURE RefreshAssemblyOrder@102(VAR AssemblyHeader@1000 : Record 900);
    BEGIN
      AssemblyHeader.FIND;
      LibraryAssembly.ReopenAO(AssemblyHeader);
      LibraryVariableStorage.Enqueue(ResetAssemblyLines);  // Enqueue for ConfirmHandler.
      AssemblyHeader.RefreshBOM;
    END;

    LOCAL PROCEDURE SelectItemSubstitutionOnAssemblyOrder@113(AssemblyOrderNo@1001 : Code[20]);
    VAR
      AssemblyOrder@1000 : TestPage 900;
    BEGIN
      AssemblyOrder.OPENEDIT;
      AssemblyOrder.FILTER.SETFILTER("No.",AssemblyOrderNo);
      AssemblyOrder.Lines.SelectItemSubstitution.INVOKE;
    END;

    LOCAL PROCEDURE ShowAssemblyListFromAssemblyLine@53(VAR AssemblyBOM@1003 : TestPage 36;DocumentNo@1002 : Code[20];No@1001 : Code[20]);
    VAR
      AssemblyLine@1000 : Record 901;
    BEGIN
      FindAssemblyOrderLine(AssemblyLine,DocumentNo,No);
      AssemblyBOM.TRAP;
      AssemblyLine.ShowAssemblyList;
    END;

    LOCAL PROCEDURE SetupAutomaticCostAdjustment@234();
    VAR
      InventorySetup@1000 : Record 313;
    BEGIN
      InventorySetup.GET;
      UpdateAutomaticCostPostAndAdjmtOnInventorySetup(
        InventorySetup."Automatic Cost Posting",InventorySetup."Automatic Cost Adjustment"::Always);
    END;

    LOCAL PROCEDURE UpdateAssemblyOrderNosOnAssemblySetup@9(NewAssemblyOrderNos@1001 : Code[10]);
    VAR
      AssemblySetup@1000 : Record 905;
    BEGIN
      AssemblySetup.GET;
      AssemblySetup.VALIDATE("Assembly Order Nos.",NewAssemblyOrderNos);
      AssemblySetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateAutomaticCostPostAndAdjmtOnInventorySetup@137(AutomaticCostPosting@1001 : Boolean;AutomaticCostAdjustment@1002 : Option);
    VAR
      InventorySetup@1000 : Record 313;
    BEGIN
      InventorySetup.GET;
      InventorySetup.VALIDATE("Automatic Cost Posting",AutomaticCostPosting);
      InventorySetup.VALIDATE("Automatic Cost Adjustment",AutomaticCostAdjustment);
      InventorySetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateAverageCostingMethodOnAssemblyItem@78(VAR AssemblyItem@1000 : Record 27);
    BEGIN
      AssemblyItem.VALIDATE("Costing Method",AssemblyItem."Costing Method"::Average);
      AssemblyItem.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCopyComponentDimensionsOnAssemblySetup@156(NewCopyComponentDimensionsFrom@1002 : Option);
    VAR
      AssemblySetup@1000 : Record 905;
    BEGIN
      AssemblySetup.GET;
      AssemblySetup.VALIDATE("Copy Component Dimensions from",NewCopyComponentDimensionsFrom);
      AssemblySetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateFixedResourceUsageTypeOnAssemblyBOM@56(VAR BOMComponent@1000 : Record 90;ParentItemNo@1001 : Code[20];Type@1002 : Option);
    BEGIN
      FindBOMComponent(BOMComponent,ParentItemNo,Type);
      BOMComponent.VALIDATE("Resource Usage Type",BOMComponent."Resource Usage Type"::Fixed);
      BOMComponent.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateFixedResourceUsageTypeOnAssemblyLine@120(AssemblyHeaderNo@1001 : Code[20];ResourceNo@1002 : Code[20]);
    VAR
      AssemblyLine@1000 : Record 901;
    BEGIN
      FindAssemblyOrderLine(AssemblyLine,AssemblyHeaderNo,ResourceNo);
      AssemblyLine.VALIDATE("Resource Usage Type",AssemblyLine."Resource Usage Type"::Fixed);
      AssemblyLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateInventoryForComponentItems@141(ItemNo@1000 : Code[20];Quantity@1001 : Decimal;QtyperUnitofMeasure@1002 : Decimal;ItemNo2@1003 : Code[20]);
    BEGIN
      CreateAndPostItemJournalLine(ItemNo,Quantity * Quantity * QtyperUnitofMeasure,'');  // Value required for Inventory using different Unit of Measure Conversion.
      CreateAndPostItemJournalLine(ItemNo2,Quantity * Quantity * QtyperUnitofMeasure,'');  // Value required for Inventory using different Unit of Measure Conversion.
    END;

    LOCAL PROCEDURE UpdateQuantityToAssembleOnAssemblyOrder@107(VAR AssemblyHeader@1000 : Record 900;QuantityToAssemble@1001 : Decimal);
    BEGIN
      AssemblyHeader.VALIDATE("Quantity to Assemble",QuantityToAssemble);
      AssemblyHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateStockOutWarningOnAssemblySetup@5(NewStockOutWarning@1001 : Boolean);
    VAR
      AssemblySetup@1000 : Record 905;
    BEGIN
      AssemblySetup.GET;
      AssemblySetup.VALIDATE("Stockout Warning",NewStockOutWarning);
      AssemblySetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdatePostingDateOnAssemblyHeader@98(VAR AssemblyHeader@1000 : Record 900;VAR AssemblyLine@1001 : Record 901);
    VAR
      NewPostingDate@1002 : Date;
    BEGIN
      AssemblyHeader.FIND;
      DeleteAssemblyCommentLine(AssemblyHeader."Document Type",AssemblyHeader."No.");
      NewPostingDate := CALCDATE('<-' + FORMAT(LibraryRandom.RandInt(5)) + 'D>',WORKDATE);
      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,AssemblyLine,40,40,FALSE,NewPostingDate);  // Less than WORKDATE.
    END;

    LOCAL PROCEDURE UpdateVariantOnAssemblyHeader@100(VAR AssemblyHeader@1000 : Record 900;VariantCode@1001 : Code[10]);
    BEGIN
      AssemblyHeader.VALIDATE("Variant Code",VariantCode);
      AssemblyHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateVariantOnAssemblyLine@99(VAR AssemblyLine@1001 : Record 901;VariantCode@1002 : Code[10]);
    BEGIN
      AssemblyLine.VALIDATE("Variant Code",VariantCode);
      AssemblyLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateQtyToAssembleOnSalesLine@169(VAR SalesLine@1000 : Record 37;QtyToAssemble@1001 : Decimal);
    BEGIN
      LibraryVariableStorage.Enqueue(STRSUBSTNO(BeforeWorkDateMsg,WORKDATE));
      SalesLine.VALIDATE("Qty. to Assemble to Order",QtyToAssemble);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateDimensionValueOnSalesLine@164(VAR SalesLine@1000 : Record 37;DimensionValueCode@1001 : Code[20];DimensionValueCode2@1002 : Code[20]);
    BEGIN
      LibraryVariableStorage.Enqueue(UpdateDimConfirmQst);
      LibraryVariableStorage.Enqueue(UpdateDimConfirmQst);
      SalesLine.VALIDATE("Shortcut Dimension 1 Code",DimensionValueCode);
      SalesLine.VALIDATE("Shortcut Dimension 2 Code",DimensionValueCode2);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateQtyPerOnAssemblyLine@187(VAR AssemblyLine@1000 : Record 901;QuantityPer@1001 : Decimal);
    BEGIN
      AssemblyLine.VALIDATE("Quantity per",QuantityPer);
      AssemblyLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemDimensionWithValuePosting@197(VAR DefaultDimension@1005 : Record 352;ItemNo@1002 : Code[20];DefaultValuePosting@1001 : Option);
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1004 : Record 349;
    BEGIN
      LibraryDimension.CreateDimension(Dimension);
      LibraryDimension.CreateDimensionValue(DimensionValue,Dimension.Code);
      LibraryDimension.CreateDefaultDimensionItem(DefaultDimension,ItemNo,Dimension.Code,DimensionValue.Code);
      DefaultDimension.VALIDATE("Value Posting",DefaultValuePosting);
      DefaultDimension.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemWithProdBOMNo@174(ItemNo@1000 : Code[20];ProductionBOMNo@1001 : Code[20]);
    VAR
      Item@1002 : Record 27;
    BEGIN
      Item.GET(ItemNo);
      Item.VALIDATE("Production BOM No.",ProductionBOMNo);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdatePostingDateOnSalesHeader@196(VAR SalesHeader@1003 : Record 36;DocumentType@1000 : Option;DocumentNo@1001 : Code[20];PostingDate@1002 : Date);
    BEGIN
      SalesHeader.GET(DocumentType,DocumentNo);
      SalesHeader.VALIDATE("Posting Date",PostingDate);
      SalesHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateQtyPerOnAssemblyLineAndPostSalesDocument@226(SalesLine@1000 : Record 37;Ship@1001 : Boolean;Invoice@1002 : Boolean);
    VAR
      BOMComponent@1003 : Record 90;
      AssemblyLine@1004 : Record 901;
      SalesHeader@1006 : Record 36;
    BEGIN
      FindBOMComponent(BOMComponent,SalesLine."No.",BOMComponent.Type::Item);
      FindAssemblyLine(AssemblyLine,BOMComponent);
      AssemblyLine.VALIDATE("Quantity per",AssemblyLine."Quantity per" / LibraryRandom.RandIntInRange(3,5));
      AssemblyLine.MODIFY(TRUE);
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");
      LibrarySales.PostSalesDocument(SalesHeader,Ship,Invoice);
    END;

    LOCAL PROCEDURE UpdateQuantityToConsumeOnAssemblyLine@205(VAR AssemblyLine@1000 : Record 901;AsmItemNo@1001 : Code[20]);
    VAR
      BOMComponent@1004 : Record 90;
    BEGIN
      FindBOMComponents(BOMComponent,AsmItemNo);
      FindAssemblyLine(AssemblyLine,BOMComponent);
      AssemblyLine.VALIDATE("Quantity to Consume",0); // Update Quantity to Consume as zero.
      AssemblyLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UndoSalesShipmentLine@202(DocumentNo@1000 : Code[20]);
    VAR
      SalesShipmentLine@1002 : Record 111;
    BEGIN
      LibraryVariableStorage.Enqueue(UndoShipmentConfirmationMsg);  // UndoShipmentMsg used in ConfirmHandler.
      LibraryVariableStorage.Enqueue(STRSUBSTNO(BeforeWorkDateMsg,WORKDATE)); // BeforeWorkDateMsg used in Messagehandler
      SalesShipmentLine.SETRANGE("Document No.",DocumentNo);
      LibrarySales.UndoSalesShipmentLine(SalesShipmentLine);
    END;

    LOCAL PROCEDURE UpdateApplToItemEntryOnAssemblyLine@212(VAR AssemblyLine@1000 : Record 901;ItemNo@1003 : Code[20]);
    VAR
      ItemLedgerEntry@1001 : Record 32;
      BOMComponent@1002 : Record 90;
    BEGIN
      FindBOMComponent(BOMComponent,ItemNo,BOMComponent.Type::Item);
      FindAssemblyLine(AssemblyLine,BOMComponent);
      FindItemLedgerEntry(ItemLedgerEntry,ItemLedgerEntry."Entry Type"::"Positive Adjmt.",AssemblyLine."No.");
      AssemblyLine.VALIDATE("Appl.-to Item Entry",ItemLedgerEntry."Entry No.");
      AssemblyLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateApplToEntryByPage@232(ItemJournalBatchName@1001 : Code[20]);
    VAR
      ItemJournalPage@1000 : TestPage 40;
    BEGIN
      ItemJournalPage.OPENEDIT;
      ItemJournalPage.CurrentJnlBatchName.SETVALUE(ItemJournalBatchName);
      ItemJournalPage."Applies-to Entry".LOOKUP;
      ItemJournalPage.OK.INVOKE;
    END;

    LOCAL PROCEDURE UpdateQuantityOnSalesLineByPage@237(SalesHeaderNo@1000 : Code[20];Qty@1001 : Decimal;SalesLineQty@1003 : Decimal);
    VAR
      SalesOrder@1002 : TestPage 42;
    BEGIN
      SalesOrder.OPENEDIT;
      SalesOrder.FILTER.SETFILTER("No.",SalesHeaderNo);
      SalesOrder.SalesLines.FILTER.SETFILTER(Quantity,FORMAT(SalesLineQty));
      SalesOrder.SalesLines.Quantity.SETVALUE(Qty);
      SalesOrder.OK.INVOKE;
    END;

    LOCAL PROCEDURE VerifyAvailabilityOnSalesOrderPage@215(DocumentNo@1001 : Code[20];ItemNo@1002 : Code[20];AvailQty@1003 : Decimal);
    VAR
      SalesOrder@1000 : TestPage 42;
    BEGIN
      SalesOrder.OPENVIEW;
      SalesOrder.FILTER.SETFILTER("No.",DocumentNo);
      SalesOrder.SalesLines.FILTER.SETFILTER("No.",ItemNo);
      SalesOrder."Sales Line FactBox"."Item Availability".ASSERTEQUALS(AvailQty);
      SalesOrder.OK.INVOKE;
    END;

    LOCAL PROCEDURE VerifyAssemblyBOM@39(VAR AssemblyBOM@1000 : TestPage 36;BomComponent@1004 : Record 90);
    BEGIN
      AssemblyBOM.FILTER.SETFILTER("No.",BomComponent."No.");
      AssemblyBOM."No.".ASSERTEQUALS(BomComponent."No.");
      AssemblyBOM."Quantity per".ASSERTEQUALS(BomComponent."Quantity per");
      BomComponent.CALCFIELDS("Assembly BOM");
      AssemblyBOM."Assembly BOM".ASSERTEQUALS(BomComponent."Assembly BOM");
    END;

    LOCAL PROCEDURE VerifyAssemblyItemDetailsOnAssemblyOrder@103(Item@1001 : Record 27;No@1002 : Code[20]);
    VAR
      AssemblyOrder@1000 : TestPage 900;
    BEGIN
      AssemblyOrder.OPENEDIT;
      AssemblyOrder.FILTER.SETFILTER("No.",No);
      AssemblyOrder."Assembly Item - Details"."Standard Cost".ASSERTEQUALS(Item."Standard Cost");
      AssemblyOrder."Assembly Item - Details"."Unit Price".ASSERTEQUALS(Item."Unit Price");
    END;

    LOCAL PROCEDURE VerifyAssemblyLine@29(ParentItemNo@1002 : Code[20];Quantity@1003 : Decimal);
    VAR
      AssemblyLine@1001 : Record 901;
      BOMComponent@1000 : Record 90;
      Quantity2@1004 : Decimal;
    BEGIN
      FindBOMComponents(BOMComponent,ParentItemNo);
      REPEAT
        Quantity2 := Quantity;
        FindAssemblyLine(AssemblyLine,BOMComponent);
        AssemblyLine.TESTFIELD("Quantity per",BOMComponent."Quantity per");
        IF AssemblyLine."Resource Usage Type" = AssemblyLine."Resource Usage Type"::Fixed THEN
          Quantity2 := 1;  // Value 1 required for the test.
        AssemblyLine.TESTFIELD(Quantity,ROUND(BOMComponent."Quantity per" * Quantity2,0.00001));  // Calculated value required for the test.
      UNTIL BOMComponent.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyBOMComponentAfterExplodeBOM@21(ParentItemNo@1001 : Code[20];ComponentItemNo@1003 : Code[20];QuantityPer@1004 : Decimal);
    VAR
      BOMComponent@1000 : Record 90;
      BOMComponent2@1002 : Record 90;
    BEGIN
      FindBOMComponents(BOMComponent,ComponentItemNo);
      REPEAT
        BOMComponent2.SETRANGE("No.",BOMComponent."No.");
        FindBOMComponent(BOMComponent2,ParentItemNo,BOMComponent.Type);
        BOMComponent2.TESTFIELD("Quantity per",BOMComponent."Quantity per" * QuantityPer);  // Calculate Quantity per from Component Assembly BOM.
      UNTIL BOMComponent.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyBOMComponentsOnAssemblyBOM@106(VAR AssemblyBOM@1001 : TestPage 36;ItemNo@1000 : Code[20]);
    VAR
      BOMComponent@1002 : Record 90;
    BEGIN
      FindBOMComponents(BOMComponent,ItemNo);
      REPEAT
        AssemblyBOM."No.".ASSERTEQUALS(BOMComponent."No.");
        AssemblyBOM."Quantity per".ASSERTEQUALS(BOMComponent."Quantity per");
        AssemblyBOM.NEXT;
      UNTIL BOMComponent.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyComponentDetailsOnAssemblyBOM@25(VAR AssemblyBOM@1000 : TestPage 36;ItemNo@1001 : Code[20];UnitPrice@1002 : Text;UnitCost@1003 : Text;ResourceNo@1004 : Code[20];ResourceType@1005 : Text;UnitCost2@1006 : Text);
    BEGIN
      AssemblyBOM."Component - Item Details"."No.".ASSERTEQUALS(ItemNo);
      AssemblyBOM."Component - Item Details"."Unit Price".ASSERTEQUALS(FORMAT(UnitPrice));
      AssemblyBOM."Component - Item Details"."Unit Cost".ASSERTEQUALS(FORMAT(UnitCost));
      AssemblyBOM."Component - Resource Details"."No.".ASSERTEQUALS(ResourceNo);
      AssemblyBOM."Component - Resource Details".Type.ASSERTEQUALS(ResourceType);
      AssemblyBOM."Component - Resource Details"."Unit Cost".ASSERTEQUALS(FORMAT(UnitCost2));
    END;

    LOCAL PROCEDURE VerifyComponentItemDetailsOnAssemblyOrder@105(Item@1000 : Record 27;No@1002 : Code[20]);
    VAR
      AssemblyOrder@1003 : TestPage 900;
    BEGIN
      FilterAssemblyOrderLine(AssemblyOrder,No,Item."No.");
      AssemblyOrder."Component - Item FactBox"."Unit Price".ASSERTEQUALS(Item."Unit Price");
      AssemblyOrder."Component - Item FactBox"."Unit Cost".ASSERTEQUALS(Item."Unit Cost");
    END;

    LOCAL PROCEDURE VerifyComponentResourceDetailsOnAssemblyOrder@104(Resource@1002 : Record 156;No@1001 : Code[20]);
    VAR
      AssemblyOrder@1000 : TestPage 900;
    BEGIN
      FilterAssemblyOrderLine(AssemblyOrder,No,Resource."No.");
      AssemblyOrder."Component - Resource Details".Type.ASSERTEQUALS(Resource.Type);
      AssemblyOrder."Component - Resource Details"."Unit Cost".ASSERTEQUALS(Resource."Unit Cost");
    END;

    LOCAL PROCEDURE VerifyGLEntry@140(AssemblyItem@1006 : Record 27;AssemblyHeaderNo@1001 : Code[20]);
    VAR
      PostedAssemblyHeader@1000 : Record 910;
      InventoryPostingSetup@1005 : Record 5813;
      GeneralPostingSetup@1002 : Record 252;
    BEGIN
      InventoryPostingSetup.GET('',AssemblyItem."Inventory Posting Group");
      GeneralPostingSetup.GET('',AssemblyItem."Gen. Prod. Posting Group");
      FindPostedAssemblyHeader(PostedAssemblyHeader,AssemblyHeaderNo,AssemblyItem."No.");
      LibraryAssembly.VerifyGLEntry(
        PostedAssemblyHeader."No.",InventoryPostingSetup."Inventory Account",PostedAssemblyHeader."Due Date",
        PostedAssemblyHeader."Cost Amount",'>');
      LibraryAssembly.VerifyGLEntry(
        PostedAssemblyHeader."No.",GeneralPostingSetup."Inventory Adjmt. Account",PostedAssemblyHeader."Due Date",
        -PostedAssemblyHeader."Cost Amount",'<');
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntries@270(ItemNo@1000 : Code[20];AdjustedQuantity@1002 : Decimal);
    VAR
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      WITH ItemLedgerEntry DO BEGIN
        SETRANGE("Item No.",ItemNo);
        FINDSET;
        REPEAT
          CALCFIELDS("Cost Amount (Actual)");
          IF Positive THEN
            Assert.AreNearlyEqual(AdjustedQuantity,"Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,CostAmountErr)
          ELSE
            Assert.AreNearlyEqual(-AdjustedQuantity,"Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,CostAmountErr)
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE VerifyNoOfRecordsAfterNavigate@122(Navigate@1000 : TestPage 344;TableName@1001 : Text[50]);
    BEGIN
      Navigate.FILTER.SETFILTER("Table Name",TableName);
      Navigate."No. of Records".ASSERTEQUALS(1);  // Only 1 Record found for each Posted Table.
    END;

    LOCAL PROCEDURE VerifyQuantityOnAssemblyOrder@154(AssemblyHeader@1001 : Record 900;QuantityToAssemble@1002 : Decimal;ConsumedQuantity@1003 : Decimal;RemainingQuantity@1000 : Decimal);
    VAR
      BOMComponent@1004 : Record 90;
      AssemblyLine@1005 : Record 901;
    BEGIN
      AssemblyHeader.TESTFIELD("Quantity to Assemble",QuantityToAssemble);
      FindBOMComponent(BOMComponent,AssemblyHeader."Item No.",BOMComponent.Type::Item);
      FindAssemblyLine(AssemblyLine,BOMComponent);
      AssemblyLine.TESTFIELD("Consumed Quantity",ConsumedQuantity);
      AssemblyLine.TESTFIELD("Remaining Quantity",RemainingQuantity);
    END;

    LOCAL PROCEDURE VerifyQuantityToConsumeOnAssemblyLine@108(ItemNo@1002 : Code[20];QuantityToAssemble@1004 : Decimal);
    VAR
      AssemblyLine@1001 : Record 901;
      BOMComponent@1000 : Record 90;
      Quantity@1003 : Decimal;
    BEGIN
      FindBOMComponents(BOMComponent,ItemNo);
      REPEAT
        Quantity := QuantityToAssemble;
        FindAssemblyLine(AssemblyLine,BOMComponent);
        IF AssemblyLine."Resource Usage Type" = AssemblyLine."Resource Usage Type"::Fixed THEN
          Quantity := 1;  // Value required for the test.
        AssemblyLine.TESTFIELD("Quantity to Consume",AssemblyLine."Quantity per" * Quantity);  // Value required for the test.
      UNTIL BOMComponent.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyReleasedProductionOrderLine@119(ProductionOrder@1001 : Record 5405) : Integer;
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderLine.SETRANGE("Item No.",ProductionOrder."Source No.");
      ProdOrderLine.FINDFIRST;
      ProdOrderLine.TESTFIELD(Quantity,ProductionOrder.Quantity);
      EXIT(ProdOrderLine."Line No.");
    END;

    LOCAL PROCEDURE VerifySalesCreditMemoLine@45(SalesLine@1004 : Record 37);
    VAR
      SalesCrMemoLine@1000 : Record 115;
    BEGIN
      SalesCrMemoLine.SETRANGE("Sell-to Customer No.",SalesLine."Sell-to Customer No.");
      SalesCrMemoLine.FINDFIRST;
      SalesCrMemoLine.TESTFIELD("No.",SalesLine."No.");
      SalesCrMemoLine.TESTFIELD(Quantity,SalesLine.Quantity);
    END;

    LOCAL PROCEDURE VerifyPostedAssemblyOrderStatistics@136(AssemblyHeaderNo@1002 : Code[20];ItemNo@1003 : Code[20];ResourceNo@1004 : Code[20]);
    VAR
      PostedAssemblyHeader@1001 : Record 910;
      PostedAssemblyLine@1005 : Record 911;
      PostedAsmOrderStatistics@1000 : TestPage 923;
    BEGIN
      PostedAsmOrderStatistics.TRAP;
      FindPostedAssemblyHeader(PostedAssemblyHeader,AssemblyHeaderNo,ItemNo);
      PostedAssemblyHeader.ShowStatistics;
      FindPostedAssemblyResourceLine(PostedAssemblyLine,PostedAssemblyHeader."No.",ResourceNo);

      // Verify Expected Resource Cost and Expected Total Cost.
      PostedAsmOrderStatistics.ExpResCost.ASSERTEQUALS(PostedAssemblyLine.Quantity * PostedAssemblyLine."Unit Cost");  // Calculated Value Required for Expected Resource Cost.
      PostedAsmOrderStatistics.ExpTotalCost.ASSERTEQUALS(PostedAssemblyLine.Quantity * PostedAssemblyLine."Unit Cost");  // Calculated Value Required for Expected Total Cost.

      // Verify Actual Resource Cost and Actual Total Cost.
      PostedAsmOrderStatistics.ActResCost.ASSERTEQUALS(PostedAssemblyLine.Quantity * PostedAssemblyLine."Unit Cost");  // Calculated Value Required for Actual Resource Cost.
      PostedAsmOrderStatistics.ActTotalCost.ASSERTEQUALS(PostedAssemblyLine.Quantity * PostedAssemblyLine."Unit Cost");  // Calculated Value Required for Actual Total Cost.
    END;

    LOCAL PROCEDURE VerifyStatisticsPage@116(VAR AssemblyHeader@1001 : Record 900;ItemNo@1003 : Code[20];ResourceNo@1004 : Code[20]);
    VAR
      AssemblyLine@1002 : Record 901;
      AssemblyOrderStatistics@1000 : TestPage 916;
    BEGIN
      AssemblyOrderStatistics.TRAP;
      AssemblyHeader.ShowStatistics;

      // Verify Expected Material Cost.
      FindAssemblyOrderLine(AssemblyLine,AssemblyHeader."No.",ItemNo);
      AssemblyOrderStatistics.ExpMatCost.ASSERTEQUALS(AssemblyLine.Quantity * AssemblyLine."Unit Cost");  // Calculated Value Required for Expected Material Cost.

      // Verify Expected Resource Cost.
      FindAssemblyOrderLine(AssemblyLine,AssemblyHeader."No.",ResourceNo);
      AssemblyOrderStatistics.ExpResCost.ASSERTEQUALS(AssemblyLine.Quantity * AssemblyLine."Unit Cost");  // Calculated Value Required for Expected Resource Cost.

      // Verify Expected Total Cost.
      AssemblyOrderStatistics.ExpTotalCost.ASSERTEQUALS(AssemblyHeader."Cost Amount");  // Calculated Value Required for Expected Total Cost.
    END;

    LOCAL PROCEDURE VerifyDimensionOnAssemblyHeader@179(AssemblyHeader@1000 : Record 900;DimensionValueCode@1001 : Code[20];DimensionValueCode2@1002 : Code[20]);
    BEGIN
      AssemblyHeader.TESTFIELD("Shortcut Dimension 1 Code",DimensionValueCode);
      AssemblyHeader.TESTFIELD("Shortcut Dimension 2 Code",DimensionValueCode2);
    END;

    LOCAL PROCEDURE VerifyDimensionOnILE@182(ItemLedgerEntry@1000 : Record 32;DimensionValueCode@1001 : Code[20];DimensionValueCode2@1002 : Code[20]);
    BEGIN
      ItemLedgerEntry.TESTFIELD("Global Dimension 1 Code",DimensionValueCode);
      ItemLedgerEntry.TESTFIELD("Global Dimension 2 Code",DimensionValueCode2);
    END;

    LOCAL PROCEDURE VerifyInvoicedQtyOnItemLedgerEntry@180(EntryType@1001 : Option;ItemNo@1000 : Code[20];InvoicedQty@1003 : Decimal);
    VAR
      ItemLedgerEntry@1002 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,EntryType,ItemNo);
      ItemLedgerEntry.TESTFIELD("Invoiced Quantity",InvoicedQty);
    END;

    LOCAL PROCEDURE VerifyQtyOnValueEntry@165(ValueEntry@1002 : Record 5802;InvoicedQty@1001 : Decimal);
    BEGIN
      ValueEntry.TESTFIELD("Valued Quantity",InvoicedQty);
      ValueEntry.TESTFIELD("Invoiced Quantity",InvoicedQty);
    END;

    LOCAL PROCEDURE VerifyQuantityAndCostAmountOnAssemblyLine@192(AssemblyLine@1000 : Record 901;QuantityPer@1001 : Decimal;AssemblyHeaderQuantity@1002 : Decimal);
    BEGIN
      WITH AssemblyLine DO BEGIN
        TESTFIELD("Quantity per",QuantityPer);
        TESTFIELD(Quantity,"Quantity per" * AssemblyHeaderQuantity);
        TESTFIELD("Remaining Quantity",Quantity);
        TESTFIELD("Quantity to Consume",Quantity);
        TESTFIELD("Quantity (Base)",Quantity * "Qty. per Unit of Measure");
        TESTFIELD("Remaining Quantity (Base)","Remaining Quantity" * "Qty. per Unit of Measure");
        TESTFIELD("Quantity to Consume (Base)","Quantity to Consume" * "Qty. per Unit of Measure");
        TESTFIELD("Cost Amount",Quantity * "Unit Cost");
      END;
    END;

    LOCAL PROCEDURE VerifyStandardCostOnAssemblyItem@186(ItemNo@1000 : Code[20];StandardCost@1001 : Decimal);
    VAR
      Item@1002 : Record 27;
    BEGIN
      Item.GET(ItemNo);
      Item.TESTFIELD("Standard Cost",StandardCost);
    END;

    LOCAL PROCEDURE VerifySalesShipmentLines@210(DocumentNo@1000 : Code[20];ItemNo@1004 : Code[20];Qty@1001 : Decimal);
    VAR
      SalesShipmentLine@1002 : Record 111;
    BEGIN
      WITH SalesShipmentLine DO BEGIN
        SETRANGE("Document No.",DocumentNo);
        SETRANGE("No.",ItemNo);
        FINDSET;
        TESTFIELD(Quantity,Qty);
        NEXT;
        TESTFIELD(Quantity,-Qty);
      END;
    END;

    LOCAL PROCEDURE VerifyPostingDateOnItemLedgerEntry@203(EntryType@1001 : Option;ItemNo@1000 : Code[20];PostingDate@1003 : Date);
    VAR
      ItemLedgerEntry@1002 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,EntryType,ItemNo);
      ItemLedgerEntry.TESTFIELD("Posting Date",PostingDate);
    END;

    LOCAL PROCEDURE VerifyCostAmountActualInILE@286(EntryType@1000 : Option;ItemNo@1002 : Code[20];CostAmountActual@1001 : Decimal);
    VAR
      ItemLedgerEntry@1003 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,EntryType,ItemNo);
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      ItemLedgerEntry.TESTFIELD("Cost Amount (Actual)",CostAmountActual);
      ItemLedgerEntry.NEXT;
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      ItemLedgerEntry.TESTFIELD("Cost Amount (Actual)",-CostAmountActual);
    END;

    LOCAL PROCEDURE VerifyCostAmountActualForAssemblyOutputAndSaleILE@293(ItemNo@1002 : Code[20];CostAmountActual@1001 : Decimal);
    VAR
      ItemLedgerEntry@1003 : Record 32;
    BEGIN
      VerifyCostAmountActualInILE(ItemLedgerEntry."Entry Type"::"Assembly Output",ItemNo,CostAmountActual);
      VerifyCostAmountActualInILE(ItemLedgerEntry."Entry Type"::Sale,ItemNo,-CostAmountActual);
    END;

    LOCAL PROCEDURE VerifyCostAmountInLastILE@221(EntryType@1000 : Option;ItemNo@1002 : Code[20];CostAmountExpected@1001 : Decimal;CostAmountActual@1004 : Decimal);
    VAR
      ItemLedgerEntry@1003 : Record 32;
    BEGIN
      FindLastItemLedgerEntry(ItemLedgerEntry,EntryType,ItemNo);
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Expected)","Cost Amount (Actual)");
      ItemLedgerEntry.TESTFIELD("Cost Amount (Expected)",CostAmountExpected);
      ItemLedgerEntry.TESTFIELD("Cost Amount (Actual)",CostAmountActual);
    END;

    LOCAL PROCEDURE VerifyOrderTypeOnItemJournalLine@239(EntryType@1001 : Option;ItemNo@1000 : Code[20];OrderType@1003 : Option);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      FindItemJournalLine(ItemJournalLine,EntryType,ItemNo);
      ItemJournalLine.TESTFIELD("Order Type",OrderType);
    END;

    LOCAL PROCEDURE VerifyApplToEntryOnILE@235(EntryType@1000 : Option;ItemNo@1002 : Code[20];ApplToEntry@1001 : Integer);
    VAR
      ItemLedgerEntry@1003 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,EntryType,ItemNo);
      ItemLedgerEntry.TESTFIELD("Applies-to Entry",ApplToEntry);
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@76(ConfirmMessage@1000 : Text[1024];VAR Reply@1001 : Boolean);
    VAR
      ExpectedMessage@1002 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ExpectedMessage);
      Assert.IsTrue(STRPOS(ConfirmMessage,ExpectedMessage) > 0,ConfirmMessage);
      Reply := TRUE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemSubstitutionEntriesPageHandler@130(VAR ItemSubstitutionEntries@1000 : TestPage 5718);
    BEGIN
      ItemSubstitutionEntries.OK.INVOKE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@125(Message@1000 : Text[1024]);
    VAR
      DequeueVariable@1002 : Variant;
      LocalMessage@1001 : Text[1024];
    BEGIN
      LibraryVariableStorage.Dequeue(DequeueVariable);
      LocalMessage := DequeueVariable;
      Assert.IsTrue(STRPOS(Message,LocalMessage) > 0,Message);
    END;

    [ModalPageHandler]
    PROCEDURE PostedSalesDocumentLinesPageHandler@175(VAR PostedSalesDocumentLines@1000 : TestPage 5850);
    BEGIN
      PostedSalesDocumentLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ProductionJournalPageHandler@128(VAR ProductionJournal@1000 : TestPage 5510);
    BEGIN
      LibraryVariableStorage.Enqueue(PostJournalLinesConfirm);  // Enqueue for ConfirmHandler.
      LibraryVariableStorage.Enqueue(JournalLinesSuccessfullyPosted);  // Enqueue for MessageHandler.
      ProductionJournal.Post.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ReservationPageHandler@159(VAR Reservation@1000 : TestPage 498);
    BEGIN
      Reservation."Auto Reserve".INVOKE;
      Reservation.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemLedgerEntriesPageHandler@233(VAR ItemLedgerEntries@1000 : TestPage 38);
    VAR
      EntryNo@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(EntryNo);
      ItemLedgerEntries.FILTER.SETFILTER("Entry No.",FORMAT(EntryNo));
      ItemLedgerEntries.OK.INVOKE;
    END;

    [StrMenuHandler]
    PROCEDURE CalculateStandardCostMenuHandler@190(Option@1005 : Text[1024];VAR Choice@1004 : Integer;Instruction@1003 : Text[1024]);
    VAR
      OptionCount@1000 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(OptionCount);
      Choice := OptionCount;
    END;

    [ModalPageHandler]
    PROCEDURE AvailabilityWindowHandler@216(VAR AsmAvailability@1000 : TestPage 908);
    VAR
      GrossRequirement@1001 : Variant;
      ScheduledReceipt@1002 : Variant;
      ExpectedInventory@1003 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(GrossRequirement);
      LibraryVariableStorage.Dequeue(ScheduledReceipt);
      LibraryVariableStorage.Dequeue(ExpectedInventory);
      AsmAvailability.AssemblyLineAvail.GrossRequirement.ASSERTEQUALS(GrossRequirement);
      AsmAvailability.AssemblyLineAvail.ScheduledReceipt.ASSERTEQUALS(ScheduledReceipt);
      AsmAvailability.AssemblyLineAvail.ExpectedAvailableInventory.ASSERTEQUALS(ExpectedInventory);
      AsmAvailability.Yes.INVOKE;
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [SCM]
      Test Cases for Kitting.
       1. Test and verify Error on Update Fixed Resource Usage Type with Item Type.
       2. Test and verify Error on Update Fixed Resource Usage Type with Blank Type.
       3. Test and verify Calculate Standard Cost after Copy Assembly BOM.
       4. Test and verify Calculate Unit Price after Copy Assembly BOM.
       5. Test and verify Error on Explode Assembly BOM with Resource Type.
       6. Test and verify Error on Explode Assembly BOM with Blank Type.
       7. Test and verify Error on Explode Assembly BOM with Item Type.
       8. Test and verify Explode Assembly BOM Component.
       9. Test and verify Calculate Standard Cost with Resource Price.
      10. Test and verify Calculate Unit Price with Resource Price.
      11. Test and verify Assembly Line after creating Assembly Order of Assembly Item.
      12. Test and verify Assembly List from Assembly Order for Component Item by page.
      13. Test and verify error on invoking Assembly List for Resource.
      14. Test and verify error on creating Assembly Order with blank Assembly Order Nos. on Assembly setup.
      15. Test and verify Assembly Order No. after creating Assembly Order by page.
      16. Test and verify posting of Sales Return Order of Assembly Item.
      17. Test and verify posting of Assembly Order after posting Sales Return Order of Assembly Item.
      18. Test and verify Assembly List from Assembly Order for Assembly Item by page.
      19. Test and verify Component Item Details on Assembly BOM page of Assembly Item.
      20. Test and verify Component Resource Details on Assembly BOM page of Assembly Item.
      21. Test and verify Post Assembly Order using Dimension and Multiple Unit of Measures.
      22. Test and verify Error on Creating Assembly Order with Posted Assembly Order No using Dimension.
      23. Test and verify Error on Posting Assembly Order before Explode Assembly List with Dimension.
      24. Test and verify Post Assembly Order after Explode Assembly List with Dimension.
      25. Test and verify Error on Posting Assembly Order after Delete Assembly Lines using Dimension.
      26. Test and verify Calculate Standard Cost with Sales Discount.
      27. Test and verify Calculate Unit Price with Sales Discount.
      28. Test and verify Calculate Standard Cost with Sales Price.
      29. Test and verify Calculate Unit Price with Sales Price.
      30. Test and verify Post Partial Assembly Order using Dimension and Multiple Unit of Measures.
      31. Test and verify Post Partial Assembly Order after Modifying Posting Date on Assembly Header.
      32. Test and verify Statistics Page after update Unit Cost and Posting Partial Assembly Order.
      33. Test and verify Post Assembly Order after Deleting Partial Quantity to Assemble and Update Resource Type Usage.
      34. Test and verify Post Partial Assembly Order after Deleting Assembly Line.
      35. Test and verify Post Assembly Order using Variant.
      36. Test and verify Assembly Item Details on Assembly BOM page of Assembly Item.
      37. Test and verify creation and updating of Variant on Assembly Header after Assembly Order gets created.
      38. Test and verify creation and updating of Component Variant on Assembly Line after Assembly Order gets created.
      39. Test and verify error on updating Variant code on Assembly Line for Resource.
      40. Test and verify Assembly Item Details on Assembly Order page.
      41. Test and verify Component Item Details on Assembly Order page.
      42. Test and verify Component Resource Details on Assembly Order page.
      43. Test and verify Assembly List from Assembly Order by page.
      44. Test and verify Quantity to consume on Assembly line gets updated on modifying Quantity to Assemble on Assembly Order.
      45. Test and verify deletion of Assembly Order after partial posting.
      46. Test and verify Item Substitution on Assembly Order with Dimension.
      47. Test and verify Post Assembly Order with Dimension and Item Substitution.
      48. Test and verify Released Production Order after Posted Assembly Order with Dimension.
      49. Test and verify Navigate Finished Production Order after Posted Assembly Order with Dimension.
      50. Test and verify Post Assembly Order with Dimension and Same Component Item Twice.
      51. Test and verify Posted Assembly Order Statistics Page after Calculate Standard Cost and Unit Price on Assembly BOM.
      52. Test and verify Post Partial Assembly Order after Adjust Cost Item Entries with Automatic Cost Posting.
      53. Test and verify GL Entry after Post Inventory Cost to GL and Post Assembly Order with Manual Automatic Cost Posting.
      54. Test and verify GL Entry after Post Inventory Cost to GL with Manual Automatic Cost Posting and Automatic Cost Adjustment.
      55. Test and verify GL Entry after Post Inventory Cost to GL with Manual Automatic Cost Posting and Manual Cost Adjustment.
      56. Test and verify GL Entry after Post Assembly Order with Automatic Cost Posting and Automatic Cost Adjustment.
      57. Test and verify partial posting of Assembly Order with Dimensions.
      58. Test and verify posting of remaining Assembly Order with Dimensions.
      59. Test and verify error on deleting Item after posting Sales Order with reservation after posting Assembly Order with Dimensions.
      60. Test and verify error on deleting Item after closing Fiscal Year and posting Sales Order with reservation and Dimensions.
      61. Test and verify that Unit cost is not adjusted on running Adjust Cost Item entries job when Dimension Combination is blocked.
      62. Test and verify Assembly Order posted successfully with Resource without Location when Location Mandatory is True.
      63. Test and verify dimensions are populated on Assembly Order header when this is created from a sales order.
      64. Test and verify dimensions are populated on Assembly Order header when the dimensions on related sales line are updated.
      65. Test and verify dimensions are populated in Item Ledger Entry of Assembly Output Type.
      66. Test and verify "Explode BOM" in Assembly Order considers current "Quantity" from the line being exploded.
      67. Test and verify "Explode BOM" in Assembly Order considers current "Qty. Per Unit of Measure" from the line being exploded.
      68. Test and verify Invoiced Quantity in Item Ledger Entry and Quantity in Value Entry after partially Invoicing Sales Order with Assembly Item.
      69. Test and verify Calc. Standard Cost is working on Assembly Item when the Assembly BOM contains the Item whose Production BOM contains another Production BOM.
      70. Test and verify no error pops up when posting Assembly Order with Dimension after explode BOM.
      71. Test and verify the Posting Date on Assembly order will be updated when the Posting Date on the related Sales Order is updated.
      72. Test and verify the Posting Date on Assembly Order cannot be later than the Posting Date of its related Sales Order.
      73. Test and verify the Posting Date on Assembly Order will be the same as the Posting Date on the related Sales Header
          when the Posting Date on Sales Header is updated before Assembly Order is created.
      74. Test and verify Cost Adjustment, and Cost Actual Amounts in Item Ledger Entry on repost modified assembly item in Sales Order.
      75. Test and verify Sales Shipment Line with Assembly Item can be undone successfully when the component Item on Assembly Order Line haven't been fully consumed.
      76. Test and verify it shows the right availability in the Sales Line Details factbox when reservation exists.
      77. Test and verify it shows right values for Assembly Availiability when reservation exists.
      78. Test and verify Appl.-to Item Entry is correct in Item Ledger Entry when Assembly Order is posted.
      79. Test and verify Order Type is correct on Item Journal Line after running "Calc. Inventory Value" from Revaluation Journal for undone posted Assembly Order.
      80. Test and verify Applies-to Entry is correct on Item Ledger Entry after posting Item Journal that apply to undone Assembly Consumption Line from ILE page.
      81. Test and verify it should not pop up Check Availability window when there is enough Inventory for Sales Order with Reservation.

      Covers Test Cases for WI - 319177
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      ErrorOnUpdateFixedResourceUsageTypeWithItemType, ErrorOnUpdateFixedResourceUsageTypeWithBlankType  230890
      CalculateStandardCostAfterCopyAssemblyBOM, CalculateUnitPriceAfterCopyAssemblyBOM                  230888
      ErrorOnExplodeAssemblyBOMWithResourceType, ErrorOnExplodeAssemblyBOMWithBlankType                  230887
      ErrorOnExplodeAssemblyBOMWithItemType                                                              230886
      ExplodeAssemblyBOMComponent                                                                        230885
      CalculateStandardCostWithResourcePrice, CalculateUnitPriceWithResourcePrice                        230879

      Covers Test Cases for WI - 319184
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      AssemblyOrderWithBOMComponents, AssemblyListFromAssemblyOrderForItem                               230853
      ErrorOnInvokingAssemblyListForResource
      ErrorOnCreatingAssemblyOrderWithBlankNoSeries, AssemblyOrderByPage                                 230855
      PostSalesReturnOrderForAssemblyItem, ErrorOnPostingAssemblyOrderAfterPostSalesReturnOrder          230134
      AssemblyListFromAssemblyOrderForAssemblyItem                                                       230826
      ComponentItemDetailsOfAssemblyItem                                                                 230868
      ComponentResourceDetailsOfAssemblyItem                                                             230869

      Covers Test Cases for WI - 319183
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      PostAssemblyOrderUsingDimensionAndMultipleUOM                                                      229971
      ErrorOnCreatingAsmOrderWithPstdAsmOrderNoUsingDim                                                  229973
      ErrorOnPostingAsmOrderBeforeExplodeAsmListWithDim                                                  229972
      PostAsmOrderAfterExplodeAsmListWithDimension                                                       229976
      ErrorOnPostingAsmOrderAfterDeleteAsmLinesUsingDim                                                  229974
      CalculateStandardCostWithSalesDiscount, CalculateUnitPriceWithSalesDiscount                        230882
      CalculateStandardCostWithSalesPrice, CalculateUnitPriceWithSalesPrice                              230881

      Covers Test Cases for WI - 319872
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      PostPartialAsmOrderUsingDimensionAndMultipleUOM                                                    230034
      PostPartialAssemblyOrderUsingDifferentPostingDate                                           230033,230032
      UpdateUnitCostAfterPartialPosting                                                                  230031
      PostPartialAsmOrderWithFixedResourceUsageType                                                      230030
      PostPartialAsmOrderWithoutFixedResourceUsageType                                                   230029
      PostAssemblyOrderUsingComponentItemVariant                                                         230001

      Covers Test Cases for WI - 319185
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      AssemblyItemDetailsOfAssemblyItem                                                                  230870
      AssemblyOrderWithAssemblyItemVariant, AssemblyOrderWithComponentItemVariant                        230856
      AssemblyOrderWithResourceVariantError
      AssemblyItemDetailsOfAssemblyOrder, ComponentItemDetailsOfAssemblyOrder                            230680
      ComponentResourceDetailsOfAssemblyOrder
      AssemblyListFromAssemblyOrder                                                                      230854
      AssemblyOrderWithQuantityToAssembleAndDimensions,DeleteAssemblyOrderAfterPartialPostWithDimensions 230038

      Covers Test Cases for WI - 319867
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      ItemSubstitutionOnAssemblyOrderWithDimension, PostAssemblyOrderWithDimensionAndItemSubstitution    229982
      ReleasedProdOrderAfterlPostedAsmOrderWithDim, NavigateFnshdProdOrderAfterPostedAsmOrderWithDim     229981
      PostAssemblyOrderWithDimAndSameComponentItemTwice                                                  229986

      Covers Test Cases for WI - 319873
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      PostAsmOrderAfterCalcStdCostAndUnitPriceOnAsmBOM                                                   230003
      PostPartialAsmOrderAfterAdjustCostItemEntries, PostInvtCostToGLAfterPostAsmOrdWithManualAutoPost   230050
      PostInvtCostToGLWithManAutoPostAndAutoCostAdjmt, PostInvtCostToGLWithManualAutoPostAndManCostAdjmt
      PostAssemblyOrderWithAutoCostPostAndAutoCostAdjmt

      Covers Test Cases for WI - 319870
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      PostPartialAssemblyOrderWithDimensions, PostRemainingAssemblyOrderWithDimensions                   230040
      ErrorOnDeletingItemAfterPostReservedSOWithDim, ErrorOnDeletingItemAfterCloseFiscalYearWithDim      230045
      AdjustCostItemEntriesAfterBlockOrderDimension                                                      230048

      Covers Test Cases for WI - N/A
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      PostAssemblyOrderWithResourceWithoutLocation                                                        49915

      Covers Test Cases for Sicily Merge Bug
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      CreateAssemblyOrderFromSalesOrderWithDimension                                                      52646
      UpdateDimensionOnSalesLineWithAssemblyOrder                                                         52646
      CreateAndPostAssemblyOrderFromSalesOrderWithDimension                                               52646
      ExplodeAssemblyBOMComponentWithBaseUnitOfMeasureInAssemblyOrder                                     55049
      ExplodeAssemblyBOMComponentWithOtherUnitOfMeasureInAssemblyOrder                                    55049
      Covers Test Cases for Sicily Merge Bug
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      PartialInvoiceSalesOrderwithAssemblyItem                                                            55062
      CalcStandardCostonOnAssemblyItem                                                                    55777

      Covers Test Cases for Sicily Merge Bug
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      PostAssemblyOrderWithDimensionAfterExplodeBOM                                                       61087
      PostSalesOrderForAssemblyItemWithUpdatedPostingDate                                                 70983
      ModifyPostingDateOnAssemblyOrder                                                                    70983
      UpdatePostingDateOnSalesHeaderAndCreateSalesLineForAssemblyItem                                     71436
      ManualCostAdjustmentOnRepostedSalesShipment                                                         86001
      ManualCostAdjustmentOnRepostedSalesShipmentAndInvoice                                               86001
      AutoCostAdjustmentOnRepostedSalesShipment                                                           86001
      AutoCostAdjustmentOnRepostedSalesShipmentAndInvoice                                                 86001

      Covers Test Cases for Crete Merge Bug
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      UndoSalesShipmentLineWithAssemblyOrder                                                              88420

      Covers Test Cases for Crete Merge Bug
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      AvailabilityOnSalesLineDetailsFactBoxWithReservation                                               88556
      AssemblyOrderWithReservation                                                                       88556

      Covers Test Cases for Crete Merge Bug
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      PostAssemblyOrderWithApplToItemEntry                                                               89277
      CalcInvtValueOnRevaluationJournalAfterUndoPostedAssemblyOrder                                      88345
      ItemJournalApplToUndoneAssemblyConsumptionLine                                                     88345

      Covers Test Cases for Merge Bug
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      InsertSalesLineToFullConsumeItemWithExistingReservation                                            89685
    }
    END.
  }
}

