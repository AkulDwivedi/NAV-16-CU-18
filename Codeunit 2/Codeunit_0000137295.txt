OBJECT Codeunit 137295 SCM Inventory Misc. III
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,NAVIN9.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      Assert@1006 : Codeunit 130000;
      LibraryCosting@1004 : Codeunit 132200;
      LibraryDimension@1016 : Codeunit 131001;
      LibraryERM@1017 : Codeunit 131300;
      LibraryFiscalYear@1024 : Codeunit 131302;
      LibraryInventory@1003 : Codeunit 132201;
      LibraryItemTracking@1036 : Codeunit 130502;
      LibraryManufacturing@1015 : Codeunit 132202;
      LibraryPurchase@1005 : Codeunit 130512;
      LibrarySales@1018 : Codeunit 130509;
      LibraryUtility@1020 : Codeunit 131000;
      LibraryWarehouse@1022 : Codeunit 132204;
      LibraryVariableStorage@1010 : Codeunit 131004;
      LibraryPlanning@1035 : Codeunit 132203;
      LibraryJob@1009 : Codeunit 131920;
      LibraryRandom@1001 : Codeunit 130440;
      TrackingOption@1033 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo';
      isInitialized@1000 : Boolean;
      ApplyItemEntryError@1028 : TextConst 'ENU="%1 must have a value in %2: Document Type=%3, Document No.=%4"';
      ChangeBaseUnitOfMeasureError@1021 : TextConst 'ENU=You cannot change Base Unit of Measure because there are one or more open ledger entries for this item.';
      CancelReservationMessage@1012 : TextConst 'ENU="Do you want to cancel all reservations in "';
      ClosedFiscalYear@1023 : TextConst 'ENU=Once the fiscal year is closed it cannot be opened again, and the periods in the fiscal year cannot be changed.';
      DeleteEntries@1027 : TextConst 'ENU=This batch job deletes entries. Therefore, it is important that you make a backup of the database before you run the batch job.';
      ExpectedMessage@1032 : TextConst 'ENU=The Credit Memo doesn''t have a Corrected Invoice No. Do you want to continue?';
      JournalLinesRegistered@1026 : TextConst 'ENU="The journal lines were successfully registered.You are now in the "';
      FinishProductionOrder@1014 : TextConst 'ENU=Production Order %1 has not been finished. Some output is still missing.';
      PhysInvLedgerEntriesExists@1002 : TextConst 'ENU=Physical Inventory Ledger Entries Must Be Deleted.';
      ProdOrderCreated@1007 : TextConst 'ENU=Prod. Order';
      ReservedQtyError@1008 : TextConst 'ENU="Reserved Qty. (Base) must be equal to ''0''  in Prod. Order Line: Status=%1, Prod. Order No.=%2"';
      PostJournalLines@1013 : TextConst 'ENU=Do you want to post the journal lines';
      RegisterJournalLines@1025 : TextConst 'ENU=Do you want to register the journal lines?';
      SuccessfullyPostLines@1011 : TextConst 'ENU=The journal lines were successfully posted';
      ValidationError@1019 : TextConst '@@@=%1:Field1,%2:Value1;ENU=%1 must be %2.';
      StandardCostRollup@1030 : TextConst 'ENU=The standard costs have been rolled up successfully.';
      UnadjustedValueEntriesMessage@1031 : TextConst 'ENU=Some unadjusted value entries will not be covered with the new setting. You must run the Adjust Cost - Item Entries batch job once to adjust these.';
      ItemFilter@1029 : TextConst 'ENU=%1|%2';
      ProductionOrderCreatedMsg@1034 : TextConst 'ENU=Released Prod. Order';

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE ReserveQtyOnProdOrderFromSalesOrder@2();
    VAR
      SalesLine@1001 : Record 37;
      ProductionOrder@1004 : Record 5405;
      OrderType@1000 : 'ItemOrder,ProjectOrder';
    BEGIN
      // Verify Quantity and Reserved Quantity on Planned Production Order Created from Sales Order.

      // Setup.
      Initialize;

      // Exercise: Create Sales Order, Planned Production order from Sales Order.
      CreateProdOrderFromSalesOrder(SalesLine,ProductionOrder.Status::Planned,OrderType::ItemOrder);

      // Verify: Verify Quantity and Reserved Quantity on Production Order.
      VerifyQuantityOnProdOrderLine(SalesLine."No.",SalesLine.Quantity,SalesLine.Quantity);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE ReserveQtyErrorOnProdOrderFromSalesOrder@15();
    VAR
      SalesLine@1001 : Record 37;
      ProductionOrder@1004 : Record 5405;
      OrderType@1000 : 'ItemOrder,ProjectOrder';
    BEGIN
      // Verify error while Refresh Planned Production Order created from Sales Order.

      // Setup: Create Sales Order, Planned Production order from Sales Order.
      Initialize;
      CreateProdOrderFromSalesOrder(SalesLine,ProductionOrder.Status::Planned,OrderType::ItemOrder);
      FindProductionOrder(ProductionOrder,ProductionOrder.Status::Planned,SalesLine."No.");

      // Exercise: Refresh Production Order.
      ASSERTERROR LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // Verify: Verify error while Refresh Planned Production Order.
      Assert.ExpectedError(STRSUBSTNO(ReservedQtyError,ProductionOrder.Status,ProductionOrder."No."));
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE ReserveQtyOnProdOrderAfterChangeStatus@1();
    VAR
      SalesLine@1001 : Record 37;
      ProductionOrder@1002 : Record 5405;
      ProdOrderStatusMgt@1006 : Codeunit 5407;
      NewStatus@1003 : 'Quote,Planned,Firm Planned,Released,Finished';
      OrderType@1000 : 'ItemOrder,ProjectOrder';
    BEGIN
      // Verify Quantity and Reserved Quantity on Production Order created from Sales Order and after changing the Production Order status from Planned to Firm Planned.

      // Setup: Create Sales Order, Planned Production order from Sales Order.
      Initialize;
      CreateProdOrderFromSalesOrder(SalesLine,ProductionOrder.Status::Planned,OrderType::ItemOrder);
      FindProductionOrder(ProductionOrder,ProductionOrder.Status::Planned,SalesLine."No.");

      // Exercise: Change Status on Production Order.
      ProdOrderStatusMgt.ChangeStatusOnProdOrder(ProductionOrder,NewStatus::"Firm Planned",WORKDATE,FALSE);

      // Verify: Verify Quantity and Reserved Quantity on Production Order.
      VerifyQuantityOnProdOrderLine(SalesLine."No.",SalesLine.Quantity,SalesLine.Quantity);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE ReserveQtyErrorOnProdOrderAfterChangeStatus@30();
    VAR
      SalesLine@1001 : Record 37;
      ProductionOrder@1004 : Record 5405;
      ProdOrderStatusMgt@1007 : Codeunit 5407;
      NewStatus@1002 : 'Quote,Planned,Firm Planned,Released,Finished';
      OrderType@1000 : 'ItemOrder,ProjectOrder';
    BEGIN
      // Verify error while Refresh Planned Production Order created from Sales Order and after changing the Production Order status from Planned to Firm Planned.

      // Setup: Create Sales Order, Planned Production order from Sales Order.
      Initialize;
      CreateProdOrderFromSalesOrder(SalesLine,ProductionOrder.Status::Planned,OrderType::ItemOrder);
      FindProductionOrder(ProductionOrder,ProductionOrder.Status::Planned,SalesLine."No.");

      // Change Status on Production Order.
      ProdOrderStatusMgt.ChangeStatusOnProdOrder(ProductionOrder,NewStatus::"Firm Planned",WORKDATE,FALSE);
      FindProductionOrder(ProductionOrder,ProductionOrder.Status::"Firm Planned",SalesLine."No.");

      // Exercise: Refresh Production Order.
      ASSERTERROR LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // Verify: Verify error while Refresh Firm Planned Production Order.
      Assert.ExpectedError(STRSUBSTNO(ReservedQtyError,ProductionOrder.Status,ProductionOrder."No."));
    END;

    [Test]
    [HandlerFunctions(ReservationPageHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE ProdOrderReservationCancel@11();
    VAR
      SalesLine@1000 : Record 37;
      ProductionOrder@1001 : Record 5405;
      OrderType@1004 : 'ItemOrder,ProjectOrder';
    BEGIN
      // Verify Reserved Quantity on Production Order created from Sales Order after cancellation of reservation.

      // Setup: Create Sales Order, Firm Planned Production order from Sales Order.
      Initialize;
      CreateProdOrderFromSalesOrder(SalesLine,ProductionOrder.Status::"Firm Planned",OrderType::ItemOrder);

      // Exercise: Cancel reservation on Production Order.
      CancelReservationOnProductionOrder(SalesLine."No.");

      // Verify: Verify there is no Reserved Quantity on Production Order Line after cancellation of reservation
      VerifyQuantityOnProdOrderLine(SalesLine."No.",SalesLine.Quantity,0);
    END;

    [Test]
    [HandlerFunctions(ReservationPageHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE ProdOrderAutoReservation@7();
    VAR
      SalesLine@1000 : Record 37;
      ProdOrderLine@1002 : Record 5406;
      ProductionOrder@1001 : Record 5405;
      ReservOption@1003 : 'AutoReserve,CancelReserv';
      OrderType@1004 : 'ItemOrder,ProjectOrder';
    BEGIN
      // Verify Reserved Quantity on Production Order created from Sales Order after Auto Reservation.

      // Setup: Create Sales Order, Planned Production order from Sales Order and cancel reservation on Production Order.
      Initialize;
      CreateProdOrderFromSalesOrder(SalesLine,ProductionOrder.Status::"Firm Planned",OrderType::ItemOrder);
      CancelReservationOnProductionOrder(SalesLine."No.");
      FindProdOrderLine(ProdOrderLine,SalesLine."No.");
      LibraryVariableStorage.Enqueue(ReservOption::AutoReserve);  // Enqueue for ReservationPageHandler.

      // Exercise: Auto reservation on Production Order.
      ProdOrderLine.ShowReservation;

      // Verify: Verify Reserved Quantity on Production Order Line.
      VerifyQuantityOnProdOrderLine(SalesLine."No.",SalesLine.Quantity,SalesLine.Quantity);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,CheckProdOrderStatusPageHandler,ConfirmHandler)]
    PROCEDURE ReserveQtyOnProdOrderAfterUpdateQty@5();
    VAR
      SalesLine@1002 : Record 37;
      ProductionOrder@1001 : Record 5405;
      OrderType@1000 : 'ItemOrder,ProjectOrder';
      Quantity@1003 : Decimal;
    BEGIN
      // Verify Quantity on Production Order Line after creating Production Order from Sales Order and updating Quantity on Sales Line.

      // Setup: Create production Order from Sales Order, update Quantity on Sales Line.
      Initialize;
      CreateProdOrderFromSalesOrder(SalesLine,ProductionOrder.Status::Released,OrderType::ProjectOrder);
      Quantity := UpdateQuantityOnSalesLine(SalesLine);
      FindProductionOrder(ProductionOrder,ProductionOrder.Status::Released,SalesLine."Document No.");
      LibraryVariableStorage.Enqueue(STRSUBSTNO(FinishProductionOrder,ProductionOrder."No."));  // Enqueue fo MessageHandler.

      // Exercise: Change Production Order Status from Released to Finished.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

      // Verify: Verify Quantity on Production Order Line.
      VerifyQuantityOnProdOrderLine(SalesLine."No.",Quantity,0);
    END;

    [Test]
    PROCEDURE PostPhysInvJournalAfterUpdateQty@9();
    VAR
      Item@1001 : Record 27;
      ItemJournalLine@1005 : Record 83;
      PurchaseLine@1002 : Record 39;
    BEGIN
      // Verify Item Ledger Entry when Qty. (Phys. Inventory) is updated for an Item with Overhead Cost and having costing method Average.

      // Setup: Create and post Purchase Order, run Adjust cost Item Entries, calculate Inventory and update "Qty. (Phys. Inventory)" on Physical Inventory Journal.
      Initialize;
      CreateAndPostPurchaseOrder(
        PurchaseLine,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::Average));
      LibraryCosting.AdjustCostItemEntries(PurchaseLine."No.",'');
      RunCalculateInventoryReport(ItemJournalLine,PurchaseLine."No.");
      UpdateQtyOnPhysInvJournal(ItemJournalLine);

      // Exercise: Post Physical Inventory Journal.
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Verify: Verify Quantity and Cost Amount (Actual) on Item Ledger Entry.
      VerifyItemLedgerEntry(
        ItemJournalLine."Item No.",ItemJournalLine."Entry Type"::"Negative Adjmt.",-ItemJournalLine.Quantity,
        -ItemJournalLine.Quantity * ItemJournalLine."Unit Cost");
    END;

    [Test]
    PROCEDURE CostAmountOnItemLedgerEntry@16();
    VAR
      Item@1002 : Record 27;
      ItemJournalLine@1000 : Record 83;
      Quantity@1001 : Decimal;
    BEGIN
      // Verify Item Ledger Entry after posting Item Journal Line for Item having costing method Average.

      // Setup: Create and post Item Journal Line.
      Initialize;
      CreateAndPostItemJournalLine(
        ItemJournalLine,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::Average));
      Quantity := ItemJournalLine.Quantity;

      // Create Item Journal Line and apply to existing Item ledger Entry for Item.
      CreateItemJournalLine(
        ItemJournalLine,ItemJournalLine."Entry Type"::"Negative Adjmt.",ItemJournalLine."Item No.",ItemJournalLine.Quantity / 2,
        ItemJournalLine."Unit Cost");
      UpdateItemJournalLineAppliesToEntry(ItemJournalLine);

      // Exercise: Post Item Journal Line.
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // verify: Verify Quantity and Cost Amount (Actual) on Item Ledger Entry.
      VerifyItemLedgerEntry(
        ItemJournalLine."Item No.",ItemJournalLine."Entry Type"::"Positive Adjmt.",Quantity,Quantity * ItemJournalLine."Unit Cost");
      VerifyItemLedgerEntry(
        ItemJournalLine."Item No.",ItemJournalLine."Entry Type"::"Negative Adjmt.",-ItemJournalLine.Quantity,
        -ItemJournalLine.Quantity * ItemJournalLine."Unit Cost");
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE GLEntriesAfterPostInvCostToGL@10();
    VAR
      JobJournalLine@1003 : Record 210;
      GLEntry@1000 : Record 17;
    BEGIN
      // Verify G/L Entries after running Adjust Cost Item Entries and post Inventory to G/L batch job for an Item.

      // Setup: Create and post Job Journal Line and run Adjust Cost Item Entries.
      Initialize;
      CreateAndPostJobJournalLine(JobJournalLine);
      LibraryCosting.AdjustCostItemEntries(JobJournalLine."No.",'');

      // Exercise: Post Inventory to G/L batch job.
      LibraryCosting.PostInvtCostToGL(FALSE,WORKDATE,'');

      // Verify: Verify Amount on G/L Entries.
      GLEntry.SETRANGE("Job No.",JobJournalLine."Job No.");
      GLEntry.FINDFIRST;
      GLEntry.TESTFIELD(Amount,-ROUND(JobJournalLine.Quantity * JobJournalLine."Unit Cost"));
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE PostInvCostToGLWithPostMethodPerEntry@27();
    VAR
      JobJournalLine@1003 : Record 210;
      ItemJournalLine@1005 : Record 83;
      ValueEntry@1000 : Record 5802;
      CostAmount@1001 : Decimal;
    BEGIN
      // Verify Value Entry after running Post Inventory Cost To G/L batch job using Post Method 'Per Entry'.

      // Setup: Create and post Job Journal Line, create and post Item Journal Line, run Adjust Cost Item Entries.
      Initialize;
      CreateAndPostJobJournalLine(JobJournalLine);
      CreateAndPostItemJournalLine(ItemJournalLine,JobJournalLine."No.");
      LibraryCosting.AdjustCostItemEntries(JobJournalLine."No.",'');

      // Exercise: Post Inventory to G/L batch job.
      LibraryCosting.PostInvtCostToGL(FALSE,WORKDATE,'');

      // Verify: Verify Value Entry after running Post Inventory Cost To G/L batch job.
      CostAmount := ROUND((JobJournalLine."Unit Cost" - ItemJournalLine."Unit Cost") * JobJournalLine.Quantity);
      VerifyValueEntry(ValueEntry."Item Ledger Entry Type"::"Negative Adjmt.",JobJournalLine."No.",CostAmount);
    END;

    [Test]
    [HandlerFunctions(CalculatePhysInvtCountingPageHandler,PhysInvtItemSelectionPageHandler)]
    PROCEDURE CountingPeriodOnPhysInvJournalWithDim@13();
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1002 : Record 83;
      ItemJournalLine2@1008 : Record 83;
    BEGIN
      // Verify Physical Inventory Journal after calculate Counting Periods for an Item if Dimensions are selected.

      // Setup: Create Item, update Dimension and Physical Inventory Counting period on Item, create and post Item Journal Line.
      Initialize;
      Item.GET(CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::Average));
      UpdateCountingPeriodOnItem(Item);
      UpdateItemDimension(Item."No.");
      CreateAndPostItemJournalLine(ItemJournalLine,Item."No.");
      LibraryVariableStorage.Enqueue(ItemJournalLine."Item No.");  // Enqueue for PhysInvtItemSelectionPageHandler.
      CreateItemJournalLineForPhysInv(ItemJournalLine2);
      COMMIT;

      // Exercise: Calculate Counting Period on Physical Inventory Journal.
      LibraryInventory.CalculateCountingPeriod(ItemJournalLine2);

      // Verify: Verify Quantity on Physical Inventory Journal.
      VerifyPhysInvJournalQty(Item."No.",ItemJournalLine.Quantity);
    END;

    [Test]
    [HandlerFunctions(DeletePhysInventoryLedgerPageHandler,ConfirmHandler)]
    PROCEDURE DeletePhysInvLedgerEntries@42();
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1001 : Record 83;
      PhysInventoryLedgerEntry@1003 : Record 281;
    BEGIN
      // Verify deletion of Physical Inventory Ledger Entries.

      // Setup: Create Item, close Fiscal Year, Create and Post Physical Inventory Journal.
      Initialize;
      CloseFiscalYear;
      CreateAndPostItemJournalLine(
        ItemJournalLine,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::Average));
      RunCalculateInventoryReport(ItemJournalLine,ItemJournalLine."Item No.");
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Exercise.
      DeletePhysInvLedger(ItemJournalLine."Item No.");

      // Verify: Verify deletion of Physical Inventory Ledger Entries
      PhysInventoryLedgerEntry.SETRANGE("Item No.",ItemJournalLine."Item No.");
      Assert.IsFalse(PhysInventoryLedgerEntry.FINDFIRST,PhysInvLedgerEntriesExists);
    END;

    [Test]
    [HandlerFunctions(WhseItemTrackingLinesPageHandler,MessageHandler,ConfirmHandler)]
    PROCEDURE UpdateItemUnitOfMeasureError@32();
    VAR
      Item@1001 : Record 27;
    BEGIN
      // Verify error while update Base Unit of Measure if there are one or more open Ledger Entries for Item.

      // Setup: Create Item, create and register Warehouse Journal and Calculate Warehouse Adjustment.
      Initialize;
      LibraryInventory.CreateTrackedItem(Item,LibraryUtility.GetGlobalNoSeriesCode,'',CreateLotWhseTrackingCode);
      CreateAndRegisterWhseJournal(Item."No.");
      CalculateWhseAdjustment(Item);

      // Exercise: Update Base Unit of Measure on Item.
      ASSERTERROR UpdateItemBaseUnitOfMeasure(Item);

      // Verify:  Verify error while update Base Unit of Measure.
      Assert.ExpectedError(ChangeBaseUnitOfMeasureError);
    END;

    [Test]
    [HandlerFunctions(RollUpStandardCostReportHandler,MessageHandler)]
    PROCEDURE RollUpStdCostOnStdCostWorkSheet@59();
    VAR
      Item@1000 : Record 27;
      Item2@1001 : Record 27;
      StandardCostWorksheetName@1004 : Record 5840;
    BEGIN
      // Verify Filtered Data Of Standard Cost Worksheet.

      // Setup: Create Item.
      Initialize;
      LibraryInventory.CreateStandardCostWorksheetName(StandardCostWorksheetName);
      Item.GET(CreateAndModifyItem(Item."Replenishment System"::"Prod. Order",Item."Costing Method"::Standard));
      Item2.GET(CreateAndModifyItem(Item2."Replenishment System"::"Prod. Order",Item2."Costing Method"::Standard));
      LibraryVariableStorage.Enqueue(StandardCostRollup);  // Enqueue value for MessageHandler.

      // Exercise: Apply Roll Up Standard Cost on Standard Cost WorkSheet.
      RunRollUpStandardCost(StandardCostWorksheetName.Name,Item."No.",Item2."No.");

      // Verify: Verify Standard Cost of Standard Cost Worksheet.
      VerifyStandardCost(Item2."No.",Item2."Standard Cost");
    END;

    [Test]
    [HandlerFunctions(RollUpStandardCostReportHandler,MessageHandler)]
    PROCEDURE RollUpStdCostAfterUpdateInvPostingGroup@74();
    VAR
      Item@1003 : Record 27;
      Item2@1002 : Record 27;
      StandardCostWorksheetName@1000 : Record 5840;
    BEGIN
      // Verify Filtered Data Of Standard Cost Worksheet After Modify Item.

      // Setup: Create Item and Update Inventory Posting Group.
      Initialize;
      LibraryInventory.CreateStandardCostWorksheetName(StandardCostWorksheetName);
      Item.GET(CreateAndModifyItem(Item."Replenishment System"::"Prod. Order",Item."Costing Method"::Standard));
      Item2.GET(CreateAndModifyItem(Item2."Replenishment System"::"Prod. Order",Item2."Costing Method"::Standard));
      UpdateItemInvPostingGroup(Item2);
      LibraryVariableStorage.Enqueue(StandardCostRollup);  // Enqueue value for MessageHandler.

      // Exercise: Apply Roll Up Standard Cost on Standard Cost WorkSheet.
      RunRollUpStandardCost(StandardCostWorksheetName.Name,Item."No.",Item2."No.");

      // Verify: Verify Standard Cost of Standard Cost Worksheet.
      VerifyStandardCost(Item."No.",Item."Standard Cost");
    END;

    [Test]
    PROCEDURE ApplyingRevaluedInboundEntryToOutbound@68();
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1002 : Record 83;
      ItemLedgerEntry@1007 : Record 32;
      PostingDate@1001 : Date;
    BEGIN
      // Verify Item Ledger Entries when Item Costing Method is Average and after applying Revalued Inbound Entry to Outbound.

      // Setup: Create Item,Create and Post Item Journal with Postive adjustment,Create and Post Revaluation Journal,Create Item Journal with Negative adjustment.
      Initialize;
      CreateAndPostItemJournalLine(
        ItemJournalLine,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::Standard));  // Random value for Quantity and Unit Cost.
      LibraryCosting.AdjustCostItemEntries(ItemJournalLine."Item No.",'');  // Blank value for ItemCategoryFilter.
      CreateandPostItemJournalForRevaluation(ItemJournalLine,ItemJournalLine."Item No.");
      CreateItemJournalLine(
        ItemJournalLine,ItemJournalLine."Entry Type"::"Negative Adjmt.",ItemJournalLine."Item No.",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10));  // Random value for Quantity and Unit Cost.
      PostingDate := CALCDATE('<' + FORMAT(LibraryRandom.RandInt(5)) + 'M>',WORKDATE);
      ItemJournalLine.VALIDATE("Posting Date",PostingDate);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Excercise: Apply Adjust Cost Item Entries.
      LibraryCosting.AdjustCostItemEntries(ItemJournalLine."Item No.",'');  // Blank value for ItemCategoryFilter.

      // Verify: Verify Item Ledger Entry.
      FindItemLedgerEntry(ItemLedgerEntry,ItemJournalLine."Item No.",ItemJournalLine."Entry Type"::"Negative Adjmt.");
      ItemLedgerEntry.TESTFIELD(Quantity,-ItemJournalLine.Quantity);
      ItemLedgerEntry.TESTFIELD("Posting Date",PostingDate);
    END;

    [Test]
    [HandlerFunctions(PostedPurchaseDocumentLinesPageHandler,MessageHandler,CreditMemoConfirmHandler)]
    PROCEDURE ApplyToItemZeroErrorOnPurchReturnOrder@47();
    VAR
      InventorySetup@1000 : Record 313;
      Item@1004 : Record 27;
      PurchasesPayablesSetup@1001 : Record 312;
      PurchaseHeader@1002 : Record 38;
      PurchaseLine@1003 : Record 39;
      DocumentNo@1005 : Code[20];
    BEGIN
      // Verify error while posting Purchase Return Order when Apply to Item Entry is Zero using Get Posted Document Lines to Reverse.

      // Setup: Update Inventory Setup and Purchase Payable Setup.
      Initialize;
      InventorySetup.GET;
      UpdateInventorySetup(InventorySetup."Automatic Cost Adjustment"::Always);
      PurchasesPayablesSetup.GET;
      UpdatePurchasesPayablesSetup(TRUE);

      // Create and post Purchase Order, Create Purchase Return Order.
      DocumentNo :=
        CreateAndPostPurchaseOrder(
          PurchaseLine,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO));
      LibraryVariableStorage.Enqueue(DocumentNo);
      CreatePurchRetOrderGetPstdDocLineToRev(PurchaseHeader,PurchaseLine."Buy-from Vendor No.");
      UpdateApplyToItemEntryOnPurchLine(PurchaseLine,PurchaseHeader."No.");

      // Exercise: Post Purchase Return Order.
      ASSERTERROR PostPurchaseDocument(PurchaseHeader);

      // Verify: Verify error while posting Purchase Return Order when Apply to Item Entry is Zero.
      Assert.ExpectedError(
        STRSUBSTNO(
          ApplyItemEntryError,PurchaseLine.FIELDCAPTION("Appl.-to Item Entry"),PurchaseLine.TABLECAPTION,
          PurchaseHeader."Document Type",PurchaseHeader."No."));

      // Tear Down.
      UpdateInventorySetup(InventorySetup."Automatic Cost Adjustment");
      UpdatePurchasesPayablesSetup(PurchasesPayablesSetup."Exact Cost Reversing Mandatory");
    END;

    [Normal]
    LOCAL PROCEDURE DeleteApplOnPurchReturnOrder@115(Serial@1007 : Boolean;Lot@1008 : Boolean;TrackingOption@1009 : Option);
    VAR
      InventorySetup@1000 : Record 313;
      Item@1004 : Record 27;
      PurchasesPayablesSetup@1001 : Record 312;
      PurchaseHeader@1002 : Record 38;
      PurchaseLine@1003 : Record 39;
      DocumentNo@1005 : Code[20];
    BEGIN
      // Verify there is no error when posting unapplied Purchase Return Order with serial/lot numbers.
      // VSTF: 212797.

      // Setup: Update Inventory Setup and Purchase Payable Setup.
      Initialize;
      InventorySetup.GET;
      UpdateInventorySetup(InventorySetup."Automatic Cost Adjustment"::Always);
      PurchasesPayablesSetup.GET;
      UpdatePurchasesPayablesSetup(TRUE);

      // Create and post Purchase Order, Create Purchase Return Order.
      LibraryInventory.CreateTrackedItem(Item,'',LibraryUtility.GetGlobalNoSeriesCode,CreateItemTrackingCode(Serial,Lot));
      DocumentNo := CreateAndPostPurchaseOrderWithIT(PurchaseHeader,Item."No.",TrackingOption,LibraryRandom.RandInt(10),2);

      LibraryVariableStorage.Enqueue(DocumentNo);
      CreatePurchRetOrderGetPstdDocLineToRev(PurchaseHeader,PurchaseHeader."Buy-from Vendor No.");
      UpdateApplyToItemEntryOnPurchLine(PurchaseLine,PurchaseHeader."No.");

      // Exercise: Post Purchase Return Order.
      PostPurchaseDocument(PurchaseHeader);

      // Verify: No error when posting. Resulting value entries are unapplied.
      VerifyValueEntryNoApplication(Item."No.");

      // Tear Down.
      UpdateInventorySetup(InventorySetup."Automatic Cost Adjustment");
      UpdatePurchasesPayablesSetup(PurchasesPayablesSetup."Exact Cost Reversing Mandatory");
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,EnterQuantitytoCreatePageHandler,PostedPurchaseDocumentLinesPageHandler,MessageHandler,CreditMemoConfirmHandler)]
    PROCEDURE DeleteApplOnPurchReturnOrderWithSerial@108();
    VAR
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo';
    BEGIN
      // VSTF: 212797.
      DeleteApplOnPurchReturnOrder(TRUE,FALSE,TrackingOption::AssignSerialNo);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,PostedPurchaseDocumentLinesPageHandler,MessageHandler,CreditMemoConfirmHandler)]
    PROCEDURE DeleteApplOnPurchReturnOrderWithLot@114();
    VAR
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo';
    BEGIN
      // VSTF: 245050, 252794.
      DeleteApplOnPurchReturnOrder(FALSE,TRUE,TrackingOption::SetLotNo);
    END;

    [Test]
    [HandlerFunctions(PostedPurchaseDocumentLinesPageHandler,ReservationPageHandler,MessageHandler,CreditMemoConfirmHandler)]
    PROCEDURE DeleteApplOnPurchReturnOrderWithReservation@112();
    VAR
      InventorySetup@1000 : Record 313;
      Item@1004 : Record 27;
      PurchasesPayablesSetup@1001 : Record 312;
      PurchaseHeader@1002 : Record 38;
      PurchaseLine@1003 : Record 39;
      ReservOption@1008 : 'AutoReserve,CancelReserv';
      DocumentNo@1005 : Code[20];
    BEGIN
      // Verify there is no error when posting unapplied Purchase Return Order with reservations.
      // VSTF: 212797.

      // Setup: Update Inventory Setup and Purchase Payable Setup.
      Initialize;
      InventorySetup.GET;
      UpdateInventorySetup(InventorySetup."Automatic Cost Adjustment"::Always);
      PurchasesPayablesSetup.GET;
      UpdatePurchasesPayablesSetup(TRUE);

      // Create and post Purchase Order, Create Purchase Return Order.
      DocumentNo :=
        CreateAndPostPurchaseOrder(
          PurchaseLine,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO));

      LibraryVariableStorage.Enqueue(DocumentNo);
      CreatePurchRetOrderGetPstdDocLineToRev(PurchaseHeader,PurchaseLine."Buy-from Vendor No.");
      UpdateApplyToItemEntryOnPurchLine(PurchaseLine,PurchaseHeader."No.");

      LibraryVariableStorage.Enqueue(ReservOption::AutoReserve);  // Enqueue for ReservationPageHandler.
      PurchaseLine.ShowReservation;

      // Exercise: Post Purchase Return Order.
      PostPurchaseDocument(PurchaseHeader);

      // Verify: No error when posting. Resulting value entries are unapplied.
      VerifyValueEntryNoApplication(PurchaseLine."No.");

      // Tear Down.
      UpdateInventorySetup(InventorySetup."Automatic Cost Adjustment");
      UpdatePurchasesPayablesSetup(PurchasesPayablesSetup."Exact Cost Reversing Mandatory");
    END;

    [Test]
    [HandlerFunctions(PostedSalesDocumentLinesPageHandler,MessageHandler,CreditMemoConfirmHandler)]
    PROCEDURE ApplyFromItemZeroErrorOnSalesReturnOrder@43();
    VAR
      InventorySetup@1000 : Record 313;
      SalesReceivablesSetup@1001 : Record 311;
      SalesHeader@1002 : Record 36;
      SalesHeader2@1003 : Record 36;
      SalesLine@1004 : Record 37;
      DocumentNo@1005 : Code[20];
    BEGIN
      // Verify error while posting sales Return Order when Apply from Item Entry is Zero using Get Posted Document Lines to Reverse.

      // Setup: Update Inventory Setup and Sales Receivable Setup.
      Initialize;
      InventorySetup.GET;
      UpdateInventorySetup(InventorySetup."Automatic Cost Adjustment"::Always);
      SalesReceivablesSetup.GET;
      UpdateSalesReceivablesSetup(TRUE,SalesReceivablesSetup."Stockout Warning");

      // Create and post Sales order, create Sales Return Order.
      DocumentNo := CreateAndPostSalesOrder(SalesHeader);
      LibrarySales.CreateSalesHeader(SalesHeader2,SalesHeader2."Document Type"::"Return Order",SalesHeader."Sell-to Customer No.");
      LibraryVariableStorage.Enqueue(DocumentNo);
      GetPostedDocToReverseOnSalesReturnOrder(SalesHeader2."No.");
      UpdateApplyFromItemEntryOnSalesLine(SalesLine,SalesHeader2."No.");

      // Exercise: Post Sales Return Order.
      ASSERTERROR PostSalesDocument(SalesLine,TRUE);

      // Verify: Verify error while posting sales Return Order when Apply from Item Entry is Zero.
      Assert.ExpectedError(
        STRSUBSTNO(
          ApplyItemEntryError,SalesLine.FIELDCAPTION("Appl.-from Item Entry"),SalesLine.TABLECAPTION,SalesHeader2."Document Type",
          SalesHeader2."No."));

      // Tear Down.
      UpdateInventorySetup(InventorySetup."Automatic Cost Adjustment");
      UpdateSalesReceivablesSetup(SalesReceivablesSetup."Exact Cost Reversing Mandatory",SalesReceivablesSetup."Stockout Warning");
    END;

    [Test]
    PROCEDURE PostPurchOrderWithFullInvoicedItemCharge@46();
    VAR
      PurchaseLine@1000 : Record 39;
      GeneralPostingSetup@1007 : Record 252;
      DocumentNo@1005 : Code[20];
    BEGIN
      // Verify G/L Entries after posting Purchase Order as Invoice if Item Charge Line is fully invoiced.

      // Setup: Create Purchase Order with Item Charge and receive it.
      Initialize;
      CreateAndReceivePurchOrderWithItemCharge(PurchaseLine);

      // Exercise: Update Quantity to Invoice and Invoice Item Charge.
      DocumentNo := UpdateQtyAndInvoicePurchaseOrder(PurchaseLine);

      // Verify: Verify G/L Entries after posting Purchase Order as Invoice.
      GeneralPostingSetup.GET(PurchaseLine."Gen. Bus. Posting Group",PurchaseLine."Gen. Prod. Posting Group");
      VerifyGLEntries(DocumentNo,GeneralPostingSetup."Purch. Account",PurchaseLine."Line Amount");
    END;

    [Test]
    PROCEDURE SalesPriceForCustomer@82();
    VAR
      SalesLine@1004 : Record 37;
      SalesPrice@1000 : Record 7002;
    BEGIN
      // Verify Unit Price on Sales Line when Order Date is same as Starting Date of Sales Price with Sales Type Customer.

      // Setup:
      Initialize;

      // Exercise: Create Sales Order.
      CreateSalesOrderWithSalesPriceOnCustomer(SalesLine,WORKDATE);

      // Verify: Verify Unit Price on Sales Line when Order Date is same as Starting Date of Sales Price.
      SalesPrice.SETRANGE("Item No.",SalesLine."No.");
      SalesPrice.FINDFIRST;
      SalesLine.TESTFIELD("Unit Price",SalesPrice."Unit Price");
    END;

    [Test]
    PROCEDURE SalesPriceForCustomerFromItem@80();
    VAR
      Item@1000 : Record 27;
      SalesLine@1004 : Record 37;
    BEGIN
      // Verify Unit Price on Sales Line when Order Date is before Starting Date of Sales Price with Sales Type Customer.

      // Setup.
      Initialize;

      // Exercise: Create Sales Order.
      CreateSalesOrderWithSalesPriceOnCustomer(SalesLine,CALCDATE('<-' + FORMAT(LibraryRandom.RandInt(5)) + 'M>',WORKDATE));

      // Verify: Verify Unit Price on Sales Line when Order Date is before Starting Date of Sales Price.
      Item.GET(SalesLine."No.");
      SalesLine.TESTFIELD("Unit Price",Item."Unit Price");
    END;

    [Test]
    PROCEDURE SalesPriceForCustPriceGroup@79();
    VAR
      Item@1031 : Record 27;
      CustomerPriceGroup@1032 : Record 6;
      SalesLine@1005 : Record 37;
      SalesPrice@1002 : Record 7002;
      VATPostingSetup@1030 : Record 325;
    BEGIN
      // Verify Unit Price on Sales Line when Customer Pricing Group defined on Sales Price.

      // Setup: Create Item, create Sales Price with Type Customer Pricing Group.
      Initialize;
      LibrarySales.CreateCustomerPriceGroup(CustomerPriceGroup);
      CreateSalesPrice(
        SalesPrice,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO),
        SalesPrice."Sales Type"::"Customer Price Group",CustomerPriceGroup.Code,0,'');  // 0 for Minimum Quantity.
      LibraryERM.FindVATPostingSetup(VATPostingSetup,VATPostingSetup."VAT Calculation Type"::"Normal VAT");

      // Exercise.
      CreateSalesOrderWithOrderDate(
        SalesLine,CreateAndUpdateCustomer(CustomerPriceGroup.Code,VATPostingSetup."VAT Bus. Posting Group",''),SalesPrice."Item No.",
        WORKDATE,'',SalesPrice."Minimum Quantity");

      // Verify: Verify Unit Price on Sales Line when Customer Pricing Group defined on Sales Price.
      SalesLine.TESTFIELD("Unit Price",SalesPrice."Unit Price");
    END;

    [Test]
    PROCEDURE SalesPriceForCustPriceGroupFromItem@117();
    VAR
      Item@1000 : Record 27;
      SalesLine@1005 : Record 37;
      SalesPrice@1001 : Record 7002;
    BEGIN
      // Verify Unit Price on Sales Line when Sales Order is created with another Customer and Customer Pricing Group is defined on Sales Price.

      // Setup: Create Item, create Sales Price with Type Customer Pricing Group, create Customer.
      Initialize;
      CreateSalesPriceWithCustomerPriceGroup(SalesPrice);

      // Exercise.
      CreateSalesOrderWithOrderDate(SalesLine,CreateCustomer,SalesPrice."Item No.",WORKDATE,'',SalesPrice."Minimum Quantity");

      // Verify: Verify Unit Price on Sales Line when Sales Order is created with another Customer.
      Item.GET(SalesLine."No.");
      SalesLine.TESTFIELD("Unit Price",Item."Unit Price");
    END;

    [Test]
    PROCEDURE SalesPriceForAllCustomer@78();
    VAR
      SalesPrice@1001 : Record 7002;
      SalesLine@1000 : Record 37;
      Item@1002 : Record 27;
    BEGIN
      // Verify Unit Price on Sales Line when Sales Price with Type All Customer is defined for Item.

      // Setup: Create Item, create Sales Price.
      Initialize;
      CreateSalesPrice(
        SalesPrice,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO),
        SalesPrice."Sales Type"::"All Customers",'',0,'');  // 0 for Minimum Quantity.

      // Exercise.
      CreateSalesOrderWithOrderDate(SalesLine,CreateCustomer,SalesPrice."Item No.",WORKDATE,'',SalesPrice."Minimum Quantity");

      // Verify: Verify Unit Price on Sales Line.
      SalesLine.TESTFIELD("Unit Price",SalesPrice."Unit Price");
    END;

    [Test]
    PROCEDURE SalesPriceForCustomerWithCurrency@73();
    VAR
      SalesLine@1004 : Record 37;
      SalesPrice@1000 : Record 7002;
      Item@1001 : Record 27;
    BEGIN
      // Verify Unit Price on Sales Line when Sales Price is defined for Customer with Currency.

      // Setup:
      Initialize;
      CreateSalesPrice(
        SalesPrice,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO),
        SalesPrice."Sales Type"::Customer,CreateCustomer,0,CreateCurrency);  // 0 for Minimum Qunatity.

      // Exercise: Create Sales Order with Currency.
      CreateSalesOrderWithOrderDate(
        SalesLine,SalesPrice."Sales Code",SalesPrice."Item No.",WORKDATE,SalesPrice."Currency Code",SalesPrice."Minimum Quantity");

      // Verify: Verify Unit Price on Sales Line.
      SalesLine.TESTFIELD("Unit Price",SalesPrice."Unit Price");
    END;

    [Test]
    [HandlerFunctions(CreditMemoConfirmHandler)]
    PROCEDURE SalesPriceForCustomerWithPartialQty@75();
    VAR
      Item@1000 : Record 27;
      SalesPrice@1002 : Record 7002;
      SalesLine@1001 : Record 37;
      DocumentNo@1005 : Code[20];
    BEGIN
      // Verify Unit Price on Posted Sales Invoice after posting Partial Quantity on Sales Order and updating Unit Price on Sales Price.

      // Setup: Create Item, create Customer, create Sales Price and Update Unit Price, create Sales Order.
      Initialize;
      CreateSalesPrice(
        SalesPrice,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO),
        SalesPrice."Sales Type"::Customer,CreateCustomer,0,'');  // 0 for Minimum Quantity.
      CreateAndUpdateSalesOrder(SalesLine,SalesPrice."Sales Code",SalesPrice."Item No.",LibraryRandom.RandDec(10,2));  // Take random for Quantity.
      UpdateUnitPriceOnSalesPrice(SalesPrice);

      // Exercise: Post Sales Order.
      DocumentNo := PostSalesDocument(SalesLine,TRUE);  // TRUE for Invoice.

      // Verify: Verify Unit Price on Posted Sales Invoice after updating Unit Price on Sales Price.
      VerifySalesInvoiceLine(DocumentNo,SalesPrice."Unit Price",0);
    END;

    [Test]
    [HandlerFunctions(CreditMemoConfirmHandler)]
    PROCEDURE PostSalesInvUsingCopyDoc@67();
    VAR
      Item@1000 : Record 27;
      SalesPrice@1002 : Record 7002;
      SalesLine@1001 : Record 37;
      SalesHeader@1004 : Record 36;
      SalesReceivablesSetup@1006 : Record 311;
      UnitPrice@1007 : Decimal;
      DocumentNo@1005 : Code[20];
      DocType@1008 : 'Quote,Blanket Order,Order,Invoice,Return Order,Credit Memo,Posted Shipment,Posted Invoice,Posted Return Receipt,Posted Credit Memo';
    BEGIN
      // Verify Unit Price on Posted Sales Invoice after posting Sales Invoice using Copy Document and updating Unit Price on Sales Price.

      // Setup: Create Sales Price, create Sales Order.
      Initialize;
      SalesReceivablesSetup.GET;
      UpdateSalesReceivablesSetup(FALSE,FALSE);
      CreateSalesPrice(
        SalesPrice,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO),
        SalesPrice."Sales Type"::Customer,CreateCustomer,0,'');  // Take 0 for Minimum Quantity.
      CreateAndUpdateSalesOrder(SalesLine,SalesPrice."Sales Code",SalesPrice."Item No.",LibraryRandom.RandDec(10,2));  // Take random for Quantity.

      // Post Sales Order, update Sales Price, create Sales Invoice using Copy Document.
      DocumentNo := PostSalesDocument(SalesLine,FALSE);  // FALSE for Invoice.
      UnitPrice := UpdateUnitPriceOnSalesPrice(SalesPrice);
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Invoice,SalesPrice."Sales Code");
      COMMIT;  // COMMIT required to run CopySalesDocument.
      LibrarySales.CopySalesDocument(SalesHeader,DocType::"Posted Shipment",DocumentNo,FALSE,TRUE);

      // Exercise: Post Sales Invoice.
      DocumentNo := LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify: Verify Unit Price on Posted Sales Invoice after updating Unit Price on Sales Price.
      VerifySalesInvoiceLine(DocumentNo,UnitPrice,0);

      // Tear Down.
      UpdateSalesReceivablesSetup(SalesReceivablesSetup."Exact Cost Reversing Mandatory",SalesReceivablesSetup."Stockout Warning");
    END;

    [Test]
    [HandlerFunctions(SalesInvoiceStatisticsPageHandler,CreditMemoConfirmHandler)]
    PROCEDURE PstdSalesInvStatisticsWithSalesPrice@71();
    VAR
      SalesLine@1000 : Record 37;
      PostedSalesInvoice@1004 : TestPage 132;
      DocumentNo@1001 : Code[20];
    BEGIN
      // Verify Amount on Posted Sales Invoice Statistics after posting Sales Order.

      // Setup: Create Sales Order, define Sales Price on Customer,.
      Initialize;
      CreateSalesOrderWithSalesPriceOnCustomer(SalesLine,WORKDATE);
      LibraryVariableStorage.Enqueue(SalesLine."Line Amount");  // Enqueue for SalesInvoiceStatisticsPageHandler.

      // Exercise: Post Sales Order.
      DocumentNo := PostSalesDocument(SalesLine,TRUE);  // TRUE for Invoice.

      // verify: Verify Amount on Posted Sales Invoice Statistics.Verification done in SalesInvoiceStatisticsPageHandler..
      PostedSalesInvoice.OPENVIEW;
      PostedSalesInvoice.FILTER.SETFILTER("No.",DocumentNo);
      PostedSalesInvoice.Statistics.INVOKE;
    END;

    [Test]
    PROCEDURE UnitPriceOnItemJournal@69();
    VAR
      Item@1002 : Record 27;
      SalesPrice@1001 : Record 7002;
      ItemJournalLine@1003 : Record 83;
    BEGIN
      // Verify Unit Amount on Item Journal Line when Sales Price is defined for Item.

      // Setup: Create Item, create Sales Price for All Customer.
      Initialize;
      CreateSalesPrice(
        SalesPrice,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO),
        SalesPrice."Sales Type"::"All Customers",'',LibraryRandom.RandDec(10,2),'');

      // Exercise: Create Item Journal Line.
      CreateItemJournalLine(ItemJournalLine,ItemJournalLine."Entry Type"::Sale,SalesPrice."Item No.",SalesPrice."Minimum Quantity",0);  // 0 for Unit Cost

      // Verify:  Verify Unit Amount on Item Journal Line.
      ItemJournalLine.TESTFIELD("Unit Amount",SalesPrice."Unit Price");
    END;

    [Test]
    PROCEDURE LineDiscountForCustomer@105();
    VAR
      SalesLineDiscount@1000 : Record 7004;
      SalesLine@1002 : Record 37;
    BEGIN
      // Verify Line Discount on Sales Line when Sales Line Discount for Sale Type Customer is defined.

      // Setup: Create Sales Line Discount for Sales Type Customer.
      Initialize;
      CreateLineDiscForCustomer(SalesLineDiscount,SalesLineDiscount."Sales Type"::Customer,CreateCustomer);

      // Exercise.
      CreateSalesOrderWithOrderDate(
        SalesLine,SalesLineDiscount."Sales Code",SalesLineDiscount.Code,WORKDATE,'',SalesLineDiscount."Minimum Quantity");

      // Verify: Verify Line Discount on Sales Line for Sale Type Customer.
      SalesLine.TESTFIELD("Line Discount %",SalesLineDiscount."Line Discount %");
    END;

    [Test]
    PROCEDURE LineDiscountForCustomerDiscountGroup@104();
    VAR
      CustomerDiscountGroup@1034 : Record 340;
      SalesLineDiscount@1000 : Record 7004;
      SalesLine@1002 : Record 37;
      VATPostingSetup@1033 : Record 325;
    BEGIN
      // Verify Line Discount on Sales Line when Sales Line Discount for Sale Type Customer Discount Group is defined.

      // Setup: Create Item, create Sales Line Discount with Type Customer Discount Group.
      Initialize;
      LibraryERM.CreateCustomerDiscountGroup(CustomerDiscountGroup);
      CreateLineDiscForCustomer(SalesLineDiscount,SalesLineDiscount."Sales Type"::"Customer Disc. Group",CustomerDiscountGroup.Code);
      LibraryERM.FindVATPostingSetup(VATPostingSetup,VATPostingSetup."VAT Calculation Type"::"Normal VAT");

      // Exercise.
      CreateSalesOrderWithOrderDate(
        SalesLine,CreateAndUpdateCustomer('',VATPostingSetup."VAT Bus. Posting Group",CustomerDiscountGroup.Code),
        SalesLineDiscount.Code,WORKDATE,'',SalesLineDiscount."Minimum Quantity");

      // Verify: Verify Line Discount on Sales Line for Sale Type Customer Discount Group.
      SalesLine.TESTFIELD("Line Discount %",SalesLineDiscount."Line Discount %");
    END;

    [Test]
    PROCEDURE LineDiscountForAllCustomer@113();
    VAR
      SalesLineDiscount@1000 : Record 7004;
      SalesLine@1002 : Record 37;
    BEGIN
      // Verify Line Discount on Sales Line when Sales Line Discount for Sales Type All Customer is defined.

      // Setup: Create Item, create Line Discount for Customer.
      Initialize;
      CreateLineDiscForCustomer(SalesLineDiscount,SalesLineDiscount."Sales Type"::"All Customers",'');

      // Exercise.
      CreateSalesOrderWithOrderDate(SalesLine,CreateCustomer,SalesLineDiscount.Code,WORKDATE,'',SalesLineDiscount."Minimum Quantity");

      // Verify: Verify Line Discount on Sales Line for Sales Type All Customer.
      SalesLine.TESTFIELD("Line Discount %",SalesLineDiscount."Line Discount %");
    END;

    [Test]
    [HandlerFunctions(CreditMemoConfirmHandler)]
    PROCEDURE LineDiscountForCustomerWithPartialQty@103();
    VAR
      SalesLineDiscount@1002 : Record 7004;
      Item@1001 : Record 27;
      SalesLine@1000 : Record 37;
      DocumentNo@1003 : Code[20];
    BEGIN
      // Verify Line Discount on Posted Sales Invoice after posting Partial Quantity on Sales Order and updating Line Discount on Sales Line Discount.

      // Setup: Create Item, create Customer, create Sales Line Discount and Update Line Discount, create Sales Order.
      Initialize;
      CreateLineDiscForCustomer(SalesLineDiscount,SalesLineDiscount."Sales Type"::Customer,CreateCustomer);
      CreateAndUpdateSalesOrder(SalesLine,SalesLineDiscount."Sales Code",SalesLineDiscount.Code,SalesLineDiscount."Minimum Quantity");
      UpdateDiscOnSalesLineDiscount(SalesLineDiscount);

      // Exercise: Post Sales Order.
      DocumentNo := PostSalesDocument(SalesLine,TRUE);  // TRUE for Invoice.

      // Verify: Verify Line Discount on Posted Sales Invoice after updating Line Discount on Sales Line Discount.
      Item.GET(SalesLine."No.");
      VerifySalesInvoiceLine(DocumentNo,Item."Unit Price",SalesLineDiscount."Line Discount %");
    END;

    [Test]
    [HandlerFunctions(CreditMemoConfirmHandler)]
    PROCEDURE LineDiscOnPostSalesInvUsingCopyDoc@102();
    VAR
      Item@1007 : Record 27;
      SalesLineDiscount@1008 : Record 7004;
      SalesLine@1005 : Record 37;
      SalesHeader@1004 : Record 36;
      SalesReceivablesSetup@1003 : Record 311;
      LineDiscPct@1002 : Decimal;
      DocumentNo@1001 : Code[20];
      DocType@1000 : 'Quote,Blanket Order,Order,Invoice,Return Order,Credit Memo,Posted Shipment,Posted Invoice,Posted Return Receipt,Posted Credit Memo';
    BEGIN
      // Verify Line Discount on Posted Sales Invoice after posting Sales Invoice using Copy Document and updating Line Discount on Sales Line Discount.

      // Setup: Create Item, create Customer, create Sales Line Discount, create Sales Order.
      Initialize;
      SalesReceivablesSetup.GET;
      UpdateSalesReceivablesSetup(FALSE,FALSE);
      CreateLineDiscForCustomer(SalesLineDiscount,SalesLineDiscount."Sales Type"::Customer,CreateCustomer);
      CreateAndUpdateSalesOrder(SalesLine,SalesLineDiscount."Sales Code",SalesLineDiscount.Code,SalesLineDiscount."Minimum Quantity");

      // Post Sales Order, update Line Discount, create Sales Invoice using Copy Document.
      DocumentNo := PostSalesDocument(SalesLine,FALSE);  // FALSE for Invoice.
      LineDiscPct := UpdateDiscOnSalesLineDiscount(SalesLineDiscount);
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Invoice,SalesLineDiscount."Sales Code");
      COMMIT;  // COMMIT required to run CopySalesDocument.
      LibrarySales.CopySalesDocument(SalesHeader,DocType::"Posted Shipment",DocumentNo,FALSE,TRUE);

      // Exercise: Post Sales Invoice.
      DocumentNo := LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify: Verify Line Discount on Posted Sales Invoice after updating Line Discount on Sales Line Discount for Customer.
      Item.GET(SalesLine."No.");
      VerifySalesInvoiceLine(DocumentNo,Item."Unit Price",LineDiscPct);

      // Tear Down.
      UpdateSalesReceivablesSetup(SalesReceivablesSetup."Exact Cost Reversing Mandatory",SalesReceivablesSetup."Stockout Warning");
    END;

    [Test]
    PROCEDURE SalesPriceForCustomerWithPriceInclVAT@101();
    VAR
      SalesPrice@1001 : Record 7002;
      VATPostingSetup@1004 : Record 325;
      CustomerNo@1006 : Code[20];
    BEGIN
      // Verify Unit Price on Sales Line when Sales Price Sales Type Customer is defined with Price Including VAT TRUE.

      // Setup: Create Customer with Price Including VAT TRUE.
      Initialize;
      LibraryERM.FindVATPostingSetup(VATPostingSetup,VATPostingSetup."VAT Calculation Type"::"Normal VAT");
      CustomerNo := CreateAndUpdateCustomer('',VATPostingSetup."VAT Bus. Posting Group",'');

      // Exercise & Verify.
      SalesPriceForPriceInclVAT(VATPostingSetup,SalesPrice."Sales Type"::Customer,CustomerNo,CustomerNo);
    END;

    [Test]
    PROCEDURE SalesPriceForCustPriceGrpWithPriceInclVAT@110();
    VAR
      SalesPrice@1001 : Record 7002;
      VATPostingSetup@1004 : Record 325;
      CustomerPriceGroup@1000 : Code[10];
    BEGIN
      // Verify Unit Price on Sales Line when Sales Price Sales Type Customer Price Group is defined with Price Including VAT TRUE.

      // Setup: Create Customer and Customer Price Group with Price Including VAT TRUE.
      Initialize;
      LibraryERM.FindVATPostingSetup(VATPostingSetup,VATPostingSetup."VAT Calculation Type"::"Normal VAT");
      CustomerPriceGroup := CreateAndUpdateCustPriceGroup(VATPostingSetup."VAT Bus. Posting Group");

      // Exercise & Verify.
      SalesPriceForPriceInclVAT(
        VATPostingSetup,SalesPrice."Sales Type"::"Customer Price Group",CustomerPriceGroup,
        CreateAndUpdateCustomer(CustomerPriceGroup,VATPostingSetup."VAT Bus. Posting Group",''));
    END;

    [Test]
    [HandlerFunctions(PostedSalesDocumentLinesPageHandler)]
    PROCEDURE ReduceQtyOnPartialReceivedSalesReturnOrder@225();
    VAR
      SalesHeader1@1004 : Record 36;
      SalesHeader2@1006 : Record 36;
      SalesInvoiceLine@1001 : Record 113;
      DocumentNo@1000 : Code[20];
      ReturnQtyReceived@1005 : Decimal;
    BEGIN
      // Verify Quantity can be reduced on partial received Sales Return Order created by using Get Posted Document Line to Reverse.
      // Setup: Create and post Sales Order, create Sales Return Order using Get Posted Document Lines To Reverse.
      Initialize;
      DocumentNo := CreateAndPostSalesOrder(SalesHeader1); // Using Random Quantity.
      LibrarySales.CreateSalesHeader(SalesHeader2,SalesHeader2."Document Type"::"Return Order",SalesHeader1."Sell-to Customer No.");
      LibraryVariableStorage.Enqueue(DocumentNo); // Enqueue value for PostedSalesDocumentLinesPageHandler.
      GetPostedDocToReverseOnSalesReturnOrder(SalesHeader2."No.");

      // Exercise: Update "Return Qty. to Receive" on Sales Return Line and post the Sales Return Order.
      ReturnQtyReceived := UpdateReturnQtyToReceiveOnSalesLine(SalesHeader2."No.",SalesHeader2."Document Type");
      LibrarySales.PostSalesDocument(SalesHeader2,TRUE,TRUE);

      // Reopen the Sales Return Order.
      LibrarySales.ReopenSalesDocument(SalesHeader2);

      SalesInvoiceLine.SETRANGE("Document No.",DocumentNo);
      SalesInvoiceLine.FINDFIRST;

      // Exercise & Verify: No error when reduce the Quantity in the Sales Line on page - not repro on the table.
      // Quantity=[SalesLine."Return Qty. Received",SalesLine.Quantity).
      UpdateQtyOnSalesReturnOrder(SalesHeader2."No.",SalesInvoiceLine."No.",
        LibraryRandom.RandDecInDecimalRange(ReturnQtyReceived,SalesInvoiceLine.Quantity - 0.01,2));
    END;

    [Test]
    [HandlerFunctions(PostedPurchaseDocumentLinesPageHandler)]
    PROCEDURE ReduceQtyOnPartialShippedPurchaseReturnOrder@233();
    VAR
      Item@1002 : Record 27;
      PurchaseLine@1000 : Record 39;
      PurchaseHeader@1003 : Record 38;
      DocumentNo@1001 : Code[20];
      ReturnQtyShipped@1004 : Decimal;
    BEGIN
      // Verify Quantity can be reduced on partial shipped Purchase Return Order created by using Get Posted Document Line to Reverse.
      // Setup: Create Item,Create and post Purchase Order, create Purchase Return Order using Get Posted Document Lines To Reverse.
      Initialize;
      LibraryInventory.CreateItem(Item);
      DocumentNo := CreateAndPostPurchaseOrder(PurchaseLine,Item."No.");
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,
        PurchaseHeader."Document Type"::"Return Order",PurchaseLine."Buy-from Vendor No.");
      LibraryVariableStorage.Enqueue(DocumentNo); // Enqueue value for PostedPurchaseDocumentLinesPageHandler.
      GetPostedDocToReverseOnPurchReturnOrder(PurchaseHeader."No.");

      // Exercise: Update "Return Qty. to Ship" on Purchase Return Line and post the Purchase Return Order.
      ReturnQtyShipped := UpdateReturnQtyToShipOnPurchLine(PurchaseHeader."No.",PurchaseHeader."Document Type");
      PurchaseHeader.VALIDATE("Vendor Cr. Memo No.",LibraryUtility.GenerateGUID);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // Reopen the Purchase Return Order.
      LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);

      // Exercise & Verify: No error when reduce the Quantity in the Purchase Line on page - not repro on the table.
      // Quantity=[PurchaseLine."Return Qty. Shipped",PurchaseLine.Quantity).
      UpdateQtyOnPurchReturnOrder(PurchaseHeader."No.",Item."No.",
        LibraryRandom.RandDecInDecimalRange(ReturnQtyShipped,PurchaseLine.Quantity - 0.01,2));
    END;

    [Test]
    PROCEDURE ReduceQtyOnPartialShippedSalesOrderWithNegativeQuantity@238();
    VAR
      SalesHeader1@1003 : Record 36;
      SalesLine2@1007 : Record 37;
      SalesHeader2@1000 : Record 36;
      SalesInvoiceLine@1001 : Record 113;
      DocumentNo@1008 : Code[20];
      QtyShipped@1005 : Decimal;
    BEGIN
      // Verify quantity can be reduced after partially shipping sales order with negative quantity created by using Appl.-from Item Entry.
      // Setup: Create and post Sales Order.
      Initialize;
      DocumentNo := CreateAndPostSalesOrder(SalesHeader1);

      SalesInvoiceLine.SETRANGE("Document No.",DocumentNo);
      SalesInvoiceLine.FINDFIRST;

      // Exercise: Create Sales Order with negative quantity using Appl.-from Item Entry, update "Qty. to Ship" and shipped.
      QtyShipped := CreateAndParitialShipSalesOrderWithNegativeQty(
          SalesHeader2,SalesLine2,SalesInvoiceLine."No.",-SalesInvoiceLine.Quantity,FALSE);

      // Reopen the Sales Order with negative quantity.
      LibrarySales.ReopenSalesDocument(SalesHeader2);

      // Exercise & Verify: No error when reduce the Quantity in the sales line on page - not repro on the table.
      // Quantity=[SalesLine."Qty. Shipped",SalesLine.Quantity).
      UpdateQtyOnSalesOrder(SalesHeader2."No.",SalesInvoiceLine."No.",
        LibraryRandom.RandDecInDecimalRange(-(SalesInvoiceLine.Quantity - 0.01),QtyShipped,2));
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ItemTrackingLinesPageHandler,ReservationPageHandler,CreditMemoConfirmHandler,ItemTrackingListPageHandler)]
    PROCEDURE CancelReservationFromBoundProductionOrder@116();
    VAR
      ProdOrderLine@1003 : Record 5406;
      ReservationEntry@1001 : Record 337;
      SalesLine@1002 : Record 37;
    BEGIN
      // Verify Expected Receipt and Shipment Date on Reservation Entries of Sales and Production Orders after cancelling reservation
      // from order-to-order bound Production Order

      // Setup: Create Released Production Order From Sales Order with Tracking.
      Initialize;
      CreateProdOrderFromSalesOrderUsingPlanning(SalesLine);
      FindProdOrderLine(ProdOrderLine,SalesLine."No.");
      AssignLotNoOnBoundProductionOrder(ProdOrderLine);

      // Exercise: Cancel Reservation on Released Production Order
      CancelReservationOnProductionOrder(ProdOrderLine."Item No.");

      // Verify: Verify Expected Receipt and Shipment Date on Reservation Entries of Sales and Production Orders after cancelling reservation
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,ProdOrderLine."Item No.",DATABASE::"Sales Line",
        SalesLine."Document Type"::Order,FALSE,SalesLine."Shipment Date",0D);
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,ProdOrderLine."Item No.",DATABASE::"Prod. Order Line",
        ProdOrderLine.Status::Released,TRUE,0D,ProdOrderLine."Due Date");
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,CreditMemoConfirmHandler,ReservationPageHandler,ItemTrackingListPageHandler)]
    PROCEDURE CancelReservationFromBoundPurchaseOrder@131();
    VAR
      Item@1000 : Record 27;
      PurchaseLine@1001 : Record 39;
      ReservationEntry@1007 : Record 337;
      SalesLine@1006 : Record 37;
      LotNo@1003 : Code[10];
      Quantity@1002 : Decimal;
    BEGIN
      // Verify Expected Receipt and Shipment Date on Reservation Entries of Sales and Purchase Orders after cancelling reservation
      // from order-to-order bound Purchase Order.

      // Setup: Create Sales and Purchase Order and Reserve Sales against Purchase.
      Initialize;
      LotNo := LibraryUtility.GenerateGUID;
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryInventory.CreateTrackedItem(
        Item,LibraryUtility.GetGlobalNoSeriesCode,'',CreateLotWhseTrackingCode);
      CreatePurchaseOrderWithItemTracking(PurchaseLine,PurchaseLine."Document Type"::Order,Item."No.",Quantity,LotNo);
      CreateSalesOrderWithItemTracking(SalesLine,SalesLine."Document Type"::Order,Item."No.",Quantity,LotNo);
      SalesLine.VALIDATE("Shipment Date",CALCDATE(STRSUBSTNO('<%1M>',LibraryRandom.RandInt(5)),WORKDATE));
      SalesLine.MODIFY(TRUE);
      CreateReservationForBoundSalesOrder(SalesLine);

      // Exercise: Cancel Reservation on Purchase Order
      CancelReservationOnBoundPurchaseOrder(PurchaseLine);

      // Verify: Verify Expected Receipt and Shipment Date on Reservation Entries of Sales and Purchase Orders after cancelling reservation
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,Item."No.",DATABASE::"Sales Line",
        SalesLine."Document Type"::Order,FALSE,SalesLine."Shipment Date",0D);
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,Item."No.",DATABASE::"Purchase Line",
        PurchaseLine."Document Type"::Order,TRUE,0D,PurchaseLine."Expected Receipt Date");
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,CreditMemoConfirmHandler,ReservationPageHandler,ItemTrackingListPageHandler)]
    PROCEDURE CancelReservationFromBoundSalesOrderWithNegativeQuantity@134();
    VAR
      Item@1002 : Record 27;
      ReservationEntry@1005 : Record 337;
      SalesLineWithNegativeQuantity@1006 : Record 37;
      SalesLine@1004 : Record 37;
      LotNo@1003 : Code[10];
      Quantity@1001 : Decimal;
    BEGIN
      // Verify Expected Receipt and Shipment Date on Reservation Entries of Sales Order and Sales Order with Negative Quantity after cancelling reservation
      // from order-to-order bound Sales Order with Negative Quantity.

      // Setup: Create Negative and Positive Quantity Sales Order and Reserve Positive Sales Order against Negative.
      Initialize;
      LotNo := LibraryUtility.GenerateGUID;
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryInventory.CreateTrackedItem(
        Item,LibraryUtility.GetGlobalNoSeriesCode,'',CreateLotWhseTrackingCode);
      CreateSalesOrderWithItemTracking(SalesLineWithNegativeQuantity,SalesLine."Document Type"::Order,Item."No.",-Quantity,
        LotNo);
      CreateSalesOrderWithItemTracking(SalesLine,SalesLine."Document Type"::Order,Item."No.",Quantity,LotNo);
      SalesLine.VALIDATE("Shipment Date",CALCDATE(STRSUBSTNO('<%1M>',LibraryRandom.RandInt(5)),WORKDATE));
      SalesLine.MODIFY(TRUE);
      CreateReservationForBoundSalesOrder(SalesLine);

      // Exercise: Cancel Reservation on Sales Order with Negative Quantity
      CancelReservationOnBoundSalesOrder(SalesLineWithNegativeQuantity);

      // Verify: Verify Expected Receipt and Shipment Date on Reservation Entries of Sales Order and Sales Order with Negative Quantity after cancelling reservation
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,Item."No.",DATABASE::"Sales Line",
        SalesLine."Document Type"::Order,TRUE,0D,SalesLineWithNegativeQuantity."Shipment Date");
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,Item."No.",DATABASE::"Sales Line",
        SalesLine."Document Type"::Order,FALSE,SalesLine."Shipment Date",0D);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,CreditMemoConfirmHandler,ReservationPageHandler,ItemTrackingListPageHandler)]
    PROCEDURE CancelReservationFromBoundPurchaseOrderWithNegativeQuantity@136();
    VAR
      Item@1003 : Record 27;
      ReservationEntry@1007 : Record 337;
      SalesLine@1005 : Record 37;
      PurchaseLineWithNegativeQuantity@1001 : Record 39;
      LotNo@1004 : Code[10];
      Quantity@1002 : Decimal;
    BEGIN
      // Verify Expected Receipt and Shipment Date on Reservation Entries of Sales Return Order and Purchase Order with Negative Quantity after cancelling reservation
      // from order-to-order bound Purchase Order with Negative Quantity.

      // Setup: Create Sales Order and Negative Quantity Purchase Order and Reserve Purchase against Sales Return.
      Initialize;
      LotNo := LibraryUtility.GenerateGUID;
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryInventory.CreateTrackedItem(
        Item,LibraryUtility.GetGlobalNoSeriesCode,'',CreateLotWhseTrackingCode);
      CreateSalesOrderWithItemTracking(SalesLine,SalesLine."Document Type"::"Return Order",Item."No.",Quantity,LotNo);
      CreatePurchaseOrderWithItemTracking(PurchaseLineWithNegativeQuantity,PurchaseLineWithNegativeQuantity."Document Type"::Order,
        Item."No.",-Quantity,LotNo);
      PurchaseLineWithNegativeQuantity.VALIDATE(
        "Expected Receipt Date",CALCDATE(STRSUBSTNO('<%1M>',LibraryRandom.RandInt(5)),WORKDATE));
      PurchaseLineWithNegativeQuantity.MODIFY(TRUE);
      CreateReservationForBoundPurchaseOrder(PurchaseLineWithNegativeQuantity);

      // Exercise: Cancel Reservation On Purchase Order
      CancelReservationOnBoundPurchaseOrder(PurchaseLineWithNegativeQuantity);

      // Verify: Verify Expected Receipt and Shipment Date on Reservation Entries of Sales Return Order and Purchase Order with Negative Quantity after cancelling reservation
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,Item."No.",DATABASE::"Sales Line",
        SalesLine."Document Type"::"Return Order",TRUE,0D,SalesLine."Shipment Date");
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,Item."No.",DATABASE::"Purchase Line",
        PurchaseLineWithNegativeQuantity."Document Type"::Order,FALSE,PurchaseLineWithNegativeQuantity."Expected Receipt Date",0D);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,CreditMemoConfirmHandler,ReservationPageHandler,ItemTrackingListPageHandler)]
    PROCEDURE CancelReservationFromBoundReturnSalesOrder@135();
    VAR
      Item@1001 : Record 27;
      ReservationEntry@1007 : Record 337;
      SalesLineReturn@1006 : Record 37;
      SalesLine@1005 : Record 37;
      LotNo@1004 : Code[10];
      Quantity@1002 : Decimal;
    BEGIN
      // Verify Expected Receipt and Shipment Date on Reservation Entries of Sales Return Order and Sales Order after cancelling reservation
      // from order-to-order bound Sales Return Order.

      // Setup: Create Sales Order and Return Sales Order and Reserve Sales against Sales Return.
      Initialize;
      LotNo := LibraryUtility.GenerateGUID;
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryInventory.CreateTrackedItem(
        Item,LibraryUtility.GetGlobalNoSeriesCode,'',CreateLotWhseTrackingCode);
      CreateSalesOrderWithItemTracking(SalesLineReturn,SalesLine."Document Type"::"Return Order",Item."No.",Quantity,LotNo);
      CreateSalesOrderWithItemTracking(SalesLine,SalesLine."Document Type"::Order,Item."No.",Quantity,LotNo);
      SalesLine.VALIDATE("Shipment Date",CALCDATE(STRSUBSTNO('<%1M>',LibraryRandom.RandInt(5)),WORKDATE));
      SalesLine.MODIFY(TRUE);
      CreateReservationForBoundSalesOrder(SalesLine);

      // Exercise: Cancel Reservation on Return Sales Order
      CancelReservationOnBoundSalesOrder(SalesLineReturn);

      // Verify: Verify Expected Receipt and Shipment Date on Reservation Entries of Sales Return Order and Sales Order after cancelling reservation
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,Item."No.",DATABASE::"Sales Line",
        SalesLine."Document Type"::"Return Order",TRUE,0D,SalesLineReturn."Shipment Date");
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,Item."No.",DATABASE::"Sales Line",
        SalesLine."Document Type"::Order,FALSE,SalesLine."Shipment Date",0D);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,CreditMemoConfirmHandler,ReservationPageHandler,ItemTrackingListPageHandler)]
    PROCEDURE CancelReservationFromBoundReturnPurchaseOrder@138();
    VAR
      Item@1005 : Record 27;
      ReservationEntry@1007 : Record 337;
      PurchaseLine@1001 : Record 39;
      PurchaseLineReturn@1000 : Record 39;
      LotNo@1004 : Code[10];
      Quantity@1002 : Decimal;
    BEGIN
      // Verify Expected Receipt and Shipment Date on Reservation Entries of Purchase Order and Purchase Return Order after cancelling reservation
      // from order-to-order bound Sales Return Order.

      // Setup: Create Purchase Order and Return Purchase Order and Reserve Purchase against Purchase Return.
      Initialize;
      LotNo := LibraryUtility.GenerateGUID;
      Quantity := LibraryRandom.RandDec(10,2);
      LibraryInventory.CreateTrackedItem(
        Item,LibraryUtility.GetGlobalNoSeriesCode,'',CreateLotWhseTrackingCode);
      CreatePurchaseOrderWithItemTracking(PurchaseLine,PurchaseLine."Document Type"::Order,Item."No.",Quantity,LotNo);
      CreatePurchaseOrderWithItemTracking(PurchaseLineReturn,PurchaseLine."Document Type"::"Return Order",Item."No.",Quantity,
        LotNo);
      PurchaseLineReturn.VALIDATE("Expected Receipt Date",CALCDATE(STRSUBSTNO('<%1M>',LibraryRandom.RandInt(5)),WORKDATE));
      PurchaseLineReturn.MODIFY(TRUE);
      CreateReservationForBoundPurchaseOrder(PurchaseLineReturn);

      // Exercise: Cancel Reservation from Purchase Order
      CancelReservationOnBoundPurchaseOrder(PurchaseLine);

      // Verify: Verify Expected Receipt and Shipment Date on Reservation Entries of Purchase Order and Purchase Return Order after cancelling reservation
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,Item."No.",DATABASE::"Purchase Line",
        PurchaseLine."Document Type"::Order,TRUE,0D,PurchaseLine."Expected Receipt Date");
      VerifyShipmentAndExpRcptDateOnReservationEntry(ReservationEntry,Item."No.",DATABASE::"Purchase Line",
        PurchaseLine."Document Type"::"Return Order",FALSE,PurchaseLineReturn."Expected Receipt Date",0D);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,EnterQuantitytoCreatePageHandler,ItemTrackingSummaryPageHandler)]
    PROCEDURE CreateSalesReturnOrderByCopyDocumentWithSerialNo@157();
    VAR
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
      CreateReturnOrderMethod@1000 : 'GetPostedDocumentLineToReserve,CopyDocument,ByManually';
    BEGIN
      // Sales Return Order created by Copy Document with Serial No. on Item Tracking Line.
      CalcPlanAfterCreateSalesReturnOrderWithIT(TRUE,FALSE,FALSE,TrackingOption::AssignSerialNo,CreateReturnOrderMethod::CopyDocument);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,ItemTrackingSummaryPageHandler)]
    PROCEDURE CreateSalesReturnOrderByManuallyWithLotNo@158();
    VAR
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
      CreateReturnOrderMethod@1000 : 'GetPostedDocumentLineToReserve,CopyDocument,ByManually';
    BEGIN
      // Sales Return Order created by manually with Lot No. on Item Tracking Line.
      CalcPlanAfterCreateSalesReturnOrderWithIT(FALSE,TRUE,FALSE,TrackingOption::SetLotNo,CreateReturnOrderMethod::ByManually);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,PostedPurchaseDocumentLinesPageHandler)]
    PROCEDURE CreatePurchReturnOrderByGetPostedDocToReverseWithLotNo@127();
    VAR
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
      CreateReturnOrderMethod@1000 : 'GetPostedDocumentLineToReserve,CopyDocument,ByManually';
    BEGIN
      // Purchase Return Order created by Get Posted Document Line To Reserve with Lot No. on Item Tracking Line.
      CalcPlanAfterCreatePurchReturnOrderWithIT(
        FALSE,TRUE,TrackingOption::SetLotNo,CreateReturnOrderMethod::GetPostedDocumentLineToReserve);
    END;

    [Test]
    [HandlerFunctions(EnterQuantitytoCreatePageHandler,ItemTrackingLinesPageHandler)]
    PROCEDURE CreatePurchReturnOrderByCopyDocumentWithSerialNo@139();
    VAR
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
      CreateReturnOrderMethod@1000 : 'GetPostedDocumentLineToReserve,CopyDocument,ByManually';
    BEGIN
      // Purchase Return Order  created by copy Document with Serial No. on Item Tracking Line.
      CalcPlanAfterCreatePurchReturnOrderWithIT(TRUE,FALSE,TrackingOption::AssignSerialNo,CreateReturnOrderMethod::CopyDocument);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler)]
    PROCEDURE CreatePurchReturnOrderByManuallyWithLotNo@165();
    VAR
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
      CreateReturnOrderMethod@1000 : 'GetPostedDocumentLineToReserve,CopyDocument,ByManually';
    BEGIN
      // Purchase Return Order  created by manually with Lot No. on Item Tracking Line.
      CalcPlanAfterCreatePurchReturnOrderWithIT(FALSE,TRUE,TrackingOption::SetLotNo,CreateReturnOrderMethod::ByManually);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,EnterQuantitytoCreatePageHandler,ItemTrackingSummaryPageHandler,PostedSalesShipmentLinesPageHandler)]
    PROCEDURE CreateSalesReturnOrderApplFromPostedShptByGetPostedDocToRevWithSerialNo@163();
    VAR
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
      CreateReturnOrderMethod@1000 : 'GetPostedDocumentLineToReserve,CopyDocument,ByManually';
    BEGIN
      // Sales Return Order created by Get Posted Document Line To Reserve function and appl. from a Sales Shipment with Serial No. on Item Tracking Line.
      CalcPlanAfterCreateSalesReturnOrderWithIT(
        TRUE,FALSE,FALSE,TrackingOption::AssignSerialNo,CreateReturnOrderMethod::GetPostedDocumentLineToReserve);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,ItemTrackingSummaryPageHandler,PostedSalesDocumentLinesPageHandler)]
    PROCEDURE CreateSalesReturnOrderApplFromPostedInvoiceByGetPostedDocToRevWithLotNo@162();
    VAR
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
      CreateReturnOrderMethod@1000 : 'GetPostedDocumentLineToReserve,CopyDocument,ByManually';
    BEGIN
      // Sales Return Order created by Get Posted Document Line To Reserve function and appl. from a Sales Invoice with Lot No. on Item Tracking Line.
      CalcPlanAfterCreateSalesReturnOrderWithIT(
        FALSE,TRUE,TRUE,TrackingOption::SetLotNo,CreateReturnOrderMethod::GetPostedDocumentLineToReserve);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingLinesPageHandler,EnterQuantitytoCreatePageHandler,ItemTrackingSummaryPageHandler)]
    PROCEDURE CreateSalesReturnOrderApplFromPostedInvoiceByCopyDocWithSerialNo@147();
    VAR
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
      CreateReturnOrderMethod@1000 : 'GetPostedDocumentLineToReserve,CopyDocument,ByManually';
    BEGIN
      // Sales Return Order created by Copy Document function and appl. from a Sales Invoice with Serial No. on Item Tracking Line.
      CalcPlanAfterCreateSalesReturnOrderWithIT(TRUE,FALSE,TRUE,TrackingOption::AssignSerialNo,CreateReturnOrderMethod::CopyDocument);
    END;

    [Test]
    PROCEDURE CheckSalesLineDiscountPageforCustomerDiscountGroup@168();
    VAR
      CustomerDiscountGroup@1000 : Record 340;
      SalesLineDiscount@1001 : Record 7004;
    BEGIN
      // Check Customer Discount Group Code and Type on Sales line discount Page.

      // Setup: Create Customer Discount Group.
      Initialize;
      LibraryERM.CreateCustomerDiscountGroup(CustomerDiscountGroup);

      // Exercise: Create Sales Discount line for Customer Discount Group.
      CreateLineDiscForCustomer(SalesLineDiscount,SalesLineDiscount."Sales Type"::"Customer Disc. Group",CustomerDiscountGroup.Code);

      // Verify: Verify Customer Discount Group Code and Type on Sales line discount Page.
      VerifySalesLineDiscountsOnPage(CustomerDiscountGroup,SalesLineDiscount.Type);
    END;

    [Test]
    PROCEDURE ReasonCodeIsInheritedFromValueEntrytoGL@170();
    VAR
      Item@1000 : Record 27;
      ReasonCode@1002 : Record 231;
      GLEntry@1004 : Record 17;
    BEGIN
      // [FEATURE] [Post Inventory Cost To GL] [Reason Code]
      // [SCENARIO 379803] Reason Code field in General Ledger should be inherited from Item Journal on posting.
      Initialize;

      // [GIVEN] Posted Item Journal Line with Reason Code = "R".
      LibraryInventory.CreateItem(Item);
      LibraryERM.CreateReasonCode(ReasonCode);
      CreateAndPostItemJournalLineWithReasonCode(Item."No.",ReasonCode.Code);

      // [GIVEN] Adjust Cost-Item Entries batch job is run.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // [WHEN] Post Inventory to G/L.
      LibraryCosting.PostInvtCostToGL(FALSE,WORKDATE,'');

      // [THEN] General Ledger contains entries with Reason Code "R".
      GLEntry.INIT;
      GLEntry.SETRANGE("Reason Code",ReasonCode.Code);
      Assert.RecordIsNotEmpty(GLEntry);
    END;

    LOCAL PROCEDURE Initialize@4();
    VAR
      LibraryERMCountryData@1002 : Codeunit 131305;
    BEGIN
      LibraryVariableStorage.Clear;

      // Lazy Setup.
      IF isInitialized THEN
        EXIT;
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.CreateGeneralPostingSetupData;
      LibraryERMCountryData.UpdateGeneralLedgerSetup;
      UpdateInventorySetupCostPosting;

      isInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE AssignLotNoOnBoundProductionOrder@126(VAR ProdOrderLine@1001 : Record 5406);
    BEGIN
      LibraryVariableStorage.Enqueue(TrackingOption::SetLotNo);
      LibraryVariableStorage.Enqueue(LibraryUtility.GenerateGUID);
      LibraryVariableStorage.Enqueue(ProdOrderLine.Quantity);
      ProdOrderLine.OpenItemTrackingLines;
    END;

    LOCAL PROCEDURE AssignLotNoOnBoundPurchaseOrder@128(VAR PurchaseLine@1000 : Record 39;LotNo@1001 : Code[20]);
    BEGIN
      LibraryVariableStorage.Enqueue(TrackingOption::SetLotNo);
      LibraryVariableStorage.Enqueue(LotNo);
      LibraryVariableStorage.Enqueue(PurchaseLine.Quantity);
      PurchaseLine.OpenItemTrackingLines;
    END;

    LOCAL PROCEDURE AssignLotNoOnBoundSalesOrder@133(VAR SalesLine@1000 : Record 37;LotNo@1001 : Code[20]);
    BEGIN
      LibraryVariableStorage.Enqueue(TrackingOption::SetLotNo);
      LibraryVariableStorage.Enqueue(LotNo);
      LibraryVariableStorage.Enqueue(SalesLine.Quantity);
      SalesLine.OpenItemTrackingLines;
    END;

    LOCAL PROCEDURE CalculateWhseAdjustment@92(Item@1000 : Record 27);
    VAR
      ItemJournalBatch@1001 : Record 233;
    BEGIN
      SelectAndClearItemJournalBatch(ItemJournalBatch,ItemJournalBatch."Template Type"::Item);
      LibraryWarehouse.CalculateWhseAdjustment(Item,ItemJournalBatch);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CalcPlanAfterCreateSalesReturnOrderWithIT@160(Serial@1008 : Boolean;Lot@1007 : Boolean;Invoice@1014 : Boolean;TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';CreateReturnOrderMethod@1011 : 'GetPostedDocumentLineToReserve,CopyDocument,ByManually');
    VAR
      SalesReceivablesSetup@1001 : Record 311;
      Item@1000 : Record 27;
      PurchaseHeader@1013 : Record 38;
      SalesHeader@1012 : Record 36;
      ItemLedgerEntry@1010 : Record 32;
      RequisitionWkshName@1009 : Record 245;
      SellToCustomerNo@1004 : Code[20];
      DocumentNo@1005 : Code[20];
      DocumentType@1002 : 'Quote,Blanket Order,Order,Invoice,Return Order,Credit Memo,Posted Shipment,Posted Invoice,Posted Return Receipt,Posted Credit Memo';
    BEGIN
      // Verify 1.Values in Item Tracking Line are correct on existing Sales Return Orders after calculate Plan in Requisition Worksheet.
      // 2.Sales Return Order can be posted successfully when "Exact Cost Reversing Mandatory" is enabled.

      // Setup: Update Sales Receivable Setup: "Exact Cost Reversing Mandatory" is enabled.
      Initialize;
      SalesReceivablesSetup.GET;
      UpdateSalesReceivablesSetup(TRUE,SalesReceivablesSetup."Stockout Warning");

      // Create Tracked Item, Create and post Purchase and Sales Order with Item Tracking.
      CreateTrackedItemWithReorderingPolicy(Item,Serial,Lot,Item."Reordering Policy"::"Lot-for-Lot");
      CreateAndPostPurchaseOrderWithIT(PurchaseHeader,Item."No.",TrackingOption,LibraryRandom.RandInt(100),1); // Make Item has inventory.
      DocumentNo := CreateAndPostSalesOrderWithIT(SellToCustomerNo,Item."No.",1,TrackingOption::SelectEntries,TRUE,Invoice); // Quantity is 1, as Quantity(Base) cannot be more than 1 with Serial No.

      // Create Sales Return Order with Item Tracking.
      FindItemLedgerEntry(ItemLedgerEntry,Item."No.",ItemLedgerEntry."Entry Type"::Sale);
      CASE CreateReturnOrderMethod OF
        CreateReturnOrderMethod::GetPostedDocumentLineToReserve:
          CreateSalesReturnOrderByGetPstdDocLineToRev(SalesHeader,Item,SellToCustomerNo,DocumentNo);
        CreateReturnOrderMethod::CopyDocument:
          BEGIN
            IF Invoice THEN
              CreateSalesReturnOrderByCopyDocument(SalesHeader,SellToCustomerNo,DocumentNo,DocumentType::"Posted Invoice",FALSE)
            ELSE
              CreateSalesReturnOrderByCopyDocument(SalesHeader,SellToCustomerNo,DocumentNo,DocumentType::"Posted Shipment",TRUE);
          END;
        CreateReturnOrderMethod::ByManually:
          CreateSalesReturnOrderWithApplFromItemEntryOnItemTrackingLine(
            SalesHeader,SellToCustomerNo,Item."No.",ItemLedgerEntry."Lot No.",1,ItemLedgerEntry."Entry No."); // Quantity is 1, as Quantity(Base) cannot be more than 1 with Serial No.
      END;

      // Exercise: Calculate Plan on Requisition Worksheets.
      CalculatePlanForRequisitionWorksheet(RequisitionWkshName,Item,WORKDATE,CALCDATE('<CM>',WORKDATE));

      // Verify: The values on Item Tracking Line is correct on existing Sales Return Orders.
      IF Lot THEN
        VerifyValuesOnTrackingLine(
          SalesHeader."Document Type",SalesHeader."No.",Item."No.",
          ItemLedgerEntry."Lot No.",'',ItemLedgerEntry."Entry No.",ItemLedgerEntry.Quantity);
      IF Serial THEN
        VerifyValuesOnTrackingLine(
          SalesHeader."Document Type",SalesHeader."No.",Item."No.",'',
          ItemLedgerEntry."Serial No.",ItemLedgerEntry."Entry No.",ItemLedgerEntry.Quantity);

      // Exercise and Verify: Verify the Sales Return Order can be posted successfully.
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Tear Down.
      UpdateSalesReceivablesSetup(SalesReceivablesSetup."Exact Cost Reversing Mandatory",SalesReceivablesSetup."Stockout Warning");
    END;

    LOCAL PROCEDURE CalcPlanAfterCreatePurchReturnOrderWithIT@161(Serial@1007 : Boolean;Lot@1008 : Boolean;TrackingOption@1009 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';CreateReturnOrderMethod@1010 : 'GetPostedDocumentLineToReserve,CopyDocument,ByManually');
    VAR
      Item@1004 : Record 27;
      PurchasesPayablesSetup@1001 : Record 312;
      PurchaseHeader@1002 : Record 38;
      PurchaseHeader2@1011 : Record 38;
      ItemLedgerEntry@1000 : Record 32;
      RequisitionWkshName@1006 : Record 245;
      DocumentNo@1005 : Code[20];
      DocumentType@1012 : 'Quote,Blanket Order,Order,Invoice,Return Order,Credit Memo,Posted Receipt,Posted Invoice,Posted Return Shipment,Posted Credit Memo';
    BEGIN
      // Verify 1.Value in Appl.-to Item Entry is correct on existing Purchase Return Orders after calculate Plan in Requisition Worksheet.
      // 2.Purchase Return Order can be posted successfully when "Exact Cost Reversing Mandatory" is enabled.

      // Setup: Update Purchase Payable Setup: "Exact Cost Reversing Mandatory" is enabled.
      Initialize;
      PurchasesPayablesSetup.GET;
      UpdatePurchasesPayablesSetup(TRUE);

      // Create Item, Create and post Purchase Order with Item Tracking.
      CreateTrackedItemWithReorderingPolicy(Item,Serial,Lot,Item."Reordering Policy"::"Lot-for-Lot");
      DocumentNo := CreateAndPostPurchaseOrderWithIT(PurchaseHeader,Item."No.",TrackingOption,1,1); // Quantity is 1, as Quantity(Base) cannot be more than 1 for Serial No.

      // Create Purchase Return Order with Item Tracking.
      FindItemLedgerEntry(ItemLedgerEntry,Item."No.",ItemLedgerEntry."Entry Type"::Purchase);
      CASE CreateReturnOrderMethod OF
        CreateReturnOrderMethod::GetPostedDocumentLineToReserve:
          BEGIN
            LibraryVariableStorage.Enqueue(DocumentNo);
            CreatePurchRetOrderGetPstdDocLineToRev(PurchaseHeader2,PurchaseHeader."Buy-from Vendor No.");
          END;
        CreateReturnOrderMethod::CopyDocument:
          BEGIN
            LibraryPurchase.CreatePurchHeader(
              PurchaseHeader2,PurchaseHeader2."Document Type"::"Return Order",PurchaseHeader."Buy-from Vendor No.");
            LibraryPurchase.CopyPurchaseDocument(PurchaseHeader2,DocumentType::"Posted Invoice",DocumentNo,TRUE,TRUE);
            PurchaseHeader2.GET(PurchaseHeader2."Document Type",PurchaseHeader2."No.");
          END;
        CreateReturnOrderMethod::ByManually:
          CreatePurchReturnOrderWithApplToItemEntryOnItemTrackingLine(
            PurchaseHeader2,PurchaseHeader."Buy-from Vendor No.",Item."No.",
            ItemLedgerEntry."Lot No.",ItemLedgerEntry.Quantity,ItemLedgerEntry."Entry No.");
      END;

      // Exercise: Calculate Plan on Requisition Worksheets.
      CalculatePlanForRequisitionWorksheet(RequisitionWkshName,Item,WORKDATE,CALCDATE('<CM>',WORKDATE));

      // Verify: The value of Appl.-to Item Entry of Item Tracking Line is correct on existing Purchase Return Orders.
      VerifyApplToItemEntryOnTrackingLine(
        PurchaseHeader2."Document Type",PurchaseHeader2."No.",Item."No.",ItemLedgerEntry."Entry No.");

      // Exercise and Verify: Verify the Purchase Return Order can be posted successfully.
      PostPurchaseReturnOrder(PurchaseHeader2);

      // Tear Down.
      UpdatePurchasesPayablesSetup(PurchasesPayablesSetup."Exact Cost Reversing Mandatory");
    END;

    LOCAL PROCEDURE CloseFiscalYear@36();
    VAR
      AccountingPeriod@1000 : Record 50;
      Counter@1500000 : Integer;
    BEGIN
      AccountingPeriod.SETRANGE("New Fiscal Year",TRUE);
      AccountingPeriod.SETRANGE(Closed,FALSE);
      IF AccountingPeriod.COUNT > 1 THEN BEGIN
        FOR Counter := 1 TO AccountingPeriod.COUNT - 1 DO
          LibraryVariableStorage.Enqueue(ClosedFiscalYear);  // Enqueue for ConfirmHandler.
        LibraryFiscalYear.CloseFiscalYear;
      END;
    END;

    LOCAL PROCEDURE CreateAndModifyItem@33(ReplenishmentSystem@1003 : Option;CostingMethod@1002 : Option) : Code[20];
    VAR
      Item@1001 : Record 27;
    BEGIN
      Item.GET(CreateItem(ReplenishmentSystem));
      Item.VALIDATE("Costing Method",CostingMethod);
      Item.VALIDATE("Overhead Rate",LibraryRandom.RandDec(10,2));  // Using Random value for Overhead Rate.
      Item.VALIDATE("Standard Cost",LibraryRandom.RandDec(100,1));  // Using Random value for Standard Cost.
      Item.VALIDATE("Unit Price",LibraryRandom.RandDec(100,1));  // Using Random value for Unit Price.
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateAndPostItemJournalLine@28(VAR ItemJournalLine@1000 : Record 83;ItemNo@1001 : Code[20]);
    BEGIN
      CreateItemJournalLine(
        ItemJournalLine,ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,LibraryRandom.RandDec(10,2),
        LibraryRandom.RandDec(10,2));  // Use random Quantity and Unit Cost.
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE CreateAndPostItemJournalLineWithReasonCode@174(ItemNo@1002 : Code[20];ReasonCode@1001 : Code[10]);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      WITH ItemJournalLine DO BEGIN
        CreateItemJournalLine(
          ItemJournalLine,"Entry Type"::"Positive Adjmt.",ItemNo,LibraryRandom.RandDec(10,2),
          LibraryRandom.RandDec(10,2));
        VALIDATE("Reason Code",ReasonCode);
        MODIFY(TRUE);
        LibraryInventory.PostItemJournalLine("Journal Template Name","Journal Batch Name");
      END;
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrder@52(VAR PurchaseLine@1000 : Record 39;No@1003 : Code[20]) : Code[20];
    VAR
      PurchaseHeader@1001 : Record 38;
    BEGIN
      CreatePurchaseOrder(PurchaseLine,No);
      UpdateGeneralPostingSetup(PurchaseLine);
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      EXIT(LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE));
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrderWithIT@123(VAR PurchaseHeader@1003 : Record 38;ItemNo@1001 : Code[20];TrackingOption@1000 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo';Quantity@1008 : Integer;LineCount@1007 : Integer) : Code[20];
    VAR
      ReservationEntry@1006 : Record 337;
      PurchaseLine@1002 : Record 39;
      LotNo@1005 : Code[20];
      count@1004 : Integer;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      LotNo := LibraryUtility.GenerateRandomCode(ReservationEntry.FIELDNO("Lot No."),DATABASE::"Reservation Entry");

      FOR count := 1 TO LineCount DO BEGIN
        LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity);
        PurchaseLine.VALIDATE("Direct Unit Cost",LibraryRandom.RandDec(10,2));  // Use Random Direct Unit Cost.
        PurchaseLine.MODIFY(TRUE);
        LibraryVariableStorage.Enqueue(TrackingOption);  // Enqueue value for ItemTrackingLinesPageHandler.
        IF TrackingOption = TrackingOption::SetLotNo THEN BEGIN
          LibraryVariableStorage.Enqueue(LotNo);
          LibraryVariableStorage.Enqueue(PurchaseLine."Quantity (Base)");
        END;
        PurchaseLine.OpenItemTrackingLines;
      END;

      EXIT(LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE));
    END;

    LOCAL PROCEDURE CreateAndPostSalesOrderWithIT@152(VAR SellToCustomerNo@1009 : Code[20];ItemNo@1001 : Code[20];Quantity@1006 : Integer;TrackingOption@1000 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo';Ship@1008 : Boolean;Invoice@1007 : Boolean) : Code[20];
    VAR
      SalesHeader@1003 : Record 36;
      ReservationEntry@1005 : Record 337;
      SalesLine@1002 : Record 37;
      LotNo@1004 : Code[20];
    BEGIN
      SalesHeader.INIT;
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CreateCustomer);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);

      LibraryVariableStorage.Enqueue(TrackingOption); // Enqueue value for ItemTrackingLinesPageHandler.
      IF TrackingOption = TrackingOption::SetLotNo THEN BEGIN
        LotNo := LibraryUtility.GenerateRandomCode(ReservationEntry.FIELDNO("Lot No."),DATABASE::"Reservation Entry");
        LibraryVariableStorage.Enqueue(LotNo);
        LibraryVariableStorage.Enqueue(SalesLine."Quantity (Base)");
      END;
      SalesLine.OpenItemTrackingLines;
      SellToCustomerNo := SalesHeader."Sell-to Customer No.";
      EXIT(LibrarySales.PostSalesDocument(SalesHeader,Ship,Invoice));
    END;

    LOCAL PROCEDURE CreateAndPostSalesOrder@60(VAR SalesHeader@1003 : Record 36) : Code[20];
    VAR
      SalesLine@1001 : Record 37;
      Item@1002 : Record 27;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CreateCustomer);
      LibrarySales.CreateSalesLine(
        SalesLine,SalesHeader,SalesLine.Type::Item,CreateItem(Item."Replenishment System"::Purchase),
        LibraryRandom.RandDec(10,2));  // Take random Quantity.
      EXIT(LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE));
    END;

    LOCAL PROCEDURE CreateAndParitialShipSalesOrderWithNegativeQty@246(VAR SalesHeader@1008 : Record 36;VAR SalesLine@1003 : Record 37;No@1006 : Code[20];Quantity@1004 : Decimal;Invoice@1002 : Boolean) : Decimal;
    VAR
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CreateCustomer);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,No,Quantity);
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");

      ItemLedgerEntry.SETRANGE("Item No.",No);
      ItemLedgerEntry.FINDFIRST;
      SalesLine.VALIDATE("Appl.-from Item Entry",ItemLedgerEntry."Entry No.");

      // Update the "Qty. to Ship"=-(ABS(SalesLine."Qty. to Ship") - 1,ABS(SalesLine."Qty. to Ship") / 2),
      // not repro when the ABS("Qty. to Ship") is less than original ABS(SalesLine."Qty. to Ship") / 2.
      SalesLine.VALIDATE("Qty. to Ship",
        -LibraryRandom.RandDecInDecimalRange(-SalesLine."Qty. to Ship" / 2 + 0.01,-SalesLine."Qty. to Ship" - 0.01,2));
      SalesLine.MODIFY(TRUE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,Invoice);
      EXIT(SalesLine."Quantity Shipped");
    END;

    LOCAL PROCEDURE CreateAndPostJobJournalLine@18(VAR JobJournalLine@1001 : Record 210);
    VAR
      Item@1004 : Record 27;
      Job@1003 : Record 167;
      JobTask@1002 : Record 1001;
    BEGIN
      Item.GET(CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::Average));
      LibraryJob.CreateJob(Job);
      LibraryJob.CreateJobTask(Job,JobTask);
      LibraryJob.CreateJobJournalLine(JobJournalLine."Line Type"::" ",JobTask,JobJournalLine);
      JobJournalLine.VALIDATE(Type,JobJournalLine.Type::Item);
      JobJournalLine.VALIDATE("No.",Item."No.");
      JobJournalLine.VALIDATE(Quantity,LibraryRandom.RandDec(10,2));
      JobJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(10,2));
      JobJournalLine.MODIFY(TRUE);
      LibraryVariableStorage.Enqueue(PostJournalLines);  // Enqueue for MessageHandler.
      LibraryVariableStorage.Enqueue(SuccessfullyPostLines);  // Enqueue for MessageHandler.
      LibraryJob.PostJobJournal(JobJournalLine);
    END;

    LOCAL PROCEDURE CreateAndReceivePurchOrderWithItemCharge@62(VAR PurchaseLine@1003 : Record 39);
    VAR
      PurchaseHeader@1004 : Record 38;
      PurchaseLine2@1002 : Record 39;
      Item@1005 : Record 27;
      ItemChargeAssignmentPurch@1000 : Record 5805;
    BEGIN
      CreatePurchaseOrder(PurchaseLine,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO));

      // Create ItemCharge Assign Purchase.
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      LibraryPurchase.CreatePurchaseLine(
        PurchaseLine2,PurchaseHeader,PurchaseLine2.Type::"Charge (Item)",LibraryInventory.CreateItemChargeNo,PurchaseLine.Quantity);
      PurchaseLine2.VALIDATE("Direct Unit Cost",LibraryRandom.RandDec(10,2));  // Use random value for Amount.
      PurchaseLine2.MODIFY(TRUE);
      LibraryInventory.CreateItemChargeAssignPurchase(
        ItemChargeAssignmentPurch,PurchaseLine2,ItemChargeAssignmentPurch."Applies-to Doc. Type"::Order,PurchaseHeader."No.",
        PurchaseLine."Line No.",PurchaseLine."No.");
      UpdateGeneralPostingSetup(PurchaseLine2);

      // Receive purchase order.
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateAndRegisterWhseJournal@89(ItemNo@1005 : Code[20]);
    VAR
      Bin@1004 : Record 7354;
      Location@1003 : Record 14;
      WarehouseJournalLine@1002 : Record 7311;
      WarehouseJournalBatch@1001 : Record 7310;
      WarehouseJournalTemplate@1000 : Record 7309;
    BEGIN
      CreateWarehouseLocation(Location);
      LibraryWarehouse.FindBin(Bin,Location.Code,FindZone(Location.Code,LibraryWarehouse.SelectBinType(FALSE,FALSE,TRUE,TRUE)),1);  // Use 1 for Bin Index.
      CreateWarehouseJournalBatch(WarehouseJournalBatch,WarehouseJournalTemplate.Type::Item,Location.Code);
      LibraryWarehouse.CreateWhseJournalLine(
        WarehouseJournalLine,WarehouseJournalBatch."Journal Template Name",WarehouseJournalBatch.Name,Location.Code,Bin."Zone Code",
        Bin.Code,WarehouseJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,5);  // Value Zero Important for test.
      LibraryVariableStorage.Enqueue(WarehouseJournalLine.Quantity);
      WarehouseJournalLine.OpenItemTrackingLines;
      LibraryVariableStorage.Enqueue(RegisterJournalLines);
      LibraryVariableStorage.Enqueue(JournalLinesRegistered);
      LibraryWarehouse.RegisterWhseJournalLine(
        WarehouseJournalLine."Journal Template Name",WarehouseJournalLine."Journal Batch Name",Location.Code,FALSE);
    END;

    LOCAL PROCEDURE CreateAndUpdateSalesOrder@90(VAR SalesLine@1000 : Record 37;CustomerNo@1001 : Code[20];ItemNo@1002 : Code[20];Quantity@1003 : Decimal);
    BEGIN
      CreateSalesOrderWithOrderDate(SalesLine,CustomerNo,ItemNo,WORKDATE,'',Quantity);
      SalesLine.VALIDATE("Qty. to Invoice",SalesLine."Qty. to Invoice" / 2);  // Take partial Quantity.
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndUpdateCustomer@98(CustomerPricingGroup@1001 : Code[10];VATBusPostingGroup@1002 : Code[10];CustomerDiscountGroup@1003 : Code[20]) : Code[20];
    VAR
      Customer@1000 : Record 18;
    BEGIN
      Customer.GET(CreateCustomer);
      Customer.VALIDATE("Customer Price Group",CustomerPricingGroup);
      Customer.VALIDATE("VAT Bus. Posting Group",VATBusPostingGroup);
      Customer.VALIDATE("Customer Disc. Group",CustomerDiscountGroup);
      Customer.MODIFY(TRUE);
      EXIT(Customer."No.");
    END;

    LOCAL PROCEDURE CreateAndUpdateSalesPrice@132(VAR SalesPrice@1000 : Record 7002;VATBusPostingGrPrice@1001 : Code[10];ItemNo@1002 : Code[20];SalesType@1004 : Option;SalesCode@1003 : Code[20]);
    BEGIN
      CreateSalesPrice(SalesPrice,ItemNo,SalesType,SalesCode,LibraryRandom.RandDec(10,2),'');  // Take random for Quantity.
      SalesPrice.VALIDATE("Price Includes VAT",TRUE);
      SalesPrice.VALIDATE("VAT Bus. Posting Gr. (Price)",VATBusPostingGrPrice);
      SalesPrice.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateLotWhseTrackingCode@140() : Code[10];
    VAR
      ItemTrackingCode@1000 : Record 6502;
    BEGIN
      LibraryItemTracking.CreateItemTrackingCode(ItemTrackingCode,FALSE,TRUE);
      ItemTrackingCode.VALIDATE("Lot Warehouse Tracking",TRUE);
      ItemTrackingCode.MODIFY(TRUE);
      EXIT(ItemTrackingCode.Code);
    END;

    LOCAL PROCEDURE CreateLineDiscForCustomer@118(VAR SalesLineDiscount@1000 : Record 7004;SalesType@1001 : Option;SalesCode@1002 : Code[20]);
    VAR
      Item@1003 : Record 27;
    BEGIN
      LibraryERM.CreateLineDiscForCustomer(
        SalesLineDiscount,SalesLineDiscount.Type::Item,
        CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO),SalesType,SalesCode,WORKDATE,'','','',
        LibraryRandom.RandDec(10,2));  // Take random for Minimum Quantity.
      SalesLineDiscount.VALIDATE("Line Discount %",LibraryRandom.RandDec(10,2));  // Take random for Line Discount Pct.
      SalesLineDiscount.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateCustomer@19() : Code[20];
    VAR
      Customer@1000 : Record 18;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      EXIT(Customer."No.");
    END;

    LOCAL PROCEDURE CreateCurrency@99() : Code[10];
    VAR
      Currency@1000 : Record 4;
    BEGIN
      LibraryERM.CreateCurrency(Currency);
      LibraryERM.CreateRandomExchangeRate(Currency.Code);
      EXIT(Currency.Code);
    END;

    LOCAL PROCEDURE CreateItem@22(ReplenishmentSystem@1001 : Option) : Code[20];
    VAR
      Item@1000 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Replenishment System",ReplenishmentSystem);
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateItemWithVAT@137(VATProdPostingGroup@1000 : Code[10]) : Code[20];
    VAR
      Item@1001 : Record 27;
    BEGIN
      Item.GET(CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO));
      Item.VALIDATE("VAT Prod. Posting Group",VATProdPostingGroup);
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateTrackedItemWithReorderingPolicy@146(VAR Item@1000 : Record 27;Serial@1003 : Boolean;Lot@1002 : Boolean;ReorderingPolicy@1001 : Option);
    BEGIN
      LibraryInventory.CreateTrackedItem(Item,'',LibraryUtility.GetGlobalNoSeriesCode,CreateItemTrackingCode(Serial,Lot));
      Item.VALIDATE("Reordering Policy",ReorderingPolicy);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateReleasedProductionOrderFromSalesOrder@125(VAR ProductionOrder@1001 : Record 5405;SalesHeader@1000 : Record 36);
    VAR
      OrderType@1002 : 'ItemOrder,ProjectOrder';
    BEGIN
      LibraryVariableStorage.Enqueue(ProductionOrderCreatedMsg);  // Enqueue variable for created Production Order message in MessageHandler.
      LibraryManufacturing.CreateProductionOrderFromSalesOrder(SalesHeader,ProductionOrder.Status::Released,OrderType::ItemOrder);
    END;

    LOCAL PROCEDURE CreateProdOrderFromSalesOrder@25(VAR SalesLine@1000 : Record 37;Status@1005 : Option;OrderType@1006 : Option);
    VAR
      Item@1001 : Record 27;
      SalesHeader@1003 : Record 36;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CreateCustomer);
      LibrarySales.CreateSalesLine(
        SalesLine,SalesHeader,SalesLine.Type::Item,CreateItem(Item."Replenishment System"::"Prod. Order"),
        LibraryRandom.RandDec(10,2));  // Take random Quantity.
      LibraryVariableStorage.Enqueue(ProdOrderCreated);  // Enqueue for MessageHandler.
      LibraryManufacturing.CreateProductionOrderFromSalesOrder(SalesHeader,Status,OrderType);
    END;

    LOCAL PROCEDURE CreatePurchaseOrder@65(VAR PurchaseLine@1000 : Record 39;No@1001 : Code[20]);
    VAR
      PurchaseHeader@1002 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,No,LibraryRandom.RandDec(10,2));  // Use random Quantity.
      PurchaseLine.VALIDATE("Direct Unit Cost",LibraryRandom.RandDec(10,2));  // Use Random Direct Unit Cost.
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreatePurchaseOrderWithItemTracking@142(VAR PurchaseLine@1005 : Record 39;DocumentType@1001 : Option;ItemNo@1003 : Code[20];Quantity@1000 : Decimal;LotNo@1008 : Code[20]);
    VAR
      PurchaseHeader@1006 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,DocumentType,'');
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity);
      AssignLotNoOnBoundPurchaseOrder(PurchaseLine,LotNo);
    END;

    LOCAL PROCEDURE CreateItemJournalLine@23(VAR ItemJournalLine@1000 : Record 83;EntryType@1002 : Option;ItemNo@1004 : Code[20];Quantity@1005 : Decimal;UnitCost@1006 : Decimal);
    VAR
      ItemJournalBatch@1001 : Record 233;
    BEGIN
      SelectAndClearItemJournalBatch(ItemJournalBatch,ItemJournalBatch."Template Type"::Item);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,EntryType,ItemNo,Quantity);
      ItemJournalLine.VALIDATE("Unit Cost",UnitCost);  // random unit cost.
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemJournalLineForPhysInv@12(VAR ItemJournalLine@1000 : Record 83);
    VAR
      ItemJournalBatch@1001 : Record 233;
    BEGIN
      SelectAndClearItemJournalBatch(ItemJournalBatch,ItemJournalBatch."Template Type"::"Phys. Inventory");
      ItemJournalLine.INIT;
      ItemJournalLine.VALIDATE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.VALIDATE("Journal Batch Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateItemTrackingCode@111(SNSpecific@1002 : Boolean;LOTSpecific@1001 : Boolean) : Code[10];
    VAR
      ItemTrackingCode@1000 : Record 6502;
    BEGIN
      LibraryItemTracking.CreateItemTrackingCode(ItemTrackingCode,SNSpecific,LOTSpecific);
      ItemTrackingCode.VALIDATE("Lot Warehouse Tracking",LOTSpecific);
      ItemTrackingCode.MODIFY(TRUE);
      EXIT(ItemTrackingCode.Code);
    END;

    LOCAL PROCEDURE CreateandPostItemJournalForRevaluation@64(VAR ItemJournalLine@1001 : Record 83;ItemNo@1000 : Code[20]);
    VAR
      ItemJournalBatch@1002 : Record 233;
      Item@1003 : Record 27;
      NoSeriesManagement@1006 : Codeunit 396;
      CalculatePer@1005 : 'Item Ledger Entry,Item';
      CalcBase@1004 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
    BEGIN
      Item.SETRANGE("No.",ItemNo);
      SelectAndClearItemJournalBatch(ItemJournalBatch,ItemJournalBatch."Template Type"::Revaluation);
      ItemJournalLine.VALIDATE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.VALIDATE("Journal Batch Name",ItemJournalBatch.Name);
      LibraryCosting.CalculateInventoryValue(
        ItemJournalLine,Item,WORKDATE,NoSeriesManagement.GetNextNo(ItemJournalBatch."No. Series",WORKDATE,FALSE),CalculatePer::Item,
        FALSE,FALSE,FALSE,CalcBase::" ",FALSE);
      ItemJournalLine.SETRANGE("Item No.",ItemJournalLine."Item No.");
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE("Unit Cost (Revalued)",LibraryRandom.RandInt(10));
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE CreateSalesRetOrderGetPstdDocLineToRev@155(VAR SalesHeader@1000 : Record 36;SellToCustomerNo@1001 : Code[20];DocumentNo@1002 : Code[20]);
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::"Return Order",SellToCustomerNo);
      LibraryVariableStorage.Enqueue(DocumentNo); // Enqueue value for PostedSalesDocumentLinesPageHandler / PostedSalesShipmentLinesPageHandler.
      GetPostedDocToReverseOnSalesReturnOrder(SalesHeader."No.");
    END;

    LOCAL PROCEDURE CreateSalesReturnOrderByGetPstdDocLineToRev@143(VAR SalesHeader@1000 : Record 36;Item@1004 : Record 27;SellToCustomerNo@1001 : Code[20];DocumentNo@1002 : Code[20]);
    VAR
      SalesLine@1003 : Record 37;
    BEGIN
      CreateSalesRetOrderGetPstdDocLineToRev(SalesHeader,SellToCustomerNo,DocumentNo);
      FindSalesLine(SalesLine,SalesLine."Document Type"::"Return Order",SalesHeader."No.",Item."No.");
      SalesLine.VALIDATE("VAT Identifier",Item."VAT Prod. Posting Group"); // It requires for IT database.
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesReturnOrderByCopyDocument@167(VAR SalesHeader@1002 : Record 36;SellToCustomerNo@1001 : Code[20];DocumentNo@1000 : Code[20];DocumentType@1003 : Option;RecalcLines@1004 : Boolean);
    BEGIN
      LibrarySales.CreateSalesHeader(
        SalesHeader,SalesHeader."Document Type"::"Return Order",SellToCustomerNo);
      LibrarySales.CopySalesDocument(SalesHeader,DocumentType,DocumentNo,TRUE,RecalcLines);
      SalesHeader.GET(SalesHeader."Document Type",SalesHeader."No.");
    END;

    LOCAL PROCEDURE CreatePurchRetOrderGetPstdDocLineToRev@57(VAR PurchaseHeader@1000 : Record 38;BuyFromVendorNo@1001 : Code[20]);
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::"Return Order",BuyFromVendorNo);
      PurchaseHeader.VALIDATE("Vendor Cr. Memo No.",LibraryUtility.GenerateGUID);
      PurchaseHeader.MODIFY(TRUE);
      GetPostedDocToReverseOnPurchReturnOrder(PurchaseHeader."No.");
    END;

    LOCAL PROCEDURE CreateSalesOrderWithSalesPriceOnCustomer@85(VAR SalesLine@1004 : Record 37;PostingDate@1000 : Date);
    VAR
      Item@1005 : Record 27;
      SalesPrice@1002 : Record 7002;
    BEGIN
      // Create Item, Customer, create Sales Price and Sales Order.
      CreateSalesPrice(
        SalesPrice,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO),
        SalesPrice."Sales Type"::Customer,CreateCustomer,0,'');  // 0 for Minimum Qunatity.
      CreateSalesOrderWithOrderDate(
        SalesLine,SalesPrice."Sales Code",SalesPrice."Item No.",PostingDate,'',LibraryRandom.RandDec(10,2));  // Take random for Quantity.
    END;

    LOCAL PROCEDURE CreateSalesPriceWithCustomerPriceGroup@86(VAR SalesPrice@1000 : Record 7002);
    VAR
      CustomerPriceGroup@1003 : Record 6;
      Item@1002 : Record 27;
    BEGIN
      // Create Customer and update Customer Pricing Group on Customer, create Sales Price with Sales Type Customer Pricing Group.
      LibrarySales.CreateCustomerPriceGroup(CustomerPriceGroup);
      CreateSalesPrice(
        SalesPrice,CreateAndModifyItem(Item."Replenishment System"::Purchase,Item."Costing Method"::FIFO),
        SalesPrice."Sales Type"::"Customer Price Group",CustomerPriceGroup.Code,0,'');  // 0 for Minimum Quantity.
    END;

    LOCAL PROCEDURE CreateSalesOrderWithItemTracking@130(VAR SalesLine@1005 : Record 37;DocumentType@1007 : Option;ItemNo@1004 : Code[20];Quantity@1001 : Decimal;LotNo@1000 : Code[20]);
    VAR
      SalesHeader@1002 : Record 36;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,DocumentType,CreateCustomer);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
      AssignLotNoOnBoundSalesOrder(SalesLine,LotNo);
    END;

    LOCAL PROCEDURE CreateSalesReturnOrderWithApplFromItemEntryOnItemTrackingLine@169(VAR SalesHeader@1002 : Record 36;SellToCustomerNo@1007 : Code[20];ItemNo@1004 : Code[20];LotNo@1000 : Code[20];Quantity@1001 : Decimal;EntryNo@1005 : Option);
    VAR
      SalesLine@1003 : Record 37;
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::"Return Order",SellToCustomerNo);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
      AssignLotNoOnBoundSalesOrder(SalesLine,LotNo);

      LibraryVariableStorage.Enqueue(TrackingOption::SetApplFromItemEntry); // Enqueue value for ItemTrackingLinesPageHandler.
      LibraryVariableStorage.Enqueue(EntryNo);
      SalesLine.OpenItemTrackingLines;
    END;

    LOCAL PROCEDURE CreatePurchReturnOrderWithApplToItemEntryOnItemTrackingLine@166(VAR PurchaseHeader@1002 : Record 38;BuyFromVendorNo@1007 : Code[20];ItemNo@1004 : Code[20];LotNo@1000 : Code[20];Quantity@1001 : Decimal;EntryNo@1005 : Option);
    VAR
      PurchaseLine@1003 : Record 39;
      TrackingOption@1006 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::"Return Order",BuyFromVendorNo);
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity);
      AssignLotNoOnBoundPurchaseOrder(PurchaseLine,LotNo);

      LibraryVariableStorage.Enqueue(TrackingOption::SetApplToItemEntry); // Enqueue value for ItemTrackingLinesPageHandler.
      LibraryVariableStorage.Enqueue(EntryNo);
      PurchaseLine.OpenItemTrackingLines;
    END;

    LOCAL PROCEDURE CreateSalesOrderWithOrderDate@87(VAR SalesLine@1003 : Record 37;CustomerNo@1002 : Code[20];ItemNo@1001 : Code[20];OrderDate@1004 : Date;CurrencyCode@1005 : Code[10];Quantity@1006 : Decimal);
    VAR
      SalesHeader@1000 : Record 36;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CustomerNo);
      SalesHeader.VALIDATE("Order Date",OrderDate);
      SalesHeader.VALIDATE("Currency Code",CurrencyCode);
      SalesHeader.MODIFY(TRUE);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
    END;

    LOCAL PROCEDURE CreateSalesPrice@88(VAR SalesPrice@1005 : Record 7002;ItemNo@1003 : Code[20];SalesType@1001 : Option;SalesCode@1002 : Code[20];Quantity@1004 : Decimal;CurrencyCode@1006 : Code[10]);
    BEGIN
      LibraryCosting.CreateSalesPrice(SalesPrice,SalesType,SalesCode,ItemNo,WORKDATE,CurrencyCode,'','',Quantity);
      SalesPrice.VALIDATE("Ending Date",WORKDATE);
      SalesPrice.VALIDATE("Unit Price",LibraryRandom.RandDec(5,2));  // Take random value for Unit Price.
      SalesPrice.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateTrackedItemWithReplenishmentSystem@141() : Code[20];
    VAR
      Item@1000 : Record 27;
    BEGIN
      LibraryInventory.CreateTrackedItem(
        Item,LibraryUtility.GetGlobalNoSeriesCode,'',CreateLotWhseTrackingCode);
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::"Prod. Order");
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateWarehouseLocation@38(VAR Location@1000 : Record 14);
    VAR
      WarehouseEmployee@1001 : Record 7301;
    BEGIN
      LibraryWarehouse.CreateFullWMSLocation(Location,1);
      WarehouseEmployee.DELETEALL;
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,Location.Code,TRUE);
    END;

    LOCAL PROCEDURE CreateWarehouseJournalBatch@51(VAR WarehouseJournalBatch@1000 : Record 7310;Type@1003 : Option;LocationCode@1001 : Code[10]);
    VAR
      WarehouseJournalTemplate@1002 : Record 7309;
    BEGIN
      LibraryWarehouse.SelectWhseJournalTemplateName(WarehouseJournalTemplate,Type);
      LibraryWarehouse.CreateWhseJournalBatch(WarehouseJournalBatch,WarehouseJournalTemplate.Name,LocationCode);
    END;

    LOCAL PROCEDURE CreateReservationForBoundPurchaseOrder@144(VAR PurchaseLine@1000 : Record 39);
    VAR
      ReservOption@1001 : 'AutoReserve,CancelReserv';
    BEGIN
      LibraryVariableStorage.Enqueue(ReservOption::AutoReserve);
      PurchaseLine.ShowReservation;
    END;

    LOCAL PROCEDURE CreateReservationForBoundSalesOrder@145(VAR SalesLine@1000 : Record 37);
    VAR
      ReservOption@1001 : 'AutoReserve,CancelReserv';
    BEGIN
      LibraryVariableStorage.Enqueue(ReservOption::AutoReserve);
      SalesLine.ShowReservation;
    END;

    LOCAL PROCEDURE CreateProdOrderFromSalesOrderUsingPlanning@129(VAR SalesLine@1006 : Record 37);
    VAR
      ProductionOrder@1005 : Record 5405;
      SalesHeader@1001 : Record 36;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,'');
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,CreateTrackedItemWithReplenishmentSystem,
        LibraryRandom.RandDec(10,2));
      CreateReleasedProductionOrderFromSalesOrder(ProductionOrder,SalesHeader);
    END;

    LOCAL PROCEDURE CancelReservationOnProductionOrder@41(ItemNo@1000 : Code[20]);
    VAR
      ProdOrderLine@1001 : Record 5406;
      ReservOption@1002 : 'AutoReserve,CancelReserv';
    BEGIN
      FindProdOrderLine(ProdOrderLine,ItemNo);
      LibraryVariableStorage.Enqueue(ReservOption::CancelReserv);  // Enqueue for ReservationPageHandler.
      LibraryVariableStorage.Enqueue(CancelReservationMessage);  // Enqueue for ConfirmHandler.
      ProdOrderLine.ShowReservation;
    END;

    LOCAL PROCEDURE CancelReservationOnBoundPurchaseOrder@148(VAR PurchaseLine@1000 : Record 39);
    VAR
      ReservOption@1001 : 'AutoReserve,CancelReserv';
    BEGIN
      LibraryVariableStorage.Enqueue(ReservOption::CancelReserv);
      PurchaseLine.ShowReservation;
    END;

    LOCAL PROCEDURE CancelReservationOnBoundSalesOrder@149(VAR SalesLine@1000 : Record 37);
    VAR
      ReservOption@1001 : 'AutoReserve,CancelReserv';
    BEGIN
      LibraryVariableStorage.Enqueue(ReservOption::CancelReserv);
      SalesLine.ShowReservation;
    END;

    LOCAL PROCEDURE DeletePhysInvLedger@40(ItemNo@1000 : Code[20]);
    VAR
      PhysInventoryLedgerEntry@1002 : Record 281;
      DeletePhysInventoryLedger@1001 : Report 789;
    BEGIN
      LibraryVariableStorage.Enqueue(DeleteEntries);
      CLEAR(DeletePhysInventoryLedger);
      PhysInventoryLedgerEntry.SETRANGE("Item No.",ItemNo);
      DeletePhysInventoryLedger.SETTABLEVIEW(PhysInventoryLedgerEntry);
      DeletePhysInventoryLedger.RUN;
    END;

    LOCAL PROCEDURE ExecuteUIHandler@1033();
    BEGIN
      // Generate Dummy message. Required for executing the test case successfully.
      IF CONFIRM(STRSUBSTNO(ExpectedMessage)) THEN;
    END;

    LOCAL PROCEDURE FindItemLedgerEntry@72(VAR ItemLedgerEntry@1002 : Record 32;ItemNo@1000 : Code[20];EntryType@1001 : Option);
    BEGIN
      ItemLedgerEntry.SETRANGE("Entry Type",EntryType);
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindProductionOrder@3(VAR ProductionOrder@1001 : Record 5405;Status@1002 : Option;SourceNo@1000 : Code[20]);
    BEGIN
      ProductionOrder.SETRANGE(Status,Status);
      ProductionOrder.SETRANGE("Source No.",SourceNo);
      ProductionOrder.FINDFIRST;
    END;

    LOCAL PROCEDURE FindProdOrderLine@35(VAR ProdOrderLine@1001 : Record 5406;ItemNo@1000 : Code[20]);
    BEGIN
      ProdOrderLine.SETRANGE("Item No.",ItemNo);
      ProdOrderLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindZone@39(LocationCode@1001 : Code[10];BinTypeCode@1002 : Code[10]) : Code[10];
    VAR
      Zone@1000 : Record 7300;
    BEGIN
      Zone.SETRANGE("Location Code",LocationCode);
      Zone.SETRANGE("Bin Type Code",BinTypeCode);
      Zone.FINDFIRST;
      EXIT(Zone.Code);
    END;

    LOCAL PROCEDURE FindSalesLine@154(VAR SalesLine@1000 : Record 37;DocumentType@1001 : Option;DocumentNo@1002 : Code[20];No@1003 : Code[20]);
    BEGIN
      SalesLine.SETRANGE("Document Type",DocumentType);
      SalesLine.SETRANGE("Document No.",DocumentNo);
      SalesLine.SETRANGE("No.",No);
      SalesLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindPurchaseLine@150(VAR PurchaseLine@1000 : Record 39;DocumentType@1001 : Option;DocumentNo@1002 : Code[20];No@1003 : Code[20]);
    BEGIN
      PurchaseLine.SETRANGE("Document Type",DocumentType);
      PurchaseLine.SETRANGE("Document No.",DocumentNo);
      PurchaseLine.SETRANGE("No.",No);
      PurchaseLine.FINDFIRST;
    END;

    LOCAL PROCEDURE GetPostedDocToReverseOnPurchReturnOrder@44(No@1001 : Code[20]);
    VAR
      PurchaseReturnOrder@1003 : TestPage 6640;
    BEGIN
      PurchaseReturnOrder.OPENEDIT;
      PurchaseReturnOrder.FILTER.SETFILTER("No.",No);
      PurchaseReturnOrder.GetPostedDocumentLinesToReverse.INVOKE;
    END;

    LOCAL PROCEDURE GetPostedDocToReverseOnSalesReturnOrder@81(No@1001 : Code[20]);
    VAR
      SalesReturnOrder@1003 : TestPage 6630;
    BEGIN
      SalesReturnOrder.OPENEDIT;
      SalesReturnOrder.FILTER.SETFILTER("No.",No);
      SalesReturnOrder.GetPostedDocumentLinesToReverse.INVOKE;
    END;

    LOCAL PROCEDURE CalculatePlanForRequisitionWorksheet@151(VAR RequisitionWkshName@1000 : Record 245;VAR Item@1001 : Record 27;StartDate@1003 : Date;EndDate@1002 : Date);
    BEGIN
      RequisitionWkshName.SETRANGE("Template Type",RequisitionWkshName."Template Type"::"Req.");
      RequisitionWkshName.FINDFIRST;
      LibraryPlanning.CalculatePlanForReqWksh(
        Item,RequisitionWkshName."Worksheet Template Name",RequisitionWkshName.Name,StartDate,EndDate);
    END;

    LOCAL PROCEDURE UpdateItemInvPostingGroup@76(VAR Item@1000 : Record 27);
    VAR
      InventoryPostingGroup@1001 : Record 94;
    BEGIN
      InventoryPostingGroup.SETFILTER(Code,'<>%1',Item."Inventory Posting Group");
      InventoryPostingGroup.FINDFIRST;
      Item.VALIDATE("Inventory Posting Group",InventoryPostingGroup.Code);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateGeneralPostingSetup@1004(PurchaseLine@1005 : Record 39);
    VAR
      GLAccount@1006 : Record 15;
      GeneralPostingSetup@1007 : Record 252;
    BEGIN
      GeneralPostingSetup.GET(PurchaseLine."Gen. Bus. Posting Group",PurchaseLine."Gen. Prod. Posting Group");
      IF GeneralPostingSetup."Purch. Account" = '' THEN BEGIN
        LibraryERM.FindGLAccount(GLAccount);
        GeneralPostingSetup.VALIDATE("Purch. Account",GLAccount."No.");
        GeneralPostingSetup.MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE UpdateQuantityOnSalesLine@8(SalesLine@1000 : Record 37) Quantity : Decimal;
    BEGIN
      Quantity := SalesLine.Quantity;
      SalesLine.VALIDATE(Quantity,SalesLine.Quantity + LibraryRandom.RandDec(10,2));  // Take random Quantity.
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateQtyAndInvoicePurchaseOrder@63(PurchaseLine@1000 : Record 39) DocumentNo : Code[20];
    VAR
      PurchaseHeader@1001 : Record 38;
    BEGIN
      // Update Quantity to Invoice on Purchase Line with Type Item, and Invoice Item Charge.
      PurchaseLine.GET(PurchaseLine."Document Type",PurchaseLine."Document No.",PurchaseLine."Line No.");
      PurchaseLine.VALIDATE("Qty. to Invoice",0);
      PurchaseLine.MODIFY(TRUE);
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE);

      // Invoice Purchase Order.
      PurchaseHeader.GET(PurchaseHeader."Document Type",PurchaseHeader."No.");
      PurchaseHeader.VALIDATE("Vendor Invoice No.",LibraryUtility.GenerateGUID);
      PurchaseHeader.MODIFY(TRUE);
      DocumentNo := LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE);
    END;

    LOCAL PROCEDURE UpdateReturnQtyToReceiveOnSalesLine@240(DocumentNo@1000 : Code[20];DocumentType@1002 : Option) : Decimal;
    VAR
      SalesLine@1001 : Record 37;
    BEGIN
      SalesLine.SETFILTER("No.",'<>%1','');
      SalesLine.SETRANGE("Document Type",DocumentType);
      SalesLine.SETRANGE("Document No.",DocumentNo);
      SalesLine.FINDFIRST;

      // Update the "Return Qty. to Receive"=(SalesLine."Return Qty. to Receive" / 2,SalesLine."Return Qty. to Receive"),
      // not repro when the "Return Qty. to Receive" is less than original SalesLine."Return Qty. to Receive" / 2.
      SalesLine.VALIDATE("Return Qty. to Receive",
        LibraryRandom.RandDecInDecimalRange(SalesLine."Return Qty. to Receive" / 2 + 0.01,
          SalesLine."Return Qty. to Receive" - 0.01,2));
      SalesLine.MODIFY(TRUE);
      EXIT(SalesLine."Return Qty. to Receive");
    END;

    LOCAL PROCEDURE UpdateReturnQtyToShipOnPurchLine@239(DocumentNo@1000 : Code[20];DocumentType@1002 : Option) : Decimal;
    VAR
      PurchaseLine@1001 : Record 39;
    BEGIN
      PurchaseLine.SETFILTER("No.",'<>%1','');
      PurchaseLine.SETRANGE("Document Type",DocumentType);
      PurchaseLine.SETRANGE("Document No.",DocumentNo);
      PurchaseLine.FINDFIRST;

      // Update the "Return Qty. to Ship"=(PurchaseLine."Return Qty. to Ship" / 2,PurchaseLine."Return Qty. to Ship"),
      // not repro when the "Return Qty. to Ship" is less than  original PurchaseLine."Return Qty. to Ship" / 2.
      PurchaseLine.VALIDATE("Return Qty. to Ship",
        LibraryRandom.RandDecInDecimalRange(PurchaseLine."Return Qty. to Ship" / 2 + 0.01,
          PurchaseLine."Return Qty. to Ship" - 0.01,2));
      PurchaseLine.MODIFY(TRUE);
      EXIT(PurchaseLine."Return Qty. to Ship");
    END;

    LOCAL PROCEDURE UpdateQtyOnSalesReturnOrder@243(DocumentNo@1001 : Code[20];ItemNo@1002 : Code[20];Qty@1000 : Decimal);
    VAR
      SalesReturnOrder@1003 : TestPage 6630;
    BEGIN
      SalesReturnOrder.OPENEDIT;
      SalesReturnOrder.FILTER.SETFILTER("No.",DocumentNo);
      SalesReturnOrder.SalesLines.FILTER.SETFILTER("No.",ItemNo);
      SalesReturnOrder.SalesLines.Quantity.SETVALUE(Qty);
    END;

    LOCAL PROCEDURE UpdateQtyOnSalesOrder@242(DocumentNo@1001 : Code[20];ItemNo@1002 : Code[20];Qty@1000 : Decimal);
    VAR
      SalesOrder@1003 : TestPage 42;
    BEGIN
      SalesOrder.OPENEDIT;
      SalesOrder.FILTER.SETFILTER("No.",DocumentNo);
      SalesOrder.SalesLines.FILTER.SETFILTER("No.",ItemNo);
      SalesOrder.SalesLines.Quantity.SETVALUE(Qty);
    END;

    LOCAL PROCEDURE UpdateQtyOnPurchReturnOrder@237(DocumentNo@1001 : Code[20];ItemNo@1000 : Code[20];Qty@1002 : Decimal);
    VAR
      PurchaseReturnOrder@1003 : TestPage 6640;
    BEGIN
      PurchaseReturnOrder.OPENEDIT;
      PurchaseReturnOrder.FILTER.SETFILTER("No.",DocumentNo);
      PurchaseReturnOrder.PurchLines.FILTER.SETFILTER("No.",ItemNo);
      PurchaseReturnOrder.PurchLines.Quantity.SETVALUE(Qty);
    END;

    LOCAL PROCEDURE PostPurchaseDocument@1034(PurchaseHeader@1035 : Record 38);
    BEGIN
      ExecuteUIHandler;
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE PostPurchaseReturnOrder@175(PurchaseHeader@1035 : Record 38);
    BEGIN
      PurchaseHeader.VALIDATE("Vendor Cr. Memo No.",LibraryUtility.GenerateGUID);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE PostSalesDocument@1035(SalesLine@1036 : Record 37;Invoice@1000 : Boolean) : Code[20];
    VAR
      SalesHeader@1001 : Record 36;
    BEGIN
      ExecuteUIHandler;
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");
      EXIT(LibrarySales.PostSalesDocument(SalesHeader,TRUE,Invoice));
    END;

    LOCAL PROCEDURE RunCalculateInventoryReport@17(VAR ItemJournalLine@1000 : Record 83;ItemNo@1001 : Code[20]);
    BEGIN
      CreateItemJournalLineForPhysInv(ItemJournalLine);
      LibraryInventory.CalculateInventory(ItemJournalLine,ItemNo,WORKDATE,TRUE);
    END;

    LOCAL PROCEDURE RunRollUpStandardCost@37(StandardCostWorksheetName@1002 : Code[10];ItemNo@1004 : Code[20];ItemNo2@1005 : Code[20]);
    VAR
      Item@1001 : Record 27;
      RollUpStandardCost@1000 : Report 5854;
    BEGIN
      COMMIT;  // Commit required for batch job reports.
      Item.SETFILTER("No.",STRSUBSTNO(ItemFilter,ItemNo,ItemNo2));
      Item.GET(ItemNo);
      Item.SETRANGE("Inventory Posting Group",Item."Inventory Posting Group");
      CLEAR(RollUpStandardCost);
      RollUpStandardCost.SETTABLEVIEW(Item);
      RollUpStandardCost.SetStdCostWksh(StandardCostWorksheetName);
      RollUpStandardCost.USEREQUESTPAGE(TRUE);
      RollUpStandardCost.RUN;
    END;

    LOCAL PROCEDURE SalesPriceForPriceInclVAT@96(VATPostingSetup@1002 : Record 325;SalesType@1008 : Option;SalesCode@1009 : Code[20];CusomerNo@1010 : Code[20]);
    VAR
      SalesLine@1000 : Record 37;
      SalesPrice@1004 : Record 7002;
      UnitPrice@1005 : Decimal;
    BEGIN
      CreateAndUpdateSalesPrice(
        SalesPrice,VATPostingSetup."VAT Bus. Posting Group",CreateItemWithVAT(VATPostingSetup."VAT Prod. Posting Group"),SalesType,
        SalesCode);

      // Exercise: Create Sales Order.
      CreateSalesOrderWithOrderDate(SalesLine,CusomerNo,SalesPrice."Item No.",WORKDATE,'',SalesPrice."Minimum Quantity");

      // Verify: Verify Unit Price on Sales Line with Price Including VAT TRUE.
      UnitPrice := SalesPrice."Unit Price" - (SalesPrice."Unit Price" * VATPostingSetup."VAT %" / (100 + VATPostingSetup."VAT %"));
      Assert.AreNearlyEqual(
        UnitPrice,SalesLine."Unit Price",LibraryERM.GetAmountRoundingPrecision,
        STRSUBSTNO(ValidationError,SalesLine.FIELDCAPTION("Unit Price"),UnitPrice));
    END;

    LOCAL PROCEDURE SelectAndClearItemJournalBatch@95(VAR ItemJournalBatch@1000 : Record 233;Type@1002 : Option);
    VAR
      ItemJournalTemplate@1001 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,Type);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
    END;

    LOCAL PROCEDURE UpdateApplyToItemEntryOnPurchLine@58(VAR PurchaseLine@1000 : Record 39;DocumentNo@1001 : Code[20]);
    BEGIN
      PurchaseLine.SETFILTER("No.",'<>''''');
      PurchaseLine.SETRANGE("Document Type",PurchaseLine."Document Type"::"Return Order");
      PurchaseLine.SETRANGE("Document No.",DocumentNo);
      PurchaseLine.FINDSET;
      REPEAT
        PurchaseLine.VALIDATE("Appl.-to Item Entry",0);
        PurchaseLine.MODIFY(TRUE);
      UNTIL PurchaseLine.NEXT = 0;
    END;

    LOCAL PROCEDURE UpdateApplyFromItemEntryOnSalesLine@84(VAR SalesLine@1000 : Record 37;DocumentNo@1001 : Code[20]);
    BEGIN
      SalesLine.SETFILTER("No.",'<>''''');
      SalesLine.SETRANGE("Document Type",SalesLine."Document Type"::"Return Order");
      SalesLine.SETRANGE("Document No.",DocumentNo);
      SalesLine.FINDFIRST;
      SalesLine.VALIDATE("Appl.-from Item Entry",0);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateInventorySetup@48(AutomaticCostAdjustment@1000 : Option);
    VAR
      InventorySetup@1001 : Record 313;
    BEGIN
      LibraryVariableStorage.Enqueue(UnadjustedValueEntriesMessage);
      InventorySetup.GET;
      InventorySetup.VALIDATE("Automatic Cost Adjustment",AutomaticCostAdjustment);
      InventorySetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemDimension@77(ItemNo@1000 : Code[20]);
    VAR
      Dimension@1001 : Record 348;
      DimensionValue@1002 : Record 349;
      DefaultDimension@1003 : Record 352;
    BEGIN
      LibraryDimension.CreateDimension(Dimension);
      LibraryDimension.CreateDimensionValue(DimensionValue,Dimension.Code);
      LibraryDimension.CreateDefaultDimensionItem(DefaultDimension,ItemNo,Dimension.Code,DimensionValue.Code);
    END;

    LOCAL PROCEDURE UpdateCountingPeriodOnItem@29(Item@1000 : Record 27);
    VAR
      PhysInvtCountingPeriod@1001 : Record 7381;
    BEGIN
      LibraryInventory.CreatePhysicalInventoryCountingPeriod(PhysInvtCountingPeriod);
      Item.VALIDATE("Phys Invt Counting Period Code",PhysInvtCountingPeriod.Code);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemBaseUnitOfMeasure@97(Item@1002 : Record 27);
    VAR
      ItemUnitOfMeasure@1001 : Record 5404;
    BEGIN
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,Item."No.",1);
      Item.VALIDATE("Base Unit of Measure",ItemUnitOfMeasure.Code);
    END;

    LOCAL PROCEDURE UpdateItemJournalLineAppliesToEntry@20(VAR ItemJournalLine@1000 : Record 83);
    VAR
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,ItemJournalLine."Item No.",ItemLedgerEntry."Entry Type"::"Positive Adjmt.");
      ItemJournalLine.VALIDATE("Applies-to Entry",ItemLedgerEntry."Entry No.");
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateQtyOnPhysInvJournal@56(VAR ItemJournalLine@1000 : Record 83);
    BEGIN
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalLine."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalLine."Journal Batch Name");
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE("Qty. (Phys. Inventory)",ItemJournalLine."Qty. (Phys. Inventory)" / 2);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntry@24(ItemNo@1000 : Code[20];EntryType@1002 : Option;Quantity@1003 : Decimal;CostAmountActual@1004 : Decimal);
    VAR
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,ItemNo,EntryType);
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      ItemLedgerEntry.TESTFIELD(Quantity,Quantity);
      Assert.AreNearlyEqual(
        CostAmountActual,ItemLedgerEntry."Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,
        STRSUBSTNO(ValidationError,ItemLedgerEntry.FIELDCAPTION("Cost Amount (Actual)"),CostAmountActual));
    END;

    LOCAL PROCEDURE CreateAndUpdateCustPriceGroup@107(VATBusPostingGrPrice@1000 : Code[10]) : Code[10];
    VAR
      CustomerPriceGroup@1001 : Record 6;
    BEGIN
      LibrarySales.CreateCustomerPriceGroup(CustomerPriceGroup);
      CustomerPriceGroup.VALIDATE("Price Includes VAT",TRUE);
      CustomerPriceGroup.VALIDATE("VAT Bus. Posting Gr. (Price)",VATBusPostingGrPrice);
      CustomerPriceGroup.MODIFY(TRUE);
      EXIT(CustomerPriceGroup.Code);
    END;

    LOCAL PROCEDURE UpdateDiscOnSalesLineDiscount@109(SalesLineDiscount@1001 : Record 7004) : Decimal;
    BEGIN
      SalesLineDiscount.VALIDATE("Line Discount %",SalesLineDiscount."Line Discount %" + LibraryRandom.RandDec(10,2));  // Take random for update Line Discount Pct.
      SalesLineDiscount.MODIFY(TRUE);
      EXIT(SalesLineDiscount."Line Discount %");
    END;

    LOCAL PROCEDURE UpdatePurchasesPayablesSetup@54(ExactCostReversingMandatory@1000 : Boolean);
    VAR
      PurchasesPayablesSetup@1002 : Record 312;
    BEGIN
      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Exact Cost Reversing Mandatory",ExactCostReversingMandatory);
      PurchasesPayablesSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateSalesReceivablesSetup@49(ExactCostReversingMandatory@1001 : Boolean;StockoutWarning@1002 : Boolean);
    VAR
      SalesReceivablesSetup@1000 : Record 311;
    BEGIN
      SalesReceivablesSetup.GET;
      SalesReceivablesSetup.VALIDATE("Exact Cost Reversing Mandatory",ExactCostReversingMandatory);
      SalesReceivablesSetup.VALIDATE("Stockout Warning",StockoutWarning);
      SalesReceivablesSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateUnitPriceOnSalesPrice@91(SalesPrice@1001 : Record 7002) : Decimal;
    BEGIN
      SalesPrice.VALIDATE("Unit Price",SalesPrice."Unit Price" + LibraryRandom.RandDec(10,2));  // Take random fo update Unit Price.
      SalesPrice.MODIFY(TRUE);
      EXIT(SalesPrice."Unit Price");
    END;

    LOCAL PROCEDURE VerifyGLEntries@50(DocumentNo@1003 : Code[20];GLAccountNo@1000 : Code[20];Amount@1001 : Decimal);
    VAR
      GLEntry@1002 : Record 17;
    BEGIN
      GLEntry.SETRANGE("Document No.",DocumentNo);
      GLEntry.SETRANGE("G/L Account No.",GLAccountNo);
      GLEntry.FINDFIRST;
      GLEntry.TESTFIELD(Amount,Amount);
    END;

    LOCAL PROCEDURE VerifyStandardCost@121(No@1000 : Code[20];StandardCost@1001 : Decimal);
    VAR
      StandardCostWorksheet@1002 : Record 5841;
    BEGIN
      StandardCostWorksheet.SETRANGE("No.",No);
      StandardCostWorksheet.FINDFIRST;
      StandardCostWorksheet.TESTFIELD("Standard Cost",StandardCost);
    END;

    LOCAL PROCEDURE VerifyQuantityOnProdOrderLine@14(ItemNo@1000 : Code[20];Quantity@1001 : Decimal;ReservedQuantity@1002 : Decimal);
    VAR
      ProdOrderLine@1003 : Record 5406;
    BEGIN
      FindProdOrderLine(ProdOrderLine,ItemNo);
      ProdOrderLine.TESTFIELD(Quantity,Quantity);
      ProdOrderLine.CALCFIELDS("Reserved Quantity");
      ProdOrderLine.TESTFIELD("Reserved Quantity",ReservedQuantity);
    END;

    LOCAL PROCEDURE VerifyPhysInvJournalQty@45(ItemNo@1000 : Code[20];Quantity@1001 : Decimal);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      ItemJournalLine.SETRANGE("Item No.",ItemNo);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.TESTFIELD("Qty. (Calculated)",Quantity);
      ItemJournalLine.TESTFIELD("Qty. (Phys. Inventory)",Quantity);
    END;

    LOCAL PROCEDURE VerifySalesInvoiceLine@94(DocumentNo@1000 : Code[20];UnitPrice@1001 : Decimal;LineDiscountPct@1003 : Decimal);
    VAR
      SalesInvoiceLine@1002 : Record 113;
    BEGIN
      SalesInvoiceLine.SETRANGE("Document No.",DocumentNo);
      SalesInvoiceLine.SETFILTER("No.",'<>''''');
      SalesInvoiceLine.FINDFIRST;
      SalesInvoiceLine.TESTFIELD("Unit Price",UnitPrice);
      SalesInvoiceLine.TESTFIELD("Line Discount %",LineDiscountPct);
    END;

    LOCAL PROCEDURE VerifyValueEntry@21(ItemLedgerEntryType@1000 : Option;ItemNo@1001 : Code[20];CostAmount@1002 : Decimal);
    VAR
      ValueEntry@1003 : Record 5802;
      ItemLedgerEntry@1004 : Record 32;
    BEGIN
      ValueEntry.SETRANGE("Item Ledger Entry Type",ItemLedgerEntryType);
      ValueEntry.SETRANGE("Item No.",ItemNo);
      ValueEntry.SETRANGE(Adjustment,TRUE);
      ValueEntry.FINDFIRST;
      Assert.AreNearlyEqual(
        CostAmount,ValueEntry."Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,
        STRSUBSTNO(ValidationError,ItemLedgerEntry.FIELDCAPTION("Cost Amount (Actual)"),CostAmount));
    END;

    [Normal]
    LOCAL PROCEDURE VerifyValueEntryNoApplication@120(ItemNo@1001 : Code[20]);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      ValueEntry.SETRANGE("Item No.",ItemNo);
      ValueEntry.SETRANGE("Document Type",ValueEntry."Document Type"::"Purchase Credit Memo");
      ValueEntry.SETRANGE(Adjustment,FALSE);
      ValueEntry.FINDSET;
      REPEAT
        ValueEntry.TESTFIELD("Applies-to Entry",0);
      UNTIL ValueEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyShipmentAndExpRcptDateOnReservationEntry@124(VAR ReservationEntry@1002 : Record 337;ItemNo@1000 : Code[20];SourceType@1001 : Integer;SourceSubType@1003 : Option;Positive@1004 : Boolean;ShipmentDate@1005 : Date;ExpectedReceiptDate@1006 : Date);
    BEGIN
      ReservationEntry.SETRANGE("Item No.",ItemNo);
      ReservationEntry.SETRANGE("Source Type",SourceType);
      ReservationEntry.SETRANGE("Source Subtype",SourceSubType);
      ReservationEntry.SETRANGE(Positive,Positive);
      ReservationEntry.FINDFIRST;
      ReservationEntry.TESTFIELD("Shipment Date",ShipmentDate);
      ReservationEntry.TESTFIELD("Expected Receipt Date",ExpectedReceiptDate);
    END;

    LOCAL PROCEDURE VerifyValuesOnTrackingLine@153(DocumentType@1006 : Option;DocumentNo@1005 : Code[20];ItemNo@1001 : Code[20];LotNo@1004 : Code[20];SerialNo@1007 : Code[20];EntryNo@1000 : Integer;Quantity@1008 : Integer);
    VAR
      SalesLine@1003 : Record 37;
      TrackingOption@1002 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
    BEGIN
      LibraryVariableStorage.Enqueue(TrackingOption::VerifyApplFromItemEntry);
      LibraryVariableStorage.Enqueue(LotNo);
      LibraryVariableStorage.Enqueue(SerialNo);
      LibraryVariableStorage.Enqueue(EntryNo);
      LibraryVariableStorage.Enqueue(-Quantity);
      FindSalesLine(SalesLine,DocumentType,DocumentNo,ItemNo);
      SalesLine.OpenItemTrackingLines; // Verify values on ItemTrackingLinesPageHandler.
    END;

    LOCAL PROCEDURE VerifyApplToItemEntryOnTrackingLine@156(DocumentType@1006 : Option;DocumentNo@1005 : Code[20];ItemNo@1001 : Code[20];EntryNo@1000 : Integer);
    VAR
      PurchaseLine@1003 : Record 39;
      TrackingOption@1002 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
    BEGIN
      LibraryVariableStorage.Enqueue(TrackingOption::VerifyApplToItemEntry);
      LibraryVariableStorage.Enqueue(EntryNo);
      FindPurchaseLine(PurchaseLine,DocumentType,DocumentNo,ItemNo);
      PurchaseLine.OpenItemTrackingLines; // Verify Appl.-to Item Entry on ItemTrackingLinesPageHandler.
    END;

    LOCAL PROCEDURE VerifySalesLineDiscountsOnPage@171(CustomerDiscountGroup@1000 : Record 340;SalesLineDiscountType@1001 : Option);
    VAR
      CustomerDiscGroups@1002 : TestPage 512;
      SalesLineDiscounts@1003 : TestPage 7004;
    BEGIN
      CustomerDiscGroups.OPENEDIT;
      CustomerDiscGroups.GOTORECORD(CustomerDiscountGroup);
      SalesLineDiscounts.TRAP;
      CustomerDiscGroups.SalesLineDiscounts.INVOKE;
      SalesLineDiscounts.SalesCodeFilterCtrl.ASSERTEQUALS(CustomerDiscountGroup.Code);
      SalesLineDiscounts.Type.ASSERTEQUALS(SalesLineDiscountType);
    END;

    LOCAL PROCEDURE UpdateInventorySetupCostPosting@195();
    VAR
      InventorySetup@1001 : Record 313;
    BEGIN
      InventorySetup.GET;
      InventorySetup.VALIDATE("Automatic Cost Posting",FALSE);
      InventorySetup.MODIFY(TRUE);
    END;

    [RequestPageHandler]
    PROCEDURE CalculatePhysInvtCountingPageHandler@61(VAR CalculatePhysInvtCounting@1000 : TestRequestPage 7380);
    BEGIN
      CalculatePhysInvtCounting.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE CheckProdOrderStatusPageHandler@6(VAR CheckProdOrderStatus@1000 : TestPage 99000833);
    BEGIN
      CheckProdOrderStatus.Yes.INVOKE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@31(ConfirmMessage@1000 : Text[1024];VAR Reply@1001 : Boolean);
    VAR
      ExpectedMessage@1002 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ExpectedMessage);  // Dequeue Variable.
      Assert.IsTrue(STRPOS(ConfirmMessage,ExpectedMessage) > 0,ConfirmMessage);
      Reply := TRUE;
    END;

    [ConfirmHandler]
    PROCEDURE CreditMemoConfirmHandler@83(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [RequestPageHandler]
    PROCEDURE DeletePhysInventoryLedgerPageHandler@55(VAR DeletePhysInventoryLedger@1000 : TestRequestPage 789);
    BEGIN
      DeletePhysInventoryLedger.StartingDate.SETVALUE(WORKDATE);
      DeletePhysInventoryLedger.EndingDate.SETVALUE(WORKDATE);
      DeletePhysInventoryLedger.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemTrackingListPageHandler@200(VAR ItemTrackingList@1000 : TestPage 6507);
    BEGIN
      ItemTrackingList.OK.INVOKE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@106(Message@1000 : Text[1024]);
    VAR
      ExpectedMessage@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ExpectedMessage);  // Dequeue Variable.
      Assert.IsTrue(STRPOS(Message,ExpectedMessage) > 0,Message);
    END;

    [ModalPageHandler]
    PROCEDURE PhysInvtItemSelectionPageHandler@53(VAR PhysInvtItemSelection@1000 : TestPage 7380);
    VAR
      ItemNo@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ItemNo);
      PhysInvtItemSelection.FILTER.SETFILTER("Item No.",ItemNo);
      PhysInvtItemSelection.OK.INVOKE;  // Open Report- Calculate Phys.Invt. Counting on CalculatePhysInvtCountingPageHandler.
    END;

    [ModalPageHandler]
    PROCEDURE PostedPurchaseDocumentLinesPageHandler@34(VAR PostedPurchaseDocumentLines@1000 : TestPage 5855);
    VAR
      DocumentNo@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(DocumentNo);
      PostedPurchaseDocumentLines.PostedInvoices.FILTER.SETFILTER("Document No.",DocumentNo);
      PostedPurchaseDocumentLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE PostedSalesDocumentLinesPageHandler@100(VAR PostedSalesDocumentLines@1000 : TestPage 5850);
    VAR
      DocumentNo@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(DocumentNo);
      PostedSalesDocumentLines.PostedInvoices.FILTER.SETFILTER("Document No.",DocumentNo);
      PostedSalesDocumentLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE PostedSalesShipmentLinesPageHandler@164(VAR PostedSalesDocumentLines@1000 : TestPage 5850);
    VAR
      DocumentNo@1001 : Variant;
      DocumentType@1002 : 'Posted Shipments,Posted Invoices,Posted Return Receipt,Posted Cr. Memo';
    BEGIN
      LibraryVariableStorage.Dequeue(DocumentNo);
      PostedSalesDocumentLines.PostedShipmentsBtn.SETVALUE(FORMAT(DocumentType::"Posted Shipments"));
      PostedSalesDocumentLines.PostedShpts.FILTER.SETFILTER("Document No.",DocumentNo);
      PostedSalesDocumentLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ReservationPageHandler@26(VAR Reservation@1000 : TestPage 498);
    VAR
      OptionValue@1003 : Variant;
      OptionString@1002 : 'AutoReserve,CancelReserv';
      ReserveOption@1001 : Option;
    BEGIN
      LibraryVariableStorage.Dequeue(OptionValue);
      ReserveOption := OptionValue;
      CASE ReserveOption OF
        OptionString::CancelReserv:
          Reservation.CancelReservationCurrentLine.INVOKE;
        OptionString::AutoReserve:
          Reservation."Auto Reserve".INVOKE;
      END
    END;

    [RequestPageHandler]
    PROCEDURE RollUpStandardCostReportHandler@66(VAR RollUpStandardCost@1000 : TestRequestPage 5854);
    BEGIN
      RollUpStandardCost.OK.INVOKE;
    END;

    [PageHandler]
    PROCEDURE SalesInvoiceStatisticsPageHandler@93(VAR SalesInvoiceStatistics@1000 : TestPage 397);
    VAR
      AmountLCY@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(AmountLCY);
      SalesInvoiceStatistics.AmountLCY.ASSERTEQUALS(AmountLCY);
    END;

    [ModalPageHandler]
    PROCEDURE WhseItemTrackingLinesPageHandler@70(VAR WhseItemTrackingLines@1000 : TestPage 6550);
    VAR
      Quantity@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(Quantity);
      WhseItemTrackingLines."Lot No.".SETVALUE(LibraryUtility.GenerateGUID);
      WhseItemTrackingLines.Quantity.SETVALUE(Quantity);
    END;

    [ModalPageHandler]
    PROCEDURE ItemTrackingLinesPageHandler@119(VAR ItemTrackingLines@1000 : TestPage 6510);
    VAR
      OptionValue@1004 : Variant;
      LotNo@1002 : Variant;
      SerialNo@1008 : Variant;
      Quantity@1001 : Variant;
      ApplFromItemEntry@1003 : Variant;
      ApplToItemEntry@1007 : Variant;
      OptionString@1005 : 'AssignSerialNo,AssignLotNo,SelectEntries,SetLotNo,SetSerialNo,SetApplFromItemEntry,SetApplToItemEntry,VerifyApplFromItemEntry,VerifyApplToItemEntry';
      TrackingOption@1006 : Option;
    BEGIN
      LibraryVariableStorage.Dequeue(OptionValue);  // Dequeue variable.
      TrackingOption := OptionValue;  // To convert Variant into Option.
      CASE TrackingOption OF
        OptionString::AssignSerialNo:
          ItemTrackingLines."Assign Serial No.".INVOKE;
        OptionString::SelectEntries:
          ItemTrackingLines."Select Entries".INVOKE;
        OptionString::SetLotNo:
          BEGIN
            LibraryVariableStorage.Dequeue(LotNo);
            LibraryVariableStorage.Dequeue(Quantity);
            ItemTrackingLines."Lot No.".SETVALUE(LotNo);
            ItemTrackingLines."Quantity (Base)".SETVALUE(Quantity);
          END;
        OptionString::SetApplFromItemEntry:
          BEGIN
            LibraryVariableStorage.Dequeue(ApplFromItemEntry); // Dequeue variable.
            ItemTrackingLines."Appl.-from Item Entry".SETVALUE(ApplFromItemEntry);
          END;
        OptionString::SetApplToItemEntry:
          BEGIN
            LibraryVariableStorage.Dequeue(ApplToItemEntry); // Dequeue variable.
            ItemTrackingLines."Appl.-to Item Entry".SETVALUE(ApplToItemEntry);
          END;
        OptionString::VerifyApplFromItemEntry:
          BEGIN
            LibraryVariableStorage.Dequeue(LotNo);
            LibraryVariableStorage.Dequeue(SerialNo);
            LibraryVariableStorage.Dequeue(ApplFromItemEntry);
            LibraryVariableStorage.Dequeue(Quantity);
            ItemTrackingLines."Appl.-from Item Entry".ASSERTEQUALS(ApplFromItemEntry);
            ItemTrackingLines."Lot No.".ASSERTEQUALS(LotNo);
            ItemTrackingLines."Serial No.".ASSERTEQUALS(SerialNo);
            ItemTrackingLines."Quantity (Base)".ASSERTEQUALS(Quantity);
          END;
        OptionString::VerifyApplToItemEntry:
          BEGIN
            LibraryVariableStorage.Dequeue(ApplToItemEntry);
            ItemTrackingLines."Appl.-to Item Entry".ASSERTEQUALS(ApplToItemEntry);
          END;
      END;
      ItemTrackingLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE EnterQuantitytoCreatePageHandler@122(VAR EnterQuantitytoCreate@1000 : TestPage 6513);
    BEGIN
      EnterQuantitytoCreate.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemTrackingSummaryPageHandler@159(VAR ItemTrackingSummary@1000 : TestPage 6500);
    BEGIN
      ItemTrackingSummary.OK.INVOKE;
    END;

    BEGIN
    {
      // [FEATURE] [SCM]
      Unsupported version tags:
      NO: Unable to Execute (TFS ID: 47913)

      Miscellaneous Test for SCM Inventory:
       1. Verify Quantity and Reserved Quantity on Planned Production Order Created from Sales Order.
       2. Verify error while Refresh Planned Production Order created from Sales Order.
       3. Verify Quantity and Reserved Quantity on Production Order created from Sales Order and after changing the Production Order status from Planned to Firm Planned.
       4. Verify error while Refresh Planned Production Order created from Sales Order and after changing the Production Order status from Planned to Firm Planned.
       5. Verify Reserved Quantity on Production Order created from Sales Order after cancellation of reservation.
       6. Verify Reserved Quantity on Production Order created from Sales Order after Auto Reservation.
       7. Verify Quantity on Production Order Line after creating Production Order from Sales Order and updating Quantity on Sales Line.
       8. Verify Item Ledger Entry when Qty. (Phys. Inventory) is updated for an Item with Overhead Cost and having costing method Average.
       9. Verify Item Ledger Entry after posting Item Journal Line for Item having costing method Average.
      10. Verify G/L Entries after running Adjust Cost Item Entries and post Inventory to G/L batch job for an Item.
      11. Verify Value Entry after running Post Inventory Cost To G/L batch job using Post Method 'Per Entry'.
      12. Verify Physical Inventory Journal after calculate Counting Periods for an Item if Dimensions are selected.
      13. Verify deletion of Physical Inventory Ledger Entries.
      14. Verify error while update Base Unit of Measure if there are one or more open Ledger Entries for Item.
      15. Verify Filtered Data Of Standard Cost Worksheet.
      16. Verify Filtered Data Of Standard Cost Worksheet After Modify Item.
      17. Verify Item Ledger Entries when Item Costing Method is Average and after applying Revalued Inbound Entry to Outbound.
      18. Verify error while posting Purchase Return Order when Apply to Item Entry is Zero using Get Posted Document Lines to Reverse.
      19. Verify error while posting sales Return Order when Apply from Item Entry is Zero using Get Posted Document Lines to Reverse.
      20. Verify G/L Entries after posting Purchase Order as Invoice if Item Charge Line is fully invoiced.
      21. Verify Unit Price on Sales Line when Order Date is same as Starting Date of Sales Price with Sales Type Customer.
      22. Verify Unit Price on Sales Line when Order Date is before Starting Date of Sales Price with Sales Type Customer.
      23. Verify Unit Price on Sales Line when Customer Pricing Group defined on Sales Price.
      24. Verify Unit Price on Sales Line when Sales Order is created with another Customer and Customer Pricing Group is defined on Sales Price.
      25. Verify Unit Price on Sales Line when Sales Price with Type All Customer is defined on Item.
      26. Verify Unit Price on Sales Line when Sales Price is defined on Customer with Currency.
      27. Verify Unit Price on Posted Sales Invoice after posting Partial Quantity on Sales Order and updating Unit Price on Sales Price.
      28. Verify Unit Price on Posted Sales Invoice after posting Partial Quantity on Sales Order and updating Unit Price on Sales Price.
      29. Verify Amount on Posted Sales Invoice Statistics after posting Sales Order.
      30. Verify Unit Amount on Item Journal Line when Sales Price is defined for Item.
      31. Verify Line Discount on Sales Line when Sales Line Discount for Sale Type Customer is defined.
      32. Verify Line Discount on Sales Line when Sales Line Discount for Sale Type Customer Discount Group is defined.
      33. Verify Line Discount on Sales Line when Sales Line Discount for Sales Type All Customer is defined.
      34. Verify Line Discount on Posted Sales Invoice after posting Partial Quantity on Sales Order and updating Line Discount on Sales Line Discount.
      35. Verify Line Discount on Posted Sales Invoice after posting Sales Invoice using Copy Document and updating Line Discount on Sales Line Discount.
      36. Verify Unit Price on Sales Line when Sales Price Sales Type Customer is defined with Price Including VAT TRUE.
      37. Verify Unit Price on Sales Line when Sales Price Sales Type Customer Price Group is defined with Price Including VAT TRUE.
      38. Verify no error while reducing quantity on partial received Sales Return Order created by Get Posted Document Lines to Reverse.
      39. Verify no error while reducing quantity on partial shipped Purchase Return Order created by Get Posted Document Lines to Reverse.
      40. Verify no error while reducing quantity on partial shipped Sales Order with negative quantity created by Appl.-from Item Entry.
      41. Verify Expected Receipt Date and Shipment Date on Canceling Reservation for Order to Order Bound Production Order.
      42. Verify Expected Receipt Date and Shipment Date on Canceling Reservation for Order to Order Bound Purchase Order.
      43. Verify Expected Receipt Date and Shipment Date on Canceling Reservation for Order to Order Bound Sales Order with Negative Quantity.
      44. Verify Expected Receipt Date and Shipment Date on Canceling Reservation for Order to Order Bound Purchase Order With Negative Quantity.
      45. Verify Expected Receipt Date and Shipment Date on Canceling Reservation for Order to Order Bound Return Sales Order.
      46. Verify Expected Receipt Date and Shipment Date on Canceling Reservation for Order to Order Bound Return Purchase Order.
      47. Verify value in Appl.-from Item Entry is correct on Item Tracking Line of existing Sales Return Orders created by Copy Document with Serial No. after executing of a Planning.
      48. Verify value in Appl.-from Item Entry is correct on Item Tracking Line of existing Sales Return Orders created by manually with Lot No. after executing of a Planning.
      49. Verify value in Appl.-to Item Entry is correct on Item Tracking Line of existing Purchase Return Orders created by Get Posted Dococument To Reverse with Lot No. after executing of a Planning.
      50. Verify value in Appl.-to Item Entry is correct on Item Tracking Line of existing Purchase Return Orders created by Copy Document with Serial No. after executing of a Planning.
      51. Verify value in Appl.-to Item Entry is correct on Item Tracking Line of existing Purchase Return Orders created by manually with Lot No. after executing of a Planning.
      52. Verify  values in Item Tracking Line of existing Sales Return Order created by Get Posted Document Line To Reserve and appl. from a Posted Shipment with Serial No. after executing of a Planning.
      53. Verify  values in Item Tracking Line of existing Sales Return Order created by Get Posted Document Line To Reserve and appl. from a Posted Invoice with Lot No. after executing of a Planning.
      54. Verify  values in Item Tracking Line of existing Sales Return Order created by Copy Document and appl. from a Posted Invoice with Serial No. after executing of a Planning.
      55. Check Customer Discount Group page opened successfully with Correct Values.

      Covers Test cases: for WI - 308680
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      ReserveQtyOnProdOrderFromSalesOrder, ReserveQtyErrorOnProdOrderFromSalesOrder
      ReserveQtyOnProdOrderAfterChangeStatus, ReserveQtyErrorOnProdOrderAfterChangeStatus            120972
      ProdOrderReservationCancel, ProdOrderAutoReservation                                           120973
      ReserveQtyOnProdOrderAfterUpdateQty                                                            120974

      Covers Test cases: for WI - 309086
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      PostPhysInvJournalAfterUpdateQty                                                               259615
      CostAmountOnItemLedgerEntry                                                                    295782
      GLEntriesAfterPostInvCostToGL, PostInvCostToGLWithPostMethodPerEntry                           294118
      CountingPeriodOnPhysInvJournalWithDim                                                          284722

      Covers Test cases: for WI - 309084
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      DeletePhysInvLedgerEntries                                                                     253867
      UpdateItemUnitOfMeasureError                                                                   289038

      Covers Test cases: for WI - 309085
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      RollUpStdCostOnStdCostWorkSheet, RollUpStdCostAfterUpdateInvPostingGroup                       282602
      ApplyingRevaluedInboundEntryToOutbound                                                         273901

      Covers Test cases: for WI - 311601
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      ApplyToItemZeroErrorOnPurchReturnOrder, ApplyFromItemZeroErrorOnSalesReturnOrder               236353
      PostPurchOrderWithFullInvoicedItemCharge                                                       276903

      TFS_TS_ID = 315156
      Cover Test cases:
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      SalesPriceForCustomer, SalesPriceForCustomerFromItem
      SalesPriceForCustPriceGroup, SalesPriceForCustPriceGroupFromItem
      SalesPriceForAllCustomer, SalesPriceForCustomerWithCurrency,
      SalesPriceForCustomerWithPartialQty, PostSalesInvUsingCopyDoc,
      PstdSalesInvStatisticsWithSalesPrice, UnitPriceOnItemJournal                                   128216

      TFS_TS_ID = 315416
      Cover Test cases:
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      LineDiscountForCustomer, LineDiscountForCustomerDiscountGroup
      LineDiscountForAllCustomer, LineDiscountForCustomerWithPartialQty
      LineDiscOnPostSalesInvUsingCopyDoc, SalesPriceForCustomerWithPriceInclVAT
      SalesPriceForCustPriceGrpWithPriceInclVAT                                                      128219

      Covers Test cases: for Sicily Merge Bug - 48474
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      ReduceQtyOnPartialReceivedSalesReturnOrder
      ReduceQtyOnPartialShippedPurchaseReturnOrder
      ReduceQtyOnPartialShippedSalesOrderWithNegativeQuantity

      Bug_ID = 6640
      Cover Test cases:
      -----------------------------------------------------------------------------------------------------
       Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      CancelReservationFromBoundProductionOrder,CancelReservationFromBoundPurchaseOrder,
      CancelReservationFromBoundSalesOrderWithNegativeQuantity,CancelReservationFromBoundPurchaseOrderWithNegativeQuantity,
      CancelReservationFromBoundReturnSalesOrder,CancelReservationFromBoundReturnPurchaseOrder

      Covers Test cases: for Sicily Merge Bug
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      CreateSalesReturnOrderByCopyDocumentWithSerialNo                                               57573
      CreateSalesReturnOrderByManuallyWithLotNo                                                      57573
      CreatePurchReturnOrderByGetPostedDocToReverseWithLotNo                                         57573
      CreatePurchReturnOrderByCopyDocumentWithSerialNo                                               57573
      CreatePurchReturnOrderByManuallyWithLotNo                                                      57573

      Covers Test cases: for Sicily Merge Bug
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      CreateSalesReturnOrderApplFromPostedShptByGetPostedDocToRevWithSerialNo                        59005
      CreateSalesReturnOrderApplFromPostedInvoiceByGetPostedDocToRevWithLotNo                        59005
      CreateSalesReturnOrderApplFromPostedInvoiceByCopyDocWithSerialNo                               59005

      Covers Test cases: for Sicily Merge Bug
      -----------------------------------------------------------------------------------------------------
      Test Function Name                                                                             TFS ID
      -----------------------------------------------------------------------------------------------------
      CheckSalesLineDiscountPageforCustomerDiscountGroup                                             71341
    }
    END.
  }
}

