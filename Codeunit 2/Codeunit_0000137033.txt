OBJECT Codeunit 137033 SCM Item Journal
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LibraryRandom@1003 : Codeunit 130440;
      Assert@1009 : Codeunit 130000;
      LibraryInventory@1010 : Codeunit 132201;
      LibraryUtility@1007 : Codeunit 131000;
      LibraryWarehouse@1001 : Codeunit 132204;
      LibraryManufacturing@1013 : Codeunit 132202;
      isInitialized@1000 : Boolean;
      ItemJournalAmountErr@1004 : TextConst 'ENU=Item Journal Amount must match.';
      ItemJournalUnitCostErr@1005 : TextConst 'ENU=Item Journal Unit Cost must match.';
      QuantityErr@1006 : TextConst 'ENU=Item Quantity must match.';
      TransferILEErr@1011 : TextConst 'ENU=Incorrect Item Ledger Entry created.';
      BlockMovementOutbErr@1002 : TextConst 'ENU=Block Movement must not be Outbound in Bin';
      BlockMovementInbErr@1008 : TextConst 'ENU=Block Movement must not be Inbound in Bin';
      BlockMovementAllErr@1012 : TextConst 'ENU=Block Movement must not be All in Bin';
      InvalidBinCodeErr@1014 : TextConst 'ENU=Bin Code is invalid.';
      LocationWithDirectedPutAwayAndPickErr@1015 : TextConst '@@@=%1: Field(Code);ENU=You cannot use a Bin Code because location %1 is set up with Directed Put-away and Pick.';
      UnitCostCannotBeChangedErr@1016 : TextConst 'ENU=You cannot change Unit Cost when Costing Method is Standard.';

    [Test]
    PROCEDURE GetStdJnlLines@1();
    VAR
      TempItemJournalLine@1003 : TEMPORARY Record 83;
      ItemJournalBatch@1006 : Record 233;
      StockoutWarning@1002 : Boolean;
      StandardItemJournalCode@1007 : Code[10];
    BEGIN
      // Setup: Update Sales Receivables setup.
      // Create Item Journal Lines and run Save As Standard Journal report and clear Item Journal Lines.
      Initialize;
      StockoutWarning := UpdateSalesReceivableSetup(FALSE);
      StandardItemJournalCode := CreateStdJournalSetup(TempItemJournalLine,ItemJournalBatch,4,TRUE);  // No of Items = 4.

      StdJournalLines(TempItemJournalLine,ItemJournalBatch,StandardItemJournalCode);

      // Update Stockout Warning to original value.
      UpdateSalesReceivableSetup(StockoutWarning);
    END;

    [Test]
    [HandlerFunctions(ItemJournalConfirmHandler)]
    PROCEDURE ChangeStdJnlLinesQty@11();
    VAR
      TempItemJournalLine@1003 : TEMPORARY Record 83;
      TempItemJournalLine2@1005 : TEMPORARY Record 83;
      ItemJournalBatch@1006 : Record 233;
      StandardItemJournalCode@1007 : Code[10];
    BEGIN
      // Setup: Create Item Journal Lines and run Save As Standard Journal report and clear Item Journal Lines.
      Initialize;
      StandardItemJournalCode := CreateStdJournalSetup(TempItemJournalLine,ItemJournalBatch,3,TRUE);  // No of Items = 3.
      CreateItemJnlFromStdJournal(ItemJournalBatch,StandardItemJournalCode);
      UpdateItemJournalLineQuantity(TempItemJournalLine2,ItemJournalBatch,StandardItemJournalCode);

      StdJournalLines(TempItemJournalLine2,ItemJournalBatch,StandardItemJournalCode);
    END;

    [Test]
    PROCEDURE GetStdJnlLinesWithoutAmt@28();
    VAR
      TempItemJournalLine@1003 : TEMPORARY Record 83;
      ItemJournalBatch@1002 : Record 233;
      ItemJournalLine@1001 : Record 83;
      StandardItemJournalCode@1000 : Code[10];
    BEGIN
      // Setup: Create Item Journal Lines and run Save As Standard Journal report and clear Item Journal Lines.
      Initialize;
      StandardItemJournalCode := CreateStdJournalSetup(TempItemJournalLine,ItemJournalBatch,4,FALSE);  // No of Items = 4.
      SelectItemJournalLine(ItemJournalLine,ItemJournalBatch);
      StandardItemJournalCode := SaveAsStandardJournal(ItemJournalBatch,ItemJournalLine,FALSE,TRUE,'');  // Unit Amount Not Saved.

      StdJournalLines(TempItemJournalLine,ItemJournalBatch,StandardItemJournalCode);
    END;

    LOCAL PROCEDURE StdJournalLines@33(VAR TempItemJournalLine@1000 : TEMPORARY Record 83;ItemJournalBatch@1001 : Record 233;StandardItemJournalCode@1002 : Code[10]);
    BEGIN
      // Exercise: Populate Item Journal Lines from Standard Item Journal.
      CreateItemJnlFromStdJournal(ItemJournalBatch,StandardItemJournalCode);

      // Verify: Verify Item Journal Lines.
      VerifyItemJournalAmount(TempItemJournalLine,ItemJournalBatch);

      // Teardown.
      ItemJournalBatch.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE DeletePartialStdJnl@9();
    VAR
      TempItem@1001 : TEMPORARY Record 27;
      TempItemJournalLine@1003 : TEMPORARY Record 83;
      TempItemJournalLine2@1005 : TEMPORARY Record 83;
      ItemJournalBatch@1006 : Record 233;
      ItemJournalBatch2@1008 : Record 233;
      StandardItemJournal@1009 : Record 752;
      StandardItemJournalCode@1007 : Code[10];
      StandardItemJournalCode2@1004 : Code[10];
    BEGIN
      // Setup: Create Item Journal Lines and run Save As Standard Journal report and clear Item Journal Lines.
      Initialize;
      CreateItemsAndCopyToTemp(TempItem,4);  // No of Items = 4.
      StandardItemJournalCode := CreateItemJournalAndCopyToTemp(TempItemJournalLine,TempItem,ItemJournalBatch,TRUE);
      StandardItemJournalCode2 := CreateItemJournalAndCopyToTemp(TempItemJournalLine2,TempItem,ItemJournalBatch2,TRUE);
      CreateItemJnlFromStdJournal(ItemJournalBatch2,StandardItemJournalCode2);

      // Exercise: Delete selected Standard Item Journal.
      SelectStandardItemJournal(StandardItemJournal,StandardItemJournalCode2,ItemJournalBatch2."Journal Template Name");
      StandardItemJournal.DELETE(TRUE);

      // Verify: Verify Standard Item Journal entry.
      VerifyStandardJournalEntry(ItemJournalBatch."Journal Template Name",StandardItemJournalCode);

      // Teardown.
      ItemJournalBatch.DELETE(TRUE);
      ItemJournalBatch2.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE ChangeItemCostRecalcUnitAmt@14();
    VAR
      TempItem@1001 : TEMPORARY Record 27;
      TempItemJournalLine@1003 : TEMPORARY Record 83;
      Item@1004 : Record 27;
      ItemJournalBatch@1006 : Record 233;
      ItemJournalLine@1002 : Record 83;
      StandardItemJournalCode@1007 : Code[10];
    BEGIN
      // Setup: Create Item Journal Line and run Save As Standard Journal report and clear Item Journal Line.
      Initialize;
      CreateItemWithoutCost(TempItem,Item);  // No of Item = 1.
      StandardItemJournalCode := CreateItemJournalAndCopyToTemp(TempItemJournalLine,TempItem,ItemJournalBatch,TRUE);
      CreateItemJnlFromStdJournal(ItemJournalBatch,StandardItemJournalCode);
      UpdateItemCost(Item);

      // Exercise: Recalculate Unit Amount for Item on Item Journal Lines.
      RecalcUnitAmountItemJnlLine(ItemJournalLine,ItemJournalBatch);

      // Verify: Verify Item Journal Line after Recalculate Unit Amount.
      Assert.AreEqual(Item."Unit Price",ItemJournalLine."Unit Amount",ItemJournalAmountErr);
      Assert.AreEqual(Item."Unit Cost",ItemJournalLine."Unit Cost",ItemJournalUnitCostErr);

      // Teardown.
      ItemJournalBatch.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE ChangeItemJnlLineRecalcUnitAmt@29();
    VAR
      TempItemJournalLine@1003 : TEMPORARY Record 83;
      ItemJournalBatch@1002 : Record 233;
      ItemJournalLine@1001 : Record 83;
      StandardItemJournalCode@1000 : Code[10];
    BEGIN
      // Setup: Create Item Journal Line and run Save As Standard Journal report and clear Item Journal Line.
      // Modify Unit Cost of Item on Item Journal Line.
      Initialize;
      StandardItemJournalCode := CreateStdJournalSetup(TempItemJournalLine,ItemJournalBatch,1,TRUE);  // No of Item = 1.
      CreateItemJnlFromStdJournal(ItemJournalBatch,StandardItemJournalCode);
      UpdateItemJournalUnitCost(ItemJournalLine,ItemJournalBatch);

      // Exercise: Recalculate Unit Amount for Item on Item Journal Line. Item Unit Cost reverts to original value.
      RecalcUnitAmountItemJnlLine(ItemJournalLine,ItemJournalBatch);

      // Verify: Verify Item Journal Line.
      Assert.AreEqual(TempItemJournalLine."Unit Cost",ItemJournalLine."Unit Cost",ItemJournalUnitCostErr);

      // Teardown.
      ItemJournalBatch.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE GetStdJnlLinesAndPost@38();
    VAR
      TempItemJournalLine@1003 : TEMPORARY Record 83;
      ItemJournalBatch@1002 : Record 233;
      ItemJournalLine@1001 : Record 83;
      StandardItemJournalCode@1000 : Code[10];
    BEGIN
      // Setup: Create Item Journal Lines and run Save As Standard Journal report and clear Item Journal Lines.
      Initialize;
      StandardItemJournalCode := CreateStdJournalSetup(TempItemJournalLine,ItemJournalBatch,4,TRUE);  // No of Items = 4.
      CreateItemJnlFromStdJournal(ItemJournalBatch,StandardItemJournalCode);
      UpdateItemJournalDocumentNo(ItemJournalLine,ItemJournalBatch);

      // Exercise: Post Item Journal Lines.
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);

      // Verify: Verify Item Ledger Entry for the Items.
      VerifyItemLedgerEntry(TempItemJournalLine);
    END;

    [Test]
    PROCEDURE PostItemJournal@7();
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      // Posting Item Journal and Verifying Item Ledger Entries.

      // Setup: Create Item Journal with Entry Type Positive Adjustment.
      CreateItemJournal(ItemJournalLine);

      // Exercise: Post Item Journal.
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Verify: Verify Item Ledger Entry.
      VerifyItemLedgerEntryForQty(ItemJournalLine);
    END;

    [Test]
    PROCEDURE PostItemJournalTransferLines@26();
    VAR
      ItemJnlBatch@1001 : Record 233;
      ItemJnlTemplate@1002 : Record 82;
      Item@1003 : Record 27;
      OldLocation@1006 : Record 14;
      NewLocation@1007 : Record 14;
      OldBinCode@1008 : Code[20];
      NewBinCode@1009 : Code[20];
      ItemQty@1004 : Integer;
      DocumentNo@1005 : Code[20];
    BEGIN
      // Complex scenario: create 2 Item Journal lines, 1st with transfer, 2nd - with Bin reclassification.
      // Verify Item Ledger Entries: they should be created only for 1st Jnl. Line

      Initialize;

      // Create 2 locations, 1st with Bin numbers, second - without
      CreateLocationWithBin(OldLocation,OldBinCode,NewBinCode);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(NewLocation);

      LibraryInventory.CreateItem(Item);

      ItemQty := LibraryRandom.RandInt(20);

      // Create Item Journal Template and Batch
      LibraryInventory.CreateItemJournalTemplate(ItemJnlTemplate);
      LibraryInventory.CreateItemJournalBatch(ItemJnlBatch,ItemJnlTemplate.Name);

      // Create Positive Adjmt. Journal Line
      CreatePositiveAdjmtLocationAndBin(
        ItemJnlTemplate.Name,ItemJnlBatch.Name,OldLocation.Code,OldBinCode,Item."No.",2 * ItemQty);

      // Create Transfer line
      CreateItemReclassJournaLine(
        ItemJnlTemplate.Name,ItemJnlBatch.Name,Item."No.",OldLocation.Code,NewLocation.Code,OldBinCode,'',ItemQty);

      // Create Bin Reclassification line - no Item Ledger Entry should be created
      DocumentNo :=
        CreateItemReclassJournaLine(
          ItemJnlTemplate.Name,ItemJnlBatch.Name,Item."No.",OldLocation.Code,OldLocation.Code,OldBinCode,NewBinCode,ItemQty);

      // Post lines
      LibraryInventory.PostItemJournalLine(ItemJnlBatch."Journal Template Name",ItemJnlBatch.Name);

      // Verify that no ledger entries for Bin Reclassification Line were created
      CheckNoItemLedgerEntries(DocumentNo);

      // Tear down.
      ItemJnlTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE UnitAmountOnItemJournalLine@103();
    VAR
      ItemJournalBatch@1001 : Record 233;
      ItemJournalLine@1000 : Record 83;
      Item@1002 : Record 27;
    BEGIN
      // [SCENARIO] Item Journal's Unit Amount field gets updated from the Unit Price value on item Card instead of Unit Cost when Entry Type=Sales.
      Initialize;

      // [GIVEN] Item with "A" with "Unit Price" = "X"
      CreateItem(Item);

      // [WHEN] Validate Item Journal with item "A" and "Entry Type" = Sale.
      SelectItemJournal(ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",
        ItemJournalBatch.Name,ItemJournalLine."Entry Type"::Sale,Item."No.",LibraryRandom.RandDec(10,2));

      // [THEN] Item Journal's "Unit Amount" = "X"
      ItemJournalLine.TESTFIELD("Unit Amount",Item."Unit Price");
    END;

    [Test]
    PROCEDURE ItemReclassLineBlockMovementNewBinInbound@70();
    VAR
      ItemJnlBatch@1008 : Record 233;
      ItemJnlTemplate@1007 : Record 82;
      Location@1004 : Record 14;
      OldBin@1003 : Record 7354;
      NewBin@1002 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 376316] Posting Item Reclassification Line should be prohibited for New Bin with Block Movement Inbound
      Initialize;

      // [GIVEN] Location "X" with two Bins: Bin1 without "Block Movement" and Bin2 with "Block Movement" = "Inbound"
      CreateLocationWithTwoBinsBlockMovement(Location,OldBin,OldBin."Block Movement"::" ",NewBin,NewBin."Block Movement"::Inbound);

      // [GIVEN] Item Reclassification Line with Bin = Bin1, New Bin = Bin2
      CreateItemReclassJournalLineWithNewBin(
        ItemJnlBatch,ItemJnlTemplate,Location.Code,OldBin.Code,NewBin.Code,LibraryRandom.RandInt(9));

      // [WHEN] Post Item Reclassification Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJnlBatch."Journal Template Name",ItemJnlBatch.Name);

      // [THEN] Error is thrown: "Block Movement must not be Inbound in Bin"
      Assert.ExpectedError(BlockMovementInbErr);
    END;

    [Test]
    PROCEDURE ItemReclassLineBlockMovementBinOutbound@40();
    VAR
      ItemJnlBatch@1008 : Record 233;
      ItemJnlTemplate@1007 : Record 82;
      Location@1004 : Record 14;
      OldBin@1003 : Record 7354;
      NewBin@1002 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 376316] Posting Item Reclassification Line should be prohibited for Bin with Block Movement Outbound
      Initialize;

      // [GIVEN] Location "X" with two Bins: Bin1 with "Block Movement" = "Outbound" and Bin2 without "Block Movement"
      CreateLocationWithTwoBinsBlockMovement(Location,OldBin,OldBin."Block Movement"::Outbound,NewBin,NewBin."Block Movement"::" ");

      // [GIVEN] Item Reclassification Line with Bin = Bin1, New Bin = Bin2
      CreateItemReclassJournalLineWithNewBin(
        ItemJnlBatch,ItemJnlTemplate,Location.Code,OldBin.Code,NewBin.Code,LibraryRandom.RandInt(9));

      // [WHEN] Post Item Reclassification Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJnlBatch."Journal Template Name",ItemJnlBatch.Name);

      // [THEN] Error is thrown: "Block Movement must not be Outbound in Bin"
      Assert.ExpectedError(BlockMovementOutbErr);
    END;

    [Test]
    PROCEDURE ItemReclassLineBlockMovementNewBinAll@55();
    VAR
      ItemJnlBatch@1008 : Record 233;
      ItemJnlTemplate@1007 : Record 82;
      Location@1004 : Record 14;
      OldBin@1003 : Record 7354;
      NewBin@1002 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 376316] Posting Item Reclassification Line should be prohibited for New Bin with Block Movement All
      Initialize;

      // [GIVEN] Location "X" with two Bins: Bin1 without "Block Movement" and Bin2 with "Block Movement" = "All"
      CreateLocationWithTwoBinsBlockMovement(Location,OldBin,OldBin."Block Movement"::" ",NewBin,NewBin."Block Movement"::All);

      // [GIVEN] Item Reclassification Line with Bin = Bin1, New Bin = Bin2
      CreateItemReclassJournalLineWithNewBin(
        ItemJnlBatch,ItemJnlTemplate,Location.Code,OldBin.Code,NewBin.Code,LibraryRandom.RandInt(9));

      // [WHEN] Post Item Reclassification Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJnlBatch."Journal Template Name",ItemJnlBatch.Name);

      // [THEN] Error is thrown: "Block Movement must not be All in Bin"
      Assert.ExpectedError(BlockMovementAllErr);
    END;

    [Test]
    PROCEDURE ItemReclassLineBlockMovementBinAll@54();
    VAR
      ItemJnlBatch@1008 : Record 233;
      ItemJnlTemplate@1007 : Record 82;
      Location@1004 : Record 14;
      OldBin@1003 : Record 7354;
      NewBin@1002 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 376316] Posting Item Reclassification Line should be prohibited for Bin with Block Movement All
      Initialize;

      // [GIVEN] Location "X" with two Bins: Bin1 with "Block Movement" = "All" and Bin2 without "Block Movement"
      CreateLocationWithTwoBinsBlockMovement(Location,OldBin,OldBin."Block Movement"::All,NewBin,NewBin."Block Movement"::" ");

      // [GIVEN] Item Reclassification Line with Bin = Bin1, New Bin = Bin2
      CreateItemReclassJournalLineWithNewBin(
        ItemJnlBatch,ItemJnlTemplate,Location.Code,OldBin.Code,NewBin.Code,LibraryRandom.RandInt(9));

      // [WHEN] Post Item Reclassification Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJnlBatch."Journal Template Name",ItemJnlBatch.Name);

      // [THEN] Error is thrown: "Block Movement must not be All in Bin"
      Assert.ExpectedError(BlockMovementAllErr);
    END;

    [Test]
    PROCEDURE ItemJournalLineSalesBlockMovementBinOutbound@45();
    VAR
      ItemJournalLine@1000 : Record 83;
      Location@1002 : Record 14;
      Bin@1001 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 377504] Posting Item Journal Line with "Entry Type" = "Sales" should be prohibited for Bin with Block Movement Outbound
      Initialize;

      // [GIVEN] Bin "B" with "Block Movement" = "Outbound"
      CreateLocationWithBinBlockMovement(Location,Bin,Bin."Block Movement"::Outbound);

      // [GIVEN] Item Journal Line with Bin = "B" and "Entry Type" = "Sales"
      CreateItemJournalLineWithEntryType(ItemJournalLine,ItemJournalLine."Entry Type"::Sale,Location.Code,Bin.Code);

      // [WHEN] Post Item Jounal Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // [THEN] Error is thrown: "Block Movement must not be Outbound in Bin"
      Assert.ExpectedError(BlockMovementOutbErr);
    END;

    [Test]
    PROCEDURE ItemJournalLineNegAdjmBlockMovementBinInbound@44();
    VAR
      ItemJournalLine@1000 : Record 83;
      Location@1002 : Record 14;
      Bin@1001 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 377504] Posting Item Journal Line with "Entry Type" = "Negative Adjmt." and negative Quantity should be prohibited for Bin with Block Movement Inbound
      Initialize;

      // [GIVEN] Bin "B" with "Block Movement" = "Inbound"
      CreateLocationWithBinBlockMovement(Location,Bin,Bin."Block Movement"::Inbound);

      // [GIVEN] Item Journal Line with Bin = "B" and "Entry Type" = "Negative Adjmt."
      CreateItemJournalLineWithEntryType(ItemJournalLine,ItemJournalLine."Entry Type"::"Negative Adjmt.",Location.Code,Bin.Code);
      ItemJournalLine.Quantity := -ItemJournalLine.Quantity;
      ItemJournalLine.MODIFY;

      // [WHEN] Post Item Jounal Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // [THEN] Error is thrown: "Block Movement must not be Inbound in Bin"
      Assert.ExpectedError(BlockMovementInbErr);
    END;

    [Test]
    PROCEDURE ItemJournalLineConsBlockMovementBinOutbound@57();
    VAR
      ItemJournalLine@1000 : Record 83;
      Location@1002 : Record 14;
      Bin@1001 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 377504] Posting Item Journal Line with "Entry Type" = "Consumption" should be prohibited for Bin with Block Movement Outbound
      Initialize;

      // [GIVEN] Bin "B" with "Block Movement" = "Outbound"
      CreateLocationWithBinBlockMovement(Location,Bin,Bin."Block Movement"::Outbound);

      // [GIVEN] Item Journal Line with Bin = "B" and "Entry Type" = "Consumption"
      CreateItemJournalLineWithEntryType(ItemJournalLine,ItemJournalLine."Entry Type"::Consumption,Location.Code,Bin.Code);

      // [WHEN] Post Item Jounal Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // [THEN] Error is thrown: "Block Movement must not be Outbound in Bin"
      Assert.ExpectedError(BlockMovementOutbErr);
    END;

    [Test]
    PROCEDURE ItemJournalLineAsmblyConsBlockMovementBinInbound@65();
    VAR
      ItemJournalLine@1000 : Record 83;
      Location@1002 : Record 14;
      Bin@1001 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 377504] Posting Item Journal Line with "Entry Type" = "Assembly Consumption" and negative Quantity should be prohibited for Bin with Block Movement Inbound
      Initialize;

      // [GIVEN] Bin "B" with "Block Movement" = "Inbound"
      CreateLocationWithBinBlockMovement(Location,Bin,Bin."Block Movement"::Inbound);

      // [GIVEN] Item Journal Line with Bin = "B" and "Entry Type" = "Assembly Consumption"
      CreateItemJournalLineWithEntryType(ItemJournalLine,ItemJournalLine."Entry Type"::"Assembly Consumption",Location.Code,Bin.Code);
      ItemJournalLine.Quantity := -ItemJournalLine.Quantity;
      ItemJournalLine.MODIFY;

      // [WHEN] Post Item Jounal Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // [THEN] Error is thrown: "Block Movement must not be Inbound in Bin"
      Assert.ExpectedError(BlockMovementInbErr);
    END;

    [Test]
    PROCEDURE ItemJournalLinePurchBlockMovementBinInbound@75();
    VAR
      ItemJournalLine@1000 : Record 83;
      Location@1002 : Record 14;
      Bin@1001 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 377504] Posting Item Journal Line with "Entry Type" = "Purchase" should be prohibited for Bin with Block Movement Inbound
      Initialize;

      // [GIVEN] Bin "B" with "Block Movement" = "Inbound"
      CreateLocationWithBinBlockMovement(Location,Bin,Bin."Block Movement"::Inbound);

      // [GIVEN] Item Journal Line with Bin = "B" and "Entry Type" = "Purchase"
      CreateItemJournalLineWithEntryType(ItemJournalLine,ItemJournalLine."Entry Type"::Purchase,Location.Code,Bin.Code);

      // [WHEN] Post Item Jounal Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // [THEN] Error is thrown: "Block Movement must not be Inbound in Bin"
      Assert.ExpectedError(BlockMovementInbErr);
    END;

    [Test]
    PROCEDURE ItemJournalLinePosAdjmBlockMovementBinOutbound@74();
    VAR
      ItemJournalLine@1000 : Record 83;
      Location@1002 : Record 14;
      Bin@1001 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 377504] Posting Item Journal Line with "Entry Type" = "Positive Adjmt." and negative Quantity should be prohibited for Bin with Block Movement Outbound
      Initialize;

      // [GIVEN] Bin "B" with "Block Movement" = "Outbound"
      CreateLocationWithBinBlockMovement(Location,Bin,Bin."Block Movement"::Outbound);

      // [GIVEN] Item Journal Line with Bin = "B" and "Entry Type" = "Positive Adjmt."
      CreateItemJournalLineWithEntryType(ItemJournalLine,ItemJournalLine."Entry Type"::"Positive Adjmt.",Location.Code,Bin.Code);
      ItemJournalLine.Quantity := -ItemJournalLine.Quantity;
      ItemJournalLine.MODIFY;

      // [WHEN] Post Item Jounal Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // [THEN] Error is thrown: "Block Movement must not be Outbound in Bin"
      Assert.ExpectedError(BlockMovementOutbErr);
    END;

    [Test]
    PROCEDURE ItemJournalLineOutputBlockMovementBinInbound@73();
    VAR
      ItemJournalLine@1000 : Record 83;
      Location@1002 : Record 14;
      Bin@1001 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 377504] Posting Item Journal Line with "Entry Type" = "Output" should be prohibited for Bin with Block Movement Inbound
      Initialize;

      // [GIVEN] Bin "B" with "Block Movement" = "Inbound"
      CreateLocationWithBinBlockMovement(Location,Bin,Bin."Block Movement"::Inbound);

      // [GIVEN] Item Journal Line with Bin = "B" and "Entry Type" = "Output"
      CreateItemJournalLineWithEntryType(ItemJournalLine,ItemJournalLine."Entry Type"::Output,Location.Code,Bin.Code);
      ItemJournalLine.VALIDATE("Output Quantity",1);
      ItemJournalLine.MODIFY(TRUE);

      // [WHEN] Post Item Jounal Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // [THEN] Error is thrown: "Block Movement must not be Inbound in Bin"
      Assert.ExpectedError(BlockMovementInbErr);
    END;

    [Test]
    PROCEDURE ItemJournalLineAsmblyOutputBlockMovementBinOutbound@72();
    VAR
      ItemJournalLine@1000 : Record 83;
      Location@1002 : Record 14;
      Bin@1001 : Record 7354;
    BEGIN
      // [FEATURE] [Item Journal] [Bin]
      // [SCENARIO 377504] Posting Item Journal Line with "Entry Type" = "Assembly Output" and negative Quantity should be prohibited for Bin with Block Movement Outbound
      Initialize;

      // [GIVEN] Bin "B" with "Block Movement" = "Outbound"
      CreateLocationWithBinBlockMovement(Location,Bin,Bin."Block Movement"::Outbound);

      // [GIVEN] Item Journal Line with Bin = "B" and "Entry Type" = "Assembly Output"
      CreateItemJournalLineWithEntryType(ItemJournalLine,ItemJournalLine."Entry Type"::"Assembly Output",Location.Code,Bin.Code);
      ItemJournalLine.Quantity := -ItemJournalLine.Quantity;
      ItemJournalLine.MODIFY;

      // [WHEN] Post Item Jounal Line
      ASSERTERROR LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // [THEN] Error is thrown: "Block Movement must not be Outbound in Bin"
      Assert.ExpectedError(BlockMovementOutbErr);
    END;

    [Test]
    PROCEDURE LocationAndBinAreUpdatedFromParentProdOrderLineOnOutput@50();
    VAR
      ItemJournalLine@1000 : Record 83;
      ParentProdOrderLine@1002 : Record 5406;
      ChildProdOrderLine@1003 : Record 5406;
    BEGIN
      // [FEATURE] [Production] [Bin]
      // [SCENARIO 380337] Location and Bin codes on Output Journal are updated with Location and Bin on parent Prod. Order Line.
      Initialize;

      // [GIVEN] Released Production Order "PO" on Location "L" with parent and child lines and bins "B1" and "B2" related to them.
      CreateReleasedProdOrderWithTwoLines(ParentProdOrderLine,ChildProdOrderLine);

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Output journal line with "Order No." = "PO".
        CreateProductionItemJournal(ItemJournalLine,"Entry Type"::Output,ParentProdOrderLine."Prod. Order No.");

        // [WHEN] Select "Order Line No.". = parent Prod. Order Line no.
        VALIDATE("Order Line No.",ParentProdOrderLine."Line No.");

        // [THEN] "Location Code" is equal to "L".
        // [THEN] "Bin Code" is equal to "B1".
        TESTFIELD("Location Code",ParentProdOrderLine."Location Code");
        TESTFIELD("Bin Code",ParentProdOrderLine."Bin Code");
      END;
    END;

    [Test]
    PROCEDURE LocationAndBinAreUpdatedFromChildProdOrderLineOnConsumption@76();
    VAR
      ItemJournalLine@1000 : Record 83;
      ParentProdOrderLine@1002 : Record 5406;
      ChildProdOrderLine@1003 : Record 5406;
    BEGIN
      // [FEATURE] [Production] [Bin]
      // [SCENARIO 380337] Location and Bin codes on Consumption Journal are updated with Location and Bin on child Prod. Order Line.
      Initialize;

      // [GIVEN] Released Production Order "PO" on Location "L" with parent and child lines and bins "B1" and "B2" related to them.
      CreateReleasedProdOrderWithTwoLines(ParentProdOrderLine,ChildProdOrderLine);

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Consumption journal line with "Order No." = "PO".
        CreateProductionItemJournal(ItemJournalLine,"Entry Type"::Consumption,ParentProdOrderLine."Prod. Order No.");
        VALIDATE(Quantity,0); // nothing is picked yet

        // [WHEN] Select "Item No." = child Prod. Order Line item.
        VALIDATE("Item No.",ChildProdOrderLine."Item No.");

        // [THEN] "Location Code" is equal to "L".
        // [THEN] "Bin Code" is equal to "B2".
        TESTFIELD("Location Code",ChildProdOrderLine."Location Code");
        TESTFIELD("Bin Code",ChildProdOrderLine."Bin Code");
      END;
    END;

    [Test]
    PROCEDURE BinIsUpdatedFromProdOrderLineWhenItemIsUpdatedOnOutput@39();
    VAR
      ItemJournalLine@1000 : Record 83;
      SavedItemJournalLine@1001 : Record 83;
      ParentProdOrderLine@1002 : Record 5406;
      ChildProdOrderLine@1003 : Record 5406;
      WMSManagement@1004 : Codeunit 7302;
    BEGIN
      // [FEATURE] [Production] [Bin]
      // [SCENARIO 380337] Bin code on Output Journal Line is updated from Prod. Order Line when Item No. is updated and only one Prod. Order Line related to this Item is found.
      Initialize;

      // [GIVEN] Released Production Order "PO" on Location "L" with parent and child lines and bins "B1" and "B2" related to them.
      CreateReleasedProdOrderWithTwoLines(ParentProdOrderLine,ChildProdOrderLine);

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Output journal line with "Order No." and "Item No." from parent Prod. Order Line.
        CreateProductionItemJournal(ItemJournalLine,"Entry Type"::Output,ParentProdOrderLine."Prod. Order No.");
        VALIDATE("Item No.",ParentProdOrderLine."Item No.");
        MODIFY(TRUE);
        SavedItemJournalLine := ItemJournalLine;

        // [WHEN] Update "Item No." in Item Journal Line with "Item No." from child Prod. Order Line.
        VALIDATE("Item No.",ChildProdOrderLine."Item No.");
        WMSManagement.CheckItemJnlLineFieldChange(ItemJournalLine,SavedItemJournalLine,FIELDCAPTION("Item No."));

        // [THEN] "Bin Code" is changed.
        Assert.AreNotEqual("Bin Code",SavedItemJournalLine."Bin Code",InvalidBinCodeErr);

        // [THEN] "Bin Code" is equal to "B2".
        TESTFIELD("Bin Code",ChildProdOrderLine."Bin Code");
      END;
    END;

    [Test]
    PROCEDURE ClearBinCodeOnItemJournalLineWithDirectedPutawayAndPickLocation@88();
    VAR
      Location@1001 : Record 14;
      Bin@1004 : Record 7354;
      ItemJournalLine@1000 : Record 83;
    BEGIN
      // [FEATURE] [Bin] [Directed Put-away and Pick] [UT]
      // [SCENARIO 380337] Bin code on Item Journal Line can be cleared for Location with enabled "Directed Put-away and Pick".
      Initialize;

      // [GIVEN] Location with Bin.
      CreateLocationWithNumberOfBins(Location,1);
      LibraryWarehouse.FindBin(Bin,Location.Code,'',1);

      // [GIVEN] Item Journal Line with Location and Bin.
      CreateItemJournal(ItemJournalLine);
      ItemJournalLine.VALIDATE("Location Code",Location.Code);
      ItemJournalLine.VALIDATE("Bin Code",Bin.Code);

      // [GIVEN] "Directed Put-away and Pick" for Location is enabled.
      Location.VALIDATE("Directed Put-away and Pick",TRUE);
      Location.MODIFY(TRUE);

      // [WHEN] Clear "Bin Code" on Item Journal Line.
      UpdateBinCodeInItemJournalLine(ItemJournalLine,'');

      // [THEN] No error raised. "Bin Code" is cleared.
      ItemJournalLine.TESTFIELD("Bin Code",'');
    END;

    [Test]
    PROCEDURE EligibleBinCodeOnOutputJournalWithDirectedPutawayAndPickLocation@37();
    VAR
      ItemJournalLine@1004 : Record 83;
      ParentProdOrderLine@1002 : Record 5406;
      ChildProdOrderLine@1001 : Record 5406;
    BEGIN
      // [FEATURE] [Production] [Bin] [Directed Put-away and Pick]
      // [SCENARIO 380337] Bin code can be set manually on Output Journal Line if the related Prod. Order Line has the same Bin code.
      Initialize;

      // [GIVEN] Released Production Order "PO" on Location "L" with parent and child lines and bins "B1" and "B2" related to them.
      CreateReleasedProdOrderWithTwoLines(ParentProdOrderLine,ChildProdOrderLine);

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Output journal line with "Order No." and "Item No." from parent Prod. Order Line.
        CreateProductionItemJournal(ItemJournalLine,"Entry Type"::Output,ParentProdOrderLine."Prod. Order No.");
        VALIDATE("Order Line No.",ParentProdOrderLine."Line No.");
        VALIDATE("Bin Code",'');

        // [WHEN] Validate "Bin Code" with "B1".
        UpdateBinCodeInItemJournalLine(ItemJournalLine,ParentProdOrderLine."Bin Code");

        // [THEN] No error raised. "Bin Code" in Item Journal Line is updated to "B1"
        TESTFIELD("Bin Code",ParentProdOrderLine."Bin Code");
      END;
    END;

    [Test]
    PROCEDURE EligibleBinCodeOnConsumptionJournalWithDirectedPutawayAndPickLocation@68();
    VAR
      ItemJournalLine@1004 : Record 83;
      ParentProdOrderLine@1002 : Record 5406;
      ChildProdOrderLine@1001 : Record 5406;
      ProdOrderComponent@1005 : Record 5407;
    BEGIN
      // [FEATURE] [Production] [Bin] [Directed Put-away and Pick]
      // [SCENARIO 380337] Bin code can be set manually on Consumption Journal Line if the related Prod. Order Component has the same Bin code and Location.
      Initialize;

      // [GIVEN] Released Production Order "PO" on Location "L" with parent and child lines and bins "B1" and "B2" related to them.
      CreateReleasedProdOrderWithTwoLines(ParentProdOrderLine,ChildProdOrderLine);

      // [GIVEN] Prod. Order Component for parent Prod. Order line.
      FindProdOrderCompLine(ProdOrderComponent,ParentProdOrderLine);

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Consumption journal line for Prod. Order Component with empty "Bin Code".
        CreateProductionItemJournal(ItemJournalLine,"Entry Type"::Consumption,ProdOrderComponent."Prod. Order No.");
        VALIDATE(Quantity,0); // nothing is picked yet
        VALIDATE("Item No.",ProdOrderComponent."Item No.");
        VALIDATE("Bin Code",'');

        // [WHEN] Validate "Bin Code" with "B2".
        UpdateBinCodeInItemJournalLine(ItemJournalLine,ChildProdOrderLine."Bin Code");

        // [THEN] No error raised. "Bin Code" in Item Journal Line is updated to "B2"
        TESTFIELD("Bin Code",ChildProdOrderLine."Bin Code");
      END;
    END;

    [Test]
    PROCEDURE NonEligibleBinCodeOnOutputJournalWithDirectedPutawayAndPickLocation@52();
    VAR
      ItemJournalLine@1004 : Record 83;
      ParentProdOrderLine@1002 : Record 5406;
      ChildProdOrderLine@1001 : Record 5406;
    BEGIN
      // [FEATURE] [Production] [Bin] [Directed Put-away and Pick]
      // [SCENARIO 380337] Bin code cannot be set manually on Output Journal Line if the related Prod. Order Component has different Bin code.
      Initialize;

      // [GIVEN] Released Production Order "PO" on Location "L" with parent and child lines and bins "B1" and "B2" related to them.
      CreateReleasedProdOrderWithTwoLines(ParentProdOrderLine,ChildProdOrderLine);

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Output journal line with "Order No." and "Item No." from parent Prod. Order Line.
        CreateProductionItemJournal(ItemJournalLine,"Entry Type"::Output,ParentProdOrderLine."Prod. Order No.");
        VALIDATE("Order Line No.",ParentProdOrderLine."Line No.");
        VALIDATE("Bin Code",'');

        // [WHEN] Validate "Bin Code" with "B2".
        ASSERTERROR UpdateBinCodeInItemJournalLine(ItemJournalLine,ChildProdOrderLine."Bin Code");

        // [THEN] Error message is raised.
        Assert.ExpectedError(STRSUBSTNO(LocationWithDirectedPutAwayAndPickErr,"Location Code"));
      END;
    END;

    [Test]
    PROCEDURE EligibleBinCodeAndWrongDirectedPutawayAndPickLocationOnOutputJournal@67();
    VAR
      ItemJournalLine@1004 : Record 83;
      ParentProdOrderLine@1002 : Record 5406;
      ChildProdOrderLine@1001 : Record 5406;
      NewLocationCode@1005 : Code[10];
    BEGIN
      // [FEATURE] [Production] [Bin] [Directed Put-away and Pick]
      // [SCENARIO 380337] Bin code cannot be set on Output Journal Line if the related Prod. Order Component has the same Bin code but different Location.
      Initialize;

      // [GIVEN] Released Production Order "PO" on Location "L1" with parent and child lines and bins "B1" and "B2" related to them.
      CreateReleasedProdOrderWithTwoLines(ParentProdOrderLine,ChildProdOrderLine);

      // [GIVEN] Location "L2" with same bin codes as in Location "L1".
      CopyLocation(NewLocationCode,ParentProdOrderLine."Location Code",ParentProdOrderLine."Bin Code");

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Output journal line with "Order No." and "Item No." from parent Prod. Order Line.
        // [GIVEN] Location Code is changed to "L2". Bin code is cleared.
        CreateProductionItemJournal(ItemJournalLine,"Entry Type"::Output,ParentProdOrderLine."Prod. Order No.");
        VALIDATE("Order Line No.",ParentProdOrderLine."Line No.");
        VALIDATE("Location Code",NewLocationCode);
        VALIDATE("Bin Code",'');

        // [WHEN] Validate "Bin Code" with "B1".
        ASSERTERROR UpdateBinCodeInItemJournalLine(ItemJournalLine,ParentProdOrderLine."Bin Code");

        // [THEN] Error message is raised.
        Assert.ExpectedError(STRSUBSTNO(LocationWithDirectedPutAwayAndPickErr,"Location Code"));
      END;
    END;

    [Test]
    PROCEDURE UnitAmountEqualsUnitCostOnJournalLineForPositiveAdjmtWhenQtyIsValidated@51();
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1002 : Record 83;
    BEGIN
      // [SCENARIO 202372] Unit Amount should be equal to Unit Cost on positive adjustment item journal line when Quantity is updated, and Costing Method of the item is other than Standard.
      Initialize;

      // [GIVEN] Item "I" with Costing Method = "FIFO" and Unit Cost = "X".
      CreateItemWithCostingMethod(Item,Item."Costing Method"::FIFO);

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Positive adjustment item journal line with quantity "Q1" of item "I".
        CreateItemJournalLine(ItemJournalLine,Item."No.");

        // [GIVEN] Unit Cost on the journal line is updated to "Y".
        VALIDATE("Unit Cost",LibraryRandom.RandDecInRange(20,40,2));

        // [WHEN] Update Quantity on the journal line to "Q2".
        VALIDATE(Quantity,LibraryRandom.RandIntInRange(20,40));

        // [THEN] Unit Amount is equal to "Y".
        TESTFIELD("Unit Amount","Unit Cost");

        // [THEN] Amount is equal to "Q2" * "Y".
        TESTFIELD(Amount,"Unit Cost" * Quantity);
      END;
    END;

    [Test]
    PROCEDURE UnitAmountEqualsUnitCostOnJournalLineForNegativeAdjmtWhenQtyIsValidated@78();
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1002 : Record 83;
    BEGIN
      // [SCENARIO 202372] Unit Amount should be equal to Unit Cost on negative adjustment item journal line when Quantity is updated, and Costing Method of the item is other than Standard.
      Initialize;

      // [GIVEN] Item "I" with Costing Method = "FIFO" and Unit Cost = "X".
      CreateItemWithCostingMethod(Item,Item."Costing Method"::FIFO);

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Negative adjustment item journal line with quantity "Q1" of item "I".
        CreateItemJournalLine(ItemJournalLine,Item."No.");
        VALIDATE("Entry Type","Entry Type"::"Negative Adjmt.");

        // [GIVEN] Unit Cost on the journal line is updated to "Y".
        VALIDATE("Unit Cost",LibraryRandom.RandDecInRange(20,40,2));

        // [WHEN] Update Quantity on the journal line to "Q2".
        VALIDATE(Quantity,LibraryRandom.RandIntInRange(20,40));

        // [THEN] Unit Amount is equal to "Y".
        TESTFIELD("Unit Amount","Unit Cost");

        // [THEN] Amount is equal to "Q2" * "Y".
        TESTFIELD(Amount,"Unit Cost" * Quantity);
      END;
    END;

    [Test]
    PROCEDURE UnitAmountEqualsUnitCostOnJournalLineForPositiveAdjmtWhenUOMIsValidated@59();
    VAR
      Item@1000 : Record 27;
      ItemUnitOfMeasure@1001 : Record 5404;
      ItemJournalLine@1002 : Record 83;
    BEGIN
      // [SCENARIO 222394] Unit Amount should be equal to Unit Cost on positive adjustment item journal line when Unit of Measure Code is updated, and Costing Method of the item is other than Standard.
      Initialize;

      // [GIVEN] Item with Costing Method = "FIFO" and Unit Cost = "X".
      CreateItemWithCostingMethod(Item,Item."Costing Method"::FIFO);

      // [GIVEN] Alternate unit of measure "UOM" for the item. Quantity per base unit of measure = "Q".
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,Item."No.",LibraryRandom.RandIntInRange(2,5));

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Positive adjustment item journal line.
        CreateItemJournalLine(ItemJournalLine,Item."No.");

        // [WHEN] Update Unit of Measure on the journal line to "UOM".
        VALIDATE("Unit of Measure Code",ItemUnitOfMeasure.Code);

        // [THEN] Unit Cost is equal to "X" * "Q".
        TESTFIELD("Unit Cost",Item."Unit Cost" * ItemUnitOfMeasure."Qty. per Unit of Measure");

        // [THEN] Unit Amount is equal to Unit Cost.
        TESTFIELD("Unit Amount","Unit Cost");
      END;
    END;

    [Test]
    PROCEDURE UnitCostCannotBeUpdatedOnJournalLineForItemWithStandardCost@48();
    VAR
      Item@1001 : Record 27;
      ItemJournalLine@1000 : Record 83;
      ItemJournal@1003 : TestPage 40;
    BEGIN
      // [SCENARIO 202372] Unit Cost cannot be changed on item journal line for an item with Costing Method = Standard.
      Initialize;

      // [GIVEN] Item "I" with Costing Method = "Standard" and Unit Cost = "X".
      CreateItemWithCostingMethod(Item,Item."Costing Method"::Standard);

      // [GIVEN] Positive adjustment item journal line with quantity "Q1" of item "I".
      CreateItemJournalLine(ItemJournalLine,Item."No.");

      // [WHEN] Update Quantity on the journal line to "Q2".
      ItemJournal.OPENEDIT;
      ItemJournal.GOTORECORD(ItemJournalLine);
      ASSERTERROR ItemJournal."Unit Cost".SETVALUE(LibraryRandom.RandDecInRange(20,40,2));

      // [THEN] An error is thrown.
      Assert.ExpectedError(UnitCostCannotBeChangedErr);
    END;

    [Test]
    PROCEDURE UnitAmountEqualsUnitCostOnItemCardWhenItemIsValidatedOnJournalLine@49();
    VAR
      Item@1002 : Record 27;
      ItemJournalLine@1001 : Record 83;
    BEGIN
      // [SCENARIO 202372] Unit Cost should be reset to Unit Cost on the item card if Item No. is re-validated on item journal line.
      Initialize;

      // [GIVEN] Item "I" with Costing Method = "FIFO" and Unit Cost = "X".
      CreateItemWithCostingMethod(Item,Item."Costing Method"::FIFO);

      WITH ItemJournalLine DO BEGIN
        // [GIVEN] Positive adjustment item journal line with quantity "Q1" of item "I".
        CreateItemJournalLine(ItemJournalLine,Item."No.");

        // [GIVEN] Unit Cost on the journal line is updated to "Y".
        VALIDATE("Unit Cost",LibraryRandom.RandDecInRange(20,40,2));

        // [WHEN] Item No. is re-validated on the item journal.
        VALIDATE("Item No.",Item."No.");

        // [THEN] Unit Amount is reset to "X".
        TESTFIELD("Unit Amount",Item."Unit Cost");

        // [THEN] Amount is equal to "Q1" * "X".
        TESTFIELD(Amount,Item."Unit Cost" * Quantity);
      END;
    END;

    [Test]
    PROCEDURE UnitAmountEqualsUnitCostOnStdJnlLineForPositiveAdjmtWhenQtyIsValidated@93();
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1002 : Record 83;
      StandardItemJournalLine@1004 : Record 753;
      StandardItemJournalCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Standard Item Journal]
      // [SCENARIO 202372] Unit Amount should be equal to Unit Cost on positive adjustment standard item journal line when Quantity is updated, and Costing Method of the item is other than Standard.
      Initialize;

      // [GIVEN] Item "I" with Costing Method = "FIFO" and Unit Cost = "X".
      CreateItemWithCostingMethod(Item,Item."Costing Method"::FIFO);

      // [GIVEN] Positive adjustment item journal line with quantity "Q1" of item "I".
      CreateItemJournalLine(ItemJournalLine,Item."No.");

      // [GIVEN] The item journal line is saved as standard journal line.
      StandardItemJournalCode := SaveItemJournalLineAsNewStandardJournal(ItemJournalLine,TRUE,TRUE);
      FindStandardItemJournalLine(StandardItemJournalLine,StandardItemJournalCode,Item."No.");

      WITH StandardItemJournalLine DO BEGIN
        // [GIVEN] Unit Cost on the standard journal line is updated to "Y".
        VALIDATE("Unit Cost",LibraryRandom.RandDecInRange(20,40,2));

        // [WHEN] Update Quantity on the standard journal line to "Q2".
        VALIDATE(Quantity,LibraryRandom.RandIntInRange(20,40));

        // [THEN] Unit Amount is equal to "Y".
        TESTFIELD("Unit Amount","Unit Cost");

        // [THEN] Amount is equal to "Q2" * "Y".
        TESTFIELD(Amount,"Unit Cost" * Quantity);
      END;
    END;

    [Test]
    PROCEDURE UnitAmountEqualsUnitCostOnStdJnlLineForNegativeAdjmtWhenQtyIsValidated@92();
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1002 : Record 83;
      StandardItemJournalLine@1004 : Record 753;
      StandardItemJournalCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Standard Item Journal]
      // [SCENARIO 202372] Unit Amount should be equal to Unit Cost on negative adjustment standard item journal line when Quantity is updated, and Costing Method of the item is other than Standard.
      Initialize;

      // [GIVEN] Item "I" with Costing Method = "FIFO" and Unit Cost = "X".
      CreateItemWithCostingMethod(Item,Item."Costing Method"::FIFO);

      // [GIVEN] Negative adjustment item journal line with quantity "Q1" of item "I".
      CreateItemJournalLine(ItemJournalLine,Item."No.");
      ItemJournalLine.VALIDATE("Entry Type",ItemJournalLine."Entry Type"::"Negative Adjmt.");
      ItemJournalLine.MODIFY(TRUE);

      // [GIVEN] The item journal line is saved as standard journal line.
      StandardItemJournalCode := SaveItemJournalLineAsNewStandardJournal(ItemJournalLine,TRUE,TRUE);
      FindStandardItemJournalLine(StandardItemJournalLine,StandardItemJournalCode,Item."No.");

      WITH StandardItemJournalLine DO BEGIN
        // [GIVEN] Unit Cost on the standard journal line is updated to "Y".
        VALIDATE("Unit Cost",LibraryRandom.RandDecInRange(20,40,2));

        // [WHEN] Update Quantity on the standard journal line to "Q2".
        VALIDATE(Quantity,LibraryRandom.RandIntInRange(20,40));

        // [THEN] Amount is equal to "Q2" * "Y".
        TESTFIELD(Amount,"Unit Cost" * Quantity);

        // [THEN] Unit Amount is equal to "Y".
        TESTFIELD("Unit Amount","Unit Cost");
      END;
    END;

    [Test]
    PROCEDURE UnitAmountEqualsUnitCostOnStdJnlLineForPositiveAdjmtWhenUOMIsValidated@53();
    VAR
      Item@1000 : Record 27;
      ItemUnitOfMeasure@1001 : Record 5404;
      ItemJournalLine@1002 : Record 83;
      StandardItemJournalLine@1004 : Record 753;
      StandardItemJournalCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Standard Item Journal]
      // [SCENARIO 222394] Unit Amount should be equal to Unit Cost on positive adjustment standard item journal line when Unit of Measure Code is updated, and Costing Method of the item is other than Standard.
      Initialize;

      // [GIVEN] Item with Costing Method = "FIFO" and Unit Cost = "X".
      CreateItemWithCostingMethod(Item,Item."Costing Method"::FIFO);

      // [GIVEN] Alternate unit of measure "UOM" for the item. Quantity per base unit of measure = "Q".
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,Item."No.",LibraryRandom.RandIntInRange(2,5));

      // [GIVEN] Positive adjustment item journal line.
      CreateItemJournalLine(ItemJournalLine,Item."No.");

      // [GIVEN] The item journal line is saved as standard journal line.
      StandardItemJournalCode := SaveItemJournalLineAsNewStandardJournal(ItemJournalLine,TRUE,TRUE);
      FindStandardItemJournalLine(StandardItemJournalLine,StandardItemJournalCode,Item."No.");

      // [WHEN] Update Unit of Measure Code on the standard journal line to "UOM".
      StandardItemJournalLine.VALIDATE("Unit of Measure Code",ItemUnitOfMeasure.Code);

      // [THEN] Unit Cost is equal to "X" * "Q".
      StandardItemJournalLine.TESTFIELD("Unit Cost",Item."Unit Cost" * ItemUnitOfMeasure."Qty. per Unit of Measure");

      // [THEN] Unit Amount is equal to Unit Cost.
      StandardItemJournalLine.TESTFIELD("Unit Amount",StandardItemJournalLine."Unit Cost");
    END;

    [Test]
    PROCEDURE UnitCostCannotBeUpdatedOnStdJnlLineForItemWithStandardCost@91();
    VAR
      Item@1001 : Record 27;
      ItemJournalLine@1000 : Record 83;
      StandardItemJournalLine@1005 : Record 753;
      StandardItemJournal@1003 : TestPage 754;
      StandardItemJournalCode@1006 : Code[10];
    BEGIN
      // [FEATURE] [Standard Item Journal]
      // [SCENARIO 202372] Unit Cost cannot be changed on standard item journal line for an item with Costing Method = Standard.
      Initialize;

      // [GIVEN] Item "I" with Costing Method = "Standard" and Unit Cost = "X".
      CreateItemWithCostingMethod(Item,Item."Costing Method"::Standard);

      // [GIVEN] Positive adjustment item journal line with quantity "Q1" of item "I".
      CreateItemJournalLine(ItemJournalLine,Item."No.");

      // [GIVEN] The item journal line is saved as standard journal line.
      StandardItemJournalCode := SaveItemJournalLineAsNewStandardJournal(ItemJournalLine,TRUE,TRUE);
      FindStandardItemJournalLine(StandardItemJournalLine,StandardItemJournalCode,Item."No.");

      // [WHEN] Update Quantity on the standard journal line to "Q2".
      StandardItemJournal.OPENEDIT;
      StandardItemJournal.FILTER.SETFILTER(Code,StandardItemJournalCode);
      StandardItemJournal.StdItemJnlLines.GOTORECORD(StandardItemJournalLine);
      ASSERTERROR StandardItemJournal.StdItemJnlLines."Unit Cost".SETVALUE(LibraryRandom.RandDecInRange(20,40,2));

      // [THEN] An error is thrown.
      Assert.ExpectedError(UnitCostCannotBeChangedErr);
    END;

    [Test]
    PROCEDURE UnitAmountEqualsUnitCostOnItemCardWhenItemIsValidatedOnStdJnlLine@95();
    VAR
      Item@1002 : Record 27;
      ItemJournalLine@1001 : Record 83;
      StandardItemJournalLine@1004 : Record 753;
      StandardItemJournalCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Standard Item Journal]
      // [SCENARIO 202372] Unit Cost should be reset to Unit Cost on the item card if Item No. is re-validated on standard item journal line.
      Initialize;

      // [GIVEN] Item "I" with Costing Method = "FIFO" and Unit Cost = "X".
      CreateItemWithCostingMethod(Item,Item."Costing Method"::FIFO);

      // [GIVEN] Positive adjustment item journal line with quantity "Q1" of item "I".
      CreateItemJournalLine(ItemJournalLine,Item."No.");

      // [GIVEN] The item journal line is saved as standard journal line.
      StandardItemJournalCode := SaveItemJournalLineAsNewStandardJournal(ItemJournalLine,TRUE,TRUE);
      FindStandardItemJournalLine(StandardItemJournalLine,StandardItemJournalCode,Item."No.");

      WITH StandardItemJournalLine DO BEGIN
        // [GIVEN] Unit Cost on the standard journal line is updated to "Y".
        VALIDATE("Unit Cost",LibraryRandom.RandDecInRange(20,40,2));

        // [WHEN] Item No. is re-validated on the standard item journal.
        VALIDATE("Item No.",Item."No.");

        // [THEN] Unit Amount is reset to "X".
        TESTFIELD("Unit Amount",Item."Unit Cost");

        // [THEN] Amount is equal to "Q1" * "X".
        TESTFIELD(Amount,Item."Unit Cost" * Quantity);
      END;
    END;

    [Test]
    PROCEDURE StdJnlLinesZeroQuantity@47();
    VAR
      ItemJournalLine@1001 : Record 83;
      StandardItemJournalLine@1004 : Record 753;
      StandardItemJournalCode@1000 : Code[10];
    BEGIN
      // [SCENARIO 201724] "Quantity (Base)" and Amount in Standard Item Journal Line are zeroes if no check "Save Quantity" checkbox.
      // [FEATURE] [Standard Item Journal]
      Initialize;

      // [GIVEN] Item Journal Line "IJL" with populated Item "I" and some Quantity.
      CreateItemJournalLine(ItemJournalLine,LibraryInventory.CreateItemNo);

      // [WHEN] Save this "IJL" as Standard Item Journal through the report "Save as Standard Item Journal" and doesn't check the checkbox "Save Quantity"
      StandardItemJournalCode := SaveItemJournalLineAsNewStandardJournal(ItemJournalLine,FALSE,FALSE);

      // [THEN] Standard Item Journal Line "SIJL" is created for Item "I", fields Quantity, "Quantity (Base)" and Amount are zeroes.
      FindStandardItemJournalLine(StandardItemJournalLine,StandardItemJournalCode,ItemJournalLine."Item No.");
      StandardItemJournalLine.TESTFIELD(Quantity,0);
      StandardItemJournalLine.TESTFIELD("Quantity (Base)",0);
      StandardItemJournalLine.TESTFIELD(Amount,0);
    END;

    LOCAL PROCEDURE Initialize@4();
    VAR
      LibraryERMCountryData@1002 : Codeunit 131305;
    BEGIN
      // Lazy Setup.
      IF isInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      isInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE UpdateSalesReceivableSetup@2(StockoutWarning@1001 : Boolean) OldStockoutWarning : Boolean;
    VAR
      SalesReceivablesSetup@1000 : Record 311;
    BEGIN
      SalesReceivablesSetup.GET;
      OldStockoutWarning := SalesReceivablesSetup."Stockout Warning";
      SalesReceivablesSetup.VALIDATE("Stockout Warning",StockoutWarning);
      SalesReceivablesSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE SelectItemJournal@30(VAR ItemJournalBatch@1000 : Record 233);
    VAR
      ItemJournalTemplate@1001 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type::Item,ItemJournalTemplate.Name);
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
    END;

    LOCAL PROCEDURE CreateStdJournalSetup@23(VAR TempItemJournalLine@1002 : TEMPORARY Record 83;VAR ItemJournalBatch@1003 : Record 233;NoOfItems@1001 : Integer;SaveAsStandard@1004 : Boolean) StandardItemJournalCode : Code[10];
    VAR
      TempItem@1000 : TEMPORARY Record 27;
    BEGIN
      // Create Items, Item Journal and Save Item Journal as Standard Journal.
      CreateItemsAndCopyToTemp(TempItem,NoOfItems);
      StandardItemJournalCode := CreateItemJournalAndCopyToTemp(TempItemJournalLine,TempItem,ItemJournalBatch,SaveAsStandard);
    END;

    LOCAL PROCEDURE CreateItemsAndCopyToTemp@13(VAR TempItem@1000 : TEMPORARY Record 27;NoOfItems@1002 : Integer);
    VAR
      Item@1001 : Record 27;
      Counter@1003 : Integer;
    BEGIN
      FOR Counter := 1 TO NoOfItems DO BEGIN
        CLEAR(Item);
        CreateItem(Item);
        TempItem := Item;
        TempItem.INSERT;
      END;
    END;

    LOCAL PROCEDURE CreateItem@6(VAR Item@1004 : Record 27);
    BEGIN
      LibraryInventory.CreateItem(Item);
      UpdateItemCost(Item);
    END;

    LOCAL PROCEDURE CreateProductionItem@43(VAR ParentItem@1005 : Record 27;VAR ChildItem@1004 : Record 27);
    VAR
      ProductionBOMHeader@1003 : Record 99000771;
    BEGIN
      LibraryManufacturing.CreateCertifiedProductionBOM(ProductionBOMHeader,ChildItem."No.",LibraryRandom.RandInt(10));
      LibraryInventory.CreateItem(ParentItem);
      WITH ParentItem DO BEGIN
        VALIDATE("Replenishment System","Replenishment System"::"Prod. Order");
        VALIDATE("Production BOM No.",ProductionBOMHeader."No.");
        VALIDATE("Manufacturing Policy","Manufacturing Policy"::"Make-to-Order");
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateItemWithCostingMethod@79(VAR Item@1000 : Record 27;CostingMethod@1001 : Option);
    BEGIN
      LibraryInventory.CreateItemWithUnitPriceAndUnitCost(Item,0,LibraryRandom.RandDec(10,2));
      Item.VALIDATE("Costing Method",CostingMethod);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemJournal@18(VAR ItemJournalLine@1000 : Record 83);
    VAR
      Item@1005 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      CreateItemJournalLine(ItemJournalLine,Item."No.");
    END;

    LOCAL PROCEDURE CreateItemJournalLine@83(VAR ItemJournalLine@1001 : Record 83;ItemNo@1000 : Code[20]);
    VAR
      ItemJournalBatch@1002 : Record 233;
    BEGIN
      SelectItemJournal(ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",
        ItemJournalBatch.Name,ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,LibraryRandom.RandInt(10));
    END;

    LOCAL PROCEDURE CreateItemJournalLineWithEntryType@97(VAR ItemJournalLine@1001 : Record 83;EntryType@1004 : 'Purchase,Sale,Positive Adjmt.,Negative Adjmt.,Transfer,Consumption,Output, ,Assembly Consumption,Assembly Output';LocationCode@1002 : Code[10];BinCode@1003 : Code[20]);
    BEGIN
      CreateItemJournal(ItemJournalLine);
      WITH ItemJournalLine DO BEGIN
        VALIDATE("Entry Type",EntryType);
        VALIDATE("Location Code",LocationCode);
        "Bin Code" := BinCode;
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateProductionItemJournal@86(VAR ItemJournalLine@1000 : Record 83;EntryType@1002 : Option;OrderNo@1003 : Code[20]);
    BEGIN
      CreateItemJournal(ItemJournalLine);
      WITH ItemJournalLine DO BEGIN
        VALIDATE("Order Type","Order Type"::Production);
        VALIDATE("Entry Type",EntryType);
        VALIDATE("Order No.",OrderNo);
      END;
    END;

    LOCAL PROCEDURE CreateItemJournalAndCopyToTemp@8(VAR TempItemJournalLine@1000 : TEMPORARY Record 83;VAR TempItem@1001 : TEMPORARY Record 27;VAR ItemJournalBatch@1004 : Record 233;SaveAsStandard@1002 : Boolean) Code : Code[10];
    VAR
      ItemJournalTemplate@1005 : Record 82;
      ItemJournalLine@1003 : Record 83;
      Count@1006 : Integer;
    BEGIN
      TempItem.FINDSET;
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      LibraryInventory.CreateItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Name);
      FOR Count := 1 TO TempItem.COUNT DO BEGIN
        LibraryInventory.CreateItemJournalLine(
          ItemJournalLine,ItemJournalBatch."Journal Template Name",
          ItemJournalBatch.Name,Count MOD 4,
          TempItem."No.",LibraryRandom.RandInt(5));  // Random Item Quantity.
        TempItem.NEXT
      END;
      CopyItemJournalLinesToTemp(TempItemJournalLine,ItemJournalLine);
      IF SaveAsStandard THEN
        Code := SaveAsStandardJournal(ItemJournalBatch,ItemJournalLine,TRUE,TRUE,'');
    END;

    LOCAL PROCEDURE CreateReleasedProdOrderWithTwoLines@46(VAR ParentProdOrderLine@1006 : Record 5406;VAR ChildProdOrderLine@1007 : Record 5406);
    VAR
      Location@1005 : Record 14;
      ComponentItem@1000 : Record 27;
      ManufChildItem@1001 : Record 27;
      ManufParentItem@1002 : Record 27;
      ProductionOrder@1003 : Record 5405;
    BEGIN
      LibraryWarehouse.CreateFullWMSLocation(Location,3);
      LibraryInventory.CreateItem(ComponentItem);
      CreateProductionItem(ManufChildItem,ComponentItem);
      CreateProductionItem(ManufParentItem,ManufChildItem);

      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,ManufParentItem."No.",
        LibraryRandom.RandDec(10,2));
      ProductionOrder.VALIDATE("Location Code",Location.Code);
      ProductionOrder.MODIFY(TRUE);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      FindProdOrderLine(ParentProdOrderLine,ProductionOrder."No.",ManufParentItem."No.");
      FindProdOrderLine(ChildProdOrderLine,ProductionOrder."No.",ManufChildItem."No.");
    END;

    LOCAL PROCEDURE CopyItemJournalLinesToTemp@17(VAR TempItemJournalLine@1000 : TEMPORARY Record 83;ItemJournalLine@1001 : Record 83);
    BEGIN
      ItemJournalLine.FINDSET;
      REPEAT
        TempItemJournalLine := ItemJournalLine;
        TempItemJournalLine.INSERT;
      UNTIL ItemJournalLine.NEXT = 0;
    END;

    LOCAL PROCEDURE CopyLocation@71(VAR NewLocCode@1000 : Code[10];ExistingLocCode@1001 : Code[10];ExistingBinCode@1008 : Code[20]);
    VAR
      NewLocation@1002 : Record 14;
      NewBin@1005 : Record 7354;
      ExistingLocation@1003 : Record 14;
      ExistingBin@1007 : Record 7354;
    BEGIN
      ExistingLocation.GET(ExistingLocCode);
      ExistingBin.GET(ExistingLocCode,ExistingBinCode);

      WITH NewLocation DO BEGIN
        INIT;
        NewLocation := ExistingLocation;
        VALIDATE(Code,LibraryUtility.GenerateRandomCode(FIELDNO(Code),DATABASE::Location));
        INSERT(TRUE);
        NewLocCode := Code;
      END;

      WITH NewBin DO BEGIN
        INIT;
        NewBin := ExistingBin;
        VALIDATE("Location Code",NewLocation.Code);
        INSERT(TRUE);
      END;
    END;

    LOCAL PROCEDURE FindProdOrderLine@80(VAR ProdOrderLine@1000 : Record 5406;ProdOrderNo@1001 : Code[20];ItemNo@1002 : Code[20]);
    BEGIN
      WITH ProdOrderLine DO BEGIN
        SETRANGE("Prod. Order No.",ProdOrderNo);
        SETRANGE("Item No.",ItemNo);
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE FindProdOrderCompLine@69(VAR ProdOrderComponent@1000 : Record 5407;ProdOrderLine@1001 : Record 5406);
    BEGIN
      WITH ProdOrderComponent DO BEGIN
        SETRANGE("Prod. Order No.",ProdOrderLine."Prod. Order No.");
        SETRANGE("Prod. Order Line No.",ProdOrderLine."Line No.");
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE FindStandardItemJournalLine@98(VAR StandardItemJournalLine@1000 : Record 753;StandardItemJournalCode@1003 : Code[10];ItemNo@1004 : Code[20]);
    BEGIN
      StandardItemJournalLine.SETRANGE("Standard Journal Code",StandardItemJournalCode);
      StandardItemJournalLine.SETRANGE("Item No.",ItemNo);
      StandardItemJournalLine.FINDFIRST;
    END;

    LOCAL PROCEDURE SaveAsStandardJournal@21(VAR ItemJournalBatch@1002 : Record 233;VAR ItemJournalLine@1001 : Record 83;SaveUnitAmount@1006 : Boolean;SaveQuantity@1007 : Boolean;StandardItemJournalCode@1005 : Code[10]) Code : Code[10];
    VAR
      StandardItemJournal@1003 : Record 752;
      SaveAsStandardItemJournal@1000 : Report 751;
    BEGIN
      // Random Code & Description values for Standard Item Journal.
      IF StandardItemJournalCode = '' THEN
        StandardItemJournalCode :=
          COPYSTR(LibraryUtility.GenerateRandomCode(StandardItemJournal.FIELDNO(Code),DATABASE::"Standard Item Journal"),1,10);
      Code := StandardItemJournalCode;
      SaveAsStandardItemJournal.InitializeRequest(
        StandardItemJournalCode,
        COPYSTR(LibraryUtility.GenerateRandomCode(StandardItemJournal.FIELDNO(Description),DATABASE::"Standard Item Journal"),1,50),
        SaveUnitAmount,SaveQuantity);
      SaveAsStandardItemJournal.Initialise(ItemJournalLine,ItemJournalBatch);
      SaveAsStandardItemJournal.USEREQUESTPAGE(FALSE);
      SaveAsStandardItemJournal.RUN;
      ItemJournalLine.DELETEALL(TRUE);
    END;

    LOCAL PROCEDURE SaveItemJournalLineAsNewStandardJournal@89(VAR ItemJournalLine@1001 : Record 83;SaveUnitAmount@1006 : Boolean;SaveQuantity@1007 : Boolean) StandardItemJournalCode : Code[10];
    VAR
      StandardItemJournal@1002 : Record 752;
      ItemJournalBatch@1003 : Record 233;
      SaveAsStandardItemJournal@1000 : Report 751;
    BEGIN
      // Random Code & Description values for Standard Item Journal.
      StandardItemJournalCode :=
        COPYSTR(LibraryUtility.GenerateRandomCode(StandardItemJournal.FIELDNO(Code),DATABASE::"Standard Item Journal"),1,10);
      SaveAsStandardItemJournal.InitializeRequest(
        StandardItemJournalCode,
        COPYSTR(LibraryUtility.GenerateRandomCode(StandardItemJournal.FIELDNO(Description),DATABASE::"Standard Item Journal"),1,50),
        SaveUnitAmount,SaveQuantity);
      ItemJournalBatch.GET(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.SETRANGE("Item No.",ItemJournalLine."Item No.");
      SaveAsStandardItemJournal.Initialise(ItemJournalLine,ItemJournalBatch);
      SaveAsStandardItemJournal.USEREQUESTPAGE(FALSE);
      SaveAsStandardItemJournal.RUN;
    END;

    LOCAL PROCEDURE CreateItemJnlFromStdJournal@15(ItemJournalBatch@1002 : Record 233;StandardItemJournalCode@1000 : Code[10]);
    VAR
      StandardItemJournal@1001 : Record 752;
    BEGIN
      SelectStandardItemJournal(StandardItemJournal,StandardItemJournalCode,ItemJournalBatch."Journal Template Name");
      StandardItemJournal.CreateItemJnlFromStdJnl(StandardItemJournal,ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE SelectStandardItemJournal@24(VAR StandardItemJournal@1000 : Record 752;StandardItemJournalCode@1001 : Code[10];JournalTemplateName@1002 : Code[10]);
    BEGIN
      StandardItemJournal.SETRANGE(Code,StandardItemJournalCode);
      StandardItemJournal.SETRANGE("Journal Template Name",JournalTemplateName);
      StandardItemJournal.FINDFIRST;
    END;

    LOCAL PROCEDURE UpdateItemJournalLineQuantity@19(VAR TempItemJournalLine@1003 : TEMPORARY Record 83;ItemJournalBatch@1000 : Record 233;StandardItemJournalCode@1002 : Code[10]);
    VAR
      ItemJournalLine@1001 : Record 83;
    BEGIN
      // Random Item Quantity greater than previous Quantity.
      SelectItemJournalLine(ItemJournalLine,ItemJournalBatch);
      REPEAT
        ItemJournalLine.VALIDATE(Quantity,ItemJournalLine.Quantity + LibraryRandom.RandInt(5));
        ItemJournalLine.MODIFY(TRUE);
      UNTIL ItemJournalLine.NEXT = 0;
      CopyItemJournalLinesToTemp(TempItemJournalLine,ItemJournalLine);
      SaveAsStandardJournal(ItemJournalBatch,ItemJournalLine,TRUE,TRUE,StandardItemJournalCode);
    END;

    LOCAL PROCEDURE SelectItemJournalLine@32(VAR ItemJournalLine@1000 : Record 83;ItemJournalBatch@1001 : Record 233);
    BEGIN
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.FINDSET;
    END;

    LOCAL PROCEDURE CreateItemWithoutCost@22(VAR TempItem@1000 : TEMPORARY Record 27;VAR Item@1001 : Record 27);
    BEGIN
      LibraryInventory.CreateItem(Item);
      TempItem := Item;
      TempItem.INSERT;
    END;

    LOCAL PROCEDURE UpdateItemCost@10(VAR Item@1000 : Record 27);
    BEGIN
      // Random values not important for test.
      Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(10,2));
      Item.VALIDATE("Last Direct Cost",LibraryRandom.RandDec(10,2));
      Item.VALIDATE("Unit Price",LibraryRandom.RandDec(10,2) + 10);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE RecalcUnitAmountItemJnlLine@16(VAR ItemJournalLine@1000 : Record 83;ItemJournalBatch@1001 : Record 233);
    BEGIN
      SelectItemJournalLine(ItemJournalLine,ItemJournalBatch);
      ItemJournalLine.RecalculateUnitAmount;
    END;

    LOCAL PROCEDURE UpdateItemJournalUnitCost@36(VAR ItemJournalLine@1001 : Record 83;ItemJournalBatch@1000 : Record 233);
    BEGIN
      // Random Unit Cost greater than previous Unit Cost.
      SelectItemJournalLine(ItemJournalLine,ItemJournalBatch);
      ItemJournalLine.VALIDATE("Unit Cost",ItemJournalLine."Unit Cost" + LibraryRandom.RandInt(10));
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemJournalDocumentNo@20(VAR ItemJournalLine@1001 : Record 83;ItemJournalBatch@1000 : Record 233);
    BEGIN
      SelectItemJournalLine(ItemJournalLine,ItemJournalBatch);
      REPEAT
        ItemJournalLine.VALIDATE(
          "Document No.",LibraryUtility.GenerateRandomCode(ItemJournalLine.FIELDNO("Document No."),DATABASE::"Item Journal Line"));
        ItemJournalLine.MODIFY(TRUE);
      UNTIL ItemJournalLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyItemJournalAmount@3(VAR TempItemJournalLine@1000 : TEMPORARY Record 83;ItemJournalBatch@1001 : Record 233);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      TempItemJournalLine.FINDSET;
      SelectItemJournalLine(ItemJournalLine,ItemJournalBatch);
      REPEAT
        Assert.AreEqual(TempItemJournalLine.Amount,ItemJournalLine.Amount,ItemJournalAmountErr);
        ItemJournalLine.NEXT
      UNTIL TempItemJournalLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyStandardJournalEntry@12(JournalTemplateName@1001 : Code[10];StandardItemJournalCode@1000 : Code[10]);
    VAR
      StandardItemJournal@1002 : Record 752;
    BEGIN
      // Verify Standard Item Journal line record exists.
      StandardItemJournal.SETRANGE(Code,StandardItemJournalCode);
      StandardItemJournal.SETRANGE("Journal Template Name",JournalTemplateName);
      StandardItemJournal.FINDFIRST;
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntry@31(VAR TempItemJournalLine@1000 : TEMPORARY Record 83);
    VAR
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      TempItemJournalLine.FINDSET;
      REPEAT
        ItemLedgerEntry.SETRANGE("Item No.",TempItemJournalLine."Item No.");
        ItemLedgerEntry.SETRANGE("Entry Type",TempItemJournalLine."Entry Type");
        ItemLedgerEntry.FINDFIRST;
        Assert.AreEqual(TempItemJournalLine.Quantity,ABS(ItemLedgerEntry.Quantity),QuantityErr);
      UNTIL TempItemJournalLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntryForQty@25(VAR ItemJournalLine@1000 : Record 83);
    VAR
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      ItemLedgerEntry.SETRANGE("Item No.",ItemJournalLine."Item No.");
      ItemLedgerEntry.SETRANGE("Entry Type",ItemJournalLine."Entry Type");
      ItemLedgerEntry.FINDFIRST;
      ItemLedgerEntry.TESTFIELD(Quantity,ItemJournalLine.Quantity);
      ItemLedgerEntry.TESTFIELD("Invoiced Quantity",ItemJournalLine."Invoiced Quantity");
      ItemLedgerEntry.TESTFIELD("Remaining Quantity",ItemJournalLine.Quantity);
    END;

    LOCAL PROCEDURE CheckNoItemLedgerEntries@27(DocumentNo@1000 : Code[20]);
    VAR
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      ItemLedgerEntry.SETRANGE("Document No.",DocumentNo);
      Assert.IsTrue(ItemLedgerEntry.ISEMPTY,TransferILEErr);
    END;

    LOCAL PROCEDURE CreateLocationWithBin@60(VAR Location@1000 : Record 14;VAR BinCode1@1001 : Code[20];VAR BinCode2@1002 : Code[20]);
    VAR
      Bin@1003 : Record 7354;
      Zone@1004 : Record 7300;
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      Location."Bin Mandatory" := TRUE;
      Location.VALIDATE("Directed Put-away and Pick",TRUE);
      Location.VALIDATE("Use Cross-Docking",TRUE);
      Location.MODIFY(TRUE);

      LibraryWarehouse.CreateZone(Zone,'',Location.Code,LibraryWarehouse.SelectBinType(FALSE,FALSE,FALSE,FALSE),'','',0,FALSE);
      LibraryWarehouse.CreateNumberOfBins(Location.Code,Zone.Code,LibraryWarehouse.SelectBinType(FALSE,FALSE,FALSE,FALSE),2,FALSE);
      LibraryWarehouse.FindBin(Bin,Location.Code,Zone.Code,1);
      BinCode1 := Bin.Code;
      Location.VALIDATE("Adjustment Bin Code",Bin.Code);
      Location.MODIFY(TRUE);

      LibraryWarehouse.FindBin(Bin,Location.Code,Zone.Code,2);
      BinCode2 := Bin.Code;
    END;

    LOCAL PROCEDURE CreateLocationWithNumberOfBins@90(VAR Location@1000 : Record 14;NoOfBins@1001 : Integer);
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      Location."Bin Mandatory" := TRUE;
      Location.MODIFY(TRUE);
      LibraryWarehouse.CreateNumberOfBins(Location.Code,'','',NoOfBins,FALSE);
    END;

    LOCAL PROCEDURE CreateLocationWithBinBlockMovement@42(VAR Location@1006 : Record 14;VAR Bin@1005 : Record 7354;BlockMovement@1004 : ' ,Inbound,Outbound,All');
    BEGIN
      CreateLocationWithNumberOfBins(Location,1);
      UpdateBlockMovementOnBin(Bin,Location.Code,1,BlockMovement);
    END;

    LOCAL PROCEDURE CreateLocationWithTwoBinsBlockMovement@63(VAR Location@1005 : Record 14;VAR Bin1@1004 : Record 7354;BlockMovement1@1001 : ' ,Inbound,Outbound,All';VAR Bin2@1003 : Record 7354;BlockMovement2@1000 : ' ,Inbound,Outbound,All');
    BEGIN
      CreateLocationWithNumberOfBins(Location,2);
      UpdateBlockMovementOnBin(Bin1,Location.Code,1,BlockMovement1);
      UpdateBlockMovementOnBin(Bin2,Location.Code,2,BlockMovement2);
    END;

    LOCAL PROCEDURE CreateItemReclassJournaLine@34(TemplateName@1006 : Code[10];BatchName@1007 : Code[10];ItemNo@1005 : Code[20];OldLocationCode@1000 : Code[10];NewLocationCode@1001 : Code[10];OldBinCode@1002 : Code[20];NewBinCode@1003 : Code[20];Qty@1004 : Integer) : Code[10];
    VAR
      ItemJournalLine@1008 : Record 83;
    BEGIN
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,TemplateName,BatchName,ItemJournalLine."Entry Type"::Transfer,ItemNo,Qty);
      WITH ItemJournalLine DO BEGIN
        VALIDATE("Location Code",OldLocationCode);
        VALIDATE("New Location Code",NewLocationCode);
        "Bin Code" := OldBinCode;
        "New Bin Code" := NewBinCode;
        VALIDATE(Quantity,Qty);
        "Document No." := LibraryUtility.GenerateGUID;
        MODIFY(TRUE);
      END;

      EXIT(ItemJournalLine."Document No.");
    END;

    LOCAL PROCEDURE CreateItemReclassJournalLineWithNewBin@56(VAR ItemJnlBatch@1002 : Record 233;VAR ItemJnlTemplate@1001 : Record 82;LocationCode@1003 : Code[10];OldBinCode@1004 : Code[20];NewBinCode@1005 : Code[20];Qty@1006 : Decimal);
    VAR
      Item@1000 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      LibraryInventory.CreateItemJournalTemplate(ItemJnlTemplate);
      LibraryInventory.CreateItemJournalBatch(ItemJnlBatch,ItemJnlTemplate.Name);
      CreatePositiveAdjmtLocationAndBin(
        ItemJnlTemplate.Name,ItemJnlBatch.Name,LocationCode,OldBinCode,Item."No.",Qty);
      CreateItemReclassJournaLine(
        ItemJnlTemplate.Name,ItemJnlBatch.Name,Item."No.",LocationCode,LocationCode,OldBinCode,NewBinCode,Qty);
    END;

    LOCAL PROCEDURE CreatePositiveAdjmtLocationAndBin@35(ItemJnlTemplateName@1000 : Code[10];ItemJnlBatchName@1001 : Code[10];LocationCode@1002 : Code[10];BinCode@1003 : Code[20];ItemNo@1005 : Code[20];ItemQty@1006 : Integer);
    VAR
      ItemJournalLine@1004 : Record 83;
    BEGIN
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJnlTemplateName,ItemJnlBatchName,ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,ItemQty);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine."Bin Code" := BinCode;
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateBlockMovementOnBin@66(VAR Bin@1000 : Record 7354;LocationCode@1001 : Code[10];BinIndex@1002 : Integer;BlockMovement@1003 : ' ,Inbound,Outbound,All');
    BEGIN
      LibraryWarehouse.FindBin(Bin,LocationCode,'',BinIndex);
      Bin.VALIDATE("Block Movement",BlockMovement);
      Bin.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateBinCodeInItemJournalLine@41(VAR ItemJournalLine@1000 : Record 83;NewBinCode@1001 : Code[20]);
    VAR
      SavedItemJournalLine@1002 : Record 83;
      WMSManagement@1003 : Codeunit 7302;
    BEGIN
      SavedItemJournalLine := ItemJournalLine;
      ItemJournalLine.VALIDATE("Bin Code",NewBinCode);
      WMSManagement.CheckItemJnlLineFieldChange(ItemJournalLine,SavedItemJournalLine,ItemJournalLine.FIELDCAPTION("Bin Code"));
    END;

    [ConfirmHandler]
    PROCEDURE ItemJournalConfirmHandler@5(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      // Overwrite Item Journal Line confirm handler.
      Reply := TRUE;
    END;

    BEGIN
    {
      // [FEATURE] [Item Journal] [SCM]
      Test for Item Journals:
        1. Create Item Journal Lines and Save as Standard Journal. Get Standard Journal and Verify Item Journal Lines.
        2. Create Item Journal Lines and Save as Standard Journal. Get Standard Journal and modify quantity. Save as Standard Journal.
           Get updated Standard Journal and Verify Item Journal Lines.
        3. Create Item Journal Lines and Save as first Standard Journal. Create more Item Journal Lines and save second Standard Journal.
           Get second Standard Journal Lines and Delete second Standard Journal. Verify first Standard Journal entry still exists.
        4. Create Item Journal Line and Save as Standard Journal with a single Item that does not any Cost or Price. Get Standard Journal.
           Update Cost and Price on Item card. Recalculate Unit Amount. Verify Unit Cost and Unit Price on Item Journal Line.
        5. Create Item Journal Lines and Save as Standard Journal. Get Standard Journal and modify Unit Cost on Item Journal.
           Recalculate Unit Amount. Verify that Unit Cost on Item Journal gets reverted to its original value.
        6. Create Item Journal Lines and Save as Standard Journal without Unit Amount. Get Standard Journal and Verify Item Journal Lines.
        7. Create Item Journal Lines and Save as Standard Journal. Get Standard Journal and Post Item Journal Lines.
           Verify Item Ledger Entry.
        8. Complex scenario (HFR 356198 automation): Create and post Positive Adjustment, Transfer and Bin Reclassification Item Journal Lines.
           Verify Item Ledger Entries: number of created entries, Quntity and Location Code fields.

        Covers Test cases:
        --------------------------------------------------------------------------------------
        Test Function Name                TFS ID
        --------------------------------------------------------------------------------------
        GetStdJnlLines                    120997,120998,120999
        ChangeStdJnlLinesQty              121000,121001,121002,121003
        GetStdJnlLinesWithoutAmt          121021,121022
        DeletePartialStdJnl               121007,121008,121009,121010,121011,121012
        ChangeItemCostRecalcUnitAmt       121013,121014,121015,121018,121019,121020
        ChangeItemJnlLineRecalcUnitAmt    121016,121017
        GetStdJnlLinesAndPost             121004,121005,121006,121557,127735,127736,127737,127738,127739,127740,127741,127742

        Covers Test cases: for WI - 259819
        --------------------------------------------------------------------------------------
        Test Function Name                TFS ID
        --------------------------------------------------------------------------------------
        PostItemJournal                   129642
    }
    END.
  }
}

