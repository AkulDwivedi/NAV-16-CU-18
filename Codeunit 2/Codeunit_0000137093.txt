OBJECT Codeunit 137093 SCM Kitting - D4
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      TempAsmAvailTestBuf@1040 : TEMPORARY Record 137093;
      ItemJournalTemplate@1006 : Record 82;
      ItemJournalBatch@1001 : Record 233;
      LocationBlue@1008 : Record 14;
      LocationRed@1010 : Record 14;
      TransitLocation@1011 : Record 14;
      LibraryERM@1022 : Codeunit 131300;
      LibraryUtility@1004 : Codeunit 131000;
      LibraryInventory@1003 : Codeunit 132201;
      LibraryManufacturing@1014 : Codeunit 132202;
      LibraryPurchase@1020 : Codeunit 130512;
      LibrarySales@1021 : Codeunit 130509;
      LibraryWarehouse@1013 : Codeunit 132204;
      LibraryAssembly@1007 : Codeunit 132207;
      Assert@1002 : Codeunit 130000;
      LibraryRandom@1012 : Codeunit 130440;
      LibrarySetupStorage@1024 : Codeunit 131009;
      LeadTimeMgt@1016 : Codeunit 5404;
      isInitialized@1000 : Boolean;
      ChangeLocationQst@1009 : TextConst 'ENU=Do you want to update the Location Code on the lines?';
      ComponentIsNotAvailableErr@1015 : TextConst 'ENU=Component availability issue for assembly item %1. Component should be available!';
      ComponentIsAvailableErr@1030 : TextConst 'ENU=Component should not be available for assembly item %1!';
      WorkDate2@1005 : Date;
      WorkDate10D@1017 : Date;
      WrongValueInAsmLineErr@1018 : TextConst 'ENU=Wrong %1 in Asm. Order line.';
      AsmAvailBufNotExistsErr@1019 : TextConst 'ENU=Asm. Availability Test Buffer does not exist';
      PostedNoSeriesErr@1023 : TextConst 'ENU="Posted Assembly Order Nos. must have a value in Assembly Setup: Primary Key=. It cannot be zero or empty."';

    [Normal]
    LOCAL PROCEDURE Initialize@8();
    VAR
      LibraryERMCountryData@1000 : Codeunit 131305;
    BEGIN
      LibrarySetupStorage.Restore;
      IF isInitialized THEN
        EXIT;

      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.CreateVATData;
      GlobalSetup;

      isInitialized := TRUE;

      COMMIT;
      LibrarySetupStorage.Save(DATABASE::"Assembly Setup");
    END;

    LOCAL PROCEDURE GlobalSetup@1();
    BEGIN
      WorkDate2 := CalcSafeDate(WORKDATE); // to avoid Due Date Before Work Date message.
      WorkDate10D := CALCDATE('<10D>',WorkDate2);
      AssemblySetup;
      SetupItemJournal;

      LocationSetup(LocationBlue,FALSE);
      LocationSetup(LocationRed,FALSE);
      LocationSetup(TransitLocation,TRUE);
      TransferRoutesSetup;
    END;

    LOCAL PROCEDURE CalcSafeDate@218(Date@1000 : Date) : Date;
    VAR
      MfgSetup@1001 : Record 99000765;
    BEGIN
      MfgSetup.GET;
      EXIT(CALCDATE(MfgSetup."Default Safety Lead Time",Date));
    END;

    [Normal]
    LOCAL PROCEDURE AssemblySetup@127();
    VAR
      AssemblySetup@1002 : Record 905;
      PurchasesPayablesSetup@1006 : Record 312;
      SalesSetup@1005 : Record 311;
    BEGIN
      AssemblySetup.GET;
      AssemblySetup.VALIDATE("Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Posted Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Default Location for Orders",'');
      AssemblySetup.MODIFY(TRUE);

      SalesSetup.GET;
      SalesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Return Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.MODIFY(TRUE);

      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      PurchasesPayablesSetup.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE SetupItemJournal@138();
    BEGIN
      CLEAR(ItemJournalTemplate);
      ItemJournalTemplate.INIT;
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      ItemJournalTemplate.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      ItemJournalTemplate.MODIFY(TRUE);

      CLEAR(ItemJournalBatch);
      ItemJournalBatch.INIT;
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      ItemJournalBatch.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      ItemJournalBatch.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE TransferRoutesSetup@86();
    VAR
      TransferRoute@1000 : Record 5742;
    BEGIN
      LibraryWarehouse.CreateTransferRoute(TransferRoute,LocationRed.Code,LocationBlue.Code);
      LibraryWarehouse.CreateTransferRoute(TransferRoute,LocationBlue.Code,LocationRed.Code);
    END;

    LOCAL PROCEDURE LocationSetup@2(VAR Location@1000 : Record 14;UseAsInTransit@1001 : Boolean);
    VAR
      WarehouseEmployee@1004 : Record 7301;
    BEGIN
      CLEAR(Location);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      IF UseAsInTransit THEN BEGIN
        Location.VALIDATE("Use As In-Transit",TRUE);
        Location.MODIFY(TRUE);
        EXIT;
      END;

      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,Location.Code,FALSE);
    END;

    LOCAL PROCEDURE AddComponent@72(ParentItem@1002 : Record 27;VAR BOMComponent@1003 : Record 90);
    VAR
      Item@1000 : Record 27;
    BEGIN
      CLEAR(Item);
      LibraryInventory.CreateItem(Item);
      CreateAssemblyListComponent(
        BOMComponent,BOMComponent.Type::Item,Item."No.",ParentItem."No.",'',
        BOMComponent."Resource Usage Type"::Direct,Item."Base Unit of Measure");
    END;

    LOCAL PROCEDURE SetRandComponentQuantityPer@83(VAR BOMComponent@1000 : Record 90) : Decimal;
    BEGIN
      BOMComponent.VALIDATE("Quantity per",RandInt5);
      BOMComponent.MODIFY;
      EXIT(BOMComponent."Quantity per");
    END;

    [Normal]
    LOCAL PROCEDURE CreateAssemblyListComponent@12(VAR BOMComponent@1008 : Record 90;ComponentType@1000 : Option;ComponentNo@1001 : Code[20];ParentItemNo@1005 : Code[20];VariantCode@1007 : Code[10];ResourceUsage@1006 : Option;UOM@1003 : Code[10]);
    BEGIN
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentItemNo,ComponentType,ComponentNo,1,UOM);
      WITH BOMComponent DO BEGIN
        IF ComponentType = Type::Resource THEN
          VALIDATE("Resource Usage Type",ResourceUsage);
        VALIDATE("Variant Code",VariantCode);
        VALIDATE(Description,LibraryUtility.GenerateRandomCode(FIELDNO(Description),DATABASE::"BOM Component"));
        MODIFY(TRUE);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CreateAssemblyOrder@9(VAR AssemblyHeader@1001 : Record 900;ParentItemNo@1000 : Code[20];LocationCode@1002 : Code[10];VariantCode@1005 : Code[10];DueDate@1004 : Date;Quantity@1003 : Decimal) : Decimal;
    BEGIN
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,DueDate,ParentItemNo,LocationCode,Quantity,VariantCode);
      EXIT(Quantity);
    END;

    [Normal]
    LOCAL PROCEDURE CreateAssemblyOrderOnSafeDate@49(VAR AssemblyHeader@1001 : Record 900;ParentItemNo@1000 : Code[20];LocationCode@1002 : Code[10];VariantCode@1005 : Code[10];DueDate@1004 : Date;Quantity@1003 : Decimal) : Decimal;
    VAR
      SafetyLeadTime@1006 : DateFormula;
    BEGIN
      EVALUATE(SafetyLeadTime,LeadTimeMgt.SafetyLeadTime(ParentItemNo,LocationCode,'')); // VSTF 256580
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CALCDATE(SafetyLeadTime,DueDate),ParentItemNo,LocationCode,Quantity,VariantCode);
      EXIT(Quantity);
    END;

    LOCAL PROCEDURE CreateAssemblyOrderMissingInventory@189(VAR AssemblyHeader@1000 : Record 900;VAR BOMComponentNo@1005 : Code[20];DueDate@1007 : Date;LocationCode@1001 : Code[10];Negative@1006 : Boolean) MissedQty : Decimal;
    VAR
      Item@1003 : Record 27;
      BOMComponent@1002 : Record 90;
      QtyOnAssemble@1004 : Integer;
    BEGIN
      // Create the assembled Item
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);

      QtyOnAssemble := RandInt;
      MissedQty := QtyOnAssemble DIV 7;
      IF Negative THEN
        MissedQty := -MissedQty;

      // Add inventory for first component
      AddInventory(BOMComponent."No.",'',LocationCode,QtyOnAssemble - MissedQty);
      BOMComponentNo := BOMComponent."No.";

      // will also "jump" to availability handler as availability warning is triggered
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',DueDate,QtyOnAssemble);
    END;

    LOCAL PROCEDURE CreateProdOrderAndRefresh@79(VAR ProductionOrder@1000 : Record 5405;ItemNo@1003 : Code[20];Quantity@1004 : Decimal;LocationCode@1001 : Code[10];DueDate@1005 : Date) : Decimal;
    BEGIN
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,ItemNo,Quantity);

      IF LocationCode <> '' THEN
        ProductionOrder.VALIDATE("Location Code",LocationCode);

      // Needed for executing the validate trigger on due date
      ProductionOrder.SetUpdateEndDate;
      ProductionOrder.VALIDATE("Due Date",DueDate);
      ProductionOrder.MODIFY(TRUE);

      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      EXIT(Quantity);
    END;

    LOCAL PROCEDURE AddComponentToProdOrder@231(ProductionOrder@1000 : Record 5405;ItemNo@1001 : Code[20];VariantCode@1004 : Code[10];QuantityPer@1002 : Decimal;LocationCode@1003 : Code[10]) : Decimal;
    VAR
      ProdOrderComponent@1005 : Record 5407;
      LineNo@1006 : Integer;
    BEGIN
      CLEAR(ProdOrderComponent);
      WITH ProdOrderComponent DO BEGIN
        SETRANGE(Status,ProductionOrder.Status);
        SETRANGE("Prod. Order No.",ProductionOrder."No.");

        IF FINDLAST THEN
          LineNo := "Line No." + 10000
        ELSE
          LineNo := 10000;

        VALIDATE(Status,ProductionOrder.Status);
        VALIDATE("Prod. Order No.",ProductionOrder."No.");
        VALIDATE("Line No.",LineNo);
        VALIDATE("Prod. Order Line No.",10000);
        VALIDATE("Item No.",ItemNo);
        VALIDATE("Variant Code",VariantCode);
        VALIDATE("Location Code",LocationCode);
        VALIDATE("Quantity per",QuantityPer);
        INSERT(TRUE);
      END;
      EXIT(QuantityPer);
    END;

    LOCAL PROCEDURE AddItemUOM@171(Item@1000 : Record 27;UOMCode@1003 : Code[10]) : Decimal;
    VAR
      ItemUnitOfMeasure@1002 : Record 5404;
    BEGIN
      LibraryInventory.CreateItemUnitOfMeasure(ItemUnitOfMeasure,Item."No.",UOMCode,LibraryRandom.RandInt(5));
      EXIT(ItemUnitOfMeasure."Qty. per Unit of Measure");
    END;

    LOCAL PROCEDURE AddComponentUOM@181(VAR BOMComponent@1000 : Record 90;QtyPerUOM@1001 : Integer;UOMCode@1003 : Code[10]);
    VAR
      ItemUnitOfMeasure@1002 : Record 5404;
    BEGIN
      LibraryInventory.CreateItemUnitOfMeasure(ItemUnitOfMeasure,BOMComponent."No.",UOMCode,QtyPerUOM);

      BOMComponent.VALIDATE("Unit of Measure Code",UOMCode);
      BOMComponent.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemVariant@185(ItemNo@1000 : Code[20]) : Code[10];
    VAR
      ItemVariant@1001 : Record 5401;
    BEGIN
      LibraryInventory.CreateItemVariant(ItemVariant,ItemNo);
      EXIT(ItemVariant.Code);
    END;

    LOCAL PROCEDURE CreatePurchaseDocType@57(VAR PurchaseHeader@1000 : Record 38;OrderType@1007 : Option;ItemNo@1004 : Code[20];VariantCode@1006 : Code[10];PurchaseQty@1003 : Integer;LocationCode@1005 : Code[10];ReceiptDate@1002 : Date);
    VAR
      PurchaseLine@1001 : Record 39;
    BEGIN
      CLEAR(PurchaseHeader);
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,OrderType,'');
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,PurchaseQty);
      PurchaseLine.VALIDATE("Variant Code",VariantCode);
      PurchaseLine.VALIDATE("Location Code",LocationCode);
      PurchaseLine.VALIDATE("Expected Receipt Date",ReceiptDate);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreatePurchaseOrder@95(VAR PurchaseHeader@1000 : Record 38;ItemNo@1001 : Code[20];VariantCode@1004 : Code[10];PurchQty@1003 : Integer;LocationCode@1006 : Code[10];ReceiptDate@1002 : Date) : Integer;
    BEGIN
      CreatePurchaseDocType(PurchaseHeader,PurchaseHeader."Document Type"::Order,ItemNo,VariantCode,PurchQty,LocationCode,ReceiptDate);
      EXIT(PurchQty);
    END;

    LOCAL PROCEDURE CreatePurchaseReturnOrder@94(VAR PurchaseHeader@1005 : Record 38;ItemNo@1004 : Code[20];VariantCode@1003 : Code[10];PurchQty@1002 : Integer;LocationCode@1000 : Code[10];ReceiptDate@1001 : Date) : Integer;
    BEGIN
      CreatePurchaseDocType(
        PurchaseHeader,PurchaseHeader."Document Type"::"Return Order",ItemNo,VariantCode,PurchQty,LocationCode,ReceiptDate);
      EXIT(PurchQty);
    END;

    LOCAL PROCEDURE CreateTransferOrder@93(VAR TransferHeader@1000 : Record 5740;ItemNo@1004 : Code[20];VariantCode@1007 : Code[10];FromLocation@1002 : Code[10];ToLocation@1003 : Code[10];ReceiptDate@1006 : Date;Qty@1005 : Integer) : Integer;
    VAR
      TransferLine@1001 : Record 5741;
    BEGIN
      LibraryWarehouse.CreateTransferHeader(TransferHeader,FromLocation,ToLocation,TransitLocation.Code);
      LibraryWarehouse.CreateTransferLine(TransferHeader,TransferLine,ItemNo,Qty);
      TransferLine.VALIDATE("Receipt Date",ReceiptDate);
      TransferLine.VALIDATE("Variant Code",VariantCode);
      TransferLine.MODIFY(TRUE);
      EXIT(Qty);
    END;

    LOCAL PROCEDURE CreateSaleDocType@65(VAR SalesHeader@1000 : Record 36;DocumentType@1005 : Option;ItemNo@1006 : Code[20];VariantCode@1003 : Code[10];SalesQty@1002 : Integer;ShipmentDate@1001 : Date;LocationCode@1007 : Code[10]);
    VAR
      SalesLine@1004 : Record 37;
    BEGIN
      CLEAR(SalesHeader);
      LibrarySales.CreateSalesHeader(SalesHeader,DocumentType,'');
      SalesHeader.VALIDATE("Location Code",LocationCode);
      SalesHeader.MODIFY(TRUE);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,SalesQty);
      SalesLine.VALIDATE("Variant Code",VariantCode);
      SalesLine.VALIDATE("Location Code",LocationCode);
      SalesLine.VALIDATE("Shipment Date",ShipmentDate);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesOrder@77(VAR SalesHeader@1000 : Record 36;ItemNo@1001 : Code[20];VariantCode@1004 : Code[10];SalesQty@1003 : Integer;ShipmentDate@1002 : Date;LocationCode@1006 : Code[10]) : Integer;
    BEGIN
      CreateSaleDocType(SalesHeader,SalesHeader."Document Type"::Order,ItemNo,VariantCode,SalesQty,ShipmentDate,LocationCode);
      EXIT(SalesQty)
    END;

    LOCAL PROCEDURE CreateSalesReturnOrder@76(VAR SalesHeader@1000 : Record 36;ItemNo@1004 : Code[20];VariantCode@1001 : Code[10];SalesQty@1003 : Integer;LocationCode@1006 : Code[10];ShipmentDate@1002 : Date) : Integer;
    BEGIN
      CreateSaleDocType(SalesHeader,SalesHeader."Document Type"::"Return Order",ItemNo,VariantCode,SalesQty,ShipmentDate,LocationCode);
      EXIT(SalesQty)
    END;

    LOCAL PROCEDURE AddInventory@5(ItemNo@1003 : Code[20];VariantCode@1001 : Code[10];LocationCode@1000 : Code[10];Qty@1004 : Integer);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      ClearJournal(ItemJournalTemplate,ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Qty);
      ItemJournalLine.VALIDATE("Variant Code",VariantCode);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE FindPostedAssemblyHeaderNotReversed@182(VAR PostedAssemblyHeader@1001 : Record 910;SourceAssemblyHeaderNo@1007 : Code[20]);
    BEGIN
      CLEAR(PostedAssemblyHeader);
      PostedAssemblyHeader.SETRANGE("Order No.",SourceAssemblyHeaderNo);
      PostedAssemblyHeader.SETRANGE(Reversed,FALSE);
      PostedAssemblyHeader.FINDFIRST;
    END;

    LOCAL PROCEDURE ClearJournal@134(ItemJournalTemplate@1002 : Record 82;ItemJournalBatch@1001 : Record 233);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CLEAR(ItemJournalLine);
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalTemplate.Name);
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.DELETEALL;
    END;

    LOCAL PROCEDURE SetVariantOnComponent@23(VAR BOMComponent@1000 : Record 90;VariantCode@1001 : Code[10]);
    BEGIN
      BOMComponent.VALIDATE("Variant Code",VariantCode);
      BOMComponent.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ChangeUOMOnAsmOrder@174(VAR AssemblyHeader@1000 : Record 900;UOMCode@1001 : Code[10]);
    BEGIN
      AssemblyHeader.VALIDATE("Unit of Measure Code",UOMCode);
      AssemblyHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE PostAssemblyOrderQty@24(VAR AssemblyHeader@1001 : Record 900;Qty@1002 : Integer);
    BEGIN
      AssemblyHeader.VALIDATE("Quantity to Assemble",Qty);
      AssemblyHeader.MODIFY(TRUE);

      CODEUNIT.RUN(CODEUNIT::"Assembly-Post",AssemblyHeader);
    END;

    LOCAL PROCEDURE MinValue@108(Val1@1000 : Decimal;Val2@1001 : Decimal) : Decimal;
    BEGIN
      IF Val1 >= Val2 THEN
        EXIT(Val2);

      EXIT(Val1);
    END;

    LOCAL PROCEDURE RandInt@193() : Integer;
    BEGIN
      EXIT(LibraryRandom.RandInt(1000))
    END;

    LOCAL PROCEDURE RandInt5@36() : Integer;
    BEGIN
      EXIT(LibraryRandom.RandInt(5) + 1)
    END;

    LOCAL PROCEDURE AssertAvailabilityHeader@18(AssemblyHeader@1000 : Record 900;ExpAsmAvailTestBuf@1001 : Record 137093);
    BEGIN
      TempAsmAvailTestBuf.VerifyHeader(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    LOCAL PROCEDURE AssertAvailabilityHeaderStatic@10(AssemblyHeader@1000 : Record 900);
    BEGIN
      TempAsmAvailTestBuf.VerifyHeaderStatic(AssemblyHeader);
    END;

    LOCAL PROCEDURE AssertAvailabilityLine@22(AssemblyHeader@1017 : Record 900;ExpAsmAvailTestBuf@1001 : Record 137093);
    VAR
      AssemblyLine@1000 : Record 901;
    BEGIN
      FindAssemblyLine(AssemblyHeader,ExpAsmAvailTestBuf."Document Line No.",AssemblyLine);
      TempAsmAvailTestBuf.VerifyLine(AssemblyLine,ExpAsmAvailTestBuf);
    END;

    LOCAL PROCEDURE AssertAvailabilityLineStatic@14(AssemblyHeader@1017 : Record 900;LineNo@1001 : Integer);
    VAR
      AssemblyLine@1000 : Record 901;
    BEGIN
      FindAssemblyLine(AssemblyHeader,LineNo,AssemblyLine);
      TempAsmAvailTestBuf.VerifyLineStatic(AssemblyLine,LineNo);
    END;

    LOCAL PROCEDURE VerifyLineGrossReqExpInv@15(AssemblyHeader@1001 : Record 900;GrossReq@1002 : Decimal;ExpInventory@1003 : Decimal);
    VAR
      ExpAsmAvailTestBuf@1000 : Record 137093;
    BEGIN
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Gross Requirement",GrossReq);
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",ExpInventory);
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    LOCAL PROCEDURE VerifyHrdGrossReqSchedRcpts@31(AssemblyHeader@1001 : Record 900;GrossReq@1002 : Decimal;SchedRcpts@1003 : Decimal);
    VAR
      ExpAsmAvailTestBuf@1000 : Record 137093;
    BEGIN
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Gross Requirement",GrossReq);
      ExpAsmAvailTestBuf.VALIDATE("Scheduled Receipts",SchedRcpts);
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    LOCAL PROCEDURE FindAssemblyLine@84(AssemblyHeader@1002 : Record 900;LineNo@1001 : Integer;VAR AssemblyLine@1000 : Record 901);
    BEGIN
      CLEAR(AssemblyLine);
      WITH AssemblyLine DO BEGIN
        SETRANGE("Document Type",AssemblyHeader."Document Type");
        SETRANGE("Document No.",AssemblyHeader."No.");
        FINDSET;
        NEXT(LineNo - 1);
      END;
    END;

    [Test]
    PROCEDURE ComponentAvailable@4();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : Record 90;
      AssemblyHeader@1001 : Record 900;
      LocationCode@1002 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 411] Component is available when assembling an Item with enough Components in inventory
      Initialize;
      LocationCode := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] The Component "C" is in inventory
      AddInventory(BOMComponent."No.",'',LocationCode,1);

      // [WHEN] Create Assembly Order for assembling 1 pcs Item "X"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,1);

      // [THEN] Component is available
      Assert.IsTrue(ComponentsAvailable(AssemblyHeader),STRSUBSTNO(ComponentIsNotAvailableErr,Item."No."));
    END;

    [Test]
    [HandlerFunctions(CloseAvailabilityWindowHandler)]
    PROCEDURE ComponentNotAvailable@3();
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1002 : Record 90;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 412] Component is NOT available when assembling an Item with missing Components in inventory
      Initialize;

      LocationCode := '';
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      // [GIVEN] The Component "C" is NOT in inventory
      AddComponent(Item,BOMComponent);

      // [WHEN] Create Assembly Order for assembling 1 pcs Item "X"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,1);

      // [THEN] Component is NOT available
      Assert.IsFalse(ComponentsAvailable(AssemblyHeader),STRSUBSTNO(ComponentIsAvailableErr,Item."No."));
    END;

    [Test]
    PROCEDURE ComponentVariantAvailable@13();
    VAR
      Item@1000 : Record 27;
      BOMComponent1@1004 : Record 90;
      BOMComponent2@1005 : Record 90;
      AssemblyHeader@1001 : Record 900;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 413] Components are available when assembling an Item with a Component with a Variant in inventory
      Initialize;

      LocationCode := '';
      // [GIVEN] Create the assembled Item "X" with 2 components:
      LibraryInventory.CreateItem(Item);
      // [GIVEN] 1st component with a Variant is in inventory
      AddComponent(Item,BOMComponent1);
      SetVariantOnComponent(BOMComponent1,CreateItemVariant(BOMComponent1."No."));
      AddInventory(BOMComponent1."No.",BOMComponent1."Variant Code",LocationCode,1);
      // [GIVEN] 2nd component without a Variant is in inventory
      AddComponent(Item,BOMComponent2);
      AddInventory(BOMComponent2."No.",'',LocationCode,1);

      // [WHEN] Create Assembly Order for assembling 1 pcs Item "X"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,1);

      // [THEN] Components are available
      Assert.IsTrue(ComponentsAvailable(AssemblyHeader),STRSUBSTNO(ComponentIsNotAvailableErr,Item."No."));
    END;

    [Test]
    [HandlerFunctions(CloseAvailabilityWindowHandler)]
    PROCEDURE ComponentVariantNotAvailable@11();
    VAR
      Item@1000 : Record 27;
      BOMComponent1@1004 : Record 90;
      BOMComponent2@1005 : Record 90;
      AssemblyHeader@1001 : Record 900;
      LocationCode@1002 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 414] Components are NOT available when assembling an Item with a missing Component with a Variant in inventory
      Initialize;

      LocationCode := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with 2 components:
      LibraryInventory.CreateItem(Item);
      // [GIVEN] 1st component with a Variant is NOT in inventory
      AddComponent(Item,BOMComponent1);
      SetVariantOnComponent(BOMComponent1,CreateItemVariant(BOMComponent1."No."));
      // [GIVEN] 2nd component without a Variant is in inventory
      AddComponent(Item,BOMComponent2);
      AddInventory(BOMComponent2."No.",'',LocationCode,1);

      // [WHEN] Create Assembly Order for assembling 1 pcs Item "X"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,1);

      // [THEN] Components are NOT available
      Assert.IsFalse(ComponentsAvailable(AssemblyHeader),STRSUBSTNO(ComponentIsAvailableErr,Item."No."));
    END;

    [Test]
    [HandlerFunctions(ChangeLocationCodeConfirm)]
    PROCEDURE ChangeLocationComponentAvailable@35();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : Record 90;
      AssemblyHeader@1001 : Record 900;
      LocationCodeFrom@1003 : Code[10];
      LocationCodeTo@1002 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 416] Component is available when assembling an Item on Location with Component in inventory
      Initialize;

      LocationCodeFrom := '';
      LocationCodeTo := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] The Component is in inventory on Locations "L1" and "L2"
      AddInventory(BOMComponent."No.",'',LocationCodeFrom,1);
      AddInventory(BOMComponent."No.",'',LocationCodeTo,1);

      // [GIVEN] Create Assembly Order for assembling 1 pcs Item "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCodeFrom,'',WorkDate2,1);

      // [WHEN] Change Location to "L2" on Assembly Order header
      AssemblyHeader.VALIDATE("Location Code",LocationCodeTo);
      AssemblyHeader.MODIFY(TRUE);

      // [THEN] Component is available
      Assert.IsTrue(ComponentsAvailable(AssemblyHeader),STRSUBSTNO(ComponentIsNotAvailableErr,Item."No."));
    END;

    [Test]
    [HandlerFunctions(CloseAvailabilityWindowHandler,ChangeLocationCodeConfirm)]
    PROCEDURE ChangeLocationComponentNotAvailable@32();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : Record 90;
      AssemblyHeader@1001 : Record 900;
      LocationCodeFrom@1003 : Code[10];
      LocationCodeTo@1002 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 417] Component is NOT available when assembling an Item on Location where no Component in inventory
      Initialize;

      LocationCodeFrom := LocationBlue.Code;
      LocationCodeTo := '';
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] The Component is NOT in inventory on Location "L2"
      AddInventory(BOMComponent."No.",'',LocationCodeFrom,RandInt);

      // [GIVEN] Create Assembly Order for assembling 1 pcs Item "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCodeFrom,'',WorkDate2,1);

      // [WHEN] Change Location to "L2" on Assembly Order header
      AssemblyHeader.VALIDATE("Location Code",LocationCodeTo);
      AssemblyHeader.MODIFY(TRUE);

      // [THEN] Component is NOT available
      Assert.IsFalse(ComponentsAvailable(AssemblyHeader),STRSUBSTNO(ComponentIsAvailableErr,Item."No."));
    END;

    [ConfirmHandler]
    PROCEDURE ChangeLocationCodeConfirm@211(Question@1000 : Text[1024];VAR Val@1001 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,ChangeLocationQst) > 0,Question);

      Val := TRUE;
    END;

    [Test]
    PROCEDURE CheckNotPostingNoSeries@17();
    VAR
      AssemblyHeader@1000 : Record 900;
      AssemblySetup@1002 : Record 905;
    BEGIN
      // [FEATURE] [Assembly Order] [UT]
      // [SCENARIO] Validating Posting No. Series the value should be getting from Posted Assembly Order No. field in Assembly Setup

      // [GIVEN] Create Item and Assembly Header for this item
      Initialize;
      AssemblySetup.GET;
      AssemblySetup."Posted Assembly Order Nos." := LibraryERM.CreateNoSeriesCode;
      AssemblySetup.MODIFY(TRUE);
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WORKDATE,LibraryInventory.CreateItemNo,'',0,'');

      // [WHEN] Validate Posting No. Series field from Assembly Header
      AssemblyHeader.VALIDATE("Posting No. Series",AssemblySetup."Posted Assembly Order Nos.");

      // [THEN] TestNoSeries function have to passed succesfully because of right Serial No. is transmitted into the trigger
      AssemblyHeader.TESTFIELD("Posting No. Series",AssemblySetup."Posted Assembly Order Nos.");
    END;

    [Test]
    PROCEDURE CheckPostedNoExist@19();
    VAR
      AssemblyHeader@1002 : Record 900;
      AssemblySetup@1000 : Record 905;
    BEGIN
      // [FEATURE] [Assembly Order] [UT]
      // [SCENARIO] Verify an error when insert Assembly Header Posted Assembly Order Nos. should not be empty

      // [GIVEN] Set Assembly Setup field to empty and create Item
      Initialize;
      AssemblySetup.GET;
      AssemblySetup."Posted Assembly Order Nos." := '';
      AssemblySetup.MODIFY(TRUE);

      // [WHEN] Insert Assembly Header
      ASSERTERROR LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WORKDATE,LibraryInventory.CreateItemNo,'',0,'');

      // [THEN] Error in testing field Posting No. Series is expected
      Assert.ExpectedError(PostedNoSeriesErr);
    END;

    [Test]
    PROCEDURE PartialPostingComponentAvailable@27();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : Record 90;
      AssemblyHeader@1001 : Record 900;
      LocationCode@1002 : Code[10];
      QtyOnInventory@1003 : Integer;
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 418] Component is available after posting part of Assembly Order with Component in inventory
      Initialize;

      LocationCode := '';
      // [GIVEN] Create the assembled Item "X" with one component in inventory. Quantity = "Q"
      QtyOnInventory := CreateItemWithComponentInventory(Item,BOMComponent,LocationCode);
      // [GIVEN] Create Assembly Order for assembling 2 pcs Items "X"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,QtyOnInventory - 1);

      // [WHEN] Post Assembly Order with "Quantity To Assemble" = 1
      PostAssemblyOrderQty(AssemblyHeader,1);

      // [THEN] Component is available
      Assert.IsTrue(ComponentsAvailable(AssemblyHeader),STRSUBSTNO(ComponentIsNotAvailableErr,Item."No."));
    END;

    [Test]
    [HandlerFunctions(CloseAvailabilityWindowHandler)]
    PROCEDURE PartialPostingComponentNotAvailable@26();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : Record 90;
      AssemblyHeader@1001 : Record 900;
      LocationCode@1002 : Code[10];
      QtyOnInventory@1003 : Integer;
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 419] Component is NOT available after posting part of Assembly Order with not enough Component in inventory
      Initialize;

      LocationCode := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with one component in inventory. Quantity = "Q"
      QtyOnInventory := CreateItemWithComponentInventory(Item,BOMComponent,LocationCode);
      // [GIVEN] Create Assembly Order for assembling "Q" + 1 pcs Items "X"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,QtyOnInventory + 1);

      // [WHEN] Post Assembly Order with "Quantity To Assemble" = 1
      PostAssemblyOrderQty(AssemblyHeader,1);

      // [THEN] Component is NOT available
      Assert.IsFalse(ComponentsAvailable(AssemblyHeader),STRSUBSTNO(ComponentIsAvailableErr,Item."No."));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AbleToAssembleMissingInventory@38();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : Record 90;
      AssemblyHeader@1001 : Record 900;
      QtyOnInventory@1005 : Integer;
      QtyOnAssemble@1002 : Integer;
      QtyAssembled@1006 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 421] "Able To Assemble" is equal to Component's quantity in inventory when "Quantity To Assemble" is bigger
      Initialize;

      LocationCode := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with one component in inventory. Quantity = "Q"
      QtyOnInventory := CreateItemWithComponentInventory(Item,BOMComponent,LocationCode);

      // [WHEN] Create Assembly Order for assembling "Q" + 1 pcs Items "X"
      QtyOnAssemble := QtyOnInventory + 1;
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,QtyOnAssemble);

      // [THEN] Assembly Availability page is shown:
      // [THEN] "Able To Assemble" = "Q" on page header
      // [THEN] "Able To Assemble" = "Q" and "Expected Inventory" = "Q" in page line
      VerifyAsmAvailMissingInventory(AssemblyHeader,QtyOnInventory,0);

      // [GIVEN] Post Assembly Order with "Quantity To Assemble" = 1 pcs
      QtyAssembled := 1;
      PostAssemblyOrderQty(AssemblyHeader,QtyAssembled);

      // [WHEN] Show Assembly Availability
      AssemblyHeader.ShowAvailability;

      // [THEN] Assembly Availability page shows:
      // [THEN] "Able To Assemble" = "Q" - 1, "Inventory" = 1 on page header
      // [THEN] "Able To Assemble" = "Q" - 1 and "Expected Inventory" = "Q" - 1 in page line
      VerifyAsmAvailMissingInventory(AssemblyHeader,QtyOnInventory - QtyAssembled,QtyAssembled);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AbleToAssembleEnoughInventory@143();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : Record 90;
      AssemblyHeader@1001 : Record 900;
      QtyOnInventory@1005 : Integer;
      QtyOnAssemble@1002 : Integer;
      QtyAssembled@1006 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 421] "Able To Assemble" is equal to "Quantity To Assemble" when enough Component's quantity in inventory
      Initialize;

      LocationCode := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with one component in inventory. Quantity = "Q"
      QtyOnInventory := CreateItemWithComponentInventory(Item,BOMComponent,LocationCode);
      // [GIVEN] Create Assembly Order for assembling "Q" - 1 pcs of Item "X"
      QtyOnAssemble := QtyOnInventory - 1;
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,QtyOnAssemble);

      // [WHEN] Show Assembly Availability
      AssemblyHeader.ShowAvailability;

      // [THEN] Assembly Availability page shows:
      // [THEN] "Able To Assemble" = "Q" - 1 on page header
      // [THEN] "Able To Assemble" = "Q" - 1 and "Expected Inventory" = "Q" in page line
      VerifyAsmAvailEnoughInventory(AssemblyHeader,QtyOnInventory,QtyOnAssemble,0);

      // [GIVEN] Post Assembly Order with "Quantity To Assemble" = 1 pcs
      QtyAssembled := 1;
      PostAssemblyOrderQty(AssemblyHeader,QtyAssembled);

      // [WHEN] Show Assembly Availability
      AssemblyHeader.ShowAvailability;

      // [THEN] Assembly Availability page shows:
      // [THEN] "Able To Assemble" = "Q" - 2, "Inventory" = 1 on page header
      // [THEN] "Able To Assemble" = "Q" - 2, "Expected Inventory" = "Q" - 1 in page line
      VerifyAsmAvailEnoughInventory(AssemblyHeader,QtyOnInventory,QtyOnAssemble,QtyAssembled);
    END;

    LOCAL PROCEDURE VerifyAsmAvailMissingInventory@183(AssemblyHeader@1003 : Record 900;QtyOnInventory@1001 : Integer;QtyAssembled@1000 : Integer);
    VAR
      ExpAsmAvailTestBuf@1002 : Record 137093;
    BEGIN
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",QtyOnInventory);
      ExpAsmAvailTestBuf.VALIDATE(Inventory,QtyAssembled);
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);

      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",QtyOnInventory);
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",QtyOnInventory);
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    LOCAL PROCEDURE VerifyAsmAvailEnoughInventory@194(AssemblyHeader@1004 : Record 900;QtyOnInventory@1003 : Integer;QtyOnAssemble@1001 : Integer;QtyAssembled@1000 : Integer);
    VAR
      ExpAsmAvailTestBuf@1002 : Record 137093;
    BEGIN
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",QtyOnAssemble - QtyAssembled);
      ExpAsmAvailTestBuf.VALIDATE(Inventory,QtyAssembled);
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);

      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",QtyOnInventory - QtyAssembled);
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",QtyOnAssemble - QtyAssembled);
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE InventoryOnHeaderOneLocation@41();
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      ExpAsmAvailTestBuf@1005 : Record 137093;
      BOMComponent@1006 : Record 90;
      QtyInInventory@1002 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 422] Assembly Availability page: Header's "Inventory" is equal to assembled Item's inventory
      Initialize;

      LocationCode := '';
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      // [GIVEN] Component is NOT in inventory
      AddComponent(Item,BOMComponent);
      // [GIVEN] Item "X" is in inventory. Quantity = "Q"
      QtyInInventory := RandInt;
      AddInventory(Item."No.",'',LocationCode,QtyInInventory);

      // [WHEN] Create Assembly Order for assembling Item "X"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,1);

      // [THEN] Assembly Availability page is shown: "Inventory" = "Q" on page header
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE(Inventory,QtyInInventory);
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE InventoryOnHeaderTwoLocations@45();
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      ExpAsmAvailTestBuf@1006 : Record 137093;
      BOMComponent@1007 : Record 90;
      QtyOnInventory@1004 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 423] Assembly Availability page: Header's "Inventory" is equal to assembled Item's inventory on Assembly Orders' Location
      Initialize;

      LocationCode1 := LocationBlue.Code;
      LocationCode2 := '';
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      // [GIVEN] Component is NOT in inventory
      AddComponent(Item,BOMComponent);
      QtyOnInventory := RandInt;
      // [GIVEN] Item "X" is in inventory on Location "L1". Quantity = "Q1"
      AddInventory(Item."No.",'',LocationCode1,QtyOnInventory);
      // [GIVEN] Item "X" is in inventory on Location "L2". Quantity = "Q2"
      AddInventory(Item."No.",'',LocationCode2,QtyOnInventory + 1);

      // [WHEN] Create Assembly Order for assembling Item "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,1);

      // [THEN] Assembly Availability page is shown: "Inventory" = "Q1" on page header
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE(Inventory,QtyOnInventory);
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE InventoryOnHeaderItemVariant@44();
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      ExpAsmAvailTestBuf@1006 : Record 137093;
      BOMComponent@1007 : Record 90;
      ItemVariantCode@1002 : Code[10];
      QtyOnInventory@1004 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 424] Assembly Availability page: Header's "Inventory" is equal to assembled Item Variant's inventory
      Initialize;

      LocationCode := '';
      // [GIVEN] Create the assembled Item "X" with Variant
      LibraryInventory.CreateItem(Item);
      ItemVariantCode := CreateItemVariant(Item."No.");
      // [GIVEN] Component is NOT in inventory
      AddComponent(Item,BOMComponent);
      // [GIVEN] Item "X" is in inventory. Quantity = "Q1"
      QtyOnInventory := RandInt;
      AddInventory(Item."No.",'',LocationCode,QtyOnInventory + 1);
      // [GIVEN] Item "X" with Variant is in inventory. Quantity = "Q2"
      AddInventory(Item."No.",ItemVariantCode,LocationCode,QtyOnInventory);

      // [WHEN] Create Assembly Order for assembling Item "X" with Variant
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,ItemVariantCode,WorkDate2,1);

      // [THEN] Assembly Availability page is shown: "Inventory" = "Q2" on page header
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE(Inventory,QtyOnInventory);
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE InventoryOnHeaderIncreasedByPost@54();
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1004 : Record 90;
      ItemInventory@1002 : Integer;
      CompInventory@1007 : Integer;
      QtyOnAssemble@1005 : Integer;
      QtyAssembled@1008 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 425] Assembly Availability page: Header's "Inventory" is increased by Assembly Order's partial posting
      Initialize;

      LocationCode := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Item "X" is in inventory. Quantity = "Q1"
      ItemInventory := RandInt;
      AddInventory(Item."No.",'',LocationCode,ItemInventory);
      // [GIVEN] Component is in inventory. Quantity = "Q2"
      CompInventory := RandInt;
      AddInventory(BOMComponent."No.",'',LocationCode,CompInventory);
      // [GIVEN] Create Assembly Order for assembling "Q3" pcs of Item "X" missing 1 pcs of Component
      QtyOnAssemble := CompInventory + 1;
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,QtyOnAssemble);
      // [GIVEN] Post Assembly Order partially, "Quantity To Assemble" = "QA"
      QtyAssembled := 1;
      PostAssemblyOrderQty(AssemblyHeader,QtyAssembled);

      // [WHEN] Show Assembly Availability
      AssemblyHeader.ShowAvailability;

      // [THEN] Assembly Availability page shows:
      // [THEN] "Inventory" = "Q1" + "QA", "Able To Assemble" = "Q2" - "QA"
      VerifyAsmAvailMissingInventory(AssemblyHeader,CompInventory - QtyAssembled,ItemInventory + QtyAssembled);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE EarliestAvailDateNoFutureDocs@51();
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent1@1004 : Record 90;
      BOMComponent2@1002 : Record 90;
      QtyOnAssemble@1005 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 426] "Earliest Availability Date" is empty when no documents that add missing inventory in future
      Initialize;

      LocationCode := '';
      // [GIVEN] Create the assembled Item "X" with two components: "C1" and "C2"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent1);
      AddComponent(Item,BOMComponent2);

      // [GIVEN] Component "C1" is in inventory. Quantity = "Q"
      QtyOnAssemble := RandInt;
      AddInventory(BOMComponent1."No.",'',LocationCode,QtyOnAssemble);
      // [GIVEN] Component "C2" is in inventory. Quantity = "Q" - 1
      AddInventory(BOMComponent2."No.",'',LocationCode,QtyOnAssemble - 1);

      // [WHEN] Create Assembly Order for assembling "Q" pcs of Item "X"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,QtyOnAssemble);

      // [THEN] Asm. Avail. "Earliest Availability Date" is empty in header and lines
      VerifyEmptyEarliestAvailDate(AssemblyHeader);

      // [GIVEN] Add missing inventory for Component "C2"
      AddInventory(BOMComponent2."No.",'',LocationCode,1);
      // [WHEN] Show Assembly Availability
      AssemblyHeader.ShowAvailability;

      // [THEN] Asm. Avail. "Earliest Availability Date" is empty in header and lines
      VerifyEmptyEarliestAvailDate(AssemblyHeader);
    END;

    LOCAL PROCEDURE VerifyEmptyEarliestAvailDate@223(AssemblyHeader@1001 : Record 900);
    VAR
      ExpAsmAvailTestBuf@1000 : Record 137093;
    BEGIN
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Earliest Availability Date",0D);
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);
      ExpAsmAvailTestBuf."Document Line No." := 1;
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
      ExpAsmAvailTestBuf."Document Line No." := 2;
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AbleToAssembleMissingComponent@61();
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent1@1004 : Record 90;
      BOMComponent2@1002 : Record 90;
      ItemVariant@1006 : Record 5401;
      QtyOnAssemble@1007 : Integer;
      LocationCode1@1010 : Code[10];
      LocationCode2@1008 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 427] "Able To Assemble" is increased when added missing inventory for one of components
      Initialize;

      LocationCode1 := '';
      LocationCode2 := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with two components: "C1" and "C2"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent1);
      AddComponent(Item,BOMComponent2);
      // [GIVEN] Component "C1" is in inventory on Location "L1". Quantity = "Q"
      QtyOnAssemble := RandInt;
      AddInventory(BOMComponent1."No.",'',LocationCode1,QtyOnAssemble);
      // [GIVEN] Component "C2" is NOT in inventory on Location "L1"
      AddInventory(BOMComponent2."No.",'',LocationCode2,RandInt);
      // [GIVEN] Component "C2" is in inventory for Variant and on Location "L2"
      LibraryInventory.CreateItemVariant(ItemVariant,BOMComponent2."No.");
      AddInventory(BOMComponent2."No.",ItemVariant.Code,LocationCode2,RandInt);
      AddInventory(BOMComponent2."No.",ItemVariant.Code,LocationCode1,RandInt);

      // [WHEN] Create Assembly Order for assembling "Q" pcs of Item "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,QtyOnAssemble);

      // [THEN] Assembly Availability page is shown: "Able To Assemble" = 0 due to missed Component "C2"
      // [THEN] "Able To Assemble" = 0 in line for Component "C2"
      VerifySecondComponentAvailability(AssemblyHeader,0);

      // [GIVEN] Add missing inventory for Component "C2" on Location "L1"
      AddInventory(BOMComponent2."No.",'',LocationCode1,QtyOnAssemble);

      // [WHEN] Show Assembly Availability
      AssemblyHeader.ShowAvailability;

      // [THEN] Assembly Availability page shows: "Able To Assemble" = "Q"
      // [THEN] "Able To Assemble" = "Q" in line for Component "C2"
      VerifySecondComponentAvailability(AssemblyHeader,QtyOnAssemble);
    END;

    LOCAL PROCEDURE VerifySecondComponentAvailability@228(AssemblyHeader@1001 : Record 900;ExpectedQuantity@1002 : Decimal);
    VAR
      ExpAsmAvailTestBuf@1000 : Record 137093;
    BEGIN
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Earliest Availability Date",0D);
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",ExpectedQuantity);
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);
      ExpAsmAvailTestBuf."Document Line No." := 2;
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",ExpectedQuantity);
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",ExpectedQuantity);
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE EarliestAvailDateProductOrders@58();
    VAR
      ProductionOrder@1007 : Record 5405;
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1004 : Record 90;
      CompQuantity@1006 : Integer;
      LocationCode1@1005 : Code[10];
      LocationCode2@1003 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 428] "Earliest Availability Date" shows date of the first Production Order that adds missing inventory
      Initialize;

      LocationCode1 := LocationBlue.Code;
      LocationCode2 := '';
      // [GIVEN] Create the assembled Item "X" with one component in inventory on Location "L1"
      CompQuantity := CreateItemWithComponentInventory(Item,BOMComponent,LocationCode1);
      // [GIVEN] Create three future released Production Orders: +9D on "L2", +10D on "L1", +11D on "L1"
      CreateProdOrderAndRefresh(ProductionOrder,BOMComponent."No.",RandInt,LocationCode2,WorkDate10D - 1);
      CreateProdOrderAndRefresh(ProductionOrder,BOMComponent."No.",RandInt,LocationCode1,WorkDate10D);
      CreateProdOrderAndRefresh(ProductionOrder,BOMComponent."No.",RandInt,LocationCode1,WorkDate10D + 1);

      // [WHEN] Create Assembly Order for assembling "Q" + 1 pcs of Item "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,CompQuantity + 1);

      // [THEN] Assembly Availability page shows in Header and Line: "Earliest Availability Date" = +10D, "Able To Assemble" = "Q"
      VerifyEarliestAvailDate(AssemblyHeader,CompQuantity,WorkDate10D);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE EarliestAvailDatePurchOrders@66();
    VAR
      Item@1000 : Record 27;
      PurchaseHeader@1007 : Record 38;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1004 : Record 90;
      CompQuantity@1002 : Integer;
      LocationCode1@1005 : Code[10];
      LocationCode2@1003 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 429] "Earliest Availability Date" shows date of the first Purchase Order that adds missing inventory
      Initialize;

      LocationCode1 := '';
      LocationCode2 := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with one component in inventory on Location "L1"
      CompQuantity := CreateItemWithComponentInventory(Item,BOMComponent,LocationCode1);
      // [GIVEN] Create three future Purchase Orders : +9D on "L2", +10D on "L1", +11D on "L1"
      CreatePurchaseOrder(PurchaseHeader,BOMComponent."No.",'',RandInt,LocationCode2,WorkDate10D - 1);
      CreatePurchaseOrder(PurchaseHeader,BOMComponent."No.",'',RandInt,LocationCode1,WorkDate10D);
      CreatePurchaseOrder(PurchaseHeader,BOMComponent."No.",'',RandInt,LocationCode1,WorkDate10D + 1);

      // [WHEN] Create Assembly Order for assembling "Q" + 1 pcs of Item "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,CompQuantity + 1);

      // [THEN] Assembly Availability page shows in Header and Line: "Earliest Availability Date" = +10D, "Able To Assemble" = "Q"
      VerifyEarliestAvailDate(AssemblyHeader,CompQuantity,WorkDate10D);
    END;

    LOCAL PROCEDURE CreateItemWithComponentInventory@28(VAR Item@1001 : Record 27;VAR BOMComponent@1000 : Record 90;LocationCode@1002 : Code[10]) CompQuantity : Decimal;
    BEGIN
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      CompQuantity := RandInt;
      AddInventory(BOMComponent."No.",'',LocationCode,CompQuantity);
    END;

    LOCAL PROCEDURE VerifyEarliestAvailDate@6(AssemblyHeader@1001 : Record 900;ExpectedQuantity@1002 : Decimal;EarliestDate@1003 : Date);
    VAR
      ExpAsmAvailTestBuf@1000 : Record 137093;
    BEGIN
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",ExpectedQuantity);
      ExpAsmAvailTestBuf.VALIDATE("Earliest Availability Date",CalcSafeDate(EarliestDate));
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);

      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",ExpectedQuantity);
      ExpAsmAvailTestBuf.VALIDATE("Earliest Availability Date",EarliestDate);
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE FutureReservationCausesAvailWarning@71();
    VAR
      AssemblyHeader@1001 : Record 900;
      CompanyInfo@1006 : Record 79;
      LateAssemblyHeader@1004 : Record 900;
      LateAssemblyLine@1003 : Record 901;
      ExpAsmAvailTestBuf@1008 : Record 137093;
      BOMComponentNo@1000 : Code[20];
      AbleToAsmQty@1002 : Decimal;
      DateWithinCheckAvailPeriod@1007 : Date;
      ReservedQty@1005 : Decimal;
    BEGIN
      // [Feature] [Check-Avail. period]
      // [SCENARIO 360419] Future Asm. Order with reservation causes Availability warning
      Initialize;

      // [GIVEN] Have a Component Item of an Assembly Item in inventory. Qty = Q
      // [GIVEN] Create an Assembly Order AO2 within Check-Avail. period with Qty = Q2, where (Q2 < Q)
      CompanyInfo.GET;
      DateWithinCheckAvailPeriod := CALCDATE(CompanyInfo."Check-Avail. Period Calc.",WorkDate2);
      AbleToAsmQty :=
        -CreateAssemblyOrderMissingInventory(LateAssemblyHeader,BOMComponentNo,DateWithinCheckAvailPeriod,LocationBlue.Code,TRUE);
      // [GIVEN] Reserve half of the Assembly Order AO2
      ReservedQty := AutoReserveHalfFirstAsmLine(LateAssemblyHeader,LateAssemblyLine);
      // [GIVEN] Create an Assembly Order AO1 on Working Date with Qty = 0
      CreateAssemblyOrder(AssemblyHeader,LateAssemblyHeader."Item No.",LateAssemblyHeader."Location Code",'',WorkDate2,0);

      // [WHEN] Set Qty = Q1 on Assembly Order AO1, where (Q1 < Q) but bigger than remaining inventory (Q1 > Q - Q2)
      AssemblyHeader.VALIDATE(Quantity,AbleToAsmQty * 3);

      // [THEN] Availability warning page shows: "Able To Assemble" = (Q - Q2) decreased by the Asm. Order AO2
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",AbleToAsmQty);
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);
      // [THEN] "Gross requirement" = not reserved Qty of the Asm. Order AO2
      // [THEN] "Expected Inventory" is not affected by the reservation on the Asm. Order AO2
      VerifyLineGrossReqExpInv(AssemblyHeader,LateAssemblyLine."Remaining Quantity (Base)" - ReservedQty,AbleToAsmQty);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AbleToAsmNotAffectedByReservation@135();
    VAR
      AssemblyHeader@1001 : Record 900;
      CompanyInfo@1005 : Record 79;
      LateAssemblyHeader@1004 : Record 900;
      LateAssemblyLine@1003 : Record 901;
      ExpAsmAvailTestBuf@1008 : Record 137093;
      BOMComponentNo@1000 : Code[20];
      AbleToAsmQty@1002 : Decimal;
      DateWithinCheckAvailPeriod@1006 : Date;
    BEGIN
      // [Feature] [Check-Avail. period]
      // [SCENARIO 360419] Reservation on Asm.Order does not affect "Able To Assemble"
      Initialize;

      // [GIVEN] Have a Component Item of an Assembly Item in inventory. Qty = Q
      // [GIVEN] Create an Assembly Order AO2 within Check-Avail. period with Qty = Q2, where (Q2 < Q)
      CompanyInfo.GET;
      DateWithinCheckAvailPeriod := GetEndDateOfCheckAvailPeriod(CALCDATE(CompanyInfo."Check-Avail. Period Calc.",WorkDate2));
      AbleToAsmQty :=
        -CreateAssemblyOrderMissingInventory(LateAssemblyHeader,BOMComponentNo,DateWithinCheckAvailPeriod,LocationBlue.Code,TRUE);
      // [GIVEN] Reserve half of the Assembly Order AO2
      AutoReserveHalfFirstAsmLine(LateAssemblyHeader,LateAssemblyLine);
      // [GIVEN] Create an Assembly Order AO1 on Working Date with Qty = Q1, where (Q1 < Q) but bigger than remaining inventory (Q1 > Q - Q2)
      CreateAssemblyOrder(
        AssemblyHeader,LateAssemblyHeader."Item No.",LateAssemblyHeader."Location Code",'',WorkDate2,AbleToAsmQty * 3);

      // [WHEN] Show Availability for reserved Assembly Order AO2
      LateAssemblyHeader.ShowAvailability;

      // [THEN] Availability page shows "Able To Assemble" = (Q - Q1) decreased by the Asm. Order AO1
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",LateAssemblyHeader.Quantity + AbleToAsmQty - AssemblyHeader.Quantity);
      ExpAsmAvailTestBuf.VALIDATE("Scheduled Receipts",AssemblyHeader.Quantity);
      AssertAvailabilityHeader(LateAssemblyHeader,ExpAsmAvailTestBuf);
      // [THEN] "Gross requirement" = full Qty of the Asm. Order AO1 regardless of reservation
      // [THEN] "Expected Inventory" is not affected by the reservation on the Asm. Order AO2
      VerifyLineGrossReqExpInv(
        LateAssemblyHeader,AssemblyHeader.Quantity,LateAssemblyHeader.Quantity + AbleToAsmQty - AssemblyHeader.Quantity);
    END;

    LOCAL PROCEDURE AutoReserveHalfFirstAsmLine@213(AssemblyHeader@1001 : Record 900;VAR AssemblyLine@1000 : Record 901) : Decimal;
    VAR
      ReservMgt@1002 : Codeunit 99000845;
      FullAutoReservation@1003 : Boolean;
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.FINDFIRST;
      ReservMgt.SetAssemblyLine(AssemblyLine);
      ReservMgt.AutoReserve(
        FullAutoReservation,'',AssemblyLine."Due Date",
        AssemblyLine."Remaining Quantity" DIV 2,AssemblyLine."Remaining Quantity (Base)" DIV 2);
      EXIT(AssemblyLine."Remaining Quantity (Base)" DIV 2);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE EarliestAvailDateTransfers@73();
    VAR
      AssemblyHeader@1000 : Record 900;
      BOMComponent@1004 : Record 90;
      Item@1008 : Record 27;
      TransferHeader@1003 : Record 5740;
      ExpAsmAvailTestBuf@1005 : Record 137093;
      CompQuantity@1007 : Integer;
      MissedQty@1001 : Integer;
      QtyToTransfer@1002 : Decimal;
      RestoringTransferDate@1006 : Date;
    BEGIN
      // [Feature] [Check-Avail. period]
      // [SCENARIO 360072] Assembly Availability page takes future requirements into account
      Initialize;

      // [GIVEN] Create the assembled Item "X" with one component in inventory
      CompQuantity := CreateItemWithComponentInventory(Item,BOMComponent,LocationBlue.Code);
      MissedQty := CompQuantity DIV 7;
      // [GIVEN] Create Assembly Order for assembling "Q" + 1 pcs of Item "X"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationBlue.Code,'',WorkDate2,CompQuantity + MissedQty);
      // [GIVEN] Decrease inventory on next day by Transfer to another location
      QtyToTransfer := (AssemblyHeader.Quantity - MissedQty) DIV 2;
      CreateTransferOrder(
        TransferHeader,BOMComponent."No.",'',LocationBlue.Code,LocationRed.Code,AssemblyHeader."Due Date" + 1,QtyToTransfer);
      // [GIVEN] Restore required inventory by transfering back in the next Check-Avail. period
      RestoringTransferDate := GetEndDateOfCheckAvailPeriod(AssemblyHeader."Due Date") + 1;
      CreateTransferOrder(
        TransferHeader,BOMComponent."No.",'',LocationRed.Code,LocationBlue.Code,RestoringTransferDate,QtyToTransfer + MissedQty);

      // [WHEN] Show Availability for Assembly Order
      AssemblyHeader.ShowAvailability;

      // [THEN] Verify Availability page:
      // [THEN] "Able To Assemble" decreased by the first transfer
      // [THEN] "Earliest Availability Date" is the receipt date of the second transfer
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",AssemblyHeader.Quantity - MissedQty - QtyToTransfer);
      ExpAsmAvailTestBuf.VALIDATE("Earliest Availability Date",CalcSafeDate(RestoringTransferDate));
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);

      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Gross Requirement",QtyToTransfer);
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",AssemblyHeader.Quantity - MissedQty - QtyToTransfer);
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",AssemblyHeader.Quantity - MissedQty - QtyToTransfer);
      ExpAsmAvailTestBuf.VALIDATE("Earliest Availability Date",RestoringTransferDate);
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    LOCAL PROCEDURE GetEndDateOfCheckAvailPeriod@206(Date@1000 : Date) : Date;
    VAR
      CompanyInfo@1001 : Record 79;
      AvailableToPromise@1002 : Codeunit 5790;
    BEGIN
      CompanyInfo.GET;
      EXIT(AvailableToPromise.AdjustedEndingDate(Date + 1,CompanyInfo."Check-Avail. Time Bucket"));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE EarliestAvailDateSalesRetOrders@64();
    VAR
      Item@1005 : Record 27;
      SalesHeader@1007 : Record 36;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1004 : Record 90;
      CompQuantity@1002 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1000 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 4211] "Earliest Availability Date" shows date of the first Sales Returning Order that adds missing inventory
      Initialize;

      LocationCode1 := LocationBlue.Code;
      LocationCode2 := '';
      // [GIVEN] Create the assembled Item "X" with one component in inventory on Location "L1"
      CompQuantity := CreateItemWithComponentInventory(Item,BOMComponent,LocationCode1);
      // [GIVEN] Create three future Sales Return Orders: +9D on "L2", +10D on "L1", +11D on "L1"
      CreateSalesReturnOrder(SalesHeader,BOMComponent."No.",'',RandInt,LocationCode2,WorkDate10D - 1);
      CreateSalesReturnOrder(SalesHeader,BOMComponent."No.",'',RandInt,LocationCode1,WorkDate10D);
      CreateSalesReturnOrder(SalesHeader,BOMComponent."No.",'',RandInt,LocationCode1,WorkDate10D + 1);

      // [WHEN] Create Assembly Order for assembling "Q" + 1 pcs of Item "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,CompQuantity + 1);

      // [THEN] Assembly Availability page shows in Header and Line: "Earliest Availability Date" = +10D, "Able To Assemble" = "Q"
      VerifyEarliestAvailDate(AssemblyHeader,CompQuantity,WorkDate10D);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AbleToAssembleExpectedInventory@75();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : Record 90;
      AssemblyHeader@1001 : Record 900;
      ItemVariantCode@1005 : Code[10];
      CompQuantity@1006 : Integer;
      AddedQuantity@1007 : Integer;
      QtyToAssemble@1009 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 4212] "Able To Assemble" is not affected by inventory on different location or item variant
      Initialize;

      LocationCode1 := LocationBlue.Code;
      LocationCode2 := '';
      // [GIVEN] Create the assembled Item "X" with one component in inventory on Location "L1", Quantity = "Q"
      CompQuantity := CreateItemWithComponentInventory(Item,BOMComponent,LocationCode1);

      // [GIVEN] Create Item variant "V" and add inventory for combinations: "V" on "L1","V" on "L2","X" on "L2"
      ItemVariantCode := CreateItemVariant(BOMComponent."No.");
      AddInventory(BOMComponent."No.",ItemVariantCode,LocationCode1,RandInt);
      AddInventory(BOMComponent."No.",ItemVariantCode,LocationCode2,RandInt);
      AddInventory(BOMComponent."No.",'',LocationCode2,RandInt);

      // [WHEN] Create Assembly Order for assembling "Q" + 1 pcs of Item "X" on Location "L1"
      QtyToAssemble := CompQuantity + 1;
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,QtyToAssemble);

      // [THEN] Assembly Availability page is shown: "Able To Assemble" = "Q","Expected Inventory" = "Q"
      VerifyAbleToAssembleExpInventory(AssemblyHeader,CompQuantity,CompQuantity);

      // [GIVEN] Add 2 psc to inventory to Location "L1"
      AddedQuantity := QtyToAssemble - CompQuantity + 1;
      AddInventory(BOMComponent."No.",'',LocationCode1,2);

      // [WHEN] Show Assembly Availability
      AssemblyHeader.ShowAvailability;

      // [THEN] Assembly Availability page shows: "Able To Assemble" = "Q" + 1,"Expected Inventory" = "Q" + 2
      VerifyAbleToAssembleExpInventory(AssemblyHeader,QtyToAssemble,CompQuantity + AddedQuantity);
    END;

    LOCAL PROCEDURE VerifyAbleToAssembleExpInventory@62(AssemblyHeader@1000 : Record 900;AbleToAssemble@1001 : Decimal;ExpInventory@1002 : Decimal);
    VAR
      ExpAsmAvailTestBuf@1003 : Record 137093;
    BEGIN
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",AbleToAssemble);
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);
      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",ExpInventory);
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HdrScheduledReceiptsAssemblyOrders@74();
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1007 : Record 90;
      ItemVariantCode@1005 : Code[10];
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
      QtyToAssemble@1004 : Integer;
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 4213] "Scheduled Receipts" on the page header counts Assembly Orders
      Initialize;

      LocationCode1 := LocationBlue.Code;
      LocationCode2 := '';
      // [GIVEN] Create the assembled Item "X" with one component
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Create Item variant "V"
      ItemVariantCode := CreateItemVariant(Item."No.");
      // [GIVEN] Create Assembly Orders for combinations: "V" on "L1","V" on "L2","X" on "L2"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode2,'',WorkDate2,RandInt);
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode2,ItemVariantCode,WorkDate2,RandInt);
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,ItemVariantCode,WorkDate2,RandInt);
      // [GIVEN] Create first Assembly Order for "X" on Location "L1". Quantity = "Q"
      QtyToAssemble := CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [WHEN] Create second Assembly Order for "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability page is shown. Header's "Gross requirement" = 0
      VerifyHrdGrossReqSchedRcpts(AssemblyHeader,0,QtyToAssemble);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HdrGrossRequirementSalesOrders@87();
    VAR
      Item@1000 : Record 27;
      SalesHeader@1004 : Record 36;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1010 : Record 90;
      ItemVariantCode@1009 : Code[10];
      Qty@1006 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 4215] "Gross requirement" on the page header counts Sales Orders
      Initialize;

      LocationCode1 := LocationBlue.Code;
      LocationCode2 := '';
      // [GIVEN] Create the assembled Item "X" with one component
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Create Item variant "V"
      ItemVariantCode := CreateItemVariant(Item."No.");
      // [GIVEN] Create Sales Orders on +10D for combinations: "V" on "L1","V" on "L2","X" on "L2"
      CreateSalesOrder(SalesHeader,Item."No.",ItemVariantCode,RandInt,WorkDate10D,LocationCode1);
      CreateSalesOrder(SalesHeader,Item."No.",'',RandInt,WorkDate10D,LocationCode2);
      CreateSalesOrder(SalesHeader,Item."No.",ItemVariantCode,RandInt,WorkDate10D,LocationCode2);
      // [GIVEN] Create Sales Order on +10D for "X" on "L1", Quantity = "Q"
      Qty := CreateSalesOrder(SalesHeader,Item."No.",'',RandInt,WorkDate10D,LocationCode1);

      // [WHEN] Create Assembly Order on +10D for "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate10D,RandInt);

      // [THEN] Assembly Availability page is shown. Header's "Gross requirement" = "Q"
      VerifyHrdGrossReqSchedRcpts(AssemblyHeader,Qty,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HdrGrossRequirementPurchRetOrders@90();
    VAR
      Item@1000 : Record 27;
      PurchaseHeader@1004 : Record 38;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1009 : Record 90;
      ItemVariantCode@1010 : Code[10];
      Qty@1007 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 4216] "Gross requirement" on the page header counts Purchase Return Orders
      Initialize;

      LocationCode1 := LocationBlue.Code;
      LocationCode2 := '';
      // [GIVEN] Create the assembled Item "X" with one component
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Create Item variant "V"
      ItemVariantCode := CreateItemVariant(Item."No.");
      // [GIVEN] Create Purchase Return Orders on +10D for combinations: "V" on "L1","V" on "L2","X" on "L2"
      CreatePurchaseReturnOrder(PurchaseHeader,Item."No.",ItemVariantCode,RandInt,LocationCode1,WorkDate10D);
      CreatePurchaseReturnOrder(PurchaseHeader,Item."No.",'',RandInt,LocationCode2,WorkDate10D);
      CreatePurchaseReturnOrder(PurchaseHeader,Item."No.",ItemVariantCode,RandInt,LocationCode2,WorkDate10D);
      // [GIVEN] Create Purchase Return Order on +10D for "X" on Location "L1", Quantity = "Q"
      Qty := CreatePurchaseReturnOrder(PurchaseHeader,Item."No.",'',RandInt,LocationCode1,WorkDate10D);

      // [WHEN] Create Assembly Order for "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability page is shown. Header's "Gross requirement" = "Q"
      VerifyHrdGrossReqSchedRcpts(AssemblyHeader,Qty,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HdrGrossRequirementTransferOrders@96();
    VAR
      TransferHeader@1007 : Record 5740;
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1009 : Record 90;
      ItemVariantCode@1002 : Code[10];
      Qty@1004 : Integer;
      LocationCode1@1005 : Code[10];
      LocationCode2@1003 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 4217] "Gross requirement" on the page header counts Transfer Orders
      Initialize;

      LocationCode1 := LocationBlue.Code;
      LocationCode2 := LocationRed.Code;
      // [GIVEN] Create the assembled Item "X" with one component
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      SetRandComponentQuantityPer(BOMComponent);
      // [GIVEN] Create Item variant "V"
      ItemVariantCode := CreateItemVariant(Item."No.");
      // [GIVEN] Create Transfer Orders on +10D for combinations: "V" on "L1","V" on "L2","X" on "L2"
      CreateTransferOrder(TransferHeader,Item."No.",ItemVariantCode,LocationCode1,LocationCode2,WorkDate10D,RandInt);
      CreateTransferOrder(TransferHeader,Item."No.",ItemVariantCode,LocationCode2,LocationCode1,WorkDate10D,RandInt);
      CreateTransferOrder(TransferHeader,Item."No.",'',LocationCode2,LocationCode1,WorkDate10D,RandInt);
      // [GIVEN] Create Transfer Order for "X" on Location "L1", Quantity = "Q"
      Qty := CreateTransferOrder(TransferHeader,Item."No.",'',LocationCode1,LocationCode2,WorkDate2,RandInt);

      // [WHEN] Create Assembly Order for "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability page is shown. Header's "Gross requirement" = "Q"
      VerifyHrdGrossReqSchedRcpts(AssemblyHeader,Qty,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HdrGrossRequirementProductionOrder@101();
    VAR
      AssembledItem@1000 : Record 27;
      ProducedItem@1006 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1012 : Record 90;
      ProductionOrder@1004 : Record 5405;
      ItemVariantCode@1011 : Code[10];
      Qty@1007 : Integer;
      QtyPer@1009 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 4218] "Gross requirement" on the page header counts Production Orders
      Initialize;

      LocationCode1 := LocationBlue.Code;
      LocationCode2 := LocationRed.Code;
      // [GIVEN] Create the assembled Item "X" with one component
      LibraryInventory.CreateItem(AssembledItem);
      AddComponent(AssembledItem,BOMComponent);
      // [GIVEN] Create Item variant "V"
      ItemVariantCode := CreateItemVariant(AssembledItem."No.");
      // [GIVEN] Create Production Order on +10D for Item "P" on Location "L1", Quantity = "PQ"
      LibraryInventory.CreateItem(ProducedItem);
      Qty := CreateProdOrderAndRefresh(ProductionOrder,ProducedItem."No.",RandInt,LocationCode1,WorkDate10D);
      // [GIVEN] Add Production Components for combinations: "V" on "L1","V" on "L2","X" on "L2"
      // [GIVEN] Add Production Components for "X" on "L1", Quantity = "Q"
      QtyPer := AddComponentsToProdOrder(ProductionOrder,AssembledItem."No.",ItemVariantCode,LocationCode1,LocationCode2);

      // [WHEN] Create Assembly Order for "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,AssembledItem."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability page is shown. Header's "Gross requirement" = "Q" * "PQ"
      VerifyHrdGrossReqSchedRcpts(AssemblyHeader,Qty * QtyPer,0);
    END;

    LOCAL PROCEDURE AddComponentsToProdOrder@7(ProductionOrder@1003 : Record 5405;ItemNo@1000 : Code[20];ItemVariantCode@1004 : Code[10];LocationCode1@1002 : Code[10];LocationCode2@1001 : Code[10]) QtyPer : Decimal;
    BEGIN
      AddComponentToProdOrder(ProductionOrder,ItemNo,ItemVariantCode,RandInt,LocationCode1);
      AddComponentToProdOrder(ProductionOrder,ItemNo,ItemVariantCode,RandInt,LocationCode2);
      AddComponentToProdOrder(ProductionOrder,ItemNo,'',RandInt,LocationCode2);
      QtyPer := AddComponentToProdOrder(ProductionOrder,ItemNo,'',RandInt,LocationCode1);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HdrScheduledReceiptsPurchaseOrders@99();
    VAR
      Item@1000 : Record 27;
      PurchaseHeader@1004 : Record 38;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1010 : Record 90;
      ItemVariantCode@1009 : Code[10];
      Qty@1006 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 4219] "Scheduled Receipts" on the page header counts Purchase Orders
      Initialize;

      LocationCode1 := '';
      LocationCode2 := LocationRed.Code;
      // [GIVEN] Create the assembled Item "X" with one component
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Create Item variant "V"
      ItemVariantCode := CreateItemVariant(Item."No.");
      // [GIVEN] Create Purchase Orders on +10D for combinations: "V" on "L1","V" on "L2","X" on "L2","X" on "L1"
      CreatePurchaseOrders(Item."No.",ItemVariantCode,WorkDate10D,LocationCode1,LocationCode2);
      // [GIVEN] Create Purchase Order on WorkDate for "X" on "L1", Quantity = "Q"
      Qty := CreatePurchaseOrder(PurchaseHeader,Item."No.",'',RandInt,LocationCode1,WorkDate2);

      // [WHEN] Create Assembly Order on WorkDate for "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability page is shown. Header's "Scheduled Receipts" = "Q"
      VerifyHrdGrossReqSchedRcpts(AssemblyHeader,0,Qty);
    END;

    LOCAL PROCEDURE CreatePurchaseOrders@16(ItemNo@1005 : Code[20];ItemVariantCode@1004 : Code[10];ReceiptDate@1003 : Date;LocationCode1@1002 : Code[10];LocationCode2@1001 : Code[10]);
    VAR
      PurchaseHeader@1000 : Record 38;
    BEGIN
      CreatePurchaseOrder(PurchaseHeader,ItemNo,ItemVariantCode,RandInt,LocationCode1,ReceiptDate);
      CreatePurchaseOrder(PurchaseHeader,ItemNo,'',RandInt,LocationCode2,ReceiptDate);
      CreatePurchaseOrder(PurchaseHeader,ItemNo,ItemVariantCode,RandInt,LocationCode1,ReceiptDate);
      CreatePurchaseOrder(PurchaseHeader,ItemNo,'',RandInt,LocationCode1,ReceiptDate);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HdrScheduledReceiptsProdOrderAsmOrder@105();
    VAR
      Item@1000 : Record 27;
      ProductionOrder@1004 : Record 5405;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1008 : Record 90;
      QtyOnAssemble@1007 : Integer;
      QtyToProduce@1006 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 4220] "Scheduled Receipts" on the page header counts Production Orders
      Initialize;

      LocationCode := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with one component
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Create Production Orders on +10D for "X" on "L1"
      CreateProdOrderAndRefresh(ProductionOrder,Item."No.",RandInt,LocationCode,WorkDate10D);
      // [GIVEN] Create Production Order on WorkDate for "X" on "L1", Quantity = "PQ"
      QtyToProduce := CreateProdOrderAndRefresh(ProductionOrder,Item."No.",RandInt,LocationCode,WorkDate2);
      // [GIVEN] Create Assembly Order on WorkDate for "X" on Location "L1", Quantity = "Q"
      QtyOnAssemble := CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,RandInt);

      // [WHEN] Create Assembly Order on WorkDate for "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability page is shown. Header's "Scheduled Receipts" = "Q" + "Qp"
      VerifyHrdGrossReqSchedRcpts(AssemblyHeader,0,QtyOnAssemble + QtyToProduce);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HdrScheduledReceiptsSalesReturnOrders@110();
    VAR
      Item@1000 : Record 27;
      SalesHeader@1004 : Record 36;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1010 : Record 90;
      ItemVariantCode@1009 : Code[10];
      Qty@1006 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 4221] "Scheduled Receipts" on the page header counts Sales Return Orders
      Initialize;

      LocationCode1 := LocationBlue.Code;
      LocationCode2 := '';
      // [GIVEN] Create the assembled Item "X" with one component
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Create Item variant "V"
      ItemVariantCode := CreateItemVariant(Item."No.");
      // [GIVEN] Create Sales Orders on +10D for combinations: "V" on "L1","V" on "L2","X" on "L2","X" on "L1"
      CreateSalesReturnOrders(Item."No.",ItemVariantCode,WorkDate10D,LocationCode1,LocationCode2);
      // [GIVEN] Create Sales Orders on WorkDate for "X" on "L1", Quantity = "Q"
      Qty := CreateSalesReturnOrder(SalesHeader,Item."No.",'',RandInt,LocationCode1,WorkDate2);

      // [WHEN] Create Assembly Order on WorkDate for "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability page is shown. Header's "Scheduled Receipts" = "Q"
      VerifyHrdGrossReqSchedRcpts(AssemblyHeader,0,Qty);
    END;

    LOCAL PROCEDURE CreateSalesReturnOrders@34(ItemNo@1004 : Code[20];ItemVariantCode@1003 : Code[10];ReceiptDate@1002 : Date;LocationCode1@1001 : Code[10];LocationCode2@1000 : Code[10]);
    VAR
      SalesHeader@1005 : Record 36;
    BEGIN
      CreateSalesReturnOrder(SalesHeader,ItemNo,ItemVariantCode,RandInt,LocationCode1,ReceiptDate);
      CreateSalesReturnOrder(SalesHeader,ItemNo,'',RandInt,LocationCode2,ReceiptDate);
      CreateSalesReturnOrder(SalesHeader,ItemNo,ItemVariantCode,RandInt,LocationCode1,ReceiptDate);
      CreateSalesReturnOrder(SalesHeader,ItemNo,'',RandInt,LocationCode1,ReceiptDate);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HdrScheduledReceiptsTransferOrders@109();
    VAR
      TransferHeader@1007 : Record 5740;
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1010 : Record 90;
      ItemVariantCode@1009 : Code[10];
      Qty@1004 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Assembled Item]
      // [SCENARIO 4222] "Scheduled Receipts" on the page header counts Transfer Orders
      Initialize;

      LocationCode1 := LocationRed.Code;
      LocationCode2 := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with one component
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Create Item variant "V"
      ItemVariantCode := CreateItemVariant(Item."No.");
      // [GIVEN] Create Transfer Orders on +10D for combinations: "V" on "L1","V" on "L2","X" on "L2"
      CreateTransferOrder(TransferHeader,Item."No.",ItemVariantCode,LocationCode1,LocationCode2,WorkDate10D,RandInt);
      CreateTransferOrder(TransferHeader,Item."No.",ItemVariantCode,LocationCode2,LocationCode1,WorkDate10D,RandInt);
      CreateTransferOrder(TransferHeader,Item."No.",'',LocationCode2,LocationCode1,WorkDate10D,RandInt);
      // [GIVEN] Create Transfer Orders on WorkDate for "X" on "L2", Quantity = "Q"
      Qty := CreateTransferOrder(TransferHeader,Item."No.",'',LocationCode2,LocationCode1,WorkDate2,RandInt);

      // [WHEN] Create Assembly Order on WorkDate for "X" on Location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability page is shown. Header's "Scheduled Receipts" = "Q"
      VerifyHrdGrossReqSchedRcpts(AssemblyHeader,0,Qty);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HdrAbleToAssembleTwoCompWithQtyPer@119();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : ARRAY [2] OF Record 90;
      AssemblyHeader@1001 : Record 900;
      ExpAsmAvailTestBuf@1010 : Record 137093;
      AbleToAssemble@1007 : ARRAY [2] OF Decimal;
      QtyOnInventory@1005 : ARRAY [2] OF Integer;
      QtyOnAssemble@1002 : Integer;
      i@1006 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Quantity Per]
      // [SCENARIO 4223] "Able To Assemble" is equal to the minimal quantity of two components in inventory, considering component's "Quantity per"
      Initialize;

      LocationCode := '';
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      FOR i := 1 TO 2 DO BEGIN
        // [GIVEN] Add two components with "Quantity per": "Qp1", "Qp2"
        AddComponent(Item,BOMComponent[i]);
        SetRandComponentQuantityPer(BOMComponent[i]);
        QtyOnInventory[i] := RandInt;
        // [GIVEN] Add inventory for both components: "Q1", "Q2"
        AddInventory(BOMComponent[i]."No.",'',LocationCode,QtyOnInventory[i]);
        AbleToAssemble[i] := QtyOnInventory[i] / BOMComponent[i]."Quantity per";
      END;

      // [WHEN] Create Assembly Order for "X" missing both components
      QtyOnAssemble := MinValue(QtyOnInventory[1],QtyOnInventory[2]);
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,QtyOnAssemble);

      // [THEN] Header's "Able To Assemble" is minimal of "Able To Assemble" in lines
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",MinValue(AbleToAssemble[1],AbleToAssemble[2]));
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);
      // [THEN] Line's "Expected Inventory" shows components inventory (Q1, Q2)
      // [THEN] Line's "Able To Assemble" shows quantity of "X" considering "Quantity per" (Q1 / Qp1, Q2 / Qp2)
      FOR i := 1 TO 2 DO BEGIN
        ExpAsmAvailTestBuf."Document Line No." := i;
        ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",QtyOnInventory[i]);
        ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",AbleToAssemble[i]);
        AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
      END;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineGrossRequirementAssemblyOrders@137();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1006 : Record 90;
      AssemblyHeader@1001 : Record 900;
      QtyOnAssemble1@1004 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Quantity Per]
      // [SCENARIO 4224] "Gross requirement" on the page line counts Assembly Orders, considering "Quantity per"
      Initialize;

      LocationCode1 := LocationRed.Code;
      LocationCode2 := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with one component
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Component's "Quantity per" = "Qp"
      SetRandComponentQuantityPer(BOMComponent);
      // [GIVEN] Create Component Variant "CV"
      SetVariantOnComponent(BOMComponent,CreateItemVariant(BOMComponent."No."));
      // [GIVEN] Create Assembly Order for item "X" for location "L2"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode2,'',WorkDate2,RandInt);
      // [GIVEN] Create first Assembly Order for item "X" for location "L1", Quantity = "Q"
      QtyOnAssemble1 := CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);
      // [WHEN] Create second Assembly Order for item "X" for location "L1"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability Line contains info only for the first order, not current one, same location and variant
      VerifyLineGrossReqExpInv(
        AssemblyHeader,QtyOnAssemble1 * BOMComponent."Quantity per",-QtyOnAssemble1 * BOMComponent."Quantity per");
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineGrossRequirementSalesOrders@131();
    VAR
      Item@1000 : Record 27;
      SalesHeader@1004 : Record 36;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1009 : Record 90;
      ItemVariantCode@1005 : Code[10];
      QtyOnSO@1006 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 4225] "Gross requirement" on the page line counts Sales Orders
      Initialize;

      LocationCode1 := LocationRed.Code;
      LocationCode2 := '';
      // [GIVEN] Create the assembled Item "X" with a component "C"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Create Component variant "CV", not in assembly list
      ItemVariantCode := CreateItemVariant(BOMComponent."No.");
      // [GIVEN] Create Sales Orders for combinations: "CV" on "L1","CV" on "L2","C" on "L2"
      CreateSalesOrder(SalesHeader,BOMComponent."No.",ItemVariantCode,RandInt,WorkDate2,LocationCode1);
      CreateSalesOrder(SalesHeader,BOMComponent."No.",'',RandInt,WorkDate2,LocationCode2);
      CreateSalesOrder(SalesHeader,BOMComponent."No.",ItemVariantCode,RandInt,WorkDate2,LocationCode1);
      // [GIVEN] Create Sales Order for "C" on "L1", Quantity = "Q"
      QtyOnSO := CreateSalesOrder(SalesHeader,BOMComponent."No.",'',RandInt,WorkDate2,LocationCode1);

      // [WHEN] Create Assembly Order for item "X" for location "L1"
      CreateAssemblyOrderOnSafeDate(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability Line: "Gross requirement" = "Q", "Expected Inventory" = -"Q"
      VerifyLineGrossReqExpInv(AssemblyHeader,QtyOnSO,-QtyOnSO);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineGrossRequirementPurchReturnOrders@150();
    VAR
      Item@1000 : Record 27;
      PurchaseHeader@1004 : Record 38;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1008 : Record 90;
      ItemVariantCode@1005 : Code[10];
      QtyOnPRO@1007 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 4226] "Gross requirement" on the page line counts Purchase Return Orders
      Initialize;

      LocationCode1 := '';
      LocationCode2 := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with a component "C"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Create Component variant "CV", not in assembly list
      ItemVariantCode := CreateItemVariant(BOMComponent."No.");
      // [GIVEN] Create Purchase Return Orders for combinations: "CV" on "L1","CV" on "L2","C" on "L2"
      CreatePurchaseReturnOrder(PurchaseHeader,BOMComponent."No.",ItemVariantCode,RandInt,LocationCode1,WorkDate2);
      CreatePurchaseReturnOrder(PurchaseHeader,BOMComponent."No.",'',RandInt,LocationCode2,WorkDate2);
      CreatePurchaseReturnOrder(PurchaseHeader,BOMComponent."No.",ItemVariantCode,RandInt,LocationCode2,WorkDate2);
      // [GIVEN] Create Purchase Return Order for "C" on "L1", Quantity = "Q"
      QtyOnPRO := CreatePurchaseReturnOrder(PurchaseHeader,BOMComponent."No.",'',RandInt,LocationCode1,WorkDate2);

      // [WHEN] Create Assembly Order for item "X" for location "L1"
      CreateAssemblyOrderOnSafeDate(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability Line: "Gross requirement" = "Q", "Expected Inventory" = -"Q"
      VerifyLineGrossReqExpInv(AssemblyHeader,QtyOnPRO,-QtyOnPRO);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineGrossRequirementTransferOrders@145();
    VAR
      TransferHeader@1007 : Record 5740;
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1008 : Record 90;
      ItemVariantCode@1002 : Code[10];
      QtyOnTO@1004 : Integer;
      LocationCode1@1005 : Code[10];
      LocationCode2@1003 : Code[10];
    BEGIN
      // [FEATURE] [Component]
      // [SCENARIO 4227] "Gross requirement" on the page line counts Transfer Orders
      Initialize;

      LocationCode1 := LocationRed.Code;
      LocationCode2 := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with a component "C"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Create Component variant "CV", not in assembly list
      ItemVariantCode := CreateItemVariant(BOMComponent."No.");
      // [GIVEN] Create Transfer Orders for combinations: "CV" on "L1","CV" on "L2"
      CreateTransferOrder(TransferHeader,BOMComponent."No.",ItemVariantCode,LocationCode1,LocationCode2,WorkDate2,RandInt);
      CreateTransferOrder(TransferHeader,BOMComponent."No.",ItemVariantCode,LocationCode2,LocationCode1,WorkDate2,RandInt);
      // [GIVEN] Create Transfer Order for "C" moving from "L1" to "L2"
      QtyOnTO := CreateTransferOrder(TransferHeader,BOMComponent."No.",'',LocationCode1,LocationCode2,WorkDate2,RandInt);

      // [WHEN] Create Assembly Order for item "X" for location "L1"
      CreateAssemblyOrderOnSafeDate(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability Line: "Gross requirement" = "Q", "Expected Inventory" = -"Q"
      VerifyLineGrossReqExpInv(AssemblyHeader,QtyOnTO,-QtyOnTO);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineGrossRequirementProductionOrders@149();
    VAR
      AssembledItem@1000 : Record 27;
      ProducedItem@1006 : Record 27;
      ProductionOrder@1004 : Record 5405;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1010 : Record 90;
      ItemVariantCode@1005 : Code[10];
      QtyOnRPO@1007 : Integer;
      QtyPerProd@1011 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Component] [Quantity Per]
      // [SCENARIO 4228] "Gross requirement" on the page line counts Production Orders
      Initialize;

      LocationCode1 := LocationRed.Code;
      LocationCode2 := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with a component "C"
      LibraryInventory.CreateItem(AssembledItem);
      AddComponent(AssembledItem,BOMComponent);
      // [GIVEN] Create Component variant "CV", not in assembly list
      ItemVariantCode := CreateItemVariant(BOMComponent."No.");
      // [GIVEN] Create Production Order for Item "P" on Location "L1", Quantity = "PQ"
      LibraryInventory.CreateItem(ProducedItem);
      QtyOnRPO := CreateProdOrderAndRefresh(ProductionOrder,ProducedItem."No.",RandInt,LocationCode1,WorkDate2);
      // [GIVEN] Add Production Components for combinations: "CV" on "L1","CV" on "L2","C" on "L2"
      // [GIVEN] Add Production Component for "C" on "L1", Quantity = "Q"
      QtyPerProd := AddComponentsToProdOrder(ProductionOrder,BOMComponent."No.",ItemVariantCode,LocationCode1,LocationCode2);

      // [WHEN] Create Assembly Order for item "X" for location "L1"
      CreateAssemblyOrder(AssemblyHeader,AssembledItem."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability Line: "Gross requirement" = ("Q" * "PQ"), "Expected Inventory" = -("Q" * "PQ")
      VerifyLineGrossReqExpInv(AssemblyHeader,QtyOnRPO * QtyPerProd,-QtyOnRPO * QtyPerProd);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineScheduledReceiptsPurchaseOrders@157();
    VAR
      Item@1000 : Record 27;
      PurchaseHeader@1004 : Record 38;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1008 : Record 90;
      ExpAsmAvailTestBuf@1011 : Record 137093;
      ItemVariantCode@1005 : Code[10];
      QtyOnPO@1006 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Component] [Quantity Per]
      // [SCENARIO 4229] "Scheduled Receipts" on the page line counts Purchase Orders
      Initialize;

      LocationCode1 := LocationRed.Code;
      LocationCode2 := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with a component "C"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Component's "Quantity per" = "Qp"
      SetRandComponentQuantityPer(BOMComponent);
      // [GIVEN] Create Component variant "CV", not in assembly list
      ItemVariantCode := CreateItemVariant(BOMComponent."No.");
      // [GIVEN] Create Purchase Orders on +10D for combinations: "CV" on "L1","CV" on "L2","C" on "L2","C" on "L1"
      CreatePurchaseOrders(BOMComponent."No.",ItemVariantCode,WorkDate10D,LocationCode1,LocationCode2);
      // [GIVEN] Create Purchase Order on WorkDate for "C" on "L1", Quantity = "Q"
      QtyOnPO := CreatePurchaseOrder(PurchaseHeader,BOMComponent."No.",'',RandInt,LocationCode1,WorkDate2);

      // [WHEN] Create Assembly Order for item "X" for location "L1"
      CreateAssemblyOrderOnSafeDate(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability Line: "Scheduled Receipts" = "Q", "Expected Inventory" = "Q"
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Scheduled Receipts",QtyOnPO);
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",QtyOnPO);
      // [THEN] "Able To Assemble" = ("Q" / "Qp")
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",QtyOnPO / BOMComponent."Quantity per");
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf)
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineScheduledReceiptsProductionOrders@148();
    VAR
      Item@1000 : Record 27;
      ProductionOrder@1004 : Record 5405;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1005 : Record 90;
      ExpAsmAvailTestBuf@1011 : Record 137093;
      QtyOnRPO@1006 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Component] [Quantity Per]
      // [SCENARIO 4230] "Scheduled Receipts" on the page line counts Production Orders
      Initialize;

      LocationCode := LocationRed.Code;
      // [GIVEN] Create the assembled Item "X" with a component "C"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Component's "Quantity per" = "Qp"
      SetRandComponentQuantityPer(BOMComponent);
      // [GIVEN] Create Production Order on +10D for "C" on "L1"
      CreateProdOrderAndRefresh(ProductionOrder,BOMComponent."No.",RandInt,LocationCode,WorkDate10D);
      // [GIVEN] Create Production Order for "C" on "L1", Quantity = "Q"
      QtyOnRPO := CreateProdOrderAndRefresh(ProductionOrder,BOMComponent."No.",RandInt,LocationCode,WorkDate2);

      // [WHEN] Create Assembly Order for item "X" for location "L1"
      CreateAssemblyOrderOnSafeDate(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability Line: "Scheduled Receipts" = "Q", "Expected Inventory" = "Q"
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Scheduled Receipts",QtyOnRPO);
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",QtyOnRPO);
      // [THEN] "Able To Assemble" = ("Q" / "Qp")
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",QtyOnRPO / BOMComponent."Quantity per");
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineScheduledReceiptsSalesReturnOrders@160();
    VAR
      Item@1000 : Record 27;
      SalesHeader@1004 : Record 36;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1009 : Record 90;
      ExpAsmAvailTestBuf@1011 : Record 137093;
      ItemVariantCode@1005 : Code[10];
      QtyOnSRO@1006 : Integer;
      LocationCode1@1003 : Code[10];
      LocationCode2@1002 : Code[10];
    BEGIN
      // [FEATURE] [Component] [Quantity Per]
      // [SCENARIO 4231] "Scheduled Receipts" on the page line counts Sales Return Orders
      Initialize;

      LocationCode1 := LocationRed.Code;
      LocationCode2 := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with a component "C"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Component's "Quantity per" = "Qp"
      SetRandComponentQuantityPer(BOMComponent);
      // [GIVEN] Create Component variant "CV", not in assembly list
      ItemVariantCode := CreateItemVariant(BOMComponent."No.");
      // [GIVEN] Create Sales Return Orders on +10D for combinations: "CV" on "L1","CV" on "L2","C" on "L1","C" on "L2"
      CreateSalesReturnOrders(BOMComponent."No.",ItemVariantCode,WorkDate10D,LocationCode1,LocationCode2);
      // [GIVEN] Create Sales Return Order on WorkDate for "C" on "L1", Quantity = "Q"
      QtyOnSRO := CreateSalesReturnOrder(SalesHeader,BOMComponent."No.",'',QtyOnSRO,LocationCode1,WorkDate2);

      // [WHEN] Create Assembly Order for item "X" for location "L1"
      CreateAssemblyOrderOnSafeDate(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability Line: "Scheduled Receipts" = "Q", "Expected Inventory" = "Q"
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Scheduled Receipts",QtyOnSRO);
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",QtyOnSRO);
      // [THEN] "Able To Assemble" = ("Q" / "Qp")
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",QtyOnSRO / BOMComponent."Quantity per");
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineScheduledReceiptsTransferOrders@163();
    VAR
      TransferHeader@1007 : Record 5740;
      Item@1000 : Record 27;
      AssemblyHeader@1001 : Record 900;
      BOMComponent@1008 : Record 90;
      ExpAsmAvailTestBuf@1011 : Record 137093;
      ItemVariantCode@1002 : Code[10];
      QtyOnTO@1004 : Integer;
      LocationCode1@1005 : Code[10];
      LocationCode2@1003 : Code[10];
    BEGIN
      // [FEATURE] [Component] [Quantity Per]
      // [SCENARIO 4232] "Scheduled Receipts" on the page line counts Transfer Orders
      Initialize;

      LocationCode1 := LocationRed.Code;
      LocationCode2 := LocationBlue.Code;
      // [GIVEN] Create the assembled Item "X" with a component "C"
      LibraryInventory.CreateItem(Item);
      AddComponent(Item,BOMComponent);
      // [GIVEN] Component's "Quantity per" = "Qp"
      SetRandComponentQuantityPer(BOMComponent);
      // [GIVEN] Create Component variant "CV", not in assembly list
      ItemVariantCode := CreateItemVariant(BOMComponent."No.");
      // [GIVEN] Create Transfer Orders for combinations: "CV" on "L1","CV" on "L2","C" on "L2"
      CreateTransferOrder(TransferHeader,BOMComponent."No.",ItemVariantCode,LocationCode1,LocationCode2,WorkDate2,RandInt);
      CreateTransferOrder(TransferHeader,BOMComponent."No.",ItemVariantCode,LocationCode2,LocationCode1,WorkDate2,RandInt);
      CreateTransferOrder(TransferHeader,BOMComponent."No.",'',LocationCode2,LocationCode1,WorkDate10D,RandInt);
      // [GIVEN] Create Transfer Order for "C" on moving from "L2" to "L1"
      QtyOnTO := CreateTransferOrder(TransferHeader,BOMComponent."No.",'',LocationCode2,LocationCode1,WorkDate2,RandInt);

      // [WHEN] Create Assembly Order for item "X" for location "L1"
      CreateAssemblyOrderOnSafeDate(AssemblyHeader,Item."No.",LocationCode1,'',WorkDate2,RandInt);

      // [THEN] Assembly Availability Line: "Scheduled Receipts" = "Q", "Expected Inventory" = "Q"
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Scheduled Receipts",QtyOnTO);
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",QtyOnTO);
      // [THEN] "Able To Assemble" = ("Q" / "Qp")
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",QtyOnTO / BOMComponent."Quantity per");
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AbleToAssembleQtyPerUOMAsmItem@166();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : ARRAY [2] OF Record 90;
      AssemblyHeader@1001 : Record 900;
      UnitOfMeasure@1010 : Record 204;
      ExpAsmAvailTestBuf@1012 : Record 137093;
      AbleToAssemble@1007 : ARRAY [2] OF Decimal;
      QtyOnInventory@1005 : ARRAY [2] OF Integer;
      QtyOnAssemble@1002 : Integer;
      QtyPerAsm@1011 : Integer;
      i@1006 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Quantity Per]
      // [SCENARIO 4233] "Able To Assemble" is calculated considering "Qty. Per Unit of Measure" of assembled Item
      Initialize;

      LocationCode := '';
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      // [GIVEN] Add another UOM, "Quantity per" = "Qp"
      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      QtyPerAsm := AddItemUOM(Item,UnitOfMeasure.Code);
      // [GIVEN] Add two components ("C1", "C2")
      FOR i := 1 TO 2 DO BEGIN
        AddComponent(Item,BOMComponent[i]);
        // [GIVEN] Component's "Quantity per" = ("Qp1", "Qp2")
        SetRandComponentQuantityPer(BOMComponent[i]);
        // [GIVEN] Add Inventory ("Q1", "Q2")
        QtyOnInventory[i] := RandInt;
        AddInventory(BOMComponent[i]."No.",'',LocationCode,QtyOnInventory[i]);
        AbleToAssemble[i] := QtyOnInventory[i] / (BOMComponent[i]."Quantity per" * QtyPerAsm);
      END;
      // [GIVEN] Create Assembly Order for item "X"
      QtyOnAssemble := QtyOnInventory[1] + QtyOnInventory[2];
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,QtyOnAssemble);

      // [WHEN] Change "Unit Of Measure Code" on Assembly Order header
      ChangeUOMOnAsmOrder(AssemblyHeader,UnitOfMeasure.Code);

      // [THEN] Assembly Availability header: "Able To Assemble" is minimal of "Able To Assemble" in lines
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",MinValue(AbleToAssemble[1],AbleToAssemble[2]));
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);
      // [THEN] Assembly Availability line: "Able To Assemble" = "Q1" / ("Qp1" * "Qp")
      FOR i := 1 TO 2 DO BEGIN
        CLEAR(ExpAsmAvailTestBuf);
        ExpAsmAvailTestBuf."Document Line No." := i;
        ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",QtyOnInventory[i]);
        ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",AbleToAssemble[i]);
        AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
      END;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AbleToAssembleQtyPerUOMComponent@175();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1004 : ARRAY [2] OF Record 90;
      AssemblyHeader@1001 : Record 900;
      UnitOfMeasure@1010 : Record 204;
      ExpAsmAvailTestBuf@1013 : Record 137093;
      AbleToAssemble@1008 : ARRAY [2] OF Decimal;
      QtyOnInventory@1005 : ARRAY [2] OF Integer;
      QtyOnAssemble@1002 : Integer;
      QtyPerComp@1007 : ARRAY [2] OF Integer;
      i@1006 : Integer;
      LocationCode@1003 : Code[10];
    BEGIN
      // [FEATURE] [Quantity Per]
      // [SCENARIO 4234] "Able To Assemble" is calculated considering "Qty. Per Unit of Measure" of components
      Initialize;

      LocationCode := '';
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      // [GIVEN] Add two components ("C1", "C2")
      FOR i := 1 TO 2 DO BEGIN
        AddComponent(Item,BOMComponent[i]);
        // [GIVEN] Component's "Quantity per" = ("Qp1", "Qp2")
        SetRandComponentQuantityPer(BOMComponent[i]);
        // [GIVEN] Add another UOM for Component, "Quantity Per UOM" = ("QU1", "QU2")
        LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
        QtyPerComp[i] := RandInt;
        AddComponentUOM(BOMComponent[i],QtyPerComp[i],UnitOfMeasure.Code);
        // [GIVEN] Add Inventory ("Q1", "Q2")
        QtyOnInventory[i] := RandInt;
        AddInventory(BOMComponent[i]."No.",'',LocationCode,QtyOnInventory[i]);
        AbleToAssemble[i] := QtyOnInventory[i] / (BOMComponent[i]."Quantity per" * QtyPerComp[i]);
      END;

      // [WHEN] Create Assembly Order for item "X"
      QtyOnAssemble := QtyOnInventory[1] + QtyOnInventory[2];
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,QtyOnAssemble);

      // [THEN] Assembly Availability header: "Able To Assemble" is minimal of "Able To Assemble" in lines
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",MinValue(AbleToAssemble[1],AbleToAssemble[2]));
      AssertAvailabilityHeader(AssemblyHeader,ExpAsmAvailTestBuf);
      // [THEN] Assembly Availability line: "Able To Assemble" = "Q1" / ("Qp1" * "QU1")
      FOR i := 1 TO 2 DO BEGIN
        ExpAsmAvailTestBuf."Document Line No." := i;
        ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",QtyOnInventory[i] / QtyPerComp[i]);
        ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",AbleToAssemble[i]);
        AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
      END;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AssemblyAvailabilityStaticData@186();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1006 : Record 90;
      AssemblyHeader@1001 : Record 900;
      LocationCode@1003 : Code[10];
    BEGIN
      // [SCENARIO] Assembly Availability header and line contains static data form the source Assembly Order
      Initialize;

      LocationCode := '';
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      // [GIVEN] Add first Component "C1"
      AddComponent(Item,BOMComponent);
      // [GIVEN] Add second Component "C2", "Quantity per" = "Qp"
      AddComponent(Item,BOMComponent);
      SetRandComponentQuantityPer(BOMComponent);
      // [GIVEN] Create Component Variant "C2V", include to assembly list asm list
      SetVariantOnComponent(BOMComponent,CreateItemVariant(BOMComponent."No."));

      // [WHEN] Create Assembly Order for Item "X"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,RandInt);

      // [THEN]  Assembly Availability page header and line contains correct values: Item No, Variant Code, Location Code, UOM, Quantity
      AssertAvailabilityHeaderStatic(AssemblyHeader);
      AssertAvailabilityLineStatic(AssemblyHeader,1);
      AssertAvailabilityLineStatic(AssemblyHeader,2);
      // [THEN] the Page contains two lines
      ASSERTERROR AssertAvailabilityLineStatic(AssemblyHeader,3);
      Assert.ExpectedError(AsmAvailBufNotExistsErr);
    END;

    [Test]
    [HandlerFunctions(CloseAvailabilityWindowHandler)]
    PROCEDURE AssemblyLineQtyWhenChangingUOMQuantityPer@190();
    VAR
      AssemblyLine@1007 : Record 901;
      Item@1000 : Record 27;
      BOMComponent@1006 : Record 90;
      AssemblyHeader@1001 : Record 900;
      UnitOfMeasure@1003 : Record 204;
      QtyOnAssemble@1004 : Integer;
      QtyPerAsm@1002 : Integer;
      ExpectedQtyPer@1005 : Decimal;
      LocationCode@1008 : Code[10];
    BEGIN
      // [FEATURE] [Quantity Per]
      // [SCENARIO] Assembly Line quantities are calculated considering "Quantity per" on Component and on assembled Item
      Initialize;

      LocationCode := LocationRed.Code;
      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      // [GIVEN] Add UOM "U2" for Item "X", where "Qty Per UOM" = "Qp"
      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      QtyPerAsm := AddItemUOM(Item,UnitOfMeasure.Code);
      // [GIVEN] Add Component "C" with UOM, where "Qty Per UOM" = "Qp1"
      AddComponent(Item,BOMComponent);
      SetRandComponentQuantityPer(BOMComponent);
      ExpectedQtyPer := BOMComponent."Quantity per" * QtyPerAsm;
      // [GIVEN] Create Assembly Order for Item "X", Quantity = "Q"
      QtyOnAssemble := CreateAssemblyOrder(AssemblyHeader,Item."No.",LocationCode,'',WorkDate2,RandInt);

      // [WHEN] Change Assembly Header's "Unit of Measure" to "U2"
      ChangeUOMOnAsmOrder(AssemblyHeader,UnitOfMeasure.Code);

      // [THEN] Assembly Line: "Quantity per" = ("Qp" * "Qp1")
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.FINDFIRST;
      Assert.AreEqual(
        ExpectedQtyPer,AssemblyLine."Quantity per",STRSUBSTNO(WrongValueInAsmLineErr,AssemblyLine.FIELDNAME("Quantity per")));
      // [THEN] Assembly Line: "Quantity","Quantity to Consume","Remaining Quantity" = ("Quantity per" * "Q")
      Assert.AreEqual(
        ExpectedQtyPer * QtyOnAssemble,AssemblyLine.Quantity,STRSUBSTNO(WrongValueInAsmLineErr,AssemblyLine.FIELDNAME(Quantity)));
      Assert.AreEqual(
        ExpectedQtyPer * QtyOnAssemble,AssemblyLine."Quantity to Consume",
        STRSUBSTNO(WrongValueInAsmLineErr,AssemblyLine.FIELDNAME("Quantity to Consume")));
      Assert.AreEqual(
        ExpectedQtyPer * QtyOnAssemble,AssemblyLine."Remaining Quantity",
        STRSUBSTNO(WrongValueInAsmLineErr,AssemblyLine.FIELDNAME("Remaining Quantity")));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineAbleToAssembleAfterPostedOrderUndo@25();
    VAR
      Item@1000 : Record 27;
      BOMComponent@1006 : Record 90;
      AssemblyHeader@1001 : Record 900;
      PostedAssemblyHeader@1002 : Record 910;
      ExpAsmAvailTestBuf@1005 : Record 137093;
      QtyOnAssemble@1004 : Integer;
    BEGIN
      // [FEATURE] [Undo Assembly Order]
      // [SCENARIO] "Able To Assemble" on page line is calculated correctly after Undo of posted Assembly Order
      Initialize;

      // [GIVEN] Create the assembled Item "X"
      LibraryInventory.CreateItem(Item);
      // [GIVEN] Add Component "C" , "Quantity per" = "Qp"
      AddComponent(Item,BOMComponent);
      SetRandComponentQuantityPer(BOMComponent);
      // [GIVEN] Add Component to inventory, enough to assemble "QA" psc, Quantity = ("QA" * "Qp")
      QtyOnAssemble := RandInt;
      AddInventory(BOMComponent."No.",'','',BOMComponent."Quantity per" * QtyOnAssemble);
      // [GIVEN] Create Assembly Order for Item "X", Quantity = "QA"
      CreateAssemblyOrder(AssemblyHeader,Item."No.",'','',WorkDate2,QtyOnAssemble);
      // [GIVEN] Post half Assembly Order
      PostAssemblyOrderQty(AssemblyHeader,QtyOnAssemble / 2);

      // [GIVEN] Undo Assembly Order and delete it
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,'');
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      AssemblyHeader.DELETE(TRUE);

      // [WHEN] Create new Assembly Order for Item "X", Quantity = ("QA" + 1) to cause Availability page
      CreateAssemblyOrder(AssemblyHeader,Item."No.",'','',WorkDate2,QtyOnAssemble + 1);

      // [THEN] Assembly Availability page is shown: "Expected Inventory" = ("QA" * "Qp"), "Able To Assemble" = "QA"
      ExpAsmAvailTestBuf.INIT;
      ExpAsmAvailTestBuf."Document Line No." := 1;
      ExpAsmAvailTestBuf.VALIDATE("Expected Inventory",BOMComponent."Quantity per" * QtyOnAssemble);
      ExpAsmAvailTestBuf.VALIDATE("Able To Assemble",QtyOnAssemble);
      AssertAvailabilityLine(AssemblyHeader,ExpAsmAvailTestBuf);
    END;

    [ModalPageHandler]
    PROCEDURE AvailabilityWindowHandler@48(VAR AsmAvailability@1000 : TestPage 908);
    BEGIN
      TempAsmAvailTestBuf.ReadDataFromPage(AsmAvailability);
      AsmAvailability.Yes.INVOKE; // always accept
    END;

    [ModalPageHandler]
    PROCEDURE CloseAvailabilityWindowHandler@115(VAR AsmAvailability@1000 : TestPage 908);
    BEGIN
      AsmAvailability.Yes.INVOKE;
    END;

    LOCAL PROCEDURE ComponentsAvailable@184(AssemblyHeader@1000 : Record 900) : Boolean;
    VAR
      LibraryAssembly@1001 : Codeunit 132207;
    BEGIN
      EXIT(LibraryAssembly.ComponentsAvailable(AssemblyHeader));
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [Item Availability] [SCM]
      This CU is covering the chapter 3.1.5 in the Test Design Specification of Kitting, as per the following:
      SC41x: Basic availability scenarios.
    }
    END.
  }
}

