OBJECT Codeunit 137912 SCM Assembly Availability II
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            Initialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      Assert@1005 : Codeunit 130000;
      FirstNumber@1001 : TextConst 'ENU=137912-001';
      LibraryAssembly@1042 : Codeunit 132207;
      LibraryInventory@1040 : Codeunit 132201;
      LibraryManufacturing@1041 : Codeunit 132202;
      LibraryPurchase@1002 : Codeunit 130512;
      LibraryWarehouse@1007 : Codeunit 132204;
      TestMethodName@1004 : Text[30];
      Step@1003 : Integer;
      CnfmUpdateLocationOnLines@1006 : TextConst 'ENU=Do you want to update the Location Code on the lines?';
      CnfmChangeOfItemNo@1008 : TextConst 'ENU=Changing Item No. will change all the lines. Do you want to change the Item No.';
      CnfmRefreshLines@1017 : TextConst 'ENU=This assembly order may have customized lines. Are you sure that you want to reset the lines according to the assembly BOM?';
      SubStep@1009 : Integer;
      ErrUpdateInterrupted@1012 : TextConst 'ENU=The update has been interrupted to respect the warning.';
      SupplyDate1@1011 : Date;
      SupplyQty1@1013 : Decimal;
      SupplyDate2@1010 : Date;
      SupplyQty2@1014 : Decimal;
      DemandDate@1015 : Date;
      DemandQty@1016 : Decimal;
      TestMethodVSTF238977@1018 : TextConst 'ENU=TestMethod: VSTF238977';
      TestVSTF257960A@1032 : TextConst 'ENU=VSTF257960A';
      CnfmStartingDateChanged@1019 : TextConst 'ENU=You have modified the Starting Date from %1 to %2. Do you want to update the Ending Date from %3 to %4 and the Due Date from %5 to %6?';
      CnfmEndingDateChanged@1020 : TextConst 'ENU=You have modified the Ending Date from %1 to %2. Do you want to update the Due Date from %3 to %4?';
      ErrEndDateBeforeStartDate@1021 : TextConst 'ENU=Ending Date %1 is before Starting Date %2.';
      ErrDueDateBeforeEndDate@1022 : TextConst 'ENU=Due Date %1 is before Ending Date %2.';
      ErrLineDueDateBeforeStartDate@1023 : TextConst 'ENU=Due Date cannot be later than %1 because the Starting Date is set to %2.';
      OldDueDate@1024 : Date;
      NewDueDate@1025 : Date;
      OldEndDate@1026 : Date;
      NewEndDate@1027 : Date;
      OldStartDate@1028 : Date;
      NewStartDate@1029 : Date;
      MsgDueDateBeforeWDFromLine@1030 : TextConst 'ENU=Due Date %1 is before work date %2.';
      MsgDueDateBeforeWDFromHeader@1031 : TextConst 'ENU=Due Date %1 is before work date %2 in one or more of the assembly lines.';
      NewLineDueDate@1033 : Date;
      TestVSTF257960B@1034 : TextConst 'ENU=VSTF257960B';
      TestDataConsistencyCheck@1035 : TextConst 'ENU=DataConsistencyCheck';
      TestVSTF266309@1036 : TextConst 'ENU=VSTF266309';
      TestMsgAvailConfirm@1037 : TextConst 'ENU="Availability warning at step = %1."';
      DateFormula1D@1038 : TextConst 'ENU=1D';
      Initialized@1039 : Boolean;

    [Normal]
    LOCAL PROCEDURE Initialize@43();
    VAR
      LibraryERMCountryData@1000 : Codeunit 131305;
    BEGIN
      IF Initialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;

      Initialized := TRUE;
      COMMIT;
    END;

    [Test]
    [HandlerFunctions(AvailWarningConfirm,UpdateLocationOnLines,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE ChangeLocCheckDueDateNoLineUpd@1();
    VAR
      ParentItem@1000 : Record 27;
      ChildItem@1001 : Record 27;
      AsmHeader@1003 : Record 900;
      AsmLine@1009 : Record 901;
      Location@1002 : Record 14;
      OldDueDate@1011 : Date;
      OldLineLocation@1010 : Code[10];
      VariantCode@1012 : Code[10];
      LeadTimeText@1008 : Text[2];
    BEGIN
      Initialize;
      TestMethodName := 'ChangeLocCheckDueDateNoLineUpd';
      MockAsmItem(ParentItem,ChildItem,1);
      Step := 1;
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,'');
      AsmHeader.VALIDATE("Due Date",GetDate('1M',AsmHeader."Due Date"));
      AsmHeader.MODIFY(TRUE);
      OldDueDate := AsmHeader."Due Date";
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line
      OldLineLocation := AsmLine."Location Code";

      // create a location and then an SKU with lead time = 1M
      LeadTimeText := '5D';
      MockSKUWithLeadTime(ParentItem,Location,LeadTimeText,VariantCode);

      // update location on asm header, but DO NOT UPDATE on lines.
      Step := 2;
      AsmHeader.VALIDATE("Location Code",Location.Code);
      AsmHeader.MODIFY(TRUE);
      AsmHeader.VALIDATE("Variant Code",VariantCode);
      AsmHeader.MODIFY(TRUE);
      Assert.AreEqual(GetDate('-' + LeadTimeText,OldDueDate),AsmHeader."Starting Date",'Starting dates are not equal.');
      Assert.AreEqual(GetDate('-' + LeadTimeText,OldDueDate),AsmHeader."Ending Date",'Ending dates are not equal.');
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line
      Assert.AreEqual(OldLineLocation,AsmLine."Location Code",'Line location is not updated.');
      Assert.AreEqual(AsmHeader."Starting Date",AsmLine."Due Date",'Line Due dates are not equal.');
    END;

    [Test]
    [HandlerFunctions(AvailWarningConfirm,UpdateLocationOnLines,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE ChangeLocCheckDueDateLineUpd@2();
    VAR
      ParentItem@1009 : Record 27;
      ChildItem@1008 : Record 27;
      AsmHeader@1007 : Record 900;
      AsmLine@1006 : Record 901;
      Location@1005 : Record 14;
      OldDueDate@1004 : Date;
      VariantCode@1011 : Code[10];
      LeadTimeText@1000 : Text[2];
    BEGIN
      Initialize;
      TestMethodName := 'ChangeLocCheckDueDateLineUpd';
      MockAsmItem(ParentItem,ChildItem,1);
      Step := 1;
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,'');
      AsmHeader.VALIDATE("Due Date",GetDate('1M',AsmHeader."Due Date"));
      AsmHeader.MODIFY(TRUE);
      OldDueDate := AsmHeader."Due Date";
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line

      // create a location and then an SKU with lead time = 1M
      LeadTimeText := '5D';
      MockSKUWithLeadTime(ParentItem,Location,LeadTimeText,VariantCode);

      // update location on asm header, but DO UPDATE on lines.
      Step := 2;
      AsmHeader.VALIDATE("Location Code",Location.Code);
      AsmHeader.MODIFY(TRUE);
      AsmHeader.VALIDATE("Variant Code",VariantCode);
      AsmHeader.MODIFY(TRUE);
      Assert.AreEqual(GetDate('-' + LeadTimeText,OldDueDate),AsmHeader."Starting Date",'Starting dates are not equal.');
      Assert.AreEqual(GetDate('-' + LeadTimeText,OldDueDate),AsmHeader."Ending Date",'Ending dates are not equal.');
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line
      Assert.AreEqual(AsmHeader."Location Code",AsmLine."Location Code",'Line location is updated.');
      Assert.AreEqual(AsmHeader."Starting Date",AsmLine."Due Date",'Line Due dates are not equal.');
    END;

    [Test]
    [HandlerFunctions(AvailWarningConfirm,UpdateLocationOnLines,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE ValidateLocAfterSKUNewDueDate@7();
    VAR
      ParentItem@1000 : Record 27;
      ChildItem@1001 : Record 27;
      AsmHeader@1002 : Record 900;
      AsmLine@1003 : Record 901;
      Location@1004 : Record 14;
      StockkeepingUnit@1008 : Record 5700;
      OldDueDate@1005 : Date;
      VariantCode@1011 : Code[10];
      LeadTimeText@1009 : Text[30];
      LeadTime@1010 : DateFormula;
    BEGIN
      Initialize;
      TestMethodName := 'ValidateLocAfterSKUNewDueDate';
      MockAsmItem(ParentItem,ChildItem,1);
      Step := 1;
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,'');
      AsmHeader.VALIDATE("Due Date",GetDate('1M',AsmHeader."Due Date"));
      AsmHeader.MODIFY(TRUE);

      // set a variant and location SKU with no lead time.
      Step := 2;
      MockSKUWithLeadTime(ParentItem,Location,'0D',VariantCode);
      AsmHeader.VALIDATE("Location Code",Location.Code);
      AsmHeader.MODIFY(TRUE);
      AsmHeader.VALIDATE("Variant Code",VariantCode);
      AsmHeader.MODIFY(TRUE);

      OldDueDate := AsmHeader."Due Date";
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line

      // set SKU for parent with lead time = 5D.
      StockkeepingUnit.GET(Location.Code,ParentItem."No.",AsmHeader."Variant Code");
      LeadTimeText := '5D';
      EVALUATE(LeadTime,'<' + LeadTimeText + '>');
      StockkeepingUnit.VALIDATE("Safety Lead Time",LeadTime);
      StockkeepingUnit.MODIFY(TRUE);

      // update location on asm header, but DO UPDATE on lines.
      Step := 3;
      AsmHeader.VALIDATE("Location Code",Location.Code); // expect no update warning on the validate - dont handle in ConfirmHandler
      AsmHeader.MODIFY(TRUE);
      Assert.AreEqual(GetDate('-' + LeadTimeText,OldDueDate),AsmHeader."Starting Date",'Starting dates are not equal.');
      Assert.AreEqual(GetDate('-' + LeadTimeText,OldDueDate),AsmHeader."Ending Date",'Ending dates are not equal.');
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line
      Assert.AreEqual(AsmHeader."Location Code",AsmLine."Location Code",'Line location is updated.');
      Assert.AreEqual(AsmHeader."Starting Date",AsmLine."Due Date",'Line Due dates are not equal.');
    END;

    [Test]
    [HandlerFunctions(AvailWarningConfirm,UpdateLocationOnLines,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE ChangeVariantNoLocUpdConfirm@9();
    VAR
      ParentItem@1000 : Record 27;
      ChildItem@1001 : Record 27;
      AsmHeader@1002 : Record 900;
      AsmLine@1003 : Record 901;
      LocationHeader@1004 : Record 14;
      LocationLine@1005 : Record 14;
      VariantCode@1011 : Code[10];
    BEGIN
      Initialize;
      TestMethodName := 'ChangeVariantNoLocUpdConfirm';
      MockAsmItem(ParentItem,ChildItem,1);
      Step := 1;
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,'');

      // set a variant and location SKU with no lead time.
      Step := 2;
      MockSKUWithLeadTime(ParentItem,LocationHeader,'0D',VariantCode);
      AsmHeader.VALIDATE("Location Code",LocationHeader.Code);
      AsmHeader.MODIFY(TRUE);

      // set line with different location code
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line
      MockLocation(LocationLine);
      AsmLine.VALIDATE("Location Code",LocationLine.Code);
      AsmLine.MODIFY(TRUE);

      // change variant code on header
      Step := 3;
      AsmHeader.VALIDATE("Variant Code",VariantCode); // expect no update warning on location - dont handle in ConfirmHandler
      AsmHeader.MODIFY(TRUE);
    END;

    [Test]
    [HandlerFunctions(AvailWarningConfirm,UpdateLocationOnLines,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE DataConsistencyCheck@11();
    VAR
      ParentItem@1004 : Record 27;
      ChildItem@1003 : Record 27;
      AsmHeader@1002 : Record 900;
      Location@1000 : Record 14;
    BEGIN
      Initialize;
      TestMethodName := TestDataConsistencyCheck;
      MockAsmItem(ParentItem,ChildItem,1);
      Step := 1;
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,'');

      // change location code on the header
      Step := 2;
      MockLocation(Location);
      // make the availability confirmation appear, and there change lines to get error
      ASSERTERROR AsmHeader.VALIDATE("Location Code",Location.Code);
      Assert.ExpectedErrorCode('DB:RecordChanged');
    END;

    [Test]
    [HandlerFunctions(AvailWarningConfirm,ConfirmChangeOfItem,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE ValidateItemNoToParentItem@13();
    VAR
      ParentItem@1002 : Record 27;
      ChildItem@1001 : Record 27;
      ParentParentItem@1003 : Record 27;
      AsmHeader@1000 : Record 900;
      AsmLine@1005 : Record 901;
      BOMComponent@1004 : Record 90;
    BEGIN
      Initialize;
      TestMethodName := 'ValidateItemNoToParentItem';
      MockAsmItem(ParentItem,ChildItem,1);
      AddItemToInventory(ChildItem,'','',1);
      Step := 1;
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,'');

      // create parent of parent item
      MockItem(ParentParentItem);
      ParentParentItem.VALIDATE("Replenishment System",ParentParentItem."Replenishment System"::Assembly);
      ParentParentItem.MODIFY(TRUE);
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentParentItem."No.",BOMComponent.Type::Item,
        ParentItem."No.",1,ParentItem."Base Unit of Measure");

      // change asm header from parent item to parent of parent item
      Step := 2;
      AsmHeader.VALIDATE("Item No.",ParentParentItem."No."); // should show availability warning
      AsmHeader.MODIFY(TRUE);

      // verify lines have been changed.
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line
      Assert.AreEqual(ParentItem."No.",AsmLine."No.",'Asm line should have parent item.');
    END;

    [Test]
    [HandlerFunctions(AvailWarningConfirm,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE VSTF238472@22();
    VAR
      ParentItem@1002 : Record 27;
      ChildItem@1001 : Record 27;
      AsmHeader@1000 : Record 900;
    BEGIN
      Initialize;
      TestMethodName := 'VSTF238472';
      // Create an "assembled item" with one comp (Qty per =2)
      MockAsmItem(ParentItem,ChildItem,2);
      Step := 1;
      // Create a new assembly order for the new item. Qty = 2
      MockAsmOrder(AsmHeader,ParentItem,2,WORKDATE,''); // avail warning should open
      Step := 2;
      // Select Unit of measure field on the assembly order header and without changing something, press tab.
      AsmHeader.VALIDATE("Unit of Measure Code"); // should not open avail warning
    END;

    [Test]
    [HandlerFunctions(DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE VSTF231811@24();
    VAR
      ParentItem@1002 : Record 27;
      ChildItem@1001 : Record 27;
      AsmHeader@1000 : Record 900;
      AsmLine@1003 : Record 901;
    BEGIN
      Initialize;
      TestMethodName := 'VSTF231811';
      // Create assembled item with one comp (qty per = 2).
      MockAsmItem(ParentItem,ChildItem,2);
      // Add 2 PCS of component to inventory
      AddItemToInventory(ChildItem,'','',2);
      // Create assembly order. Qty = 1
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,'');
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line
      // Change the Qty per on the line to 3.
      AsmLine.VALIDATE("Quantity per",3);
      Assert.IsTrue(AsmLine."Avail. Warning",'Avail. warning should be Yes');
      // Change the Qty per on the line back to 2 (or 1).
      AsmLine.VALIDATE("Quantity per",2);
      Assert.IsFalse(AsmLine."Avail. Warning",'Avail. warning should be No');
      AsmLine.VALIDATE("Quantity per",1);
      Assert.IsFalse(AsmLine."Avail. Warning",'Avail. warning should be No');
    END;

    [Test]
    [HandlerFunctions(AvailWarningConfirm,ConfirmRefreshLines,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE VSTF255987@27();
    VAR
      ParentItem@1003 : Record 27;
      ChildItem@1002 : Record 27;
      AsmHeader@1001 : Record 900;
      AsmLine@1000 : Record 901;
    BEGIN
      Initialize;
      TestMethodName := 'VSTF255987';
      // Create assembled item with one comp (qty per = 1).
      MockAsmItem(ParentItem,ChildItem,1);
      Step := 1;
      // Create assembly order. Qty = 1
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,'');
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line
      Step := 2;
      // Change the Qty per on the line to 3.
      AsmLine.VALIDATE("Quantity per",3); // accept avail. warning by handler
      AsmLine.MODIFY(TRUE);
      Step := 3;
      // Refresh Asm header.
      AsmHeader.RefreshBOM; // say No to confirm - expect no avail. warning
      // verify line has NOT been changed.
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line
      Assert.AreEqual(3,AsmLine."Quantity per",'Quantity per should be the same as set above. Assert at Step = ' + FORMAT(Step));
      Step := 4;
      // Refresh Asm header.
      AsmHeader.RefreshBOM; // say Yes to confirm - expect avail. warning
      // verify line has been changed.
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first line
      Assert.AreEqual(1,AsmLine."Quantity per",'Quantity per should be the same as Assembly BOM. Assert at Step = ' + FORMAT(Step));
    END;

    [Test]
    [HandlerFunctions(DateConfirmationHandler)]
    PROCEDURE VSTF258428@28();
    VAR
      ParentItem@1000 : Record 27;
      Location@1001 : Record 14;
      StockkeepingUnit@1002 : Record 5700;
      MfgSetup@1003 : Record 99000765;
      AsmHeader@1004 : Record 900;
      DTFormula@1005 : DateFormula;
      NewStartDate2@1006 : Date;
      NewEndDate2@1007 : Date;
      NewDueDate2@1008 : Date;
      OldDefSafetyLeadTime@1009 : DateFormula;
    BEGIN
      Initialize;
      TestMethodName := 'VSTF258428';
      Step := 0;
      // Create item KIT with Replenishment System = Assembly
      MockItem(ParentItem);
      ParentItem.VALIDATE("Replenishment System",ParentItem."Replenishment System"::Assembly);
      ParentItem.MODIFY(TRUE);
      // Create SKU for KIT @ BLUE with Safety Lead Time = 3D and Lead Time Calculation =4D
      MockLocation(Location);
      LibraryInventory.CreateStockkeepingUnitForLocationAndVariant(StockkeepingUnit,Location.Code,ParentItem."No.",'');
      EVALUATE(DTFormula,'3D');
      StockkeepingUnit.VALIDATE("Safety Lead Time",DTFormula);
      EVALUATE(DTFormula,'4D');
      StockkeepingUnit.VALIDATE("Lead Time Calculation",DTFormula);
      StockkeepingUnit.MODIFY(TRUE);
      // Change manufacturing Default Safety Lead Time = 2D
      OldDefSafetyLeadTime := MfgSetup."Default Safety Lead Time";
      EVALUATE(DTFormula,'2D');
      MfgSetup.GET;
      MfgSetup.VALIDATE("Default Safety Lead Time",DTFormula);
      MfgSetup.MODIFY(TRUE);
      // Create asm order for KIT with due date = WorkDate, Location=Blank.
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,'');
      Assert.AreEqual(WORKDATE,AsmHeader."Due Date",'Due Date = WorkDate');
      EVALUATE(DTFormula,'-2D');
      Assert.AreEqual(CALCDATE(DTFormula,WORKDATE),AsmHeader."Ending Date",'Ending Date = WorkDate - 2D');
      Assert.AreEqual(AsmHeader."Ending Date",AsmHeader."Starting Date",'Starting Date = Ending Date');
      // Change location code on header = BLUE
      AsmHeader.VALIDATE("Location Code",Location.Code);
      Assert.AreEqual(WORKDATE,AsmHeader."Due Date",'Due Date = WorkDate');
      EVALUATE(DTFormula,'-3D');
      Assert.AreEqual(CALCDATE(DTFormula,AsmHeader."Due Date"),AsmHeader."Ending Date",'Ending Date = Due date - 3D (SKU safety lead time)');
      EVALUATE(DTFormula,'-4D');
      Assert.AreEqual(CALCDATE(DTFormula,AsmHeader."Ending Date"),AsmHeader."Starting Date",'Starting Date = Ending Date - 4D (SKU Lead Time Calculation)');

      // Extension based on repro of Bug 257960
      // Change due date on header = WORKDATE + 1M
      Step := 1;
      EVALUATE(DTFormula,'+1M');
      AsmHeader.VALIDATE("Due Date",CALCDATE(DTFormula,WORKDATE));
      EVALUATE(DTFormula,'-3D');
      Assert.AreEqual(CALCDATE(DTFormula,AsmHeader."Due Date"),AsmHeader."Ending Date",'Ending Date = Due date - 3D (SKU safety lead time)');
      EVALUATE(DTFormula,'-4D');
      Assert.AreEqual(CALCDATE(DTFormula,AsmHeader."Ending Date"),AsmHeader."Starting Date",'Starting Date = Ending Date - 4D (SKU Lead Time Calculation)');
      // Change starting date to WORKDATE - 2D
      Step := 2;
      EVALUATE(DTFormula,'-2D');
      NewStartDate2 := CALCDATE(DTFormula,WORKDATE);
      EVALUATE(DTFormula,'+4D');
      NewEndDate2 := CALCDATE(DTFormula,NewStartDate2);
      EVALUATE(DTFormula,'+3D');
      NewDueDate2 := CALCDATE(DTFormula,NewEndDate2);
      SetGlobalDates(AsmHeader,NewDueDate2,NewEndDate2,NewStartDate2,NewStartDate2);
      AsmHeader.VALIDATE("Starting Date",NewStartDate);
      Assert.AreEqual(NewEndDate,AsmHeader."Ending Date",'Ending Date = Starting date + 4D (SKU Lead Time Calculation)');
      Assert.AreEqual(NewDueDate,AsmHeader."Due Date",'Due Date = Ending date + 3D (SKU safety lead time)');
      // Change Due date to WORKDATE and then Change Ending Date to WORKDATE.
      Step := 3;
      AsmHeader.VALIDATE("Due Date",WORKDATE);
      Step := 4;
      NewEndDate2 := WORKDATE;
      EVALUATE(DTFormula,'-4D');
      NewStartDate2 := CALCDATE(DTFormula,NewEndDate2);
      EVALUATE(DTFormula,'+3D');
      NewDueDate2 := CALCDATE(DTFormula,NewEndDate2);
      SetGlobalDates(AsmHeader,NewDueDate2,NewEndDate2,NewStartDate2,NewStartDate2);
      AsmHeader.VALIDATE("Ending Date",NewEndDate);
      Assert.AreEqual(NewStartDate,AsmHeader."Starting Date",'Starting Date = Ending date - 4D (SKU Lead Time Calculation)');
      Assert.AreEqual(NewDueDate,AsmHeader."Due Date",'Due Date = Ending date + 3D (SKU safety lead time)');

      ASSERTERROR ERROR(''); // to restore Mfg Setup Default Safety Lead time to original value

      // set data back to original
      MfgSetup.VALIDATE("Default Safety Lead Time",OldDefSafetyLeadTime);
      MfgSetup.MODIFY(TRUE);
    END;

    [Test]
    [HandlerFunctions(AvailWarningConfirm,VSTF238977ConfirmHandler)]
    PROCEDURE VSTF238977@29();
    VAR
      ParentItem@1002 : Record 27;
      ChildItem@1001 : Record 27;
      AsmHeader@1000 : Record 900;
      AsmLine@1003 : Record 901;
      MfgSetup@1004 : Record 99000765;
    BEGIN
      Initialize;
      TestMethodName := TestMethodVSTF238977;
      // Create assembled item with one comp (qty per = 1).
      MockAsmItem(ParentItem,ChildItem,1);
      // Make purchase order for 10 PCS with expected rcpt date = workdate + 1M
      MockPurchOrder(ChildItem."No.",10,'',CALCDATE('<+1M>',WORKDATE));
      // Create assembly order. Qty = 1
      Step := 1;
      MfgSetup.GET;
      MockAsmOrder(AsmHeader,ParentItem,1,CALCDATE(MfgSetup."Default Safety Lead Time",WORKDATE),''); // to avoid the message about due date being before work date
      Step := 2;
      // Set due date on the line to 1W before the expected rcpt date of the purchase
      AsmHeader.VALIDATE("Starting Date",CALCDATE('<+1M-1W>',WORKDATE));
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get the only line
      Assert.AreEqual(TRUE,AsmLine."Avail. Warning",'');
      // Set due date on the line to 1W after the expected rcpt date of the purchase
      AsmHeader.VALIDATE("Starting Date",CALCDATE('<+1M+1W>',WORKDATE));
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get the only line
      Assert.AreEqual(FALSE,AsmLine."Avail. Warning",'');
    END;

    [ConfirmHandler]
    PROCEDURE VSTF238977ConfirmHandler@35(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [Test]
    [HandlerFunctions(DateConfirmationHandler,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE VSTF257960A@33();
    VAR
      ParentItem@1006 : Record 27;
      ChildItem@1008 : Record 27;
      BOMComponent@1009 : Record 90;
      Location@1005 : Record 14;
      StockkeepingUnit@1004 : Record 5700;
      AsmHeader@1003 : Record 900;
      AsmLine@1015 : Record 901;
      SafetyLeadTime@1000 : DateFormula;
      LeadTimeCalc@1001 : DateFormula;
      LeadTimeOffset@1002 : DateFormula;
      OldWorkDate@1007 : Date;
      DTFormula@1010 : DateFormula;
      ExpDueDate@1011 : Date;
      ExpEndDate@1012 : Date;
      ExpStartDate@1013 : Date;
      ExpLineDueDate@1014 : Date;
      SavedDueDate@1016 : Date;
      SavedEndDate@1017 : Date;
      SavedStartDate@1018 : Date;
      SavedLineDueDate@1019 : Date;
    BEGIN
      Initialize;
      TestMethodName := TestVSTF257960A;
      Step := 0;
      OldWorkDate := WORKDATE;
      WORKDATE := CALCDATE('<CY-1Y+7D>',WORKDATE);

      // SETUP
      EVALUATE(SafetyLeadTime,'<1D>');
      EVALUATE(LeadTimeCalc,'<4D>');
      EVALUATE(LeadTimeOffset,'<1D>');
      // Create item KIT with Replenishment System = Assembly with components and lead time offset
      MockAsmItem(ParentItem,ChildItem,1);
      BOMComponent.GET(ParentItem."No.",10000);
      BOMComponent.VALIDATE("Lead-Time Offset",LeadTimeOffset);
      BOMComponent.MODIFY(TRUE);
      // Make enough inventory for component.
      MockLocation(Location);
      AddItemToInventory(ChildItem,Location.Code,'',10);
      // Create SKU for KIT @ BLUE with Safety Lead Time and Lead Time Calculation
      LibraryInventory.CreateStockkeepingUnitForLocationAndVariant(StockkeepingUnit,Location.Code,ParentItem."No.",'');
      StockkeepingUnit.VALIDATE("Safety Lead Time",SafetyLeadTime);
      StockkeepingUnit.VALIDATE("Lead Time Calculation",LeadTimeCalc);
      StockkeepingUnit.MODIFY(TRUE);
      // Create asm order for KIT with due date = WORKDATE + 8D
      Step := 1;
      EVALUATE(DTFormula,'<+8D>');
      ExpDueDate := CALCDATE(DTFormula,WORKDATE);
      MockAsmOrder(AsmHeader,ParentItem,1,ExpDueDate,Location.Code);
      ExpEndDate := ShiftDateBackBy(SafetyLeadTime,ExpDueDate);
      ExpStartDate := ShiftDateBackBy(LeadTimeCalc,ExpEndDate);
      ExpLineDueDate := ShiftDateBackBy(LeadTimeOffset,ExpStartDate);
      SetGlobalDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      VSTF257960AVerifyDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      SavedDueDate := AsmHeader."Due Date";
      SavedEndDate := AsmHeader."Ending Date";
      SavedStartDate := AsmHeader."Starting Date";
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000);
      SavedLineDueDate := AsmLine."Due Date";
      COMMIT; // save the state as the rest of the test method uses this data.

      // EXERCISE
      // Push starting date 2 days in the future.
      Step := 2;
      EVALUATE(DTFormula,'<+2D>');
      ExpStartDate := CALCDATE(DTFormula,AsmHeader."Starting Date");
      ExpEndDate := CALCDATE(LeadTimeCalc,ExpStartDate);
      ExpDueDate := CALCDATE(SafetyLeadTime,ExpEndDate);
      ExpLineDueDate := ShiftDateBackBy(LeadTimeOffset,ExpStartDate);
      SetGlobalDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      AsmHeader.VALIDATE("Starting Date",ExpStartDate);
      VSTF257960AVerifyDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      // revert back to original setup
      ASSERTERROR ERROR('');

      // Push starting date by 6 days in the future.
      Step := 3;
      EVALUATE(DTFormula,'<+6D>');
      ExpStartDate := CALCDATE(DTFormula,AsmHeader."Starting Date");
      ExpEndDate := CALCDATE(LeadTimeCalc,ExpStartDate);
      ExpDueDate := CALCDATE(SafetyLeadTime,ExpEndDate);
      ExpLineDueDate := ShiftDateBackBy(LeadTimeOffset,ExpStartDate);
      SetGlobalDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      ASSERTERROR AsmHeader.VALIDATE("Starting Date",ExpStartDate);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,STRSUBSTNO(ErrEndDateBeforeStartDate,AsmHeader."Ending Date",ExpStartDate)) > 0,'');

      // Pull starting date by 1D in the past.
      Step := 4;
      EVALUATE(DTFormula,'<-1D>');
      ExpStartDate := CALCDATE(DTFormula,AsmHeader."Starting Date");
      ExpEndDate := CALCDATE(LeadTimeCalc,ExpStartDate);
      ExpDueDate := CALCDATE(SafetyLeadTime,ExpEndDate);
      ExpLineDueDate := ShiftDateBackBy(LeadTimeOffset,ExpStartDate);
      SetGlobalDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      AsmHeader.VALIDATE("Starting Date",ExpStartDate);
      VSTF257960AVerifyDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      // revert back to original setup
      ASSERTERROR ERROR('');

      // Pull ending date by 1D in the past.
      Step := 5;
      EVALUATE(DTFormula,'<-1D>');
      ExpEndDate := CALCDATE(DTFormula,AsmHeader."Ending Date");
      ExpStartDate := ShiftDateBackBy(LeadTimeCalc,ExpEndDate);
      ExpDueDate := CALCDATE(SafetyLeadTime,ExpEndDate);
      ExpLineDueDate := ShiftDateBackBy(LeadTimeOffset,ExpStartDate);
      SetGlobalDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      AsmHeader.VALIDATE("Ending Date",ExpEndDate);
      VSTF257960AVerifyDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      // revert back to original setup
      ASSERTERROR ERROR('');

      // Push ending date by 2D in the future.
      Step := 6;
      EVALUATE(DTFormula,'<+2D>');
      ExpEndDate := CALCDATE(DTFormula,AsmHeader."Ending Date");
      ExpStartDate := ShiftDateBackBy(LeadTimeCalc,ExpEndDate);
      ExpDueDate := CALCDATE(SafetyLeadTime,ExpEndDate);
      ExpLineDueDate := ShiftDateBackBy(LeadTimeOffset,ExpStartDate);
      SetGlobalDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      ASSERTERROR AsmHeader.VALIDATE("Ending Date",ExpEndDate);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,STRSUBSTNO(ErrDueDateBeforeEndDate,AsmHeader."Due Date",ExpEndDate)) > 0,'');

      // Push line due date by 2D in the future.
      Step := 6;
      EVALUATE(DTFormula,'<+2D>');
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000);
      ExpLineDueDate := CALCDATE(DTFormula,AsmLine."Due Date");
      SetGlobalDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      ASSERTERROR AsmLine.VALIDATE("Due Date",ExpLineDueDate);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,STRSUBSTNO(ErrLineDueDateBeforeStartDate,ShiftDateBackBy(LeadTimeOffset,AsmHeader."Starting Date"),AsmHeader."Starting Date")) > 0,'');

      // Pull start date by 1D in the past (say No to confirm) and then reset it back to its old value- no confirms expected the second time.
      Step := 7;
      EVALUATE(DTFormula,'<-1D>');
      ExpStartDate := CALCDATE(DTFormula,AsmHeader."Starting Date");
      ExpEndDate := CALCDATE(LeadTimeCalc,ExpStartDate);
      ExpDueDate := CALCDATE(SafetyLeadTime,ExpEndDate);
      ExpLineDueDate := ShiftDateBackBy(LeadTimeOffset,ExpStartDate);
      SetGlobalDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      AsmHeader.VALIDATE("Starting Date",ExpStartDate);
      VSTF257960AVerifyDates(AsmHeader,SavedDueDate,SavedEndDate,ExpStartDate,ExpLineDueDate);
      Step := 8;
      AsmHeader.VALIDATE("Starting Date",SavedStartDate); // no confirm expected
      VSTF257960AVerifyDates(AsmHeader,SavedDueDate,SavedEndDate,SavedStartDate,SavedLineDueDate);
      // revert back to original setup
      ASSERTERROR ERROR('');

      // Set start date = WorkDate and verify message coming up
      Step := 9;
      ExpStartDate := WORKDATE;
      ExpEndDate := CALCDATE(LeadTimeCalc,ExpStartDate);
      ExpDueDate := CALCDATE(SafetyLeadTime,ExpEndDate);
      ExpLineDueDate := ShiftDateBackBy(LeadTimeOffset,ExpStartDate);
      SetGlobalDates(AsmHeader,ExpDueDate,ExpEndDate,ExpStartDate,ExpLineDueDate);
      AsmHeader.VALIDATE("Starting Date",ExpStartDate);
      VSTF257960AVerifyDates(AsmHeader,SavedDueDate,SavedEndDate,ExpStartDate,ExpLineDueDate);
      // revert back to original setup
      ASSERTERROR ERROR('');

      // Set a date before workdate on AsmLine and verify message
      Step := 10;
      AsmHeader.GET(AsmHeader."Document Type",AsmHeader."No.");
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000);
      EVALUATE(DTFormula,'<-1D>');
      ExpLineDueDate := CALCDATE(DTFormula,WORKDATE);
      AsmLine.VALIDATE("Due Date",ExpLineDueDate);
      AsmLine.MODIFY(TRUE);
      VSTF257960AVerifyDates(AsmHeader,SavedDueDate,SavedEndDate,SavedStartDate,ExpLineDueDate);
      // revert back to original setup
      ASSERTERROR ERROR('');

      WORKDATE := OldWorkDate;
    END;

    LOCAL PROCEDURE VSTF257960AVerifyDates@50(AsmHeader@1000 : Record 900;DueDate@1001 : Date;EndDate@1002 : Date;StartDate@1003 : Date;LineDueDate@1005 : Date);
    VAR
      AsmLine@1004 : Record 901;
    BEGIN
      Assert.AreEqual(DueDate,AsmHeader."Due Date",'Due Date not OK.');
      Assert.AreEqual(EndDate,AsmHeader."Ending Date",'Ending Date not OK.');
      Assert.AreEqual(StartDate,AsmHeader."Starting Date",'Starting Date not OK.');
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // first line
      Assert.AreEqual(LineDueDate,AsmLine."Due Date",'Line Due Date not OK.');
    END;

    [Test]
    [HandlerFunctions(VSTF257960BDateMsgHandler,UpdateLocationOnLines)]
    PROCEDURE VSTF257960B@37();
    VAR
      ParentItem@1000 : Record 27;
      ChildItem@1001 : Record 27;
      Location@1002 : Record 14;
      AsmHeader@1004 : Record 900;
      DTFormula@1003 : DateFormula;
    BEGIN
      Initialize;
      TestMethodName := TestVSTF257960B;
      Step := 0;
      // Create assembled item with one comp (qty per = 1).
      MockAsmItem(ParentItem,ChildItem,1);
      // Make sure that safety lead time for parent = 1D
      EVALUATE(DTFormula,'<+1D>');
      ParentItem.VALIDATE("Safety Lead Time",DTFormula);
      ParentItem.MODIFY(TRUE);
      // Create two locations and put in enough inventory for Child Item in both empty and new location
      AddItemToInventory(ChildItem,'','',1);
      MockLocation(Location);
      AddItemToInventory(ChildItem,Location.Code,'',1);
      // Create asm order for 1 PCS of Parent on Location 1
      Step := 1;
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,''); // expected message about Due Date before work date from header only
      Step := 2;
      AsmHeader.VALIDATE("Location Code",Location.Code); // expected message about Due Date before work date from header only
    END;

    [MessageHandler]
    PROCEDURE VSTF257960BDateMsgHandler@39(Msg@1000 : Text[1024]);
    VAR
      MessageTextFromHeader@1001 : Text[1024];
      DTFormula@1002 : DateFormula;
    BEGIN
      EVALUATE(DTFormula,'<-1D>');
      MessageTextFromHeader := STRSUBSTNO(MsgDueDateBeforeWDFromHeader,CALCDATE(DTFormula,WORKDATE),WORKDATE);
      CASE Step OF
        1,2:
          BEGIN
            Assert.AreEqual(MessageTextFromHeader,Msg,'');
            EXIT;
          END;
      END;
      Assert.Fail(FORMAT(Step));
    END;

    [Test]
    [HandlerFunctions(AvailWarningConfirm,LineAvailWarningConfirm)]
    PROCEDURE VSTF266309@38();
    VAR
      AssemblySetup@1004 : Record 905;
      ParentItem@1002 : Record 27;
      ChildItem@1001 : Record 27;
      AsmHeader@1000 : Record 900;
      AsmLine@1003 : Record 901;
      AsmOrder@1007 : TestPage 900;
      ZeroDF@1005 : DateFormula;
    BEGIN
      Initialize;
      TestMethodName := TestVSTF266309;
      Step := 0;
      // Set Assembly setup to show no warning
      AssemblySetup.GET;
      AssemblySetup.VALIDATE("Stockout Warning",FALSE);
      AssemblySetup.MODIFY(TRUE);
      // Create assembled item with one comp (qty per = 1).
      MockAsmItem(ParentItem,ChildItem,1);
      EVALUATE(ZeroDF,'<0D>');
      ParentItem.VALIDATE("Safety Lead Time",ZeroDF);
      ParentItem.MODIFY(TRUE);
      // Create asm order for 1 PCS of Parent
      Step := 1;
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,''); // no availability check expected
      AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // first line
      // Show availability from line
      Step := 2;
      AsmLine.ShowAvailabilityWarning; // line availability warning expected
      Assert.IsTrue(AsmLine."Avail. Warning",''); // expect availability warning
      // Show availability from header
      AsmOrder.TRAP;
      PAGE.RUN(PAGE::"Assembly Order",AsmHeader);
      Step := 3;
      AsmOrder.ShowAvailability.INVOKE; // availability warning expected
      ASSERTERROR ERROR(''); // to undo changes made to Setup table.
    END;

    [Test]
    [HandlerFunctions(DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE VSTF267434@42();
    VAR
      ParentItem@1000 : Record 27;
      ChildItem@1001 : Record 27;
      Location@1002 : Record 14;
      Bin@1003 : Record 7354;
      AsmHeader@1004 : Record 900;
      AsmLine@1005 : Record 901;
      MfgSetup@1007 : Record 99000765;
      OldDefSafetyLeadTime@1006 : DateFormula;
      DTFormula@1008 : DateFormula;
    BEGIN
      Initialize;
      // Create assembled item with one comp (qty per = 1).
      MockAsmItem(ParentItem,ChildItem,1);
      // Create Bin Mandatory location with To-Assembly Bin filled in
      MockLocation(Location);
      Location."Bin Mandatory" := TRUE;
      LibraryWarehouse.CreateBin(Bin,Location.Code,FirstNumber,'','');
      Location."To-Assembly Bin Code" := Bin.Code;
      Location.MODIFY;
      // Add 2 PCS of component to inventory
      AddItemToInventory(ChildItem,Location.Code,Bin.Code,2);
      // Change manufacturing Default Safety Lead Time = 2D
      OldDefSafetyLeadTime := MfgSetup."Default Safety Lead Time";
      EVALUATE(DTFormula,DateFormula1D);
      MfgSetup.GET;
      MfgSetup.VALIDATE("Default Safety Lead Time",DTFormula);
      MfgSetup.MODIFY(TRUE);
      // Create asm order
      CLEAR(AsmHeader);
      AsmHeader."Document Type" := AsmHeader."Document Type"::Order;
      AsmHeader.INSERT(TRUE);
      AsmHeader.VALIDATE("Due Date",WORKDATE);
      AsmHeader.VALIDATE("Location Code",Location.Code);
      AsmHeader.VALIDATE("Item No.",ParentItem."No.");
      AsmHeader.VALIDATE(Quantity,1);
      AsmHeader.MODIFY(TRUE);
      // verify that the bin code on the line is To-Asm Bin Code
      AsmLine.SETRANGE("Document Type",AsmHeader."Document Type");
      AsmLine.SETRANGE("Document No.",AsmHeader."No.");
      AsmLine.FINDLAST;
      Assert.AreEqual(Bin.Code,AsmLine."Bin Code",'');

      // set data back to original
      MfgSetup.VALIDATE("Default Safety Lead Time",OldDefSafetyLeadTime);
      MfgSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ShiftDateBackBy@58(Offset@1000 : DateFormula;RefDate@1001 : Date) : Date;
    BEGIN
      EXIT(RefDate - (CALCDATE(Offset,WORKDATE) - WORKDATE));
    END;

    LOCAL PROCEDURE SetGlobalDates@34(AsmHeader@1005 : Record 900;NewDueDate2@1000 : Date;NewEndDate2@1001 : Date;NewStartDate2@1002 : Date;NewLineDueDate2@1003 : Date);
    BEGIN
      OldDueDate := AsmHeader."Due Date";
      OldEndDate := AsmHeader."Ending Date";
      OldStartDate := AsmHeader."Starting Date";
      NewDueDate := NewDueDate2;
      NewEndDate := NewEndDate2;
      NewStartDate := NewStartDate2;
      NewLineDueDate := NewLineDueDate2;
    END;

    [ConfirmHandler]
    PROCEDURE DateConfirmationHandler@41(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    VAR
      StartDateChangedText@1002 : Text[1024];
      EndDateChangedText@1003 : Text[1024];
    BEGIN
      StartDateChangedText := STRSUBSTNO(CnfmStartingDateChanged,OldStartDate,NewStartDate,OldEndDate,NewEndDate,OldDueDate,NewDueDate);
      EndDateChangedText := STRSUBSTNO(CnfmEndingDateChanged,OldEndDate,NewEndDate,OldDueDate,NewDueDate);
      CASE TestMethodName OF
        'VSTF258428':
          CASE Step OF
            2:
              BEGIN
                Assert.IsTrue(STRPOS(Question,StartDateChangedText) > 0,STRSUBSTNO('Wrong Question: %1 \Expected: %2',Question,StartDateChangedText));
                Reply := TRUE;
                EXIT;
              END;
            4:
              BEGIN
                Assert.IsTrue(STRPOS(Question,EndDateChangedText) > 0,STRSUBSTNO('Wrong Question: %1 \Expected: %2',Question,EndDateChangedText));
                Reply := TRUE;
                EXIT;
              END;
          END;
        TestVSTF257960A:
          CASE Step OF
            2:
              BEGIN
                Assert.IsTrue(STRPOS(Question,StartDateChangedText) > 0,STRSUBSTNO('Wrong Question: %1 \Expected: %2',Question,StartDateChangedText));
                Reply := TRUE;
                EXIT;
              END;
            3:
              BEGIN
                Assert.IsTrue(STRPOS(Question,StartDateChangedText) > 0,STRSUBSTNO('Wrong Question: %1 \Expected: %2',Question,StartDateChangedText));
                Reply := FALSE;
                EXIT;
              END;
            4:
              BEGIN
                Assert.IsTrue(STRPOS(Question,StartDateChangedText) > 0,STRSUBSTNO('Wrong Question: %1 \Expected: %2',Question,StartDateChangedText));
                Reply := TRUE;
                EXIT;
              END;
            5:
              BEGIN
                Assert.IsTrue(STRPOS(Question,EndDateChangedText) > 0,STRSUBSTNO('Wrong Question: %1 \Expected: %2',Question,EndDateChangedText));
                Reply := TRUE;
                EXIT;
              END;
            6:
              BEGIN
                Assert.IsTrue(STRPOS(Question,EndDateChangedText) > 0,STRSUBSTNO('Wrong Question: %1 \Expected: %2',Question,EndDateChangedText));
                Reply := FALSE;
                EXIT;
              END;
            7:
              BEGIN
                Assert.IsTrue(STRPOS(Question,StartDateChangedText) > 0,STRSUBSTNO('Wrong Question: %1 \Expected: %2',Question,StartDateChangedText));
                Reply := FALSE;
                EXIT;
              END;
            9:
              BEGIN
                Assert.IsTrue(STRPOS(Question,StartDateChangedText) > 0,STRSUBSTNO('Wrong Question: %1 \Expected: %2',Question,StartDateChangedText));
                Reply := FALSE;
                EXIT;
              END;
          END;
      END;
      Assert.Fail(STRSUBSTNO('Confirmation dialog at step = %1 not expected.',Step));
    END;

    [MessageHandler]
    PROCEDURE DueDateBeforeWorkDateMsgHandler@32(Msg@1000 : Text[1024]);
    VAR
      MessageTextFromHeader@1001 : Text[1024];
      MessageTextFromLine@1002 : Text[1024];
    BEGIN
      MessageTextFromHeader := STRSUBSTNO(MsgDueDateBeforeWDFromHeader,NewLineDueDate,WORKDATE);
      MessageTextFromLine := STRSUBSTNO(MsgDueDateBeforeWDFromLine,NewLineDueDate,WORKDATE);
      CASE TestMethodName OF
        TestVSTF257960A:
          CASE Step OF
            1,9:
              BEGIN
                Assert.IsTrue(STRPOS(Msg,MessageTextFromHeader) > 0,STRSUBSTNO('Wrong message: %1 \Expected: %2',Msg,MessageTextFromHeader));
                EXIT;
              END;
            10:
              BEGIN
                Assert.IsTrue(STRPOS(Msg,MessageTextFromLine) > 0,STRSUBSTNO('Wrong message: %1 \Expected: %2',Msg,MessageTextFromLine));
                EXIT;
              END;
          END;
        ELSE
          EXIT; // for other test methods.
      END;

      Assert.Fail(STRSUBSTNO('Message at Step %1 not expected.',Step));
    END;

    [ModalPageHandler]
    PROCEDURE AvailWarningConfirm@14(VAR AssemblyAvailability@1000 : Page 908;VAR Response@1001 : Action);
    VAR
      AsmHeader@1002 : Record 900;
      AsmLine@1003 : Record 901;
      NewChildItem@1004 : Record 27;
    BEGIN
      CASE TestMethodName OF
        'ChangeLocCheckDueDateNoLineUpd',
        'ChangeLocCheckDueDateLineUpd':
          IF Step IN [1,2] THEN BEGIN
            Response := ACTION::Yes;
            EXIT;
          END;
        'ValidateLocAfterSKUNewDueDate',
        'ChangeVariantNoLocUpdConfirm':
          IF Step IN [1,2,3] THEN BEGIN
            Response := ACTION::Yes;
            EXIT;
          END;
        TestDataConsistencyCheck:
          CASE Step OF
            1:
              BEGIN
                Response := ACTION::Yes;
                EXIT;
              END;
            2:
              BEGIN
                // get assembly line for this header and modify it
                AsmHeader.INIT;
                AssemblyAvailability.GETRECORD(AsmHeader);
                AsmLine.GET(AsmHeader."Document Type",AsmHeader."No.",10000); // get first asm line
                AsmLine.VALIDATE(Type,AsmLine.Type::Item);
                MockItem(NewChildItem);
                AsmLine.VALIDATE("No.",NewChildItem."No.");
                AsmLine.MODIFY(TRUE);
                // now respond by Yes.
                Response := ACTION::Yes;
                EXIT;
              END;
          END;
        'ValidateItemNoToParentItem':
          IF Step = 2 THEN BEGIN
            Response := ACTION::Yes;
            EXIT;
          END;
        'VSTF238472':
          IF Step = 1 THEN BEGIN
            Response := ACTION::Yes;
            EXIT;
          END;
        'EarliestDatesCheck':
          IF Step = 1 THEN BEGIN
            Response := ACTION::Yes;
            EXIT;
          END;
        'VSTF255987':
          CASE Step OF
            1,4:
              BEGIN
                Response := ACTION::Yes;
                EXIT;
              END;
          END;
        TestMethodVSTF238977:
          IF Step IN [1,2] THEN BEGIN
            Response := ACTION::Yes;
            EXIT;
          END;
        TestVSTF266309:
          IF Step = 3 THEN BEGIN
            Response := ACTION::Yes;
            EXIT;
          END;
      END;
      Assert.Fail(STRSUBSTNO(TestMsgAvailConfirm,Step));
    END;

    [ModalPageHandler]
    PROCEDURE LineAvailWarningConfirm@40(VAR CheckAvailability@1000 : Page 342;VAR Response@1001 : Action);
    BEGIN
      CASE TestMethodName OF
        TestVSTF266309:
          IF Step = 2 THEN BEGIN
            Response := ACTION::Yes;
            EXIT;
          END;
      END;
      Assert.Fail(STRSUBSTNO(TestMsgAvailConfirm,Step));
    END;

    [ConfirmHandler]
    PROCEDURE UpdateLocationOnLines@3(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,CnfmUpdateLocationOnLines) > 0,'Wrong Confirm Question: ' + Question);
      CASE TestMethodName OF
        'ChangeLocCheckDueDateNoLineUpd':
          IF Step = 2 THEN BEGIN
            Reply := FALSE;
            EXIT;
          END;
        'ChangeLocCheckDueDateLineUpd',
        'ValidateLocAfterSKUNewDueDate',
        'ChangeVariantNoLocUpdConfirm',
        TestDataConsistencyCheck,
        TestVSTF257960B:
          IF Step = 2 THEN BEGIN
            Reply := TRUE;
            EXIT;
          END;
      END;
      Assert.Fail('Location update confirm should not appear on step = ' + FORMAT(Step));
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmChangeOfItem@12(Question@1001 : Text[1024];VAR Reply@1000 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,CnfmChangeOfItemNo) > 0,'Wrong Confirm Question: ' + Question);
      Reply := TRUE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmRefreshLines@30(Question@1001 : Text[1024];VAR Reply@1000 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,CnfmRefreshLines) > 0,Question);
      CASE TestMethodName OF
        'VSTF255987':
          CASE Step OF
            3:
              BEGIN
                Reply := FALSE;
                EXIT;
              END;
            4:
              BEGIN
                Reply := TRUE;
                EXIT;
              END;
          END;
      END;
      Assert.Fail('Refresh confirm should not appear on step = ' + FORMAT(Step));
    END;

    [Test]
    [HandlerFunctions(EarliestDatesCheckTestPage,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE EarliestDatesCheck@25();
    VAR
      ParentItem@1003 : Record 27;
      ChildItem@1002 : Record 27;
      AsmHeader@1001 : Record 900;
      AsmLine@1009 : Record 901;
      MfgSetup@1000 : Record 99000765;
      Location@1005 : Record 14;
      ItemUOM@1010 : Record 5404;
      UnitOfMeasure@1011 : Record 204;
      LeadTime@1004 : DateFormula;
      OldDefSafetyLeadTime@1012 : DateFormula;
    BEGIN
      Initialize;
      // 1. Create item X with 2 UOMs (BOX = 5, PCS = 1). Set replenishment system = Assembly.
      // 2. Create SKU at BLUE with Safety Lead Time = 3D
      // 3. Change manufacturing default safety lead time = 2D
      // 4. Create item Y and post 2 PCS at BLUE.
      // 5. Create purchase order for 10 PCS at BLUE with Expected receipt date = 1M from WORKDATE
      // 6. Create asm order at BLUE for location X: 1 PCS.
      // 7. Add asm line for 1 PCS of item Y, also at BLUE.
      // 8. Change UOM in header from PCS to BOX.

      TestMethodName := 'EarliestDatesCheck';
      // Create assembled item without comp.
      MockItem(ParentItem);
      ParentItem.VALIDATE("Replenishment System",ParentItem."Replenishment System"::Assembly);
      ParentItem.MODIFY(TRUE);

      // Set dates
      MfgSetup.GET;
      OldDefSafetyLeadTime := MfgSetup."Default Safety Lead Time";
      EVALUATE(LeadTime,'2D');
      MfgSetup.VALIDATE("Default Safety Lead Time",LeadTime);
      MfgSetup.MODIFY(TRUE);
      MockLocation(Location);
      MockSKU(ParentItem,Location.Code,'3D','4D');

      // add 2 PCS of child to inventory
      MockItem(ChildItem);
      AddItemToInventory(ChildItem,Location.Code,'',2);

      // Create supply for next month for 10 PCS of child
      MockPurchOrder(ChildItem."No.",10,Location.Code,CALCDATE('<+1M>',WORKDATE));

      // Create asm order
      Step := 1;
      MockAsmOrder(AsmHeader,ParentItem,1,WORKDATE,'');
      Step := 2;
      AsmHeader.VALIDATE("Location Code",Location.Code);
      AsmHeader.MODIFY(TRUE);
      // edit the production lead time on the asm line to 5D
      LibraryAssembly.CreateAssemblyLine(AsmHeader,AsmLine,AsmLine.Type::Item,ChildItem."No.",'',1,1,'');
      AsmLine.VALIDATE("Location Code",Location.Code);
      EVALUATE(LeadTime,'5D');
      AsmLine.VALIDATE("Lead-Time Offset",LeadTime);
      AsmLine.MODIFY(TRUE);

      // Now change UOM on header to BOX (= 5 PCS)
      UnitOfMeasure.FINDLAST;
      LibraryInventory.CreateItemUnitOfMeasure(ItemUOM,ParentItem."No.",UnitOfMeasure.Code,5);
      Step := 3;
      ASSERTERROR AsmHeader.VALIDATE("Unit of Measure Code",UnitOfMeasure.Code); // avail warning should open - make check
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ErrUpdateInterrupted) > 0,'Error expected: ' + ErrUpdateInterrupted +
        '; Actual: ' + GETLASTERRORTEXT);
      CLEARLASTERROR;

      // set data back to original
      MfgSetup.VALIDATE("Default Safety Lead Time",OldDefSafetyLeadTime);
      MfgSetup.MODIFY(TRUE);
    END;

    [ModalPageHandler]
    PROCEDURE EarliestDatesCheckTestPage@36(VAR AsmAvailability@1000 : TestPage 908);
    VAR
      ExpectedPageToAppear@1001 : Boolean;
    BEGIN
      IF Step = 3 THEN
        CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,CALCDATE('<+1M>',WORKDATE),
          2 / 5,0,0,0); // (2 / 5) because 2 are in inventory & 5 is Qty per UOM
      IF NOT ExpectedPageToAppear THEN
        Assert.Fail('Availability warning should not appear on Step = ' + FORMAT(Step));
    END;

    [Test]
    [HandlerFunctions(CAWTestAvailWarningPage)]
    PROCEDURE CheckAvailWarning@15();
    VAR
      MfgSetup@1000 : Record 99000765;
      OldDefSafetyLeadTime@1001 : DateFormula;
      DTFormula@1002 : DateFormula;
    BEGIN
      Initialize;
      TestMethodName := 'CheckAvailWarning';

      // Change manufacturing Default Safety Lead Time = 2D
      OldDefSafetyLeadTime := MfgSetup."Default Safety Lead Time";
      EVALUATE(DTFormula,DateFormula1D);
      MfgSetup.GET;
      MfgSetup.VALIDATE("Default Safety Lead Time",DTFormula);
      MfgSetup.MODIFY(TRUE);

      // Steps 1 to 3 are for case when no other demand exists
      SupplyDate1 := GetDate('-1W',WORKDATE);
      SupplyQty1 := 2;
      SupplyDate2 := GetDate('+3W',WORKDATE);
      SupplyQty2 := 4;

      Step := 1; // Asm order created before 1st supply
      CAWLaunchTest(GetDate('-1W',SupplyDate1));
      Step := 2; // Asm order created between 1st & 2nd supply
      CAWLaunchTest(GetDate('+1W+1D',SupplyDate1)); // 1D is added to avoid getting the "Due Date is before Work Date message"
      Step := 3; // Asm order created after 2nd supply
      CAWLaunchTest(GetDate('+1W',SupplyDate2));

      // Steps 4 to 6 for case when asm demand exists before 1st supply
      DemandDate := GetDate('-2W',SupplyDate1);
      DemandQty := 1;

      Step := 4; // Asm order created between asm demand and 1st supply
      CAWLaunchTest(GetDate('-1W',SupplyDate1));
      Step := 5; // Asm order created between 1st and 2nd supply
      CAWLaunchTest(GetDate('+1W+1D',SupplyDate1)); // 1D is added to avoid getting the "Due Date is before Work Date message"
      Step := 6; // Asm order created after 2nd supply
      CAWLaunchTest(GetDate('+1W',SupplyDate2));

      // Steps 7 to 9 for case when asm demand between 1st and 2nd supply
      DemandDate := GetDate('+2W',SupplyDate1);
      DemandQty := 1;

      Step := 7; // Asm order created between asm demand and 1st supply
      CAWLaunchTest(GetDate('+1W+1D',SupplyDate1)); // 1D is added to avoid getting the "Due Date is before Work Date message"
      Step := 8; // Asm order created between asm demand and 2nd supply
      CAWLaunchTest(GetDate('+1W',DemandDate));
      Step := 9; // Asm order created after 2nd supply
      CAWLaunchTest(GetDate('+1W',SupplyDate2));

      // Steps 10 to 12 for case when asm demand lies after 2nd supply
      DemandDate := GetDate('+2W',SupplyDate2);
      DemandQty := 1;

      Step := 10; // Asm order created between 1st and 2nd supply
      CAWLaunchTest(GetDate('+1W+1D',SupplyDate1)); // 1D is added to avoid getting the "Due Date is before Work Date message"
      Step := 11; // Asm order created between asm demand and 2nd supply
      CAWLaunchTest(GetDate('+1W',SupplyDate2));
      Step := 12; // Asm order created after asm demand
      CAWLaunchTest(GetDate('+1W',DemandDate));

      // set data back to original
      MfgSetup.VALIDATE("Default Safety Lead Time",OldDefSafetyLeadTime);
      MfgSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CAWLaunchTest@17(AsmDueDate@1002 : Date);
    BEGIN
      SubStep := 1; // Make asm order for qty less than 1st supply
      CAWCreateDataAndExercise(SupplyQty1 - 1,AsmDueDate);
      SubStep := 2; // Make asm order for qty = 1st supply
      CAWCreateDataAndExercise(SupplyQty1,AsmDueDate);
      SubStep := 3; // Make asm order for qty > 1st supply
      CAWCreateDataAndExercise(SupplyQty1 + 1,AsmDueDate);
      SubStep := 4; // Make asm order for qty = 2nd supply
      CAWCreateDataAndExercise(SupplyQty2,AsmDueDate);
      SubStep := 5; // Make asm order for qty = 1st + 2nd supply
      CAWCreateDataAndExercise(SupplyQty1 + SupplyQty2,AsmDueDate);
      SubStep := 6; // Make asm order for qty > 1st + 2nd supply
      CAWCreateDataAndExercise(SupplyQty1 + SupplyQty2 + 1,AsmDueDate);
    END;

    LOCAL PROCEDURE CAWCreateDataAndExercise@23(AsmQty@1007 : Decimal;AsmDueDate@1008 : Date);
    VAR
      AsmHeader2@1015 : Record 900;
      AsmLine2@1003 : Record 901;
      AsmHeader@1000 : Record 900;
      ChildItem@1002 : Record 27;
      ParentItem@1001 : Record 27;
      BOMComponent@1004 : Record 90;
    BEGIN
      MockItem(ChildItem);
      // make purchase as supply for Supply 1
      MockPurchOrder(ChildItem."No.",SupplyQty1,'',SupplyDate1);
      // make assembly as supply for Supply 2
      LibraryAssembly.CreateAssemblyHeader(AsmHeader2,SupplyDate2,ChildItem."No.",'',SupplyQty2,'');

      // make assembly order as demand
      MockItem(ParentItem);
      ParentItem.VALIDATE("Replenishment System",ParentItem."Replenishment System"::Assembly);
      ParentItem.MODIFY(TRUE);
      IF DemandDate <> 0D THEN BEGIN
        LibraryAssembly.CreateAssemblyHeader(AsmHeader2,DemandDate,ParentItem."No.",'',DemandQty,'');
        LibraryAssembly.CreateAssemblyLine(AsmHeader2,AsmLine2,AsmLine2.Type::Item,ChildItem."No.",'',DemandQty,1,'');
      END;

      // make the Assembly list- the reason it wasnt above because it throws up availability warning.
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentItem."No.",BOMComponent.Type::Item,
        ChildItem."No.",1,ChildItem."Base Unit of Measure");

      IF (Step = 1) OR
         ((Step = 2) AND (SubStep IN [3,4,5,6])) OR
         ((Step = 3) AND (SubStep IN [6])) OR
         (Step = 4) OR
         ((Step = 5) AND (SubStep IN [2,3,4,5,6])) OR
         ((Step = 6) AND (SubStep IN [5,6])) OR
         ((Step = 7) AND (SubStep IN [2,3,4,5,6])) OR
         ((Step = 8) AND (SubStep IN [2,3,4,5,6])) OR
         ((Step = 9) AND (SubStep IN [5,6])) OR
         ((Step = 10) AND (SubStep IN [3,4,5,6])) OR
         ((Step = 11) AND (SubStep IN [5,6])) OR
         ((Step = 12) AND (SubStep IN [5,6])) THEN BEGIN
        ASSERTERROR MockAsmOrder(AsmHeader,ParentItem,AsmQty,AsmDueDate,'');
        Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ErrUpdateInterrupted) > 0,'Error expected: ' + ErrUpdateInterrupted +
          '; Actual: ' + GETLASTERRORTEXT);
      END ELSE BEGIN
        ASSERTERROR BEGIN
          MockAsmOrder(AsmHeader,ParentItem,AsmQty,AsmDueDate,''); // verification that avail warning does not appear.
          ERROR(''); // this is done so that the assembly order just created goes away, else it will contribute to demand.
        END;
        Assert.AreEqual('',GETLASTERRORTEXT,'Unexpected error: ' + GETLASTERRORTEXT);
      END;
      CLEARLASTERROR;
    END;

    [ModalPageHandler]
    [HandlerFunctions(AvailWarningConfirm)]
    PROCEDURE CAWTestAvailWarningPage@18(VAR AsmAvailability@1000 : TestPage 908);
    VAR
      ExpectedPageToAppear@1001 : Boolean;
    BEGIN
      CASE Step OF
        1:
          CASE SubStep OF
            1,2:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,SupplyDate1,0,0,0,0);
            3,4,5:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,SupplyDate2,0,0,0,0);
            6:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,0D,0,0,0,0);
          END;
        2:
          CASE SubStep OF
            3,4,5:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,SupplyDate2,SupplyQty1,0,SupplyQty1,0);
            6:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,0D,SupplyQty1,0,SupplyQty1,0);
          END;
        3:
          CASE SubStep OF
            6:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,0D,SupplyQty1 + SupplyQty2,0,SupplyQty1 + SupplyQty2,0);
          END;
        4:
          CASE SubStep OF
            1:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,SupplyDate1,0,DemandQty,0,DemandQty);
            2,3,4:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,SupplyDate2,0,DemandQty,0,DemandQty);
            5,6:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,0D,0,DemandQty,0,DemandQty);
          END;
        5:
          CASE SubStep OF
            2,3,4:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,SupplyDate2,SupplyQty1 - DemandQty,
                DemandQty,SupplyQty1,DemandQty);
            5,6:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,0D,SupplyQty1 - DemandQty,
                DemandQty,SupplyQty1,DemandQty);
          END;
        6:
          CASE SubStep OF
            5,6:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,0D,SupplyQty1 + SupplyQty2 - DemandQty,
                DemandQty,SupplyQty1 + SupplyQty2,DemandQty);
          END;
        7:
          CASE SubStep OF
            2,3,4:
              CAWVerifyAvailWarningPage(
                AsmAvailability,ExpectedPageToAppear,SupplyDate2,SupplyQty1 - DemandQty,0,SupplyQty1,DemandQty);
            5,6:
              CAWVerifyAvailWarningPage(
                AsmAvailability,ExpectedPageToAppear,0D,SupplyQty1 - DemandQty,0,SupplyQty1,DemandQty);
          END;
        8:
          CASE SubStep OF
            2,3,4:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,SupplyDate2,SupplyQty1 - DemandQty,
                DemandQty,SupplyQty1,DemandQty);
            5,6:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,0D,SupplyQty1 - DemandQty,DemandQty,SupplyQty1,DemandQty);
          END;
        9:
          CASE SubStep OF
            5,6:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,0D,SupplyQty1 + SupplyQty2 - DemandQty,
                DemandQty,SupplyQty1 + SupplyQty2,DemandQty);
          END;
        10:
          CASE SubStep OF
            3,4:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,SupplyDate2,SupplyQty1,0,SupplyQty1,0);
            5:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,SupplyDate2,SupplyQty1,0,SupplyQty1,0);
            6:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,0D,SupplyQty1,0,SupplyQty1,0);
          END;
        11:
          CASE SubStep OF
            5,6:
              CAWVerifyAvailWarningPage(
                AsmAvailability,ExpectedPageToAppear,0D,SupplyQty1 + SupplyQty2 - DemandQty,0,SupplyQty1 + SupplyQty2,DemandQty);
          END;
        12:
          CASE SubStep OF
            5,6:
              CAWVerifyAvailWarningPage(AsmAvailability,ExpectedPageToAppear,0D,SupplyQty1 + SupplyQty2 - DemandQty,
                DemandQty,SupplyQty1 + SupplyQty2,DemandQty);
          END;
      END;
      IF NOT ExpectedPageToAppear THEN
        Assert.Fail('Availability warning should not appear on Step = ' + FORMAT(Step) +
          ' and SubStep = ' + FORMAT(SubStep));
    END;

    PROCEDURE CAWVerifyAvailWarningPage@20(VAR AsmAvailability@1000 : TestPage 908;VAR ExpectedPageToAppear@1005 : Boolean;ExpectedLineAvailDate@1004 : Date;ExpectedAbleToAssemble@1003 : Decimal;ExpectedHeaderSchRcpt@1019 : Decimal;ExpectedLineSchRcpt@1006 : Decimal;ExpectedLineGrossReq@1008 : Decimal);
    VAR
      MfgSetup@1013 : Record 99000765;
      StockkeepingUnit@1014 : Record 5700;
      HdrEarliestDateOffset@1015 : Text[30];
      ExpectedAvailDate@1012 : Date;
      ActualAbleToAssemble@1001 : Decimal;
      ActualEarliestAvailDate@1002 : Date;
      ActualGrossReq@1017 : Decimal;
      ActualSchRcpt@1018 : Decimal;
      ActualLineEarliestAvailDate@1011 : Date;
      ActualLineSchRcpt@1007 : Decimal;
      ActualLineGrossReq@1009 : Decimal;
      StepInfo@1010 : Text[30];
      DF@1016 : DateFormula;
    BEGIN
      ExpectedPageToAppear := TRUE;
      EVALUATE(ActualAbleToAssemble,AsmAvailability.AbleToAssemble.VALUE);
      ActualEarliestAvailDate := AsmAvailability.EarliestAvailableDate.ASDATE;
      AsmAvailability.AssemblyLineAvail.FIRST;
      EVALUATE(ActualLineSchRcpt,AsmAvailability.AssemblyLineAvail.ScheduledReceipt.VALUE);
      EVALUATE(ActualLineGrossReq,AsmAvailability.AssemblyLineAvail.GrossRequirement.VALUE);
      ActualLineEarliestAvailDate := AsmAvailability.AssemblyLineAvail.EarliestAvailableDate.ASDATE;
      StepInfo := 'Step = ' + FORMAT(Step) + '; SubStep = ' + FORMAT(SubStep);
      Assert.AreEqual(ExpectedAbleToAssemble,ActualAbleToAssemble,'Incorrect Able to Assemble Qty. ' + StepInfo);
      EVALUATE(ActualGrossReq,AsmAvailability.GrossRequirement.VALUE);
      Assert.AreEqual(0,ActualGrossReq,'Incorrect Gross Req in Header. ' + StepInfo); // always zero in these test methods
      EVALUATE(ActualSchRcpt,AsmAvailability.ScheduledReceipts.VALUE);
      Assert.AreEqual(ExpectedHeaderSchRcpt,ActualSchRcpt,'Incorrect Scheduled Receipt in Header. ' + StepInfo);
      MfgSetup.GET;
      IF StockkeepingUnit.GET(AsmAvailability."Location Code".VALUE,AsmAvailability."Item No.".VALUE,
           AsmAvailability."Variant Code".VALUE) THEN;
      IF ExpectedLineAvailDate > 0D THEN BEGIN
        AddToDateOffsetText(HdrEarliestDateOffset,MfgSetup."Default Safety Lead Time",FALSE);
        AddToDateOffsetText(HdrEarliestDateOffset,StockkeepingUnit."Safety Lead Time",TRUE);
        AddToDateOffsetText(HdrEarliestDateOffset,StockkeepingUnit."Lead Time Calculation",FALSE);
        EVALUATE(DF,AsmAvailability.AssemblyLineAvail."Lead-Time Offset".VALUE);
        AddToDateOffsetText(HdrEarliestDateOffset,DF,FALSE);
        EVALUATE(DF,HdrEarliestDateOffset);
        ExpectedAvailDate := CALCDATE(DF,ExpectedLineAvailDate);
      END;
      Assert.AreEqual(ExpectedAvailDate,ActualEarliestAvailDate,'Incorrect earliest availability date. ' + StepInfo);
      Assert.AreEqual(ExpectedLineSchRcpt,ActualLineSchRcpt,'Incorrect line scheduled receipt. ' + StepInfo);
      Assert.AreEqual(ExpectedLineGrossReq,ActualLineGrossReq,'Incorrect line gross requirement. ' + StepInfo);
      Assert.AreEqual(ExpectedLineAvailDate,ActualLineEarliestAvailDate,'Incorrect line available date. ' + StepInfo);
    END;

    LOCAL PROCEDURE AddToDateOffsetText@26(VAR OffsetText@1001 : Text[30];NewOffset@1000 : DateFormula;Replace@1003 : Boolean);
    VAR
      ZeroDF@1002 : DateFormula;
    BEGIN
      IF NewOffset <> ZeroDF THEN BEGIN
        IF OffsetText = '' THEN
          OffsetText := FORMAT(NewOffset)
        ELSE BEGIN
          IF Replace THEN
            OffsetText := FORMAT(NewOffset)
          ELSE
            OffsetText += '+' + FORMAT(NewOffset);
        END;
      END;
    END;

    LOCAL PROCEDURE MockItem@6(VAR Item@1000 : Record 27);
    BEGIN
      LibraryInventory.CreateItem(Item);
    END;

    LOCAL PROCEDURE MockSKU@19(Item@1000 : Record 27;LocationCode@1002 : Code[10];LeadTime@1004 : Text[30];LeadTimeCalc@1006 : Text[30]) : Code[10];
    VAR
      ItemVariant@1005 : Record 5401;
      StockkeepingUnit@1003 : Record 5700;
      DF@1007 : DateFormula;
    BEGIN
      LibraryInventory.CreateItemVariant(ItemVariant,Item."No.");
      LibraryInventory.CreateStockkeepingUnitForLocationAndVariant(StockkeepingUnit,LocationCode,Item."No.",ItemVariant.Code);
      EVALUATE(DF,LeadTime);
      StockkeepingUnit.VALIDATE("Safety Lead Time",DF);
      EVALUATE(DF,LeadTimeCalc);
      StockkeepingUnit.VALIDATE("Lead Time Calculation",DF);
      StockkeepingUnit.MODIFY(TRUE);
      EXIT(ItemVariant.Code);
    END;

    LOCAL PROCEDURE MockLocation@5(VAR Location@1000 : Record 14);
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
    END;

    LOCAL PROCEDURE AddItemToInventory@4(Item@1000 : Record 27;LocationCode@1001 : Code[10];BinCode@1002 : Code[20];Quantity@1003 : Decimal);
    VAR
      ItemJournalLine@1004 : Record 83;
      ItemJournalTemplate@1005 : Record 82;
      ItemJournalBatch@1006 : Record 233;
    BEGIN
      ItemJournalTemplate.SETRANGE(Type,ItemJournalTemplate.Type::Item);
      ItemJournalTemplate.SETRANGE(Recurring,FALSE);
      ItemJournalTemplate.FINDFIRST;
      ItemJournalBatch.SETRANGE("Journal Template Name",ItemJournalTemplate.Name);
      ItemJournalBatch.FINDFIRST;

      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalTemplate.Name);
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.DELETEALL;
      LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",Item."No.",Quantity);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.VALIDATE("Bin Code",BinCode);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE MockAsmItem@10(VAR ParentItem@1000 : Record 27;VAR ChildItem@1001 : Record 27;QtyPer@1003 : Decimal);
    VAR
      BOMComponent@1002 : Record 90;
    BEGIN
      MockItem(ChildItem);
      MockItem(ParentItem);
      ParentItem.VALIDATE("Replenishment System",ParentItem."Replenishment System"::Assembly);
      ParentItem.MODIFY(TRUE);
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentItem."No.",BOMComponent.Type::Item,
        ChildItem."No.",QtyPer,ChildItem."Base Unit of Measure");
    END;

    LOCAL PROCEDURE MockAsmOrder@16(VAR AsmHeader@1002 : Record 900;ParentItem@1000 : Record 27;Qty@1001 : Decimal;DueDate@1003 : Date;LocationCode@1004 : Code[10]);
    BEGIN
      CLEAR(AsmHeader);
      AsmHeader."Document Type" := AsmHeader."Document Type"::Order;
      AsmHeader.INSERT(TRUE);
      AsmHeader.VALIDATE("Due Date",DueDate);
      AsmHeader.VALIDATE("Location Code",LocationCode);
      AsmHeader.VALIDATE("Item No.",ParentItem."No.");
      AsmHeader.VALIDATE(Quantity,Qty);
      AsmHeader.MODIFY(TRUE);
      AsmHeader.VALIDATE("Item No."); // setting qty above leads to creation of asm lines here.
      AsmHeader.MODIFY(TRUE); // to clear the LinesAlreadyUpdated flag.
    END;

    LOCAL PROCEDURE MockSKUWithLeadTime@8(Item@1000 : Record 27;VAR Location@1004 : Record 14;LeadTimeText@1001 : Text[30];VAR VariantCode@1011 : Code[10]);
    BEGIN
      MockLocation(Location);
      VariantCode := MockSKU(Item,Location.Code,LeadTimeText,'');
    END;

    LOCAL PROCEDURE MockPurchOrder@31(ItemNo@1000 : Code[20];Qty@1001 : Decimal;LocationCode@1002 : Code[10];ExpectedRcptDate@1003 : Date);
    VAR
      PurchaseHeader@1005 : Record 38;
      PurchaseLine@1006 : Record 39;
    BEGIN
      LibraryPurchase.CreatePurchaseDocumentWithItem(
        PurchaseHeader,PurchaseLine,PurchaseHeader."Document Type"::Order,'',ItemNo,Qty,LocationCode,ExpectedRcptDate);
    END;

    LOCAL PROCEDURE GetDate@21(DateText@1000 : Text[31];RefDate@1002 : Date) : Date;
    VAR
      DF@1001 : DateFormula;
    BEGIN
      EVALUATE(DF,'<' + DateText + '>');
      EXIT(CALCDATE(DF,RefDate));
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [SCM]
      Unsupported version tags:
      NZ: Unable to Execute
      AU: Unable to Execute
      SE: Unable to Execute
    }
    END.
  }
}

