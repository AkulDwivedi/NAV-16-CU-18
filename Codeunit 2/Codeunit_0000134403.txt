OBJECT Codeunit 134403 ERM Test SEPA Credit Transfers
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      GenJournalTemplate@1005 : Record 80;
      GenJournalBatch@1004 : Record 232;
      BankAccount@1007 : Record 270;
      Customer@1013 : Record 18;
      CustomerBankAccount@1014 : Record 287;
      Vendor@1008 : Record 23;
      VendorBankAccount@1015 : Record 288;
      BankExportImportSetup@1010 : Record 1200;
      Assert@1003 : Codeunit 130000;
      LibrarySales@1012 : Codeunit 130509;
      LibraryPurchase@1002 : Codeunit 130512;
      LibraryERM@1000 : Codeunit 131300;
      LibraryUtility@1018 : Codeunit 131000;
      LibraryRandom@1021 : Codeunit 130440;
      LibraryXPathXMLReader@1031 : Codeunit 131337;
      Initialized@1006 : Boolean;
      NameTxt@1001 : TextConst 'ENU=You Name It';
      AddressTxt@1009 : TextConst 'ENU=Privet Drive';
      RemitTxt@1011 : TextConst 'ENU=Invoice';
      EURCode@1016 : Code[10];
      FieldMustHaveValueErr@1019 : TextConst '@@@=.;ENU=%1 must be equal to ''%2''  in %3';
      ExtDocNoTxt@1020 : TextConst '@@@=Don''t translate.;ENU=A123';
      InvalidLengthErr@1032 : TextConst 'ENU=The lengths are not identical';
      NamespaceTxt@1033 : TextConst 'ENU=urn:iso:std:iso:20022:tech:xsd:pain.001.001.03';
      MessageToRecipientNotFoundErr@1030 : TextConst 'ENU=The Message To Recipient was not found in the XML file.';
      MessageExceedsLimitErr@1034 : TextConst '@@@=.;ENU=The length of the string is %1, but it must be less than or equal to';
      TransferDateErr@1023 : TextConst 'ENU=The earliest possible transfer date is today.';
      XMLNoChildrenErr@1025 : TextConst 'ENU=XML Document has no child nodes.';
      XMLUnknownElementErr@1024 : TextConst '@@@="%1 = xml element name.";ENU=Unknown element: %1.';
      DefaultLineAmount@1026 : Decimal;
      MessageIDErr@1027 : TextConst 'ENU=Wrong Message ID in Payment Export Data.';
      PaymentInformationIDErr@1028 : TextConst 'ENU=Wrong Payment Information ID in Payment Export Data.';
      EndtoEndIDErr@1029 : TextConst 'ENU=Wrong End-to-End ID in Payment Export Data.';
      HasErrorsErr@1017 : TextConst 'ENU=The file export has one or more errors. For each of the lines to be exported, resolve any errors that are displayed in the File Export Errors FactBox.';
      CdtrAgtTagErr@1035 : TextConst 'ENU=There should not be CdtrAgt tag.';

    [Test]
    PROCEDURE BasicTestWindowsToASCII@9();
    VAR
      StringConversionManagement@1000 : Codeunit 47;
      t@1001 : Text;
      i@1002 : Integer;
      c@1003 : Char;
    BEGIN
      FOR i := 1 TO 1119 DO
        t := AddCharToText(t,i);
      t := StringConversionManagement.WindowsToASCII(t);
      FOR i := 1 TO 1119 DO BEGIN
        c := t[i];
        Assert.IsTrue(c < 128,'Non-ASCII character returned.');
      END;
    END;

    [Test]
    PROCEDURE TestWindowsToASCII16Bit@26();
    VAR
      StringConversionManagement@1000 : Codeunit 47;
      ActualText@1005 : Text;
      t@1001 : Text;
    BEGIN
      t := '';
      t := AddCharToText(t,1040); // ->A
      t := AddCharToText(t,945); // ->a
      t := AddCharToText(t,1041); // ->B
      t := AddCharToText(t,1073); // ->b
      t := AddCharToText(t,268); // ->C
      t := AddCharToText(t,967); // ->c
      t := AddCharToText(t,270); // ->D
      t := AddCharToText(t,273); // ->d
      t := AddCharToText(t,280); // ->E
      t := AddCharToText(t,941); // ->e
      t := AddCharToText(t,934); // ->F
      t := AddCharToText(t,1092); // ->f
      t := AddCharToText(t,1043); // ->G
      t := AddCharToText(t,285); // ->g
      t := AddCharToText(t,294); // ->H
      t := AddCharToText(t,295); // ->h
      t := AddCharToText(t,306); // ->I
      t := AddCharToText(t,301); // ->i
      t := AddCharToText(t,308); // ->J
      t := AddCharToText(t,309); // ->j
      t := AddCharToText(t,922); // ->K
      t := AddCharToText(t,1082); // ->k
      t := AddCharToText(t,313); // ->L
      t := AddCharToText(t,318); // ->l
      t := AddCharToText(t,924); // ->M
      t := AddCharToText(t,1084); // ->m
      t := AddCharToText(t,323); // ->N
      t := AddCharToText(t,957); // ->n
      t := AddCharToText(t,338); // ->O
      t := AddCharToText(t,337); // ->o
      t := AddCharToText(t,936); // ->P
      t := AddCharToText(t,968); // ->p
      t := AddCharToText(t,344); // ->R
      t := AddCharToText(t,961); // ->r
      t := AddCharToText(t,536); // ->S
      t := AddCharToText(t,351); // ->s
      t := AddCharToText(t,1058); // ->T
      t := AddCharToText(t,1094); // ->t
      t := AddCharToText(t,360); // ->U
      t := AddCharToText(t,369); // ->u
      t := AddCharToText(t,914); // ->V
      t := AddCharToText(t,1074); // ->v
      t := AddCharToText(t,372); // ->W
      t := AddCharToText(t,373); // ->w
      t := AddCharToText(t,926); // ->X
      t := AddCharToText(t,958); // ->x
      t := AddCharToText(t,910); // ->Y
      t := AddCharToText(t,375); // ->y
      t := AddCharToText(t,377); // ->Z
      t := AddCharToText(t,382); // ->z
      t := AddCharToText(t,1120); // ->.
      ActualText := StringConversionManagement.WindowsToASCII(t);
      Assert.AreEqual(
        'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpRrSsTtUuVvWwXxYyZz.',ActualText,'Wrong conversion from ' + t);
    END;

    [Test]
    PROCEDURE TestWindowsToASCII8Bit@27();
    VAR
      StringConversionManagement@1000 : Codeunit 47;
      ActualText@1005 : Text;
      t@1001 : Text;
    BEGIN
      t := '';
      t := AddCharToText(t,191); // ->?
      t := AddCharToText(t,193); // ->A
      t := AddCharToText(t,225); // ->a
      t := AddCharToText(t,199); // ->C
      t := AddCharToText(t,231); // ->c
      t := AddCharToText(t,208); // ->D
      t := AddCharToText(t,240); // ->d
      t := AddCharToText(t,202); // ->E
      t := AddCharToText(t,234); // ->e
      t := AddCharToText(t,205); // ->I
      t := AddCharToText(t,237); // ->i
      t := AddCharToText(t,209); // ->N
      t := AddCharToText(t,241); // ->n
      t := AddCharToText(t,213); // ->O
      t := AddCharToText(t,246); // ->o
      t := AddCharToText(t,223); // ->s
      t := AddCharToText(t,222); // ->T
      t := AddCharToText(t,254); // ->t
      t := AddCharToText(t,220); // ->U
      t := AddCharToText(t,250); // ->u
      t := AddCharToText(t,221); // ->Y
      t := AddCharToText(t,255); // ->y
      ActualText := StringConversionManagement.WindowsToASCII(t);
      Assert.AreEqual(
        '?AaCcDdEeIiNnOosTtUuYy',ActualText,'Wrong conversion from ' + t);
    END;

    [Test]
    PROCEDURE TestWindowsToASCIIEPC@25();
    VAR
      StringConversionManagement@1000 : Codeunit 47;
      ActualText@1004 : Text;
      t@1001 : Text;
    BEGIN
      t := '';
      t := AddCharToText(t,33); // !->.
      t := AddCharToText(t,34); // "->space
      t := AddCharToText(t,35); // #->.
      t := AddCharToText(t,36); // $->.
      t := AddCharToText(t,37); // %->.
      t := AddCharToText(t,38); // &->+
      t := AddCharToText(t,39); // '->space
      t := AddCharToText(t,42); // *->.
      t := AddCharToText(t,59); // ;->,
      t := AddCharToText(t,60); // <->space
      t := AddCharToText(t,61); // =->.
      t := AddCharToText(t,62); // >->space
      t := AddCharToText(t,64); // @->.
      t := AddCharToText(t,91); // [->(
      t := AddCharToText(t,92); // \->/
      t := AddCharToText(t,93); // ]->)
      t := AddCharToText(t,94); // ^->.
      t := AddCharToText(t,95); // _->-
      t := AddCharToText(t,96); // `->space
      t := AddCharToText(t,123); // {->(
      t := AddCharToText(t,124); // |->/
      t := AddCharToText(t,125); // }->)
      t := AddCharToText(t,126); // ~->-
      t := AddCharToText(t,127); // delete->.
      t := AddCharToText(t,8364); // EURO->E.
      ActualText := StringConversionManagement.WindowsToASCII(t);
      Assert.AreEqual(
        '. ...+ ., . .(/).- (/)-.E',ActualText,'Wrong conversion from ' + t);
    END;

    [Test]
    PROCEDURE TestCreditTransferRegister@15();
    VAR
      CreditTransferRegister@1000 : Record 1205;
      i@1001 : Integer;
    BEGIN
      WITH CreditTransferRegister DO BEGIN
        IF FINDLAST THEN;
        i := "No.";
        CreateNew('ID123','BANK1');
        Assert.AreEqual(i + 1,"No.",'No. was not incremented correctly.');
        TESTFIELD(Identifier,'ID123');
        TESTFIELD("From Bank Account No.",'BANK1');
        TESTFIELD(Status,Status::Canceled);
        SetStatus(Status::"File Created");
        TESTFIELD(Status,Status::"File Created");
      END;
    END;

    [Test]
    PROCEDURE TestCreditTransferEntry@16();
    VAR
      CreditTransferEntry@1000 : Record 1206;
      CustLedgerEntry@1005 : Record 21;
      VendorLedgerEntry@1004 : Record 25;
      GenJnlLine@1006 : Record 81;
      CredTrfRegNo@1002 : Integer;
      TrfDate@1003 : Date;
      i@1001 : Integer;
    BEGIN
      Init;
      GenJnlLine.INIT;
      IF CustLedgerEntry.FINDLAST THEN;
      CustLedgerEntry."Entry No." += 1;
      CustLedgerEntry."Customer No." := Customer."No.";
      CustLedgerEntry."Posting Date" := TODAY;
      CustLedgerEntry."Document No." := '123';
      CustLedgerEntry.Description := 'Test';
      CustLedgerEntry."Currency Code" := EURCode;
      CustLedgerEntry.INSERT;
      IF VendorLedgerEntry.FINDLAST THEN;
      VendorLedgerEntry."Entry No." += 1;
      VendorLedgerEntry."Vendor No." := Vendor."No.";
      VendorLedgerEntry."Posting Date" := TODAY;
      VendorLedgerEntry."Document No." := '123';
      VendorLedgerEntry.Description := 'Test';
      VendorLedgerEntry."Currency Code" := EURCode;
      VendorLedgerEntry.INSERT;
      WITH CreditTransferEntry DO BEGIN
        IF FINDLAST THEN;
        CredTrfRegNo := "Credit Transfer Register No.";
        i := "Entry No.";
        TrfDate := TODAY;
        CreateNew(
          CredTrfRegNo,0,GenJnlLine."Account Type"::Vendor,VendorLedgerEntry."Vendor No.",VendorLedgerEntry."Entry No.",
          TrfDate,VendorLedgerEntry."Currency Code",123.45,'ID123',
          GenJnlLine."Recipient Bank Account",GenJnlLine."Message to Recipient");
        Assert.AreEqual(i + 1,"Entry No.",'Entry No. was not incremented correctly.');
        TESTFIELD("Transfer Date",TrfDate);
        TESTFIELD("Credit Transfer Register No.",CredTrfRegNo);
        TESTFIELD("Account No.",VendorLedgerEntry."Vendor No.");
        TESTFIELD("Applies-to Entry No.",VendorLedgerEntry."Entry No.");
        TESTFIELD("Currency Code",VendorLedgerEntry."Currency Code");
        TESTFIELD("Transfer Amount",123.45);
        TESTFIELD("Transaction ID",'ID123');
        VendorLedgerEntry.CALCFIELDS(Amount,"Remaining Amount");
        Assert.AreEqual(Vendor.Name,CreditorName,'Wrong Creditor Name.');
        Assert.AreEqual(VendorLedgerEntry."Document No.",AppliesToEntryDocumentNo,'Wrong VLE Doc. No.');
        Assert.AreEqual(VendorLedgerEntry.Description,AppliesToEntryDescription,'Wrong VLE Description.');
        Assert.AreEqual(VendorLedgerEntry."Posting Date",AppliesToEntryPostingDate,'Wrong VLE Posting Date.');
        Assert.AreEqual(VendorLedgerEntry."Currency Code",AppliesToEntryCurrencyCode,'Wrong VLE Currency Code.');
        Assert.AreEqual(VendorLedgerEntry.Amount,AppliesToEntryAmount,'Wrong VLE Amount.');
        Assert.AreEqual(VendorLedgerEntry."Remaining Amount",AppliesToEntryRemainingAmount,'Wrong VLE Rem. Amt.');

        CreateNew(
          CredTrfRegNo,0,GenJnlLine."Account Type"::Customer,CustLedgerEntry."Customer No.",CustLedgerEntry."Entry No.",
          TrfDate,CustLedgerEntry."Currency Code",123.45,'ID123',
          GenJnlLine."Recipient Bank Account",GenJnlLine."Message to Recipient");
        CustLedgerEntry.CALCFIELDS(Amount,"Remaining Amount");
        Assert.AreEqual(Customer.Name,CreditorName,'Wrong Creditor Name.');
        Assert.AreEqual(CustLedgerEntry."Document No.",AppliesToEntryDocumentNo,'Wrong CLE Doc. No.');
        Assert.AreEqual(CustLedgerEntry.Description,AppliesToEntryDescription,'Wrong CLE Description.');
        Assert.AreEqual(CustLedgerEntry."Posting Date",AppliesToEntryPostingDate,'Wrong CLE Posting Date.');
        Assert.AreEqual(CustLedgerEntry."Currency Code",AppliesToEntryCurrencyCode,'Wrong CLE Currency Code.');
        Assert.AreEqual(CustLedgerEntry.Amount,AppliesToEntryAmount,'Wrong CLE Amount.');
        Assert.AreEqual(CustLedgerEntry."Remaining Amount",AppliesToEntryRemainingAmount,'Wrong CLE Rem. Amt.');
      END;
    END;

    [Test]
    PROCEDURE TestPaymentExportData_InstPrio@17();
    VAR
      PaymentExportData@1000 : Record 1226;
    BEGIN
      WITH PaymentExportData DO BEGIN
        INIT;
        VALIDATE("SEPA Instruction Priority","SEPA Instruction Priority"::NORMAL);
        TESTFIELD("SEPA Instruction Priority Text",'NORM');
        VALIDATE("SEPA Instruction Priority","SEPA Instruction Priority"::HIGH);
        TESTFIELD("SEPA Instruction Priority Text",'HIGH');
      END;
    END;

    [Test]
    PROCEDURE TestPaymentExportData_PmtMeth@6();
    VAR
      PaymentExportData@1000 : Record 1226;
    BEGIN
      WITH PaymentExportData DO BEGIN
        INIT;
        VALIDATE("SEPA Payment Method","SEPA Payment Method"::CHK);
        TESTFIELD("SEPA Payment Method Text",'CHK');
        VALIDATE("SEPA Payment Method","SEPA Payment Method"::TRF);
        TESTFIELD("SEPA Payment Method Text",'TRF');
        VALIDATE("SEPA Payment Method","SEPA Payment Method"::TRA);
        TESTFIELD("SEPA Payment Method Text",'TRA');
      END;
    END;

    [Test]
    PROCEDURE TestPaymentExportData_CrgBearer@8();
    VAR
      PaymentExportData@1000 : Record 1226;
    BEGIN
      WITH PaymentExportData DO BEGIN
        INIT;
        VALIDATE("SEPA Charge Bearer","SEPA Charge Bearer"::DEBT);
        TESTFIELD("SEPA Charge Bearer Text",'DEBT');
        VALIDATE("SEPA Charge Bearer","SEPA Charge Bearer"::CRED);
        TESTFIELD("SEPA Charge Bearer Text",'CRED');
        VALIDATE("SEPA Charge Bearer","SEPA Charge Bearer"::SHAR);
        TESTFIELD("SEPA Charge Bearer Text",'SHAR');
        VALIDATE("SEPA Charge Bearer","SEPA Charge Bearer"::SLEV);
        TESTFIELD("SEPA Charge Bearer Text",'SLEV');
      END;
    END;

    [Test]
    PROCEDURE TestPaymentExportDataIsFieldBlank@28();
    VAR
      PaymentExportData@1000 : Record 1226;
    BEGIN
      WITH PaymentExportData DO BEGIN
        INIT;
        "Line No." := 1;
        Assert.IsFalse(IsFieldBlank(FIELDNO("Line No.")),FIELDNAME("Line No."));
        "Line No." := 0;
        Assert.IsTrue(IsFieldBlank(FIELDNO("Line No.")),FIELDNAME("Line No."));
        Amount := 1;
        Assert.IsFalse(IsFieldBlank(FIELDNO(Amount)),FIELDNAME(Amount));
        Amount := 0;
        Assert.IsTrue(IsFieldBlank(FIELDNO(Amount)),FIELDNAME(Amount));
        "Sender Bank Account Code" := 'x';
        Assert.IsFalse(IsFieldBlank(FIELDNO("Sender Bank Account Code")),FIELDNAME("Sender Bank Account Code"));
        "Sender Bank Account Code" := '';
        Assert.IsTrue(IsFieldBlank(FIELDNO("Sender Bank Account Code")),FIELDNAME("Sender Bank Account Code"));
        "Sender Bank Account No." := 'x';
        Assert.IsFalse(IsFieldBlank(FIELDNO("Sender Bank Account No.")),FIELDNAME("Sender Bank Account No."));
        "Sender Bank Account No." := '';
        Assert.IsTrue(IsFieldBlank(FIELDNO("Sender Bank Account No.")),FIELDNAME("Sender Bank Account No."));
        "Transfer Date" := 010101D;
        Assert.IsFalse(IsFieldBlank(FIELDNO("Transfer Date")),FIELDNAME("Transfer Date"));
        "Transfer Date" := 0D;
        Assert.IsTrue(IsFieldBlank(FIELDNO("Transfer Date")),FIELDNAME("Transfer Date"));
        // an option field always returns FALSE;
        "SEPA Payment Method" := 1;
        Assert.IsFalse(IsFieldBlank(FIELDNO("SEPA Payment Method")),FIELDNAME("SEPA Payment Method"));
        "SEPA Payment Method" := 0;
        Assert.IsFalse(IsFieldBlank(FIELDNO("SEPA Payment Method")),FIELDNAME("SEPA Payment Method"));
      END;
    END;

    [Test]
    PROCEDURE TestPaymentExportErrorText@18();
    VAR
      PaymentJnlExportErrorText@1001 : Record 1228;
      GenJnlLine@1000 : Record 81;
      i@1002 : Integer;
    BEGIN
      IF GenJnlLine.FINDLAST THEN;
      WITH PaymentJnlExportErrorText DO BEGIN
        SETRANGE("Journal Template Name",GenJnlLine."Journal Template Name");
        SETRANGE("Journal Batch Name",GenJnlLine."Journal Batch Name");
        SETRANGE("Journal Line No.",GenJnlLine."Line No.");
        IF FINDLAST THEN;
        i := "Line No.";
        CreateNew(GenJnlLine,'Error 1','','');
        FINDLAST;
        Assert.AreEqual(i + 1,"Line No.",'Wrong Line No.');
        TESTFIELD("Error Text",'Error 1');
        Assert.IsTrue(GenJnlLine.HasPaymentFileErrors,'Journal line is missing error text.');
        Assert.IsTrue(JnlLineHasErrors(GenJnlLine),'Error text not found.');
        DeleteJnlLineErrors(GenJnlLine);
        Assert.IsFalse(GenJnlLine.HasPaymentFileErrors,'Journal line has an error text.');
        Assert.IsFalse(JnlLineHasErrors(GenJnlLine),'Error text 1 found.');
        CreateNew(GenJnlLine,'Error 2','','');
        DeleteJnlBatchErrors(GenJnlLine);
        Assert.IsFalse(JnlLineHasErrors(GenJnlLine),'Error text 2 found.');
      END;
    END;

    [Test]
    PROCEDURE TestPaymentExportDataCharSetWindows@19();
    VAR
      TempPaymentExportData@1000 : TEMPORARY Record 1226;
      TempPaymentExportRemittanceText@1001 : TEMPORARY Record 1229;
    BEGIN
      WITH TempPaymentExportData DO BEGIN
        SetPreserveNonLatinCharacters(TRUE);
        CreatePaymentExportDataCharSetData(TempPaymentExportData);
        Assert.AreEqual(AccentuateText(NameTxt),"Recipient Name",'Name has been converted.');
        Assert.AreEqual(AccentuateText(AddressTxt),"Recipient Address",'Address has been converted.');
        GetRemittanceTexts(TempPaymentExportRemittanceText);
        TempPaymentExportRemittanceText.FINDFIRST;
        Assert.AreEqual(AccentuateText(RemitTxt),TempPaymentExportRemittanceText.Text,'Remittance text has been converted.');
      END;
    END;

    [Test]
    PROCEDURE TestPaymentExportDataCharSetASCII@21();
    VAR
      TempPaymentExportData@1000 : TEMPORARY Record 1226;
      TempPaymentExportRemittanceText@1001 : TEMPORARY Record 1229;
    BEGIN
      WITH TempPaymentExportData DO BEGIN
        SetPreserveNonLatinCharacters(FALSE);
        CreatePaymentExportDataCharSetData(TempPaymentExportData);
        Assert.AreEqual(FORMAT(NameTxt),"Recipient Name",'Name has not been converted.');
        Assert.AreEqual(FORMAT(AddressTxt),"Recipient Address",'Address has not been converted.');
        GetRemittanceTexts(TempPaymentExportRemittanceText);
        TempPaymentExportRemittanceText.FINDFIRST;
        Assert.AreEqual(FORMAT(RemitTxt),TempPaymentExportRemittanceText.Text,'Remittance text has not been converted.');
      END;
    END;

    [Test]
    PROCEDURE TestCompanyInformationSetASCII@10();
    VAR
      CompanyInformation@1000 : Record 79;
      PaymentExportData@1001 : Record 1226;
    BEGIN
      WITH CompanyInformation DO BEGIN
        INIT;
        Name := COPYSTR(AccentuateText(NameTxt),1,MAXSTRLEN(Name));
        Address := COPYSTR(AccentuateText(AddressTxt),1,MAXSTRLEN(Address));
        PaymentExportData.CompanyInformationConvertToLatin(CompanyInformation);
        Assert.AreEqual(FORMAT(NameTxt),Name,'Name has not been converted.');
        Assert.AreEqual(FORMAT(AddressTxt),Address,'Address has not been converted.');
      END;
    END;

    [Test]
    PROCEDURE TestSEPACreatePayment00100103Success@1();
    VAR
      GenJnlLine@1001 : Record 81;
      TempPaymentExportData@1000 : TEMPORARY Record 1226;
      CreditTransferRegister@1002 : Record 1205;
      TempPaymentExportRemittanceText@1004 : TEMPORARY Record 1229;
      SEPACTFillExportBuffer@1003 : Codeunit 1221;
    BEGIN
      Init;
      CreateGenJnlLine(GenJnlLine);
      SEPACTFillExportBuffer.FillExportBuffer(GenJnlLine,TempPaymentExportData);
      Assert.AreEqual(1,TempPaymentExportData.COUNT,'Wrong number of payment lines created.');
      TempPaymentExportData.GetRemittanceTexts(TempPaymentExportRemittanceText);
      Assert.AreEqual(1,TempPaymentExportRemittanceText.COUNT,'Wrong number of remittance lines created.');
      Assert.IsTrue(STRPOS(TempPaymentExportRemittanceText.Text,ExtDocNoTxt) > 0,'Remittance text should contain ext. doc. no.');
      CreditTransferRegister.FINDLAST;
      CreditTransferRegister.TESTFIELD("Created by User",USERID);
      CreditTransferRegister.TESTFIELD(Status,CreditTransferRegister.Status::Canceled);
    END;

    [Test]
    PROCEDURE TestSEPACreatePayment00100103Failure@4();
    VAR
      GenJnlLine@1001 : Record 81;
      TempPaymentExportData@1000 : TEMPORARY Record 1226;
      CreditTransferRegister@1002 : Record 1205;
      PaymentJnlExportErrorText@1003 : Record 1228;
      SEPACTFillExportBuffer@1004 : Codeunit 1221;
      LastTransferRegNo@1005 : Integer;
    BEGIN
      Init;
      CreateGenJnlLine(GenJnlLine);
      GenJnlLine.Amount := -GenJnlLine.Amount;
      GenJnlLine.MODIFY;
      IF CreditTransferRegister.FINDLAST THEN;
      LastTransferRegNo := CreditTransferRegister."No.";

      ASSERTERROR SEPACTFillExportBuffer.FillExportBuffer(GenJnlLine,TempPaymentExportData);

      IF CreditTransferRegister.FINDLAST THEN;
      Assert.AreEqual(LastTransferRegNo,CreditTransferRegister."No.",'Credit Transfer Reg. was inserted.');

      PaymentJnlExportErrorText.SETRANGE("Journal Template Name",GenJnlLine."Journal Template Name");
      PaymentJnlExportErrorText.SETRANGE("Journal Batch Name",GenJnlLine."Journal Batch Name");
      PaymentJnlExportErrorText.SETRANGE("Journal Line No.",GenJnlLine."Line No.");
      Assert.AreEqual(1,PaymentJnlExportErrorText.COUNT,'Wrong number of error texts created.');
    END;

    [Test]
    PROCEDURE TestSetCustomerAsRecipient@24();
    VAR
      Customer@1001 : Record 18;
      CustomerBankAccount@1002 : Record 287;
      PaymentExportData@1000 : Record 1226;
    BEGIN
      // [FEATURE] [UT]
      // [SCENARIO] Customer Bank Account information should be transferred by PaymentExportData.SetCustomerAsRecipient
      Customer.INIT;
      Customer.Name := LibraryUtility.GenerateGUID;
      Customer.Address := LibraryUtility.GenerateGUID;
      Customer.City := LibraryUtility.GenerateGUID;
      Customer.County := LibraryUtility.GenerateGUID;
      Customer."Post Code" := LibraryUtility.GenerateGUID;
      Customer."Country/Region Code" := LibraryUtility.GenerateGUID;

      CustomerBankAccount.INIT;
      CustomerBankAccount.Name := LibraryUtility.GenerateGUID;
      CustomerBankAccount.Address := LibraryUtility.GenerateGUID;
      CustomerBankAccount.City := LibraryUtility.GenerateGUID;
      CustomerBankAccount.County := LibraryUtility.GenerateGUID;
      CustomerBankAccount."Post Code" := LibraryUtility.GenerateGUID;
      CustomerBankAccount."Country/Region Code" := LibraryUtility.GenerateGUID;
      CustomerBankAccount."SWIFT Code" := LibraryUtility.GenerateGUID;
      CustomerBankAccount.IBAN := LibraryUtility.GenerateGUID;
      CustomerBankAccount."Bank Clearing Standard" := LibraryUtility.GenerateGUID;
      CustomerBankAccount."Bank Clearing Code" := LibraryUtility.GenerateGUID;

      PaymentExportData.SetCustomerAsRecipient(Customer,CustomerBankAccount);

      PaymentExportData.TESTFIELD("Recipient Name",Customer.Name);
      PaymentExportData.TESTFIELD("Recipient Address",Customer.Address);
      PaymentExportData.TESTFIELD("Recipient City",Customer.City);
      PaymentExportData.TESTFIELD("Recipient County",Customer.County);
      PaymentExportData.TESTFIELD("Recipient Post Code",Customer."Post Code");
      PaymentExportData.TESTFIELD("Recipient Country/Region Code",Customer."Country/Region Code");
      PaymentExportData.TESTFIELD("Recipient Email Address",Customer."E-Mail");
      PaymentExportData.TESTFIELD("Recipient Bank Name",CustomerBankAccount.Name);
      PaymentExportData.TESTFIELD("Recipient Bank Address",CustomerBankAccount.Address);
      PaymentExportData.TESTFIELD("Recipient Bank City",CustomerBankAccount.City);
      PaymentExportData.TESTFIELD("Recipient Bank County",CustomerBankAccount.County);
      PaymentExportData.TESTFIELD("Recipient Bank Post Code",CustomerBankAccount."Post Code");
      PaymentExportData.TESTFIELD("Recipient Bank Country/Region",CustomerBankAccount."Country/Region Code");
      PaymentExportData.TESTFIELD("Recipient Bank BIC",CustomerBankAccount."SWIFT Code");
      PaymentExportData.TESTFIELD("Recipient Bank Acc. No.",CustomerBankAccount.IBAN);
      PaymentExportData.TESTFIELD("Recipient Bank Clearing Std.",CustomerBankAccount."Bank Clearing Standard");
      PaymentExportData.TESTFIELD("Recipient Bank Clearing Code",CustomerBankAccount."Bank Clearing Code");
    END;

    [Test]
    PROCEDURE TestSetVendorAsRecipient@31();
    VAR
      Vendor@1001 : Record 23;
      PaymentExportData@1000 : Record 1226;
    BEGIN
      // [FEATURE] [UT]
      // [SCENARIO] Vendor Bank Account information should be transferred by PaymentExportData.SetVendorAsRecipient
      Vendor.INIT;
      Vendor.Name := LibraryUtility.GenerateGUID;
      Vendor.Address := LibraryUtility.GenerateGUID;
      Vendor.City := LibraryUtility.GenerateGUID;
      Vendor.County := LibraryUtility.GenerateGUID;
      Vendor."Post Code" := LibraryUtility.GenerateGUID;
      Vendor."Country/Region Code" := LibraryUtility.GenerateGUID;

      VendorBankAccount.INIT;
      VendorBankAccount.Name := LibraryUtility.GenerateGUID;
      VendorBankAccount.Address := LibraryUtility.GenerateGUID;
      VendorBankAccount.City := LibraryUtility.GenerateGUID;
      VendorBankAccount.County := LibraryUtility.GenerateGUID;
      VendorBankAccount."Post Code" := LibraryUtility.GenerateGUID;
      VendorBankAccount."Country/Region Code" := LibraryUtility.GenerateGUID;
      VendorBankAccount."SWIFT Code" := LibraryUtility.GenerateGUID;
      VendorBankAccount.IBAN := LibraryUtility.GenerateGUID;
      VendorBankAccount."Bank Clearing Standard" := LibraryUtility.GenerateGUID;
      VendorBankAccount."Bank Clearing Code" := LibraryUtility.GenerateGUID;

      PaymentExportData.SetVendorAsRecipient(Vendor,VendorBankAccount);

      PaymentExportData.TESTFIELD("Recipient Name",Vendor.Name);
      PaymentExportData.TESTFIELD("Recipient Address",Vendor.Address);
      PaymentExportData.TESTFIELD("Recipient City",Vendor.City);
      PaymentExportData.TESTFIELD("Recipient County",Vendor.County);
      PaymentExportData.TESTFIELD("Recipient Post Code",Vendor."Post Code");
      PaymentExportData.TESTFIELD("Recipient Country/Region Code",Vendor."Country/Region Code");
      PaymentExportData.TESTFIELD("Recipient Email Address",Vendor."E-Mail");
      PaymentExportData.TESTFIELD("Recipient Bank Name",VendorBankAccount.Name);
      PaymentExportData.TESTFIELD("Recipient Bank Address",VendorBankAccount.Address);
      PaymentExportData.TESTFIELD("Recipient Bank City",VendorBankAccount.City);
      PaymentExportData.TESTFIELD("Recipient Bank County",VendorBankAccount.County);
      PaymentExportData.TESTFIELD("Recipient Bank Post Code",VendorBankAccount."Post Code");
      PaymentExportData.TESTFIELD("Recipient Bank Country/Region",VendorBankAccount."Country/Region Code");
      PaymentExportData.TESTFIELD("Recipient Bank BIC",VendorBankAccount."SWIFT Code");
      PaymentExportData.TESTFIELD("Recipient Bank Acc. No.",VendorBankAccount.IBAN);
      PaymentExportData.TESTFIELD("Recipient Bank Clearing Std.",VendorBankAccount."Bank Clearing Standard");
      PaymentExportData.TESTFIELD("Recipient Bank Clearing Code",VendorBankAccount."Bank Clearing Code");
    END;

    [Test]
    PROCEDURE TestBankAsSenderBank@36();
    VAR
      BankAccount@1001 : Record 270;
      PaymentExportData@1000 : Record 1226;
    BEGIN
      // [FEATURE] [UT]
      // [SCENARIO] Bank Account information should be transferred by PaymentExportData.SetBankAsSenderBank
      BankAccount.INIT;
      BankAccount."Bank Name - Data Conversion" := LibraryUtility.GenerateGUID;
      BankAccount.Name := LibraryUtility.GenerateGUID;
      BankAccount.Address := LibraryUtility.GenerateGUID;
      BankAccount.City := LibraryUtility.GenerateGUID;
      BankAccount.County := LibraryUtility.GenerateGUID;
      BankAccount."Post Code" := LibraryUtility.GenerateGUID;
      BankAccount."No." := LibraryUtility.GenerateGUID;
      BankAccount.IBAN := LibraryUtility.GenerateGUID;
      BankAccount."SWIFT Code" := LibraryUtility.GenerateGUID;
      BankAccount."Bank Clearing Standard" := LibraryUtility.GenerateGUID;
      BankAccount."Bank Clearing Code" := LibraryUtility.GenerateGUID;

      PaymentExportData.SetBankAsSenderBank(BankAccount);

      PaymentExportData.TESTFIELD("Sender Bank Name - Data Conv.",BankAccount."Bank Name - Data Conversion");
      PaymentExportData.TESTFIELD("Sender Bank Name",BankAccount.Name);
      PaymentExportData.TESTFIELD("Sender Bank Address",BankAccount.Address);
      PaymentExportData.TESTFIELD("Sender Bank City",BankAccount.City);
      PaymentExportData.TESTFIELD("Sender Bank County",BankAccount.County);
      PaymentExportData.TESTFIELD("Sender Bank Post Code",BankAccount."Post Code");
      PaymentExportData.TESTFIELD("Sender Bank Account Code",BankAccount."No.");
      PaymentExportData.TESTFIELD("Sender Bank Account No.",BankAccount.IBAN);
      PaymentExportData.TESTFIELD("Sender Bank BIC",BankAccount."SWIFT Code");
      PaymentExportData.TESTFIELD("Sender Bank Clearing Std.",BankAccount."Bank Clearing Standard");
      PaymentExportData.TESTFIELD("Sender Bank Clearing Code",BankAccount."Bank Clearing Code");
    END;

    [Test]
    PROCEDURE TestCreateXMLDoc@2();
    VAR
      GenJnlLine@1000 : Record 81;
      TempBlob@1003 : Record 99008535;
      OutStr@1001 : OutStream;
      InStr@1004 : InStream;
      s@1005 : Text;
    BEGIN
      Init;
      CreateGenJnlLine(GenJnlLine);
      TempBlob.INIT;
      TempBlob.Blob.CREATEOUTSTREAM(OutStr);
      XMLPORT.EXPORT(BankAccount.GetPaymentExportXMLPortID,OutStr,GenJnlLine);
      TempBlob.Blob.CREATEINSTREAM(InStr);
      InStr.READTEXT(s);
      Assert.AreEqual('<?xml version="1.0" encoding="UTF-8" standalone="no"?>',s,'Wrong XML header.');
      InStr.READTEXT(s);
      Assert.AreEqual('<Document xmlns="urn:iso:std:iso:20022:tech:xsd:pain.001.001.03">',s,'Wrong XML Instruction.');
      InStr.READTEXT(s);
      Assert.AreEqual('  <CstmrCdtTrfInitn>',s,'Wrong XML root.');
    END;

    [Test]
    PROCEDURE TestXMLDocGrouping@33();
    VAR
      GenJnlLine@1007 : Record 81;
      TempBlob@1003 : Record 99008535;
      XMLDOMManagement@1002 : Codeunit 6224;
      XMLDoc@1009 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlDocument";
      XMLDocNode@1012 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode";
      XMLNodes@1011 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeList";
      XMLNode@1010 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode";
      OutStr@1008 : OutStream;
      InStr@1005 : InStream;
      TransferDate@1006 : Date;
      ExpectedNoOfGroups@1000 : Integer;
      NoOfPmtsPerGroup@1004 : Integer;
      NoOfPmtInf@1013 : Integer;
      i@1001 : Integer;
    BEGIN
      Init;

      ExpectedNoOfGroups := 4;
      NoOfPmtsPerGroup := 5;
      CreateGenJnlLinesDiffDate(GenJnlLine,ExpectedNoOfGroups,NoOfPmtsPerGroup);
      GenJnlLine.FINDFIRST;
      TransferDate := GenJnlLine."Posting Date";

      TempBlob.INIT;
      TempBlob.Blob.CREATEOUTSTREAM(OutStr);
      XMLPORT.EXPORT(BankAccount.GetPaymentExportXMLPortID,OutStr,GenJnlLine);

      // Validation of elements
      TempBlob.Blob.CREATEINSTREAM(InStr);
      XMLDOMManagement.LoadXMLDocumentFromInStream(InStr,XMLDoc);
      XMLDocNode := XMLDoc.DocumentElement;
      IF NOT XMLDocNode.HasChildNodes THEN
        ERROR(XMLNoChildrenErr);

      XMLNode := XMLDocNode.FirstChild;
      Assert.AreEqual('CstmrCdtTrfInitn',XMLNode.Name,'CstmrCdtTrfInitn');
      XMLNodes := XMLNode.ChildNodes;
      FOR i := 0 TO XMLNodes.Count - 1 DO BEGIN
        XMLNode := XMLNodes.ItemOf(i);
        CASE XMLNode.Name OF
          'GrpHdr':
            ValidateGrpHdr(XMLNode,GenJnlLine);
          'PmtInf':
            BEGIN
              NoOfPmtInf += 1;
              ValidatePmtInf(XMLNode,NoOfPmtsPerGroup,NoOfPmtsPerGroup * DefaultLineAmount,TransferDate);
              TransferDate += 1;
            END;
          ELSE
            ERROR(XMLUnknownElementErr,XMLNode.Name);
        END;
      END;

      Assert.AreEqual(ExpectedNoOfGroups,NoOfPmtInf,'Wrong number of PmtInf nodes.');

      // TFS378393 No empty 'CdtrAgt' tag is exported
      XMLNodes := XMLDoc.GetElementsByTagName('CdtrAgt');
      Assert.AreEqual(0,XMLNodes.Count,CdtrAgtTagErr);
    END;

    [Test]
    PROCEDURE TestXMLMessageToRecipient@40();
    VAR
      GenJnlLine@1000 : Record 81;
      TempBlob@1001 : Record 99008535;
      NodeList@1003 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeList";
      OutStr@1006 : OutStream;
      ContainsReqCharacters@1004 : Boolean;
      i@1005 : Integer;
      RequiredMessageLength@1007 : Integer;
    BEGIN
      // [SCENARIO 109389] Message to recipient is stored in the exported file
      Init;
      RequiredMessageLength := 140;

      // [GIVEN] A Payment Journal Line
      // [GIVEN] bal. bank account using the SEPA CT export format
      CreateGenJnlLine(GenJnlLine);

      // [GIVEN] 140 characters in "Message to recipient"
      GenJnlLine.VALIDATE("Message to Recipient",LibraryUtility.GenerateRandomXMLText(RequiredMessageLength));
      GenJnlLine.MODIFY(TRUE);
      Assert.AreEqual(RequiredMessageLength,STRLEN(GenJnlLine."Message to Recipient"),InvalidLengthErr);

      // [WHEN] The Payment Journal Line is exported
      GenJnlLine.SETRANGE("Document No.",GenJnlLine."Document No.");
      GenJnlLine.SETRANGE("Document Type",GenJnlLine."Document Type");
      TempBlob.INIT;
      TempBlob.Blob.CREATEOUTSTREAM(OutStr);
      XMLPORT.EXPORT(BankAccount.GetPaymentExportXMLPortID,OutStr,GenJnlLine);

      // [THEN] The exported file contains an ustrd tag with all 140 characters
      LibraryXPathXMLReader.InitializeWithBlob(TempBlob,NamespaceTxt);
      LibraryXPathXMLReader.GetNodeList('//Ustrd',NodeList);

      ContainsReqCharacters := FALSE;
      FOR i := 1 TO NodeList.Count DO
        IF GenJnlLine."Message to Recipient" = NodeList.Item(i - 1).InnerText THEN
          ContainsReqCharacters := TRUE;

      Assert.IsTrue(ContainsReqCharacters,MessageToRecipientNotFoundErr);
    END;

    [Test]
    PROCEDURE TestXMLMessageToRecipientLimit@41();
    VAR
      GenJnlLine@1000 : Record 81;
      RequiredMessageLength@1001 : Integer;
    BEGIN
      // [SCENARIO 109389] Message to recipient cannot contain more than 140 characters
      Init;
      RequiredMessageLength := 141;

      // [GIVEN] A Payment Journal Line
      // [GIVEN] bal. bank account using the SEPA CT export format
      CreateGenJnlLine(GenJnlLine);

      // [WHEN] 141 characters is inserted into "Message to recipient"
      // [THEN] Expect error message, that 141 characters are not allowed into this field.
      ASSERTERROR GenJnlLine.VALIDATE("Message to Recipient",LibraryUtility.GenerateRandomXMLText(RequiredMessageLength));

      Assert.ExpectedError(STRSUBSTNO(MessageExceedsLimitErr,RequiredMessageLength));
    END;

    [Test]
    PROCEDURE PostingDateAfterToday@32();
    VAR
      PaymentJnlExportErrorText@1130 : Record 1228;
      GenJnlLine@1001 : Record 81;
      TempPaymentExportData@1000 : TEMPORARY Record 1226;
      SEPACTFillExportBuffer@1003 : Codeunit 1221;
    BEGIN
      Init;
      // Setup.
      CreateGenJnlLine(GenJnlLine);
      GenJnlLine."Posting Date" := CALCDATE('<1D>',TODAY);
      GenJnlLine.MODIFY;
      PaymentJnlExportErrorText.DELETEALL;

      // Exercise.
      SEPACTFillExportBuffer.FillExportBuffer(GenJnlLine,TempPaymentExportData);

      // Verify.
      TempPaymentExportData.TESTFIELD("Transfer Date",GenJnlLine."Posting Date");
    END;

    [Test]
    PROCEDURE DueDateBeforePostingDateBeforeToday@35();
    VAR
      PaymentJnlExportErrorText@1130 : Record 1228;
      VendLedgerEntry@1005 : Record 25;
      GenJnlLine@1001 : Record 81;
      TempPaymentExportData@1000 : TEMPORARY Record 1226;
      SEPACTFillExportBuffer@1003 : Codeunit 1221;
    BEGIN
      Init;
      // Setup.
      CreateVendorLedgerEntry(VendLedgerEntry,-2);
      CreateGenJnlLine(GenJnlLine);
      GenJnlLine."Posting Date" := CALCDATE('<-1D>',TODAY);
      GenJnlLine.VALIDATE("Applies-to Doc. Type",GenJnlLine."Applies-to Doc. Type"::Invoice);
      GenJnlLine.VALIDATE("Applies-to Doc. No.",VendLedgerEntry."Document No.");
      GenJnlLine.MODIFY;
      PaymentJnlExportErrorText.DELETEALL;

      // Exercise.
      ASSERTERROR SEPACTFillExportBuffer.FillExportBuffer(GenJnlLine,TempPaymentExportData);

      // Verify.
      Assert.ExpectedError(HasErrorsErr);
      CheckPostingDateError(GenJnlLine);
    END;

    [Test]
    PROCEDURE DueDateBeforeTodayBeforePostingDate@39();
    VAR
      VendLedgerEntry@1005 : Record 25;
      GenJnlLine@1001 : Record 81;
      TempPaymentExportData@1000 : TEMPORARY Record 1226;
      SEPACTFillExportBuffer@1003 : Codeunit 1221;
    BEGIN
      Init;
      // Setup.
      CreateVendorLedgerEntry(VendLedgerEntry,-2);
      CreateGenJnlLine(GenJnlLine);
      GenJnlLine."Posting Date" := CALCDATE('<1D>',TODAY);
      GenJnlLine.VALIDATE("Applies-to Doc. Type",GenJnlLine."Applies-to Doc. Type"::Invoice);
      GenJnlLine.VALIDATE("Applies-to Doc. No.",VendLedgerEntry."Document No.");
      GenJnlLine.MODIFY;

      // Exercise.
      SEPACTFillExportBuffer.FillExportBuffer(GenJnlLine,TempPaymentExportData);

      // Verify.
      TempPaymentExportData.TESTFIELD("Transfer Date",GenJnlLine."Posting Date");
    END;

    [Test]
    PROCEDURE VendorLedgerEntryMarkedAsExportedToFile@13();
    VAR
      VendorLedgerEntry@1005 : Record 25;
      GenJnlLine@1001 : Record 81;
      SEPACTExportFile@1000 : Codeunit 1220;
    BEGIN
      Init;
      // Setup.
      CreateVendorLedgerEntry(VendorLedgerEntry,0);
      CreateGenJnlLine(GenJnlLine);
      GenJnlLine."Posting Date" := TODAY;
      GenJnlLine.VALIDATE("Applies-to Doc. Type",GenJnlLine."Applies-to Doc. Type"::Invoice);
      GenJnlLine.VALIDATE("Applies-to Doc. No.",VendorLedgerEntry."Document No.");
      GenJnlLine.MODIFY;

      // Exercise.
      SEPACTExportFile.EnableExportToServerFile;
      SEPACTExportFile.RUN(GenJnlLine);

      // Verify.
      VendorLedgerEntry.GET(VendorLedgerEntry."Entry No.");
      GenJnlLine.GET(GenJnlLine."Journal Template Name",GenJnlLine."Journal Batch Name",GenJnlLine."Line No.");
      Assert.IsTrue(VendorLedgerEntry."Exported to Payment File",
        '''Exported to payment file'' flag not set on the vendor ledger entry.');
      Assert.IsTrue(GenJnlLine."Exported to Payment File",
        '''Exported to payment file'' flag not set on the general journal line.');
    END;

    [Test]
    PROCEDURE GenJnlLineDocNoGapWithNoSeries@30();
    VAR
      GenJnlLine@1001 : Record 81;
      NoSeries@1006 : Record 308;
      NoSeriesLine@1008 : Record 309;
      BankAcc@1002 : Record 270;
    BEGIN
      Init;

      // Pre-Setup
      CreateGenJnlLine(GenJnlLine);
      LibraryUtility.CreateNoSeries(NoSeries,TRUE,FALSE,FALSE);
      LibraryUtility.CreateNoSeriesLine(NoSeriesLine,NoSeries.Code,'','');

      // Setup
      LibraryERM.CreateBankAccount(BankAcc);
      GenJournalBatch.VALIDATE("No. Series",NoSeries.Code);
      GenJournalBatch.VALIDATE("Allow Payment Export",TRUE);
      GenJournalBatch."Bal. Account Type" := GenJournalBatch."Bal. Account Type"::"Bank Account";
      GenJournalBatch."Bal. Account No." := BankAcc."No.";
      GenJournalBatch.MODIFY(TRUE);
      GenJnlLine.VALIDATE("Document No.",'1');
      GenJnlLine.MODIFY(TRUE);

      // Pre-Exercise
      GenJnlLine.SETRANGE("Journal Template Name",GenJournalTemplate.Name);
      GenJnlLine.SETRANGE("Journal Batch Name",GenJournalBatch.Name);
      GenJnlLine."Bal. Account Type" := GenJnlLine."Bal. Account Type"::"Bank Account";
      GenJnlLine."Bal. Account No." := BankAcc."No.";

      // Exercise
      ASSERTERROR CODEUNIT.RUN(CODEUNIT::"Export Payment File (Yes/No)",GenJnlLine);

      // Verify
      Assert.ExpectedError(
        STRSUBSTNO(FieldMustHaveValueErr,GenJnlLine.FIELDCAPTION("Document No."),NoSeriesLine."Starting No.",GenJnlLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE GenJnlLineDocNoGapWithoutNoSeries@29();
    VAR
      GenJnlLine@1001 : Record 81;
      TempPaymentExportData@1000 : TEMPORARY Record 1226;
      CreditTransferRegister@1002 : Record 1205;
      SEPACTFillExportBuffer@1003 : Codeunit 1221;
    BEGIN
      Init;

      // Pre-Setup
      CreateGenJnlLine(GenJnlLine);

      // Setup
      GenJournalBatch.VALIDATE("No. Series",'');
      GenJournalBatch.MODIFY(TRUE);
      GenJnlLine.VALIDATE("Document No.",'1');
      GenJnlLine.MODIFY(TRUE);

      // Pre-Exercise
      GenJnlLine.SETRANGE("Journal Template Name",GenJournalTemplate.Name);
      GenJnlLine.SETRANGE("Journal Batch Name",GenJournalBatch.Name);

      // Exercise
      SEPACTFillExportBuffer.FillExportBuffer(GenJnlLine,TempPaymentExportData);

      // Verify
      Assert.AreEqual(1,TempPaymentExportData.COUNT,'Wrong number of payment lines created.');
      CreditTransferRegister.FINDLAST;
      CreditTransferRegister.TESTFIELD("Created by User",USERID);
      CreditTransferRegister.TESTFIELD(Status,CreditTransferRegister.Status::Canceled);
    END;

    [Test]
    PROCEDURE ExportSEPACreditTransferFileToDisk@14();
    VAR
      GenJnlLine@1000 : Record 81;
      CreditTransferRegister@1001 : Record 1205;
      SEPACTExportFile@1002 : Codeunit 1220;
    BEGIN
      Init;

      // Pre-Setup
      GenJournalBatch.VALIDATE("Bal. Account Type",GenJournalBatch."Bal. Account Type"::"Bank Account");
      GenJournalBatch.VALIDATE("Bal. Account No.",BankAccount."No.");
      GenJournalBatch.MODIFY(TRUE);

      // Setup
      CreateGenJnlLine(GenJnlLine);

      // Exercise
      SEPACTExportFile.EnableExportToServerFile;
      SEPACTExportFile.RUN(GenJnlLine);

      // Pre-Verify
      CreditTransferRegister.SETRANGE("From Bank Account No.",BankAccount."No.");
      CreditTransferRegister.FINDLAST;

      // Verify
      CreditTransferRegister.TESTFIELD(Status,CreditTransferRegister.Status::"File Created");
      CreditTransferRegister.TESTFIELD("Exported File");
    END;

    [Test]
    PROCEDURE TestPaymentExportDataSetCreditTransferIDs@34();
    VAR
      PaymentExportData@1000 : Record 1226;
      MessageID@1001 : Code[20];
      EntryNo@1002 : Integer;
      PaymentInformationID@1003 : Text[35];
    BEGIN
      // [SCENARIO] Check filling fields in Payment Export Data: fields "Message ID", "Payment Information ID" and "End-to-End ID"
      // [GIVEN] Create new record of Payment Export Data with "Entry No" = "X"
      // [GIVEN] Autogenerated Message ID = "Y"
      EntryNo := LibraryRandom.RandInt(1000);
      MessageID := FORMAT(LibraryRandom.RandInt(1000));
      PaymentExportData.INIT;
      PaymentExportData."Entry No." := EntryNo;
      // [WHEN] PaymentExportData.SetCreditTransferIDs("Y")
      PaymentExportData.SetCreditTransferIDs(MessageID);
      // [THEN] "Message ID" = "Y"
      // [THEN] "Payment Information ID" = "Y/X"
      // [THEN] "End-to-End ID" = "Y/X"
      PaymentInformationID := MessageID + '/' + FORMAT(EntryNo);
      WITH PaymentExportData DO BEGIN
        Assert.AreEqual(MessageID,"Message ID",MessageIDErr);
        Assert.AreEqual(PaymentInformationID,"Payment Information ID",PaymentInformationIDErr);
        Assert.AreEqual(PaymentInformationID,"End-to-End ID",EndtoEndIDErr);
      END;
    END;

    [Test]
    PROCEDURE TestSetExportFlagOnEmptyGenJnlLineUT@22();
    VAR
      GenJournalLine@1000 : Record 81;
      ExpUserFeedbackGenJnl@1001 : Codeunit 1278;
    BEGIN
      // [FEATURE] [UT]
      // [SCENARIO 363096] Setting Export Flag should not fail if no Gen. Journal Lines found
      // [GIVEN] GenJournal Line with filter only, as it may come from ES
      GenJournalLine.SETFILTER("Document No.",LibraryUtility.GenerateGUID);

      // [WHEN] Run setting Export Flag on GenJournal Line
      ExpUserFeedbackGenJnl.SetExportFlagOnGenJnlLine(GenJournalLine);

      // [THEN] Export Flag setting does not fail
    END;

    LOCAL PROCEDURE Init@3();
    VAR
      NoSeries@1000 : Record 308;
      PaymentTerms@1002 : Record 3;
      PaymentMethod@1003 : Record 289;
    BEGIN
      IF Initialized THEN
        EXIT;

      EURCode := LibraryERM.GetCurrencyCode('EUR');
      DefaultLineAmount := LibraryRandom.RandDec(1000,2);

      LibraryERM.CreateGenJournalTemplate(GenJournalTemplate);
      LibraryERM.CreateGenJournalBatch(GenJournalBatch,GenJournalTemplate.Name);
      LibraryERM.CreateBankAccount(BankAccount);
      IF EURCode = 'EUR' THEN
        LibraryERM.CreateExchangeRate(EURCode,CALCDATE('<-1Y>',TODAY),LibraryRandom.RandDec(100,2),
          LibraryRandom.RandDec(100,2));

      Vendor.INIT;
      Vendor."No." := 'TEST-SEPA';
      IF Vendor.FIND THEN
        Vendor.DELETE;
      Vendor.Name := 'Microsoft';
      Vendor.Address := 'Microsoft Way 1';
      Vendor.City := 'MS Town';
      Vendor."Post Code" := 'AL-1234';
      LibraryERM.FindPaymentTerms(PaymentTerms);
      Vendor.VALIDATE("Payment Terms Code",PaymentTerms.Code);
      LibraryERM.FindPaymentMethod(PaymentMethod);
      Vendor.VALIDATE("Payment Method Code",PaymentMethod.Code);
      Vendor.VALIDATE("Vendor Posting Group",LibraryPurchase.FindVendorPostingGroup);
      Vendor.INSERT;

      LibraryPurchase.CreateVendorBankAccount(VendorBankAccount,Vendor."No.");
      VendorBankAccount.Name := 'Alban Bank No. 1';
      VendorBankAccount."Bank Account No." := '1234567890';
      VendorBankAccount.IBAN := 'AL47 2121 1009 0000 0002 3569 8741';
      VendorBankAccount.MODIFY;

      LibrarySales.CreateCustomer(Customer);
      LibrarySales.CreateCustomerBankAccount(CustomerBankAccount,Customer."No.");

      NoSeries.FINDFIRST;
      CreateBankExpSetup;
      BankAccount."Bank Account No." := '1234 12345678';
      BankAccount.IBAN := 'AL47 2121 1009 0000 0002 3569 8741';
      BankAccount."Credit Transfer Msg. Nos." := NoSeries.Code;
      BankAccount."Payment Export Format" := BankExportImportSetup.Code;
      BankAccount.MODIFY;
      Initialized := TRUE;
    END;

    LOCAL PROCEDURE CreateGenJnlLine@7(VAR GenJnlLine@1000 : Record 81);
    BEGIN
      WITH GenJnlLine DO BEGIN
        SETRANGE("Journal Template Name",GenJournalTemplate.Name);
        SETRANGE("Journal Batch Name",GenJournalBatch.Name);
        DELETEALL;

        INIT;
        LibraryERM.CreateGeneralJnlLine(
          GenJnlLine,GenJournalTemplate.Name,GenJournalBatch.Name,
          "Document Type"::Payment,"Account Type"::Vendor,Vendor."No.",1);

        IF "Applies-to Ext. Doc. No." = '' THEN
          "Applies-to Ext. Doc. No." := ExtDocNoTxt;
        VALIDATE("Recipient Bank Account",VendorBankAccount.Code);
        VALIDATE("Currency Code",EURCode);
        VALIDATE(Amount,DefaultLineAmount);
        VALIDATE("Bal. Account Type","Bal. Account Type"::"Bank Account");
        VALIDATE("Bal. Account No.",BankAccount."No.");
        MODIFY;
      END;
    END;

    LOCAL PROCEDURE CreateGenJnlLinesDiffDate@44(VAR GenJnlLine@1001 : Record 81;NoOfGroups@1000 : Integer;NoOfPmtsPerGroup@1003 : Integer);
    VAR
      i@1002 : Integer;
      PostingDate@1004 : Date;
    BEGIN
      CreateGenJnlLine(GenJnlLine);
      PostingDate := GenJnlLine."Posting Date";
      FOR i := 1 TO NoOfGroups * NoOfPmtsPerGroup - 1 DO BEGIN
        GenJnlLine."Line No." += 10000;
        GenJnlLine.VALIDATE("Posting Date",PostingDate + i DIV NoOfPmtsPerGroup);
        GenJnlLine.INSERT;
      END;
      GenJnlLine.SETRANGE("Journal Template Name",GenJnlLine."Journal Template Name");
      GenJnlLine.SETRANGE("Journal Batch Name",GenJnlLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE CreateBankExpSetup@5();
    BEGIN
      WITH BankExportImportSetup DO BEGIN
        Code := 'SEPA-TEST';
        IF FIND THEN
          DELETE;
        Direction := Direction::Export;
        "Processing Codeunit ID" := CODEUNIT::"SEPA CT-Export File";
        "Processing XMLport ID" := XMLPORT::"SEPA CT pain.001.001.03";
        "Check Export Codeunit" := CODEUNIT::"SEPA CT-Check Line";
        INSERT;
      END;
    END;

    LOCAL PROCEDURE CreatePaymentExportDataCharSetData@11(VAR PaymentExportData@1000 : Record 1226);
    BEGIN
      WITH PaymentExportData DO BEGIN
        INIT;
        "Recipient Name" := COPYSTR(AccentuateText(NameTxt),1,MAXSTRLEN("Recipient Name"));
        "Recipient Address" := COPYSTR(AccentuateText(AddressTxt),1,MAXSTRLEN("Recipient Address"));
        AddRemittanceText(COPYSTR(AccentuateText(RemitTxt),1,140));
        INSERT(TRUE);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CreateVendorLedgerEntry@43(VAR VendLedgerEntry@1000 : Record 25;DateOffset@1002 : Integer);
    VAR
      GenJnlLine@1001 : Record 81;
      GenJnlBatch@1003 : Record 232;
    BEGIN
      LibraryERM.CreateGenJournalBatch(GenJnlBatch,LibraryERM.SelectGenJnlTemplate);
      LibraryERM.CreateGeneralJnlLine(
        GenJnlLine,GenJnlBatch."Journal Template Name",GenJnlBatch.Name,
        GenJnlLine."Document Type"::Invoice,GenJnlLine."Account Type"::Vendor,
        Vendor."No.",-LibraryRandom.RandDec(100,2));
      GenJnlLine.VALIDATE("Bal. Account Type",GenJnlLine."Bal. Account Type"::"Bank Account");
      GenJnlLine.VALIDATE("Bal. Account No.",BankAccount."No.");
      GenJnlLine.MODIFY;

      LibraryERM.PostGeneralJnlLine(GenJnlLine);
      VendLedgerEntry.SETRANGE("Vendor No.",Vendor."No.");
      VendLedgerEntry.SETRANGE("Document Type",VendLedgerEntry."Document Type"::Invoice);
      VendLedgerEntry.FINDLAST;
      VendLedgerEntry.VALIDATE("Posting Date",CALCDATE('<-30D>',TODAY));
      VendLedgerEntry.VALIDATE("Due Date",CALCDATE('<' + FORMAT(DateOffset) + 'D>',TODAY));
      VendLedgerEntry.MODIFY;
    END;

    LOCAL PROCEDURE AddCharToText@12(Text@1000 : Text;c@1001 : Char) : Text;
    BEGIN
      Text[STRLEN(Text) + 1] := c;
      EXIT(Text);
    END;

    LOCAL PROCEDURE AccentuateText@20(Text@1000 : Text) : Text;
    VAR
      ConvStr@1001 : Text;
    BEGIN
      ConvStr := AddCharToText(ConvStr,238); // i with circomflexe
      ConvStr := AddCharToText(ConvStr,233); // e with accent egu
      ConvStr := AddCharToText(ConvStr,259); // a with accent 'Czech'
      ConvStr := AddCharToText(ConvStr,245); // o with tilde
      ConvStr := AddCharToText(ConvStr,272); // D Icelandic/Faroese 'ed'
      EXIT(CONVERTSTR(Text,'ieaoD',ConvStr));
    END;

    LOCAL PROCEDURE CheckPostingDateError@37(GenJnlLine@1000 : Record 81);
    VAR
      PaymentJnlExportErrorText@1001 : Record 1228;
    BEGIN
      PaymentJnlExportErrorText.SETRANGE("Journal Template Name",GenJnlLine."Journal Template Name");
      PaymentJnlExportErrorText.SETRANGE("Journal Batch Name",GenJnlLine."Journal Batch Name");
      PaymentJnlExportErrorText.SETRANGE("Journal Line No.",GenJnlLine."Line No.");
      PaymentJnlExportErrorText.SETRANGE("Error Text",TransferDateErr);
      Assert.AreEqual(1,PaymentJnlExportErrorText.COUNT,'Unexpected errors for jnl. line.');
    END;

    LOCAL PROCEDURE ValidateGrpHdr@59(VAR XMLParentNode@1002 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode";VAR GenJnlLine@1004 : Record 81);
    VAR
      XMLNodes@1001 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeList";
      XMLNode@1000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode";
      i@1003 : Integer;
      dt@1006 : DateTime;
    BEGIN
      XMLNodes := XMLParentNode.ChildNodes;
      FOR i := 0 TO XMLNodes.Count - 1 DO BEGIN
        XMLNode := XMLNodes.ItemOf(i);
        CASE XMLNode.Name OF
          'MsgId':
            ;
          'CreDtTm':
            BEGIN
              Assert.AreNotEqual('',XMLNode.InnerXml,'Wrong CreDtTm.');
              EVALUATE(dt,XMLNode.InnerXml,9);
              Assert.AreNearlyEqual(0,CURRENTDATETIME - dt,60000,'Wrong CreDtTm.');
              Assert.AreEqual(19,STRLEN(XMLNode.InnerXml),'Wrong CreDtTm length');
            END;
          'NbOfTxs':
            Assert.AreEqual(FORMAT(GenJnlLine.COUNT,0,9),XMLNode.InnerXml,'Wrong NbOfTxs.');
          'CtrlSum':
            BEGIN
              GenJnlLine.CALCSUMS(Amount);
              Assert.AreEqual(FORMAT(GenJnlLine.Amount,0,9),XMLNode.InnerXml,'Wrong CtrlSum.');
            END;
          'InitgPty':
            ValidatePartyElement(XMLNode);
          ELSE
            ERROR(XMLUnknownElementErr,XMLNode.Name);
        END;
      END;
    END;

    LOCAL PROCEDURE ValidatePartyAddress@51(VAR XMLParentNode@1002 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode");
    VAR
      XMLNodes@1001 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeList";
      XMLNode@1000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode";
      i@1003 : Integer;
    BEGIN
      XMLNodes := XMLParentNode.ChildNodes;
      FOR i := 0 TO XMLNodes.Count - 1 DO BEGIN
        XMLNode := XMLNodes.ItemOf(i);
        CASE XMLNode.Name OF
          'StrtNm','PstCd','TwnNm','Ctry':
            ;
          ELSE
            ERROR(XMLUnknownElementErr,XMLNode.Name);
        END;
      END;
    END;

    LOCAL PROCEDURE ValidatePartyElement@48(VAR XMLParentNode@1002 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode");
    VAR
      XMLNodes@1001 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeList";
      XMLNode@1000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode";
      i@1003 : Integer;
    BEGIN
      XMLNodes := XMLParentNode.ChildNodes;
      FOR i := 0 TO XMLNodes.Count - 1 DO BEGIN
        XMLNode := XMLNodes.ItemOf(i);
        CASE XMLNode.Name OF
          'Nm':
            Assert.AreNotEqual('',XMLNode.InnerXml,'');
          'PstlAdr':
            ValidatePartyAddress(XMLNode);
          'Id':
            ;
          ELSE
            ERROR(XMLUnknownElementErr,XMLNode.Name);
        END;
      END;
    END;

    LOCAL PROCEDURE ValidatePmtInf@66(VAR XMLParentNode@1002 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode";ExpectedNoOfCdtTrfTxInf@1004 : Integer;ExpectedCtrlSum@1006 : Decimal;ExpectedDate@1010 : Date);
    VAR
      XMLNodes@1001 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeList";
      XMLNode@1000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode";
      ActualDate@1009 : Date;
      NoOfCdtTrfTxInf@1005 : Integer;
      i@1003 : Integer;
      CtrlSum@1007 : Decimal;
      NbOfTxs@1008 : Integer;
    BEGIN
      XMLNodes := XMLParentNode.ChildNodes;
      FOR i := 0 TO XMLNodes.Count - 1 DO BEGIN
        XMLNode := XMLNodes.ItemOf(i);
        CASE XMLNode.Name OF
          'PmtInfId','BtchBookg','PmtTpInf','Dbtr','DbtrAcct','DbtrAgt':
            ;
          'PmtMtd':
            Assert.AreEqual('TRF',XMLNode.InnerXml,'PmtMtd');
          'ChrgBr':
            Assert.AreEqual('SLEV',XMLNode.InnerXml,'ChrgBr');
          'CtrlSum':
            BEGIN
              EVALUATE(CtrlSum,XMLNode.InnerXml,9);
              Assert.AreEqual(ExpectedCtrlSum,CtrlSum,'CtrlSum');
            END;
          'NbOfTxs':
            BEGIN
              EVALUATE(NbOfTxs,XMLNode.InnerXml,9);
              Assert.AreEqual(ExpectedNoOfCdtTrfTxInf,NbOfTxs,'NbOfTxs');
            END;
          'ReqdExctnDt':
            BEGIN
              EVALUATE(ActualDate,XMLNode.InnerXml,9);
              Assert.AreEqual(ExpectedDate,ActualDate,'ReqdExctnDt');
            END;
          'CdtTrfTxInf':
            NoOfCdtTrfTxInf += 1;
          ELSE
            ERROR(XMLUnknownElementErr,XMLNode.Name);
        END;
      END;
      Assert.AreEqual(ExpectedNoOfCdtTrfTxInf,NoOfCdtTrfTxInf,'Wrong number of DrctDbtTxInf nodes.');
    END;

    BEGIN
    {
      // [FEATURE] [SEPA] [Credit Transfer]
    }
    END.
  }
}

