OBJECT Codeunit 137079 SCM Production Order III
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVIN9.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            IsInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LocationRed@1009 : Record 14;
      LocationBlue@1011 : Record 14;
      LocationWhite@1027 : Record 14;
      LocationSilver@1031 : Record 14;
      ItemJournalTemplate@1018 : Record 82;
      ItemJournalBatch@1017 : Record 233;
      ConsumptionItemJournalTemplate@1014 : Record 82;
      ConsumptionItemJournalBatch@1013 : Record 233;
      OutputItemJournalTemplate@1016 : Record 82;
      OutputItemJournalBatch@1015 : Record 233;
      WarehouseJournalTemplate@1030 : Record 7309;
      WarehouseJournalBatch@1029 : Record 7310;
      LibraryWarehouse@1006 : Codeunit 132204;
      LibraryManufacturing@1007 : Codeunit 132202;
      LibraryInventory@1002 : Codeunit 132201;
      LibraryItemTracking@1036 : Codeunit 130502;
      LibraryUtility@1003 : Codeunit 131000;
      LibraryVariableStorage@1008 : Codeunit 131004;
      LibraryPlanning@1005 : Codeunit 132203;
      LibrarySales@1004 : Codeunit 130509;
      LibraryPurchase@1022 : Codeunit 130512;
      LibraryRandom@1019 : Codeunit 130440;
      Assert@1001 : Codeunit 130000;
      ItemJournalLineExistErr@1010 : TextConst 'ENG=There is no Item Journal Line within the filter.';
      LibraryERMCountryData@1023 : Codeunit 131305;
      LibraryERM@1044 : Codeunit 131300;
      LibraryCosting@1053 : Codeunit 132200;
      IsInitialized@1000 : Boolean;
      TrackingMsg@1021 : TextConst 'ENU=The change will not affect existing entries';
      NewWorksheetMsg@1012 : TextConst 'ENU=You are now in worksheet';
      ItemTrackingErr@1024 : TextConst 'ENG=You cannot define item tracking on this line because it is linked to production order';
      StartingDateMsg@1026 : TextConst 'ENG=Starting Date must be less or equal.';
      EndingDateMsg@1025 : TextConst 'ENG=Ending Date must be greater or equal.';
      PickActivitiesCreatedMsg@1032 : TextConst 'ENU=Number of Invt. Pick activities created';
      UnadjustedValueEntriesNotCoveredMsg@1035 : TextConst 'ENU=Some unadjusted value entries will not be covered with the new setting. You must run the Adjust Cost - Item Entries batch job once to adjust these.';
      ChangeExpectedCostPostingToGLMsg@1034 : TextConst 'ENU=If you change the Expected Cost Posting to G/L, the program must update table Post Value Entry to G/L.';
      ExpectedCostPostingChangedMsg@1033 : TextConst 'ENU=Expected Cost Posting to G/L has been changed to Yes. You should now run Post Inventory Cost to G/L.';
      PostJournalLinesConfirmationMsg@1037 : TextConst 'ENU=Do you want to post the journal lines';
      JournalLinesPostedMsg@1038 : TextConst 'ENU=The journal lines were successfully posted.';
      RecreatePurchaseLineConfirmHandlerQst@1020 : TextConst 'ENU=If you change %1, the existing purchase lines will be deleted and new purchase lines based on the new information in the header will be created.\\Do you want to change %1?';
      WHHandlingIsRequiredErr@1039 : TextConst 'ENU="Warehouse handling is required for Entry Type = Output"';
      AppliesToEntryErr@1040 : TextConst 'ENU=Applies-to Entry must have a value in Item Journal Line: Journal Template Name';
      QtyPickedBaseErr@1041 : TextConst 'ENU=Qty. Picked (Base) must not be 0 in Prod. Order Component';
      ItemTrackingMode@1045 : 'AssignLotNo,AssignSerialNo,SelectEntries,SetValue,UpdateQuantityBase';
      LeaveProductionJournalQst@1042 : TextConst 'ENU=Do you want to leave the Production Journal?';
      QtyToHandleBaseInTrackingErr@1043 : TextConst 'ENU=It must be %1.';
      WhseRequestErr@1047 : TextConst 'ENU=There is no "Warehouse Request" related to Production Order %1.';
      WhsePickRequestErr@1046 : TextConst 'ENU=There is no "Whse. Pick Request" related to Production Order %1.';
      OutputJournalItemNoErr@1048 : TextConst 'ENU=%1 must be equal to ''%2''  in %3';
      ProdOrderLineBinCodeErr@1049 : TextConst 'ENU=Wrong "Prod. Order Line" BinCode value';
      ItemSubstCountErr@1050 : TextConst 'ENU=Wrong Item Substitution''s count.';
      ItemSubstDublicationErr@1051 : TextConst 'ENU=Duplicated Substitution Item is found.';
      ItemSubstItemNoErr@1052 : TextConst 'ENU=Wron Item Substitution No.';
      ValueEntrySourceTypeErr@1054 : TextConst 'ENU=Value Entry Source Type must be equal to %1';
      ValueEntrySourceNoErr@1055 : TextConst 'ENU=Value Entry Source No must be equal to %1';
      ProdJournalOutQtyErr@1058 : TextConst 'ENU=Output Quantity should be 0 in Production Journal Line lined to Subcontracted Workcenter';
      ComponentsAlreadyPickedQst@1057 : TextConst '@@@=Production order no.: Components for production order 101001 have already been picked. Do you want to continue?;ENU=Components for production order %1 have already been picked. Do you want to continue?';
      SubcItemJnlErr@1056 : TextConst '@@@=%1 - "Subcontractor No.";ENU=%1 must not be';
      RtngLineBinCodeErr@1059 : TextConst '@@@=%1: Field(To-Production Bin Code), %2: TableCaption(Prod. Order Routing Line);ENU=Wrong %1 in %2.';

    [Test]
    PROCEDURE PostConsumptionForReleasedProductionOrderWithLocationAndBin@4();
    BEGIN
      // Verify Consumption Entry after post Consumption for the Child Item for Released Production Order.
      // Setup.
      Initialize;
      PostJournalsForReleasedProductionOrderWithLocationAndBin(FALSE);  // Post Output FALSE.
    END;

    [Test]
    PROCEDURE PostPartialOutputForReleasedProductionOrderWithLocationAndBin@5();
    BEGIN
      // Verify Output Entry after post Output of the Parent Item for Released Production Order.
      // Setup.
      Initialize;
      PostJournalsForReleasedProductionOrderWithLocationAndBin(TRUE);  // Post Output TRUE.
    END;

    LOCAL PROCEDURE PostJournalsForReleasedProductionOrderWithLocationAndBin@7(PostOutput@1008 : Boolean);
    VAR
      Item@1006 : Record 27;
      ChildItem@1005 : Record 27;
      Bin@1004 : Record 7354;
      ProductionOrder@1002 : Record 5405;
      ItemJournalLine@1001 : Record 83;
      WarehouseEntry@1003 : Record 7312;
      ComponentsAtLocation@1000 : Code[10];
      Quantity@1007 : Decimal;
      QuantityPer@1009 : Integer;
    BEGIN
      // Update Components at Location. Create Parent and Child Items in a Production BOM and certify it. Update Inventory for the Child Item. Create and refresh a Released Production Order.
      ComponentsAtLocation := UpdateManufacturingSetupComponentsAtLocation(LocationRed.Code);
      LibraryWarehouse.FindBin(Bin,LocationRed.Code,'',1);  // Find Bin of Index 1.
      QuantityPer := LibraryRandom.RandInt(5);
      Quantity := LibraryRandom.RandInt(10);
      CreateItemsSetup(Item,ChildItem,QuantityPer);
      CreateAndPostItemJournalLine(ChildItem."No.",Quantity + 100,LocationRed.Code,Bin.Code);  // More Component Item required for Production Item.
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",Quantity,LocationRed.Code,Bin.Code);

      // Exercise: Calculate and post Consumption Journal. Create and post Output Journal.
      CalculateAndPostConsumptionJournal(ProductionOrder."No.");
      IF PostOutput THEN
        CreateAndPostOutputJournalWithExplodeRouting(ProductionOrder."No.",Quantity / 2);  // Post partial Quantity.

      // Verify: Verify the partial Output Quantity and Location for the Parent Item in Item Ledger Entry and Warehouse Entry. Verify Consumption Quantity and Location for the Child Item in Item Ledger Entry and Warehouse Entry.
      IF PostOutput THEN BEGIN
        VerifyItemLedgerEntry(ItemJournalLine."Entry Type"::Output,Item."No.",Quantity / 2,LocationRed.Code);
        VerifyWarehouseEntry(
          WarehouseEntry."Entry Type"::"Positive Adjmt.",ProductionOrder."No.",Item."No.",Bin.Code,LocationRed.Code,Quantity);
      END ELSE BEGIN
        VerifyItemLedgerEntry(ItemJournalLine."Entry Type"::Consumption,ChildItem."No.",-Quantity * QuantityPer,LocationRed.Code);
        VerifyWarehouseEntry(
          WarehouseEntry."Entry Type"::"Negative Adjmt.",ProductionOrder."No.",ChildItem."No.",Bin.Code,LocationRed.Code,
          -Quantity * QuantityPer);
      END;

      // Tear Down.
      UpdateManufacturingSetupComponentsAtLocation(ComponentsAtLocation);
    END;

    [Test]
    PROCEDURE ErrorPostConsumptionForAlreadyConsumedComponentItemWithLocation@2();
    VAR
      Item@1006 : Record 27;
      ChildItem@1005 : Record 27;
      Bin@1004 : Record 7354;
      ProductionOrder@1002 : Record 5405;
      ComponentsAtLocation@1000 : Code[10];
      Quantity@1007 : Decimal;
      QuantityPer@1001 : Integer;
    BEGIN
      // Setup: Update Components at a Location. Create Parent and Child Items in a Production BOM and certify it. Update Inventory for the Child Item. Create and refresh a Released Production Order.
      Initialize;
      ComponentsAtLocation := UpdateManufacturingSetupComponentsAtLocation(LocationRed.Code);
      LibraryWarehouse.FindBin(Bin,LocationRed.Code,'',1);  // Find Bin of Index 1.
      QuantityPer := LibraryRandom.RandInt(5);
      CreateItemsSetup(Item,ChildItem,QuantityPer);
      Quantity := LibraryRandom.RandInt(10);
      CreateAndPostItemJournalLine(ChildItem."No.",Quantity + 100,LocationRed.Code,Bin.Code);  // More Component Item required for Production Item.
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",Quantity,LocationRed.Code,Bin.Code);
      CalculateAndPostConsumptionJournal(ProductionOrder."No.");  // Calculate and post Consumption.

      // Exercise: Create and post Consumption Journal.
      ASSERTERROR CalculateAndPostConsumptionJournal(ProductionOrder."No.");

      // Verify: Verify the error post Consumption for the already Consumed Item with Location.
      Assert.ExpectedError(ItemJournalLineExistErr);

      // Tear Down.
      UpdateManufacturingSetupComponentsAtLocation(ComponentsAtLocation);
    END;

    [Test]
    PROCEDURE ErrorPostConsumptionForAlreadyConsumedComponentItemWithoutLocation@226();
    VAR
      Item@1006 : Record 27;
      ChildItem@1005 : Record 27;
      ProductionOrder@1002 : Record 5405;
      Quantity@1007 : Decimal;
      QuantityPer@1001 : Integer;
      ComponentsAtLocation@1000 : Code[10];
    BEGIN
      // Setup: Update Components at blank Location. Create Parent and Child Items in a Production BOM and certify it. Update Inventory for the Child Item. Create and refresh a Released Production Order.
      Initialize;
      ComponentsAtLocation := UpdateManufacturingSetupComponentsAtLocation('');  // Using blank Location.
      Quantity := LibraryRandom.RandInt(10);
      QuantityPer := LibraryRandom.RandInt(5);
      CreateItemsSetup(Item,ChildItem,QuantityPer);
      CreateAndPostItemJournalLine(ChildItem."No.",Quantity + 100,'','');  // More Component Item required for Production Item.
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",Quantity,'','');
      CalculateAndPostConsumptionJournal(ProductionOrder."No.");  // Calculate and post Consumption.

      // Exercise: Calculate and post Consumption Journal.
      ASSERTERROR CalculateAndPostConsumptionJournal(ProductionOrder."No.");

      // Verify: Verify the error post Consumption for the already Consumed Item without Location.
      Assert.ExpectedError(ItemJournalLineExistErr);

      // Tear Down.
      UpdateManufacturingSetupComponentsAtLocation(ComponentsAtLocation);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE OrderTrackingForMultiLineSalesWithFirmPlannedProdOrder@285();
    VAR
      ProductionOrder@1001 : Record 5405;
      SalesHeader@1007 : Record 36;
      Item@1004 : Record 27;
      Quantity@1008 : Decimal;
    BEGIN
      // Setup: Craete Item. Update Order Tracking Policy on Item. Create and release Sales Order with multiple Sales Lines.
      Initialize;
      CreateItem(Item);
      Quantity := LibraryRandom.RandDec(100,2);
      UpdateOrderTrackingPolicyOnItem(Item,Item."Order Tracking Policy"::"Tracking & Action Msg.");
      CreateAndReleaseSalesOrderWithMultipleLines(SalesHeader,Item."No.",Quantity);

      // Exercise: Create and refresh a Firm Planned Production Order.
      CreateAndRefreshProductionOrder(ProductionOrder,ProductionOrder.Status::"Firm Planned",Item."No.",Quantity,'','');

      // Verify: Verify the ItemNo and Quantity on Order Tracking Page.
      VerifyOrderTrackingForProductionOrder(Item."No.",Quantity);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE OrderTrackingForMultiLineSalesWithFirmPlannedProdOrderCalcRegenPlanAndCarryOut@44();
    VAR
      Item@1004 : Record 27;
      SalesHeader@1000 : Record 36;
      Quantity@1008 : Decimal;
    BEGIN
      // Setup: Create Item. Update Order Tracking Policy on Item. Update Planning parameters on Item.
      Initialize;
      CreateItem(Item);
      Quantity := LibraryRandom.RandDec(100,2);
      UpdateOrderTrackingPolicyOnItem(Item,Item."Order Tracking Policy"::"Tracking & Action Msg.");
      UpdateItemParametersForPlanning(Item,Item."Replenishment System"::"Prod. Order",Item."Reordering Policy"::"Lot-for-Lot");

      // Create and release Sales Order with multiple Lines, Calculate Regenerative Plan on WORKDATE.
      CreateAndReleaseSalesOrderWithMultipleLines(SalesHeader,Item."No.",Quantity);
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item,WORKDATE,WORKDATE);

      // Exercise: Accept and Carry Out Action Message.
      AcceptAndCarryOutActionMessageForPlanningWorksheet(Item."No.");

      // Verify: Verify the ItemNo and Quantity on Order Tracking Page.
      VerifyOrderTrackingForProductionOrder(Item."No.",Quantity);
    END;

    [Test]
    PROCEDURE RequisitionLineAfterCalcPlanReqWkshWithMaximumQuantityItemForEqualDemand@70();
    BEGIN
      // Verify the Due Date, Action Message and Quantity on Requisition Line created for Maximum Quantity Item.
      // Setup.
      Initialize;
      CalcPlanReqWkshWithMaximumQuantityItemForEqualDemand(FALSE);  // Accept and Carry Out Action FALSE.
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE PurchaseLineAfterCalcPlanReqWkshWithMaximumQuantityItemForEqualDemand@48();
    BEGIN
      // Verify the Quantity on Purchase Line created for Maximum Quantity Item after Calc. Plan and Carry Out Action.
      // Setup.
      Initialize;
      CalcPlanReqWkshWithMaximumQuantityItemForEqualDemand(TRUE);  // Accept and Carry Out Action TRUE.
    END;

    LOCAL PROCEDURE CalcPlanReqWkshWithMaximumQuantityItemForEqualDemand@116(AcceptAndCarryOutAction@1000 : Boolean);
    VAR
      Item@1008 : Record 27;
      RequisitionLine@1001 : Record 246;
      PurchaseHeader@1002 : Record 38;
      ManufacturingSetup@1003 : Record 99000765;
    BEGIN
      // Create item with Reordering Policy. Create and post Purchase Order. Create and post Sales Order with Item Maximum Quantity.
      CreateMaximumQtyItem(Item,LibraryRandom.RandDec(100,2) + 100);  // Large Quantity required for Item Maximum Inventory.
      CreateAndPostPurchaseOrderAsReceive(PurchaseHeader,Item."No.",Item."Maximum Inventory");
      CreateAndPostSalesOrderAsShip(Item,Item."Maximum Inventory");

      // Exercise: Calculate Plan for Requisition Worksheet on WORKDATE. Accept and Carry Out Requisition Worksheet.
      CalculatePlanForRequisitionWorksheet(Item);
      IF AcceptAndCarryOutAction THEN
        AcceptAndCarryOutActionMessageForRequisitionWorksheet(Item."No.");

      // Verify: Verify Quantity on Purchase Line created. Verify the Due Date, Action Message and Quantity on Requisition Line created.
      IF AcceptAndCarryOutAction THEN
        VerifyPurchaseLine(Item."No.",Item."Maximum Inventory")
      ELSE BEGIN
        ManufacturingSetup.GET;
        VerifyRequisitionLine(
          Item."No.",RequisitionLine."Action Message"::New,Item."Maximum Inventory",
          CALCDATE(ManufacturingSetup."Default Safety Lead Time",WORKDATE));
      END;
    END;

    [Test]
    PROCEDURE RequisitionLineAfterCalcPlanOnPlanWkshForDemandFromBlanketOrderWithLocation@223();
    BEGIN
      // Verify the Requisition Line after Calculate Plan on Planning Worksheet with demand generated from Blanket Order with Location.
      // Setup.
      Initialize;
      CalcPlanOnPlanWkshForDemandFromBlanketOrderWithLocation(FALSE);  // Accept and Carry Out FALSE.
    END;

    [Test]
    PROCEDURE ProdOrderLineAfterAcceptAndCarryOutPlanWkshForDemandFromBlanketOrderWithLocation@224();
    BEGIN
      // Verify the Prod. Order Line after Calculate Plan and Carry Out on Planning Worksheet with demand generated from Blanket Order with Location.
      // Setup.
      Initialize;
      CalcPlanOnPlanWkshForDemandFromBlanketOrderWithLocation(TRUE);  // Accept and Carry Out TRUE.
    END;

    LOCAL PROCEDURE CalcPlanOnPlanWkshForDemandFromBlanketOrderWithLocation@45(AcceptAndCarryOut@1013 : Boolean);
    VAR
      Item@1001 : Record 27;
      SalesReceivablesSetup@1008 : Record 311;
      SalesHeader@1004 : Record 36;
      SalesOrderHeader@1006 : Record 36;
      RequisitionLine@1007 : Record 246;
      OldStockoutWarning@1009 : Boolean;
      OldCreditWarnings@1012 : Option;
      Quantity@1003 : Integer;
    BEGIN
      // Update Sales and Receivables setup. Create Item with Planning parameters with Reordering Policy of Lot for Lot. Create Sales Order from Blanket Order.
      UpdateSalesReceivablesSetup(OldStockoutWarning,OldCreditWarnings,FALSE,SalesReceivablesSetup."Credit Warnings"::"No Warning");
      CreateItem(Item);
      UpdateItemParametersForPlanning(Item,Item."Replenishment System"::"Prod. Order",Item."Reordering Policy"::"Lot-for-Lot");
      Quantity := LibraryRandom.RandInt(10);
      CreateSalesOrderFromBlanketOrder(SalesHeader,SalesOrderHeader,Item."No.",Quantity,LocationBlue.Code);

      // Exercise: Calculate Regenerative Plan on WORKDATE for Planning Worksheet. Accept and Carry Out Action Message.
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item,WORKDATE,WORKDATE);
      IF AcceptAndCarryOut THEN
        AcceptAndCarryOutActionMessageForPlanningWorksheet(Item."No.");

      // Verify: Verify the Quantity, Due Date and Location Code on Prod. Order Line created. Verify the Quantity and Location Code and Action Message on Requisition Line.
      IF AcceptAndCarryOut THEN
        VerifyProdOrderLine(Item."No.",LocationBlue.Code,Quantity,WORKDATE)
      ELSE
        VerifyRequisitionLineWithLocation(Item."No.",Quantity,LocationBlue.Code,RequisitionLine."Action Message"::New);

      // Tear Down.
      UpdateSalesReceivablesSetup(OldStockoutWarning,OldCreditWarnings,OldStockoutWarning,OldCreditWarnings);
    END;

    [Test]
    PROCEDURE RequisitionLineAfterCalcPlanTwiceOnPlanWkshForDemandFromBlanketOrderWithLocation@103();
    VAR
      Item@1001 : Record 27;
      SalesReceivablesSetup@1008 : Record 311;
      SalesHeader@1004 : Record 36;
      SalesOrderHeader@1006 : Record 36;
      RequisitionLine@1007 : Record 246;
      OldStockoutWarning@1009 : Boolean;
      OldCreditWarnings@1012 : Option;
      Quantity@1003 : Integer;
    BEGIN
      // Setup: Update Sales and Receivables setup. Create Item with Planning parameters with Reordering Policy of Lot for Lot. Create Sales Order from Blanket Order.
      Initialize;
      UpdateSalesReceivablesSetup(OldStockoutWarning,OldCreditWarnings,FALSE,SalesReceivablesSetup."Credit Warnings"::"No Warning");
      CreateItem(Item);
      UpdateItemParametersForPlanning(Item,Item."Replenishment System"::"Prod. Order",Item."Reordering Policy"::"Lot-for-Lot");
      Quantity := LibraryRandom.RandInt(10);
      CreateSalesOrderFromBlanketOrder(SalesHeader,SalesOrderHeader,Item."No.",Quantity,LocationBlue.Code);
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item,WORKDATE,WORKDATE);  // Calculate Regenerative Plan on WORKDATE.
      LibrarySales.PostSalesDocument(SalesOrderHeader,TRUE,FALSE); // Post Sales Order as Ship only.

      // Exercise: Calculate Regenerative Plan on WORKDATE for Planning Worksheet after posting Sales Order.
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item,WORKDATE,WORKDATE);

      // Verify: Verify the Quantity and Location Code and Action Message on Requisition Line.
      VerifyRequisitionLineWithLocation(Item."No.",Quantity,LocationBlue.Code,RequisitionLine."Action Message"::New);

      // Tear Down.
      UpdateSalesReceivablesSetup(OldStockoutWarning,OldCreditWarnings,OldStockoutWarning,OldCreditWarnings);
    END;

    [Test]
    PROCEDURE RequisitionLineAfterCalcPlanOnPlanWkshForSalesOrderWithUpdatedBlanketOrderNoWithLocation@107();
    VAR
      Item@1012 : Record 27;
      SalesHeader@1010 : Record 36;
      SalesLine@1002 : Record 37;
      SalesOrderHeader@1001 : Record 36;
      RequisitionLine@1006 : Record 246;
      Quantity@1000 : Integer;
    BEGIN
      // Setup: Create Item with Planning parameters with Reordering Policy of Lot for Lot. Create a Blanket Order.
      Initialize;
      CreateItem(Item);
      UpdateItemParametersForPlanning(Item,Item."Replenishment System"::Purchase,Item."Reordering Policy"::"Lot-for-Lot");
      Quantity := LibraryRandom.RandInt(10);
      CreateBlanketOrder(SalesHeader,Item."No.",Quantity,'');

      // Create Sales Order. Update Blanket Order No and Location Code on Sales Order.
      CreateSalesOrder(SalesOrderHeader,Item."No.",Quantity,FALSE);  // Multiple Sales Lines FALSE.
      SelectSalesOrderLine(SalesLine,SalesOrderHeader."No.");
      UpdateBlanketOrderNoAndLocationOnSalesLine(SalesLine,SalesHeader."No.",LocationBlue.Code);

      // Exercise: Calculate Regenerative Plan for Planning Worksheet on WORKDATE.
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item,WORKDATE,WORKDATE);

      // Verify: Verify the Quantity and Location Code and Action Message on Requisition Line.
      VerifyRequisitionLineWithLocation(Item."No.",Quantity,LocationBlue.Code,RequisitionLine."Action Message"::New);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingPageHandler)]
    PROCEDURE CalcSubcontractOrderForReleasedProdOrderWithTracking@22();
    VAR
      WorkCenter@1000 : Record 99000754;
      Item@1003 : Record 27;
      ProductionOrder@1004 : Record 5405;
      ReservationEntry@1007 : Record 337;
    BEGIN
      // Setup: Create Item with Item Tracking Code and Routing. Create and refresh Released Production Order.
      Initialize;
      CreateItemWithItemTrackingCode(Item);
      CreateRoutingAndUpdateItemSubc(Item,WorkCenter,TRUE);
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandDec(10,2),'','');
      AssignTrackingOnProdOrderLine(ProductionOrder."No.");  // Assign Lot Tracking on Prod. Order Line.

      // Exercise: Calculate Subcontracts from Subcontracting Worksheet.
      CalculateSubcontractOrder(WorkCenter);

      // Verify: Verify Reservation Entry for Status and Tracking after Calculate Subcontracts. Verify Production Quantity and WorkCenter Subcontractor on Subcontracting Worksheet.
      VerifyReservationEntry(Item."No.",ProductionOrder.Quantity,ReservationEntry."Reservation Status"::Surplus,'');
      VerifyRequisitionLineForSubcontract(ProductionOrder,WorkCenter,Item."No.");
    END;

    [Test]
    [HandlerFunctions(ItemTrackingPageHandler)]
    PROCEDURE PurchaseLineAfterCalcSubcontractOrderAndCarryOutForProdOrderWithTracking@20();
    BEGIN
      // Verify the Purchase Line created after Calculate Subcontracts and Carry Out on Subcontracting Worksheet.
      // Setup.
      Initialize;
      CalcSubcontractOrderForReleasedProductionOrderWithTracking(FALSE);  // Assign Tracking on Purchase Line FALSE.
    END;

    [Test]
    [HandlerFunctions(ItemTrackingPageHandler)]
    PROCEDURE ErrorAssignTrackingOnPurchLineAfterCalcSubcontractOrderAndCarryOutForProdOrderWithTracking@43();
    BEGIN
      // Verify the Tracking error on Purchase Line after Calculate Subcontracts and Carry Out.
      // Setup.
      Initialize;
      CalcSubcontractOrderForReleasedProductionOrderWithTracking(TRUE);  // Assign Tracking on Purchase Line TRUE.
    END;

    LOCAL PROCEDURE CalcSubcontractOrderForReleasedProductionOrderWithTracking@39(AssignTracking@1010 : Boolean);
    VAR
      WorkCenter@1000 : Record 99000754;
      Item@1003 : Record 27;
      ProductionOrder@1004 : Record 5405;
      PurchaseLine@1008 : Record 39;
      RequisitionLine@1002 : Record 246;
    BEGIN
      // Create Item with Item Tracking Code and Routing. Create and refresh Released Production Order.
      CreateItemWithItemTrackingCode(Item);
      CreateRoutingAndUpdateItemSubc(Item,WorkCenter,TRUE);
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandDec(100,2),'','');
      AssignTrackingOnProdOrderLine(ProductionOrder."No.");  // Assign Lot Tracking on Prod. Order Line.
      CalculateSubcontractOrder(WorkCenter);  // Calculate Subcontracts from Subcontracting worksheet.

      // Exercise: Accept and Carry Out Subcontracting Worksheet. Assign Tracking on Purchase Line.
      AcceptActionMessage(RequisitionLine,Item."No.");
      LibraryPlanning.CarryOutAMSubcontractWksh(RequisitionLine);
      FindPurchaseOrderLine(PurchaseLine,Item."No.");
      IF AssignTracking THEN BEGIN
        ASSERTERROR PurchaseLine.OpenItemTrackingLines;

        // Verify: Verify the Tracking error on Purchase Line. Verify the Quantity on Purchase Line created.
        Assert.ExpectedError(ItemTrackingErr);
      END ELSE
        VerifyPurchaseLine(Item."No.",ProductionOrder.Quantity);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingPageHandler)]
    PROCEDURE PostPurchOrderWithCalcSubcontractOrderAndCarryOutForProdOrderWithTracking@35();
    VAR
      WorkCenter@1000 : Record 99000754;
      Item@1003 : Record 27;
      ProductionOrder@1004 : Record 5405;
      RequisitionLine@1002 : Record 246;
      ProductionLine@1500000 : Record 5406;
      ProdcutionComp@1500001 : Record 5407;
    BEGIN
      // Setup: Create Item with Item Tracking Code and Routing. Create and refresh Released Production Order.
      Initialize;
      CreateItemWithItemTrackingCode(Item);
      CreateRoutingAndUpdateItemSubc(Item,WorkCenter,TRUE);
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandDec(100,2),'','');
      AssignTrackingOnProdOrderLine(ProductionOrder."No.");  // Assign Lot Tracking on Prod. Order Line.
      CalculateSubcontractOrder(WorkCenter);  // Calculate Subcontracts from Subcontracting worksheet.
      ProductionLine.SETRANGE(Status,ProductionOrder.Status);
      ProductionLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProductionLine.FINDFIRST;
      LibraryManufacturing.CreateProductionOrderComponent(
        ProdcutionComp,ProductionOrder.Status,ProductionOrder."No.",ProductionLine."Line No.");
      ProdcutionComp.VALIDATE("Item No.",Item."No.");
      ProdcutionComp.MODIFY(TRUE);

      // Accept and Carry Out Action Message on Subcontracting Worksheet.
      AcceptActionMessage(RequisitionLine,Item."No.");
      LibraryPlanning.CarryOutAMSubcontractWksh(RequisitionLine);

      // Exercise: Post Purchase Order as Ship.
      PostPurchaseOrderAsShip(Item."No.");

      // Verify: Verify that Finished Quantity on Prod. Order Line exist after Purchase Order posting.
      VerifyReleasedProdOrderLine(Item."No.",ProductionOrder.Quantity);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingPageHandler)]
    PROCEDURE CalcSubcontractOrderForReleasedProductionOrderWithLocationAndTracking@237();
    VAR
      WorkCenter@1000 : Record 99000754;
      Item@1003 : Record 27;
      ProductionOrder@1004 : Record 5405;
      ReservationEntry@1007 : Record 337;
    BEGIN
      // Setup: Create Item with Item Tracking Code and Routing. Create and refresh Released Production Order with Location.
      Initialize;
      CreateItemWithItemTrackingCode(Item);
      CreateRoutingAndUpdateItemSubc(Item,WorkCenter,TRUE);
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandDec(10,2),LocationBlue.Code,'');
      AssignTrackingOnProdOrderLine(ProductionOrder."No.");  // Assign Lot Tracking on Prod. Order Line.

      // Exercise: Calculate Subcontracts from Subcontracting Worksheet.
      CalculateSubcontractOrder(WorkCenter);

      // Verify: Verify Reservation Entry for Status, Location Code and Tracking after Calculate Subcontracts. Verify Production Quantity and WorkCenter Subcontractor on Subcontracting Worksheet.
      VerifyReservationEntry(Item."No.",ProductionOrder.Quantity,ReservationEntry."Reservation Status"::Surplus,LocationBlue.Code);
      VerifyRequisitionLineForSubcontract(ProductionOrder,WorkCenter,Item."No.");
    END;

    [Test]
    PROCEDURE StartingDateOnProdOrderRoutingLineForReleasedProdOrderSchedulingBack@141();
    VAR
      ProductionOrder@1001 : Record 5405;
      Item@1004 : Record 27;
      WorkCenter@1000 : Record 99000754;
      ProdOrderRoutingLine@1005 : Record 5409;
    BEGIN
      // Setup: Create Item. Create Routing Setup and update Routing on Item. Create a Released Production Order.
      Initialize;
      CreateItem(Item);
      CreateRoutingAndUpdateItem(Item,WorkCenter);
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,Item."No.",
        LibraryRandom.RandDec(100,2));

      // Exercise: Refresh Released Production Order with Scheduling Direction Back.
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // Verify: Verify that the Starting Date is less than or equal to the Due Date on Production Order Routing Line.
      FindProductionOrderRoutingLine(ProdOrderRoutingLine,ProductionOrder."No.");
      Assert.IsTrue(ProdOrderRoutingLine."Starting Date" <= ProductionOrder."Due Date",StartingDateMsg);
    END;

    [Test]
    PROCEDURE EndingDateOnProdOrderRoutingLineForReleasedProdOrderSchedulingForward@75();
    VAR
      ProductionOrder@1001 : Record 5405;
      Item@1004 : Record 27;
      WorkCenter@1000 : Record 99000754;
      ProdOrderRoutingLine@1005 : Record 5409;
    BEGIN
      // Setup: Create parent and child Items, create Production BOM. Create Routing Setup and update Routing on Item. Create a Firm Planned Production Order.
      Initialize;
      CreateItem(Item);
      CreateRoutingAndUpdateItem(Item,WorkCenter);
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,Item."No.",
        LibraryRandom.RandDec(100,2) + 1000);  // Large Quantity required.

      // Exercise: Refresh Released Production Order with Scheduling Direction Forward.
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,TRUE,TRUE,TRUE,TRUE,FALSE);

      // Verify: Verify that the Ending Date is greater than or equal to the Due Date on Production Order Routing Line.
      FindProductionOrderRoutingLine(ProdOrderRoutingLine,ProductionOrder."No.");
      Assert.IsTrue(ProdOrderRoutingLine."Ending Date" >= ProductionOrder."Due Date",EndingDateMsg);
    END;

    [Test]
    PROCEDURE CostAmountActualAfterPostConsumptionForReleasedProductionOrder@32();
    BEGIN
      // [FEATURE] [Production]
      // [SCENARIO] Verify Cost Amount Actual on Production Order Statistics page after post Consumption for Released Production Order.

      // Setup.
      Initialize;
      PostJournalsForReleasedProductionOrder(FALSE);  // Post Output FALSE.
    END;

    [Test]
    PROCEDURE CostAmountActualAfterPostConsumptionAndOutputForReleasedProductionOrder@30();
    BEGIN
      // [FEATURE] [Production]
      // [SCENARIO] Verify Cost Amount Actual on Production Order Statistics page after post Consumption and Output for Released Production Order.

      // Setup.
      Initialize;
      PostJournalsForReleasedProductionOrder(TRUE);  // Post Output TRUE.
    END;

    LOCAL PROCEDURE PostJournalsForReleasedProductionOrder@27(PostOutput@1008 : Boolean);
    VAR
      Item@1006 : Record 27;
      ChildItem@1005 : Record 27;
      ProductionOrder@1002 : Record 5405;
      ComponentsAtLocation@1000 : Code[10];
      QuantityPer@1009 : Integer;
      ActualCost@1010 : Decimal;
    BEGIN
      // Update Components at blank Location. Create Parent and Child Items in a Production BOM and certify it. Update Inventory for the Child Item. Create and refresh a Released Production Order.
      ComponentsAtLocation := UpdateManufacturingSetupComponentsAtLocation('');
      QuantityPer := LibraryRandom.RandInt(5);
      CreateItemsSetup(Item,ChildItem,QuantityPer);
      CreateAndPostItemJournalLine(ChildItem."No.",LibraryRandom.RandInt(10) + 100,'','');  // Large Quantity required for Component Item.
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandInt(10),'','');

      // Exercise: Calculate and post Consumption Journal. Create and post Output Journal.
      CalculateAndPostConsumptionJournal(ProductionOrder."No.");
      ActualCost := QuantityPer * (ProductionOrder.Quantity * ChildItem."Unit Cost");
      IF PostOutput THEN BEGIN
        CreateAndPostOutputJournalWithExplodeRouting(ProductionOrder."No.",ProductionOrder.Quantity);
        LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");  // Change Production Order Status from Released to Finished.
      END;

      // Verify: Verify the Cost Amount Actual on Production Order Statistics Page.
      IF PostOutput THEN
        VerifyCostAmountActualOnFinishedProductionOrderStatisticsPage(ProductionOrder."No.",ActualCost)
      ELSE
        VerifyCostAmountActualOnReleasedProductionOrderStatisticsPage(ProductionOrder."No.",ActualCost);

      // Tear Down.
      UpdateManufacturingSetupComponentsAtLocation(ComponentsAtLocation);
    END;

    [Test]
    PROCEDURE FirmPlannedProductionOrderWithFamily@34();
    VAR
      ParentItem@1012 : Record 27;
      ParentItem2@1003 : Record 27;
      ChildItem@1010 : Record 27;
      ChildItem2@1002 : Record 27;
      Family@1004 : Record 99000773;
      ProductionOrder@1006 : Record 5405;
      FamilyItemQuantity@1007 : Decimal;
    BEGIN
      // Setup: Create parent and child Items for a Family. Update Inventory for child Items. Create a Family.
      Initialize;
      FamilyItemQuantity := LibraryRandom.RandDec(10,2);
      CreateItemHierarchyForFamily(ParentItem,ParentItem2,ChildItem,ChildItem2,LibraryRandom.RandInt(5));
      CreateFamily(Family,ParentItem."No.",ParentItem2."No.",FamilyItemQuantity);

      // Exercise: Create and refresh a Firm Planned Production Order.
      CreateAndRefreshProductionOrderWithSourceTypeFamily(
        ProductionOrder,ProductionOrder.Status::"Firm Planned",Family."No.",FamilyItemQuantity);

      // Verify: Verify the Production Order Lines created. Production Order Quantity as calculated from Family Item Quantity.
      VerifyProdOrderLine(ParentItem."No.",'',FamilyItemQuantity * FamilyItemQuantity,WORKDATE);
      VerifyProdOrderLine(ParentItem2."No.",'',FamilyItemQuantity * FamilyItemQuantity,WORKDATE);
    END;

    [Test]
    PROCEDURE TotalCostOnFinishedProductionOrderStatisticsPageForFamily@364();
    VAR
      ParentItem@1010 : Record 27;
      ParentItem2@1003 : Record 27;
      ChildItem@1009 : Record 27;
      ChildItem2@1002 : Record 27;
      Family@1004 : Record 99000773;
      ProductionOrder@1006 : Record 5405;
      FamilyItemQuantity@1000 : Decimal;
      ActualCost@1011 : Decimal;
      QuantityPer@1001 : Decimal;
    BEGIN
      // [FEATURE] [Production]
      // [SCENARIO] Verify the correct Total Actual Cost on Finished Production Order with source type Family.

      // Setup: Create parent and child Items for a Family. Update Inventory for child Items. Create a Family. Create and refresh a Released Production Order.
      Initialize;
      QuantityPer := LibraryRandom.RandInt(5);
      FamilyItemQuantity := LibraryRandom.RandInt(10);
      CreateItemHierarchyForFamily(ParentItem,ParentItem2,ChildItem,ChildItem2,QuantityPer);
      CreateFamily(Family,ParentItem."No.",ParentItem2."No.",FamilyItemQuantity);
      CreateAndRefreshProductionOrderWithSourceTypeFamily(
        ProductionOrder,ProductionOrder.Status::Released,Family."No.",FamilyItemQuantity);

      // Calculate and post Consumption and Output journals.
      CalculateAndPostConsumptionJournal(ProductionOrder."No.");
      CreateAndPostOutputJournalWithExplodeRouting(ProductionOrder."No.",LibraryRandom.RandDec(100,2) + 100);  // Quantity greater than FamilyItemQuantity.

      // Exercise: Change Production Order Status from Released to Finished.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

      // Verify: Verify the correct Total Actual Cost on Finished Production Order Statistics page.
      ActualCost :=
        QuantityPer * FamilyItemQuantity * (FamilyItemQuantity * ChildItem."Unit Cost" + FamilyItemQuantity * ChildItem2."Unit Cost");
      VerifyTotalActualCostOnFinishedProductionOrderStatisticsPage(ProductionOrder."No.",ActualCost);
    END;

    [Test]
    PROCEDURE UnitOfMeasureOnWhseReceiptWithLocation@54();
    VAR
      Item@1014 : Record 27;
      ItemUnitOfMeasure@1013 : Record 5404;
      ItemUnitOfMeasure2@1012 : Record 5404;
      PurchaseHeader@1010 : Record 38;
      WarehouseReceiptLine@1001 : Record 7317;
    BEGIN
      // Setup: Create Item with multiple Item Unit of Measure, create and release Purchase Order.
      Initialize;
      CreateItem(Item);
      CreateMultipleItemUnitOfMeasureSetup(Item,ItemUnitOfMeasure,ItemUnitOfMeasure2);

      // Exercise: Create Whse Receipt from Purchase Order.
      CreateWhseReceiptFromPurchaseOrder(PurchaseHeader,Item."No.",LocationWhite.Code,LibraryRandom.RandDec(10,2));

      // Verify: Verify the Unit of Measure on whse Receipt Line.
      FindWarehouseReceiptNo(WarehouseReceiptLine,WarehouseReceiptLine."Source Document"::"Purchase Order",PurchaseHeader."No.");
      WarehouseReceiptLine.TESTFIELD("Unit of Measure Code",ItemUnitOfMeasure.Code);
      WarehouseReceiptLine.TESTFIELD("Qty. per Unit of Measure",ItemUnitOfMeasure."Qty. per Unit of Measure");
    END;

    [Test]
    PROCEDURE UnitOfMeasureOnWhsePutAwayWithLocation@36();
    VAR
      Item@1007 : Record 27;
      ItemUnitOfMeasure@1006 : Record 5404;
      ItemUnitOfMeasure2@1010 : Record 5404;
      PurchaseHeader@1005 : Record 38;
      WarehouseActivityLine@1000 : Record 5767;
    BEGIN
      // Setup: Create Item with multiple Item Unit of Measure. Create and release Purchase Order, create Whse Receipt.
      Initialize;
      CreateItem(Item);
      CreateMultipleItemUnitOfMeasureSetup(Item,ItemUnitOfMeasure,ItemUnitOfMeasure2);
      CreateWhseReceiptFromPurchaseOrder(PurchaseHeader,Item."No.",LocationWhite.Code,LibraryRandom.RandDec(10,2));

      // Exercise: Post Warehouse Receipt.
      PostWarehouseReceipt(PurchaseHeader."No.");

      // Verify: Verify the Put Away created with new Unit of Measure.
      FindWhseActivityLine(
        WarehouseActivityLine,WarehouseActivityLine."Activity Type"::"Put-away",LocationWhite.Code,PurchaseHeader."No.",
        WarehouseActivityLine."Action Type"::Take);
      VerifyUOMOnWhseActivityLine(WarehouseActivityLine,ItemUnitOfMeasure.Code,ItemUnitOfMeasure."Qty. per Unit of Measure");
    END;

    [Test]
    PROCEDURE NewUnitOfMeasureOnWhsePickForReleasedProdOrder@38();
    VAR
      Item@1007 : Record 27;
      ProductionOrder@1008 : Record 5405;
      ItemUnitOfMeasure@1006 : Record 5404;
      ItemUnitOfMeasure2@1010 : Record 5404;
      PurchaseHeader@1005 : Record 38;
      ChildItem@1016 : Record 27;
      WarehouseActivityLine@1003 : Record 5767;
      WarehouseActivityHeader@1000 : Record 5766;
      Quantity@1001 : Decimal;
      ComponentsAtLocation@1015 : Code[10];
    BEGIN
      // Setup: Update Components at Location. Create parent and child Items with multiple Item Unit of Measure in a Prod. BOM, create and release Purchase Order. Create and post Warehouse Receipt.
      Initialize;
      ComponentsAtLocation := UpdateManufacturingSetupComponentsAtLocation(LocationWhite.Code);
      Quantity := LibraryRandom.RandInt(100);
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(5));
      CreateMultipleItemUnitOfMeasureSetup(ChildItem,ItemUnitOfMeasure,ItemUnitOfMeasure2);
      CreateWhseReceiptFromPurchaseOrder(PurchaseHeader,ChildItem."No.",LocationWhite.Code,Quantity);
      PostWarehouseReceipt(PurchaseHeader."No.");

      // Register the Put Away, create and refresh a Released Production Order.
      RegisterWarehouseActivity(PurchaseHeader."No.",WarehouseActivityHeader.Type::"Put-away");
      CreateAndRefreshReleasedProductionOrder(
        ProductionOrder,Item."No.",Quantity,LocationWhite.Code,LocationWhite."To-Production Bin Code");

      // Exercise: Create Pick from Released Production Order.
      LibraryWarehouse.CreateWhsePickFromProduction(ProductionOrder);

      // Verify: Verify that new Unit of Measure is updated on Warehouse Pick Line.
      FindWhseActivityLine(
        WarehouseActivityLine,WarehouseActivityLine."Activity Type"::Pick,LocationWhite.Code,ProductionOrder."No.",
        WarehouseActivityLine."Action Type"::Take);
      VerifyUOMOnWhseActivityLine(WarehouseActivityLine,ItemUnitOfMeasure2.Code,ItemUnitOfMeasure2."Qty. per Unit of Measure");

      // Tear Down.
      UpdateManufacturingSetupComponentsAtLocation(ComponentsAtLocation);
    END;

    [Test]
    PROCEDURE NewUnitOfMeasureOnRegisteredWhsePutAwayWithProductionBOM@59();
    VAR
      Item@1007 : Record 27;
      ItemUnitOfMeasure@1006 : Record 5404;
      ItemUnitOfMeasure2@1010 : Record 5404;
      PurchaseHeader@1005 : Record 38;
      ChildItem@1016 : Record 27;
      WarehouseActivityHeader@1002 : Record 5766;
      RegisteredWhseActivityLine@1004 : Record 5773;
      Quantity@1001 : Decimal;
    BEGIN
      // Setup: Create parent and child Items with multiple Item Unit of Measure in a Prod. BOM, create and release Purchase Order. Create and post Warehouse Receipt.
      Initialize;
      Quantity := LibraryRandom.RandInt(100);
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(5));
      CreateMultipleItemUnitOfMeasureSetup(ChildItem,ItemUnitOfMeasure,ItemUnitOfMeasure2);
      CreateWhseReceiptFromPurchaseOrder(PurchaseHeader,ChildItem."No.",LocationWhite.Code,Quantity);
      PostWarehouseReceipt(PurchaseHeader."No.");

      // Exercise: Register the Put Away created.
      RegisterWarehouseActivity(PurchaseHeader."No.",WarehouseActivityHeader.Type::"Put-away");

      // Verify: Verify the Unit of Measure Code updated on Registered Whse Activity Lines.
      FindRegisteredWhseActivityLine(
        RegisteredWhseActivityLine,PurchaseHeader."No.",RegisteredWhseActivityLine."Action Type"::Take,
        RegisteredWhseActivityLine."Activity Type"::"Put-away");
      VerifyRegisteredWhseActivityLine(
        RegisteredWhseActivityLine,ItemUnitOfMeasure.Code,ItemUnitOfMeasure."Qty. per Unit of Measure",Quantity);
      FindRegisteredWhseActivityLine(
        RegisteredWhseActivityLine,PurchaseHeader."No.",RegisteredWhseActivityLine."Action Type"::Place,
        RegisteredWhseActivityLine."Activity Type"::"Put-away");
      VerifyRegisteredWhseActivityLine(
        RegisteredWhseActivityLine,ItemUnitOfMeasure2.Code,ItemUnitOfMeasure2."Qty. per Unit of Measure",Quantity / 2);  // Used for Break bulk.
    END;

    [Test]
    [HandlerFunctions(ProductionJournalPageHandler)]
    PROCEDURE OutputEntryOnProductionJournalForReleasedProductionOrder@269();
    VAR
      Item@1012 : Record 27;
      ProductionOrder@1006 : Record 5405;
      ItemJournalLine@1000 : Record 83;
    BEGIN
      // Setup: Create Item. Create and refresh a Released Production Order.
      Initialize;
      CreateItem(Item);
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,Item."No.",LibraryRandom.RandDec(100,2),LocationWhite.Code,
        LocationWhite."To-Production Bin Code");

      // Exercise & Verify: Open Production Journal for the Released Production Order. Verify the Output Entry on Production Journal through ProductionJournalPageHandler.
      OpenProductionJournalPage(ProductionOrder,Item."No.",Item."No.",ProductionOrder.Quantity,ItemJournalLine."Entry Type"::Output);
    END;

    [Test]
    [HandlerFunctions(ProductionJournalPageHandler)]
    PROCEDURE ConsumptionEntryOnProductionJournalForProductionOrderAfterCreateAndRegisterPick@106();
    VAR
      Item@1012 : Record 27;
      ChildItem@1010 : Record 27;
      ProductionOrder@1006 : Record 5405;
      WarehouseActivityLine@1000 : Record 5767;
      ItemJournalLine@1007 : Record 83;
      ComponentsAtLocation@1002 : Code[10];
      AlwaysCreatePickLine@1005 : Boolean;
      Quantity@1003 : Decimal;
    BEGIN
      // Setup: Update Location Setup, update Components at Location.
      Initialize;
      AlwaysCreatePickLine := UpdateLocationSetup(LocationWhite,TRUE);  // Always Create Pick Line as TRUE.
      ComponentsAtLocation := UpdateManufacturingSetupComponentsAtLocation(LocationWhite.Code);

      // Create parent and child Items in a Production BOM and certify it. Update Inventory for Child Item. Create and refresh a Released Production Order.
      // Create Warehouse Pick from the Released Production Order.
      Quantity := LibraryRandom.RandInt(100);
      CreateItemsSetup(Item,ChildItem,1);  // Value required to avoid Bin Code mismatch.
      UpdateInventoryWithWhseItemJournal(ChildItem,LocationWhite,Quantity);
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,Item."No.",Quantity,LocationWhite.Code,
        LocationWhite."To-Production Bin Code");
      LibraryWarehouse.CreateWhsePickFromProduction(ProductionOrder);
      RegisterWarehouseActivity(ProductionOrder."No.",WarehouseActivityLine."Activity Type"::Pick);  // Register the Pick created.

      // Exercise & Verify: Open Production Journal for the Released Production Order. Verify the Consumption Entry on Production Journal through ProductionJournalPageHandler.
      OpenProductionJournalPage(ProductionOrder,ChildItem."No.",Item."No.",Quantity,ItemJournalLine."Entry Type"::Consumption);

      // Tear Down.
      UpdateManufacturingSetupComponentsAtLocation(ComponentsAtLocation);
      UpdateLocationSetup(LocationWhite,AlwaysCreatePickLine);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE InventoryPickForProductionOrderWithMultipleComponents@132();
    VAR
      Item@1012 : Record 27;
      Item2@1010 : Record 27;
      Item3@1004 : Record 27;
      Bin@1001 : Record 7354;
      ProductionOrder@1006 : Record 5405;
      WarehouseActivityLine@1000 : Record 5767;
      ComponentsAtLocation@1002 : Code[10];
      Quantity@1003 : Decimal;
    BEGIN
      // Setup: Update Components at a Location. Create parent and multiple components in a Production BOM and certify it. Update Inventory for component Items. Create and refresh a Released Production Order.
      Initialize;
      ComponentsAtLocation := UpdateManufacturingSetupComponentsAtLocation(LocationSilver.Code);
      LibraryWarehouse.FindBin(Bin,LocationSilver.Code,'',1);  // Find Bin of Index 1.
      Quantity := LibraryRandom.RandInt(100);
      CreateAndCertifyProdBOMWithMultipleComponent(Item,Item2,Item3);
      UpdateComponentsInventory(Item2."No.",Item3."No.",LocationSilver.Code,Bin.Code,Quantity);
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,Item."No.",Quantity,LocationSilver.Code,Bin.Code);

      // Exercise: Create Inventory Pick from the Released Production Order.
      LibraryVariableStorage.Enqueue(PickActivitiesCreatedMsg);  // Enqueue variable required inside MessageHandler.
      LibraryWarehouse.CreateInvtPutPickMovement(
        WarehouseActivityLine."Source Document"::"Prod. Consumption",ProductionOrder."No.",FALSE,TRUE,FALSE);

      // Verify: Verify that Inventory Pick created successfully.
      FindWhseActivityLine(
        WarehouseActivityLine,WarehouseActivityLine."Activity Type"::"Invt. Pick",LocationSilver.Code,ProductionOrder."No.",
        WarehouseActivityLine."Action Type"::Take);
      VerifyWarehouseActivityLine(WarehouseActivityLine,Item2."No.",Quantity);
      VerifyWarehouseActivityLine(WarehouseActivityLine,Item3."No.",Quantity);

      // Tear Down.
      UpdateManufacturingSetupComponentsAtLocation(ComponentsAtLocation);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE PostedPartialInventoryPickForProductionOrderWithMultipleComponents@153();
    VAR
      Item@1012 : Record 27;
      Item2@1010 : Record 27;
      Item3@1004 : Record 27;
      Bin@1001 : Record 7354;
      ProductionOrder@1006 : Record 5405;
      WarehouseActivityHeader@1005 : Record 5766;
      WarehouseActivityLine@1000 : Record 5767;
      ComponentsAtLocation@1002 : Code[10];
      Quantity@1003 : Decimal;
    BEGIN
      // Setup: Update Components at a Location. Create parent and multiple components in a Production BOM and certify it. Update Inventory for component Items. Create and refresh a Released Production Order.
      Initialize;
      ComponentsAtLocation := UpdateManufacturingSetupComponentsAtLocation(LocationSilver.Code);
      LibraryWarehouse.FindBin(Bin,LocationSilver.Code,'',1);  // Find Bin of Index 1.
      Quantity := LibraryRandom.RandInt(100);
      CreateAndCertifyProdBOMWithMultipleComponent(Item,Item2,Item3);
      UpdateComponentsInventory(Item2."No.",Item3."No.",LocationSilver.Code,Bin.Code,Quantity);
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,Item."No.",Quantity,LocationSilver.Code,Bin.Code);

      // Create Inventory Pick from the Released Production Order. Update partial quantity on Inventory Pick line created.
      LibraryVariableStorage.Enqueue(PickActivitiesCreatedMsg);  // Enqueue variable required inside MessageHandler.
      LibraryWarehouse.CreateInvtPutPickMovement(
        WarehouseActivityLine."Source Document"::"Prod. Consumption",ProductionOrder."No.",FALSE,TRUE,FALSE);
      UpdateQuantityOnWarehouseActivityLine(
        ProductionOrder."No.",WarehouseActivityLine."Action Type"::Take,Quantity / 2,LocationSilver.Code);
      FindWarehouseActivityHeader(
        WarehouseActivityHeader,ProductionOrder."No.",WarehouseActivityLine."Action Type"::Take,LocationSilver.Code);

      // Exercise: Post Inventory Pick.
      LibraryWarehouse.PostInventoryActivity(WarehouseActivityHeader,FALSE);  // Post as Invoice False.

      // Verify: Verify that Inventory Pick posted successfully with partial Quantity.
      VerifyPostedInventoryPickLine(ProductionOrder."No.",Item2."No.",Bin.Code,Quantity / 2,LocationSilver.Code);

      // Tear Down.
      UpdateManufacturingSetupComponentsAtLocation(ComponentsAtLocation);
    END;

    [Test]
    PROCEDURE PostConsumptionCompItemWithBackwardFlushingForReleasedProdOrderError@231();
    VAR
      Item@1004 : Record 27;
      ChildItem@1009 : Record 27;
      ProductionOrder@1003 : Record 5405;
      WorkCenter@1000 : Record 99000754;
    BEGIN
      // Setup: Create Parent and Child Items in Certified Production BOM. Update Flushing method on child Item. Update Inventory for the Child Item. Create Routing. Create and Refresh a Released Production Order.
      Initialize;
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(5));
      UpdateFlushingMethodOnItem(ChildItem,ChildItem."Flushing Method"::Backward);
      CreateAndPostItemJournalLine(ChildItem."No.",LibraryRandom.RandDec(10,2) + 100,'','');  // Large Component Quantity is required.
      CreateRoutingAndUpdateItem(Item,WorkCenter);
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,Item."No.",LibraryRandom.RandDec(10,2),'','');

      // Exercise: Calculate and post Consumption for the child Item.
      ASSERTERROR CalculateAndPostConsumptionJournal(ProductionOrder."No.");

      // Verify: Verify the error post Consumption.
      Assert.ExpectedError(ItemJournalLineExistErr);
    END;

    [Test]
    PROCEDURE PostOutputAndFinishReleasedProdOrderWithComponentBackwardFlushing@177();
    VAR
      Item@1004 : Record 27;
      ChildItem@1009 : Record 27;
      ProductionOrder@1003 : Record 5405;
      WorkCenter@1000 : Record 99000754;
    BEGIN
      // [FEATURE] [Production]
      // [SCENARIO] Verify Finished Quantity is correct on Prod. Order Line with component Flushing Method = Backward, after Prod. Order change Status from Released to Finished.

      // Setup: Create Parent and Child Items in Certified Production BOM. Update Flushing method on child Item. Update Inventory for the Child Item. Create Routing. Create and Refresh a Released Production Order.
      Initialize;
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(5));
      UpdateFlushingMethodOnItem(ChildItem,ChildItem."Flushing Method"::Backward);
      CreateAndPostItemJournalLine(ChildItem."No.",LibraryRandom.RandDec(10,2) + 100,'','');  // Large Component Quantity is required.
      CreateRoutingAndUpdateItem(Item,WorkCenter);
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,Item."No.",LibraryRandom.RandDec(10,2),'','');
      CreateAndPostOutputJournalWithExplodeRouting(ProductionOrder."No.",ProductionOrder.Quantity);  // Create and post Output Journal for the Production Order.

      // Exercise: Change Status from Released to Finished.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");  // Change Status from Released to Finished.

      // Verify: Verify the Finished Quantity on Prod. Order Line.
      VerifyFinishedProdOrderLine(Item."No.",ProductionOrder.Quantity);
    END;

    [Test]
    PROCEDURE CostAmountActualAfterPostNegativeOutputForProdOrderWithComponentBackwardFlushing@86();
    VAR
      Item@1004 : Record 27;
      ChildItem@1009 : Record 27;
      ProductionOrder@1003 : Record 5405;
      ItemJournalLine@1005 : Record 83;
    BEGIN
      // Setup: Create Parent and Child Items in Certified Production BOM. Update Backward Flushing method on child Item. Create and post Purchase Order for Child Item. Create and Refresh a Released Production Order.
      Initialize;
      CreateProdOrderItemSetupWithOutputJournalAndExplodeRouting(Item,ChildItem,ProductionOrder);

      // Exercise: Post the negative Output for the Production Order.
      CreateAndPostOutputJournalWithApplyEntry(Item."No.",-ProductionOrder.Quantity);

      // Verify: Verify the Cost Amount Actual as zero for Output Entry.
      VerifyValueEntry(Item."No.",ProductionOrder."No.",ItemJournalLine."Entry Type"::Output,0);
    END;

    [Test]
    PROCEDURE CostAmountActualAfterPostOutputAndFinishReleasedProdOrderWithComponentBackwardFlushing@88();
    VAR
      Item@1004 : Record 27;
      ChildItem@1009 : Record 27;
      ProductionOrder@1003 : Record 5405;
      ItemJournalLine@1005 : Record 83;
    BEGIN
      // [FEATURE] [Production]
      // [SCENARIO] Verify that Cost Amount is correct in Value Entry after Production Order post Output and change status from Released to Finished, child item has Flushing Method = Backward.

      // Setup: Create Parent and Child Items in Certified Production BOM. Update Backward Flushing method on child Item. Create and post Purchase Order for Child Item. Create and Refresh a Released Production Order.
      Initialize;
      CreateProdOrderItemSetupWithOutputJournalAndExplodeRouting(Item,ChildItem,ProductionOrder);

      // Exercise: Change Status from Released to Finished.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

      // Verify: Verify the Cost Amount Actual in Value Entry created. Verify the Cost Amount Actual as zero for Output Entry.
      VerifyValueEntry(
        ChildItem."No.",ProductionOrder."No.",ItemJournalLine."Entry Type"::Consumption,
        -ProductionOrder.Quantity * ChildItem."Unit Cost");
      VerifyValueEntry(Item."No.",ProductionOrder."No.",ItemJournalLine."Entry Type"::Output,0);
    END;

    [Test]
    PROCEDURE UnitOfMeasureCodeOnProdOrderLineWithBOMVersionCode@125();
    VAR
      Item@1003 : Record 27;
      ChildItem@1000 : Record 27;
      ProductionOrder@1002 : Record 5405;
      ProdOrderLine@1001 : Record 5406;
    BEGIN
      // Setup: Create parent and child Items in a Certified Production BOM. Create Certified Production BOM version with Copy Version and certify it. Create and refresh a Released Production Order.
      Initialize;
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(5));
      CreateCertifiedProductionBOMVersionWithCopyBOM(Item."Production BOM No.",Item."Base Unit of Measure");
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,Item."No.",LibraryRandom.RandDec(100,2),'','');

      // Exercise: Update Production BOM Version Code on Production Order Line.
      UpdateProdBOMVersionCodeOnProdOrderLine(Item);

      // Verify: Verify the Unit Of Measure Code remains same on Production Order Line when Production BOM Version Code is changed.
      FindReleasedProdOrderLine(ProdOrderLine,Item."No.");
      ProdOrderLine.TESTFIELD("Unit of Measure Code",Item."Base Unit of Measure");
    END;

    [Test]
    PROCEDURE QuantityPickedAfterRegisterWhsePickForProductionOrder@93();
    VAR
      Item@1012 : Record 27;
      ChildItem@1010 : Record 27;
      ProductionOrder@1006 : Record 5405;
      WarehouseActivityLine@1000 : Record 5767;
      AlwaysCreatePickLine@1005 : Boolean;
      Quantity@1003 : Decimal;
    BEGIN
      // Setup: Update Location Setup. Create parent and child Items in a Production BOM and certify it. Update Inventory for Child Item. Create and refresh a Released Production Order.
      // Create Warehouse Pick from the Released Production Order.
      Initialize;
      AlwaysCreatePickLine := UpdateLocationSetup(LocationWhite,TRUE);  // Always Create Pick Line as TRUE.
      Quantity := LibraryRandom.RandInt(100);
      CreateItemsSetup(Item,ChildItem,1);  // Value required to avoid Bin Code mismatch.
      UpdateInventoryWithWhseItemJournal(ChildItem,LocationWhite,Quantity);
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,Item."No.",Quantity,LocationWhite.Code,
        LocationWhite."To-Production Bin Code");
      LibraryWarehouse.CreateWhsePickFromProduction(ProductionOrder);

      // Exercise: Register the Whse Pick.
      RegisterWarehouseActivity(ProductionOrder."No.",WarehouseActivityLine."Activity Type"::Pick);

      // Verify: Verify the Qty Picked and Qty Picked (Base) on Production Order Component.
      VerifyProdOrderComponent(ProductionOrder."No.",ProductionOrder.Status::Released,ChildItem."No.",ProductionOrder.Quantity);

      // Tear Down.
      UpdateLocationSetup(LocationWhite,AlwaysCreatePickLine);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerTRUE)]
    PROCEDURE WhsePickAfterRefreshProductionOrderForAlreadyPickedItem@142();
    VAR
      Item@1012 : Record 27;
      ChildItem@1010 : Record 27;
      ProductionOrder@1006 : Record 5405;
      WarehouseActivityLine@1000 : Record 5767;
      AlwaysCreatePickLine@1005 : Boolean;
      Quantity@1003 : Decimal;
    BEGIN
      // Setup: Update Location Setup. Create parent and child Items in a Production BOM and certify it. Update Inventory for Child Item. Create and refresh a Released Production Order.
      // Create Warehouse Pick from the Released Production Order.
      Initialize;
      AlwaysCreatePickLine := UpdateLocationSetup(LocationWhite,TRUE);  // Always Create Pick Line as TRUE.
      Quantity := LibraryRandom.RandInt(100);
      CreateItemsSetup(Item,ChildItem,1);  // Value required to avoid Bin Code mismatch.
      UpdateInventoryWithWhseItemJournal(ChildItem,LocationWhite,Quantity);
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,Item."No.",Quantity,LocationWhite.Code,
        LocationWhite."To-Production Bin Code");
      LibraryWarehouse.CreateWhsePickFromProduction(ProductionOrder);

      // Register the Whse Pick. Refresh the Production Order again.
      RegisterWarehouseActivity(ProductionOrder."No.",WarehouseActivityLine."Activity Type"::Pick);
      LibraryVariableStorage.Enqueue(STRSUBSTNO(ComponentsAlreadyPickedQst,ProductionOrder."No."));
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // Exercise: Create Whse Pick again.
      LibraryWarehouse.CreateWhsePickFromProduction(ProductionOrder);

      // Verify: Verify the Take and Place Pick lines created after refresh Production Order twice.
      FindWhseActivityLine(
        WarehouseActivityLine,WarehouseActivityLine."Activity Type"::Pick,LocationWhite.Code,ProductionOrder."No.",
        WarehouseActivityLine."Action Type"::Take);
      VerifyWarehouseActivityLine(WarehouseActivityLine,ChildItem."No.",ProductionOrder.Quantity);
      FindWhseActivityLine(
        WarehouseActivityLine,WarehouseActivityLine."Activity Type"::Pick,LocationWhite.Code,ProductionOrder."No.",
        WarehouseActivityLine."Action Type"::Place);
      VerifyWarehouseActivityLine(WarehouseActivityLine,ChildItem."No.",ProductionOrder.Quantity);

      // Tear Down.
      UpdateLocationSetup(LocationWhite,AlwaysCreatePickLine);
    END;

    [Test]
    PROCEDURE WhsePickForReleasedProductionOrderWithItemFlushingPickAndBackward@399();
    BEGIN
      // Verify the Movement Warehouse Entries created after create Whse Pick with Child Item Flushing method Pick + Backward.
      // Setup.
      Initialize;
      CreateAndRegisterWhsePickForProductionOrderWithItemFlushingPickAndBackward(FALSE);  // Register Pick FALSE.
    END;

    [Test]
    PROCEDURE WhseEntryAfterRegisterPickForReleasedProductionOrderWithItemFlushingPickAndBackward@400();
    BEGIN
      // Verify the Movement Warehouse Entries created after Register Whse Pick with Child Item Flushing method Pick + Backward.
      // Setup.
      Initialize;
      CreateAndRegisterWhsePickForProductionOrderWithItemFlushingPickAndBackward(TRUE);  // Register Pick TRUE.
    END;

    LOCAL PROCEDURE CreateAndRegisterWhsePickForProductionOrderWithItemFlushingPickAndBackward@258(RegisterPick@1018 : Boolean);
    VAR
      Item@1007 : Record 27;
      ChildItem@1002 : Record 27;
      ProductionOrder@1008 : Record 5405;
      WarehouseActivityHeader@1005 : Record 5766;
      WarehouseActivityLine@1003 : Record 5767;
      WarehouseEntry@1000 : Record 7312;
      Quantity@1001 : Decimal;
      ComponentsAtLocation@1015 : Code[10];
    BEGIN
      // Update Components at Location. Create parent and child Items in a Production BOM. Update Flushing Method on Child Item. Update Child Item Inventory. Create and refresh a Released Production Order.
      ComponentsAtLocation := UpdateManufacturingSetupComponentsAtLocation(LocationWhite.Code);
      Quantity := LibraryRandom.RandInt(100);
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(5));
      UpdateItemFlushingMethodPickAndBackward(ChildItem);
      UpdateInventoryWithWhseItemJournal(ChildItem,LocationWhite,Quantity);
      CreateAndRefreshReleasedProductionOrder(
        ProductionOrder,Item."No.",Quantity,LocationWhite.Code,LocationWhite."To-Production Bin Code");

      // Exercise: Create Whse Pick from Released Production Order. Register the Whse Pick created.
      LibraryWarehouse.CreateWhsePickFromProduction(ProductionOrder);
      IF RegisterPick THEN
        RegisterWarehouseActivity(ProductionOrder."No.",WarehouseActivityHeader.Type::Pick);

      // Verify: Verify the Movement Warehouse Entry created after Register Whse Pick. Verify the Pick created for Child Item with Pick + Backward Flushing method.
      IF RegisterPick THEN
        VerifyWarehouseEntry(
          WarehouseEntry."Entry Type"::Movement,ProductionOrder."No.",ChildItem."No.",LocationWhite."Cross-Dock Bin Code",
          LocationWhite.Code,-Quantity)
      ELSE BEGIN
        FindWhseActivityLine(
          WarehouseActivityLine,WarehouseActivityLine."Activity Type"::Pick,LocationWhite.Code,ProductionOrder."No.",
          WarehouseActivityLine."Action Type"::Take);
        VerifyWarehouseActivityLine(WarehouseActivityLine,ChildItem."No.",ProductionOrder.Quantity);
        FindWhseActivityLine(
          WarehouseActivityLine,WarehouseActivityLine."Activity Type"::Pick,LocationWhite.Code,ProductionOrder."No.",
          WarehouseActivityLine."Action Type"::Place);
        VerifyWarehouseActivityLine(WarehouseActivityLine,ChildItem."No.",ProductionOrder.Quantity);
      END;

      // Tear Down.
      UpdateManufacturingSetupComponentsAtLocation(ComponentsAtLocation);
    END;

    [Test]
    PROCEDURE WhseEntryAfterPutAwayForReleasedProductionOrderWithItemFlushingBackward@472();
    BEGIN
      // Verify the Movement Warehouse Entries created after post Whse Receipt for Item with Backward Flushing method.
      // Setup.
      Initialize;
      CreateAndRegisterWhsePutAwayForProductionOrderWithItemFlushingBackward(FALSE);  // Register Put Away FALSE.
    END;

    [Test]
    PROCEDURE WhseEntriesAfterRegisterPutAwayForReleasedProductionOrderWithItemFlushingBackward@473();
    BEGIN
      // Verify the Movement Warehouse Entries created after Register Whse Put Away for Item with Backward Flushing method.
      // Setup.
      Initialize;
      CreateAndRegisterWhsePutAwayForProductionOrderWithItemFlushingBackward(TRUE);  // Register Put Away TRUE.
    END;

    LOCAL PROCEDURE CreateAndRegisterWhsePutAwayForProductionOrderWithItemFlushingBackward@324(RegisterPutAway@1018 : Boolean);
    VAR
      Item@1007 : Record 27;
      ChildItem@1002 : Record 27;
      PurchaseHeader@1005 : Record 38;
      WarehouseActivityHeader@1000 : Record 5766;
      WarehouseEntry@1014 : Record 7312;
      Quantity@1001 : Decimal;
    BEGIN
      // Create parent and child Items in a Production BOM and update Backward Flushing on child Item. Create and release Purchase Order. Create Warehouse Receipt.
      Quantity := LibraryRandom.RandInt(100);
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(5));
      UpdateFlushingMethodOnItem(ChildItem,ChildItem."Flushing Method"::Backward);
      CreateWhseReceiptFromPurchaseOrder(PurchaseHeader,ChildItem."No.",LocationWhite.Code,Quantity);

      // Exercise: Post Warehouse Receipt. Register the Put Away created.
      PostWarehouseReceipt(PurchaseHeader."No.");
      IF RegisterPutAway THEN
        RegisterWarehouseActivity(PurchaseHeader."No.",WarehouseActivityHeader.Type::"Put-away");

      // Verify: Verify the Movement Warehouse Entries created after post Whse Receipt and Register Whse Put Away for Child Item with Backward Flushing method.
      IF RegisterPutAway THEN
        VerifyWarehouseEntry(
          WarehouseEntry."Entry Type"::Movement,PurchaseHeader."No.",ChildItem."No.",LocationWhite."Receipt Bin Code",
          LocationWhite.Code,-Quantity)
      ELSE
        VerifyWarehouseEntry(
          WarehouseEntry."Entry Type"::"Positive Adjmt.",PurchaseHeader."No.",ChildItem."No.",LocationWhite."Receipt Bin Code",
          LocationWhite.Code,Quantity);
    END;

    [Test]
    [HandlerFunctions(PostProductionJournalHandler,MessageHandler,ConfirmHandlerTRUE)]
    PROCEDURE ValueEntriesForFinishedProdOrderWithNewUOM@129();
    VAR
      ParentItem@1000 : Record 27;
      ChildItem@1001 : Record 27;
      PurchaseHeader@1002 : Record 38;
      ProductionOrder@1003 : Record 5405;
      ProdOrderLine@1004 : Record 5406;
      ItemUnitOfMeasure@1005 : Record 5404;
      InventorySetup@1006 : Record 313;
      ValueEntry@1008 : Record 5802;
      CostAmount@1010 : Decimal;
    BEGIN
      // [FEATURE] [Production]
      // [SCENARIO] Verify that Value Entries are correct for Finished Production Order if Prod. Order Line is updated with new UOM, then Production Journal posted, then status changed from Released to Finished.

      // Setup: Create parent and child Items in a Production BOM and certify it. Update Overhead rate, Unit of measure and Quantity per unit of measure on Parent Item. Create and Post Purchase Order as Receive.
      Initialize;
      UpdateInventorySetup(InventorySetup);
      CreateItemsSetup(ParentItem,ChildItem,LibraryRandom.RandInt(5));
      UpdateItemOverheadRate(ParentItem);
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,ParentItem."No.",LibraryRandom.RandInt(10));
      CreateAndPostPurchaseOrderWithDirectUnitCostAsReceive(PurchaseHeader,ChildItem."No.",LibraryRandom.RandDec(10,2) + 100);  // Large Quantity required.

      // Create and refresh Released Production Order and change Unit of Measure on Production Order Line.
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ParentItem."No.",LibraryRandom.RandDec(10,2),'','');
      UpdateProdOrderLineUnitOfMeasureCode(ProdOrderLine,ParentItem."No.",ItemUnitOfMeasure.Code);

      // Open Production Journal and Post.
      LibraryManufacturing.OpenProductionJournal(ProductionOrder,ProdOrderLine."Line No.");  // Handler used -PostProductionJournalHandler.

      // Exercise: Change Status from Released to Finished.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

      // Verify: Verify Value Entries for Finished Production Order With Entry Type Direct Cost and Indirect Cost. Verify the Cost Amount, Cost Per Unit and Invoiced Quantity as Zero.
      CostAmount := ProdOrderLine."Overhead Rate" * ItemUnitOfMeasure."Qty. per Unit of Measure" * ProductionOrder.Quantity;
      VerifyValueEntryForEntryType(
        ValueEntry."Entry Type"::"Direct Cost",ProductionOrder."No.",
        ProductionOrder.Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",0,0,0,0);
      VerifyValueEntryForEntryType(
        ValueEntry."Entry Type"::"Indirect Cost",ProductionOrder."No.",0,CostAmount,0,ProdOrderLine."Overhead Rate",CostAmount);

      // Tear Down.
      ResetInventorySetup(InventorySetup);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerTRUE)]
    PROCEDURE PurchaseLineAfterUpdatingVATBusPostingGroupFromHeader@19();
    VAR
      WorkCenter@1000 : Record 99000754;
      Item@1003 : Record 27;
      ProductionOrder@1004 : Record 5405;
      PurchaseLine@1006 : Record 39;
      PurchaseHeader@1002 : Record 38;
      RequisitionLine@1005 : Record 246;
    BEGIN
      // Test that after changing VAT bus posting group from Purchase Header created from subcontacting worksheet, Purchase line should not be updated with Item card.
      // Setup: Create Item. Create Routing and update on Item.
      Initialize;
      CreateItem(Item);
      CreateRoutingAndUpdateItemSubc(Item,WorkCenter,TRUE);
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandDec(10,2),'','');

      // Calculate Subcontracts from Subcontracting worksheet and Carry Out Action Message.
      CalculateSubcontractOrder(WorkCenter);
      AcceptActionMessage(RequisitionLine,Item."No.");
      LibraryPlanning.CarryOutAMSubcontractWksh(RequisitionLine);

      // Exercise: Update the purchase header with VAT bus posting group different from the earlier one.
      LibraryVariableStorage.Enqueue(RecreatePurchaseLineConfirmHandlerQst);  // Required inside ConfirmHandlerTRUE.
      FindPurchaseOrderLine(PurchaseLine,Item."No.");
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      UpdatePurchaseHeaderVATBusPostingGroup(PurchaseHeader);

      // Verify: Verify that the Purchase line should not be updated with Item card. And the field values remains the same.
      VerifyRecreatedPurchaseLine(PurchaseLine,PurchaseHeader."VAT Bus. Posting Group");
    END;

    [Test]
    PROCEDURE PostOutputCorrectionWithRequirePickLocationForItemWithRouting@148();
    BEGIN
      // Verify production journal with negative quantity on output line can be posted with Require Pick Location for Item with routing
      PostOutputCorrectionWithRequirePickLocation(TRUE); // TRUE indicates routing exists
    END;

    [Test]
    PROCEDURE PostOutputCorrectionWithRequirePickLocationForItemWithoutRouting@154();
    BEGIN
      // Verify production journal with negative quantity on output line can be posted with Require Pick Location for Item without routing
      PostOutputCorrectionWithRequirePickLocation(FALSE); // FALSE indicates routing doesn't exist
    END;

    LOCAL PROCEDURE PostOutputCorrectionWithRequirePickLocation@127(HasRouting@1008 : Boolean);
    VAR
      RoutingLine@1005 : Record 99000764;
      Item@1003 : Record 27;
      ProductionOrder@1004 : Record 5405;
      WorkCenter@1006 : Record 99000754;
      Location@1007 : Record 14;
    BEGIN
      // Setup: Create Production Item
      Initialize;
      LibraryInventory.CreateItem(Item);

      IF HasRouting THEN BEGIN
        CreateRoutingAndUpdateItem(Item,WorkCenter); // Set Routing No. for Item
        FindLastRoutingLine(RoutingLine,Item."Routing No."); // The Operation No. for last routing line is needed when posting output with negative quantity
      END;

      LibraryWarehouse.CreateLocationWMS(Location,FALSE,FALSE,TRUE,FALSE,FALSE); // Create a Require-Pick Location
      // Create and refresh release Production Order with setting Location code
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandInt(10),Location.Code,''); // Set Bin Code to empty
      CreateAndPostOutputJournalWithExplodeRouting(ProductionOrder."No.",ProductionOrder.Quantity); // Create and post Output Journal for the Production Order.

      // Exercise and Verify: Post output journal with negative quantity and expect the post can succeed
      CreateAndPostOutputJournalWithApplyEntryAndOperationNo(Item."No.",-ProductionOrder.Quantity,RoutingLine."Operation No.");

      // Verify: 2 Item Ledger Entries for the production item exist, one with positive quantity, one with negative quantity
      VerifyOutputItemLedgerEntry(Item."No.",ProductionOrder."Location Code",ProductionOrder.Quantity,-ProductionOrder.Quantity);
    END;

    [Test]
    PROCEDURE PostOutputCorrectionWithLocationBinMandatory@192();
    VAR
      Bin@1001 : Record 7354;
      Item@1002 : Record 27;
      ProductionOrder@1000 : Record 5405;
    BEGIN
      // Test to verify the production journal with negative quantity can be posted with Bin Mandatory Location for Item with routing.

      // Use a Bin-Mandatory Location
      LibraryWarehouse.FindBin(Bin,LocationRed.Code,'',1);
      CreateOutputCorrectionWithLocation(Item,ProductionOrder,LocationRed.Code,Bin.Code,TRUE);

      // Exercise and Verify: Post output journal with negative quantity and expect the post can succeed
      LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);

      // Verify: 2 Item Ledger Entries for the production item exist, one with positive quantity, one with negative quantity
      VerifyOutputItemLedgerEntry(Item."No.",ProductionOrder."Location Code",ProductionOrder.Quantity,-ProductionOrder.Quantity);
    END;

    [Test]
    PROCEDURE PostOutputCorrectionWithLocationRequirePickWithoutApplyToEntry@297();
    VAR
      Location@1007 : Record 14;
      Item@1001 : Record 27;
      ProductionOrder@1000 : Record 5405;
    BEGIN
      // Test to verify the error message pops up when posting production correction journal without setting Apply-to Entry using Location with Require Pick.

      // Create a Require-Pick Location and create output correct journal without "Applies-to Entry"
      LibraryWarehouse.CreateLocationWMS(Location,FALSE,FALSE,TRUE,FALSE,FALSE);
      CreateOutputCorrectionWithLocation(Item,ProductionOrder,Location.Code,'',FALSE);

      // Exercise and Verify: Post output journal and expect the error pops up
      ASSERTERROR LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
      Assert.ExpectedError(WHHandlingIsRequiredErr);
    END;

    [Test]
    PROCEDURE PostOutputCorrectionWithLocationRequirePickAndShipmentWithoutApplyToEntry@291();
    VAR
      Location@1007 : Record 14;
      Item@1001 : Record 27;
      ProductionOrder@1000 : Record 5405;
    BEGIN
      // Test to verify the error message pops up when posting production correction journal without setting Apply-to Entry using Location with Require Pick and Require Shipment.

      // Create a Require-Pick and Require-Shipment Location and create output correct journal without "Applies-to Entry"
      LibraryWarehouse.CreateLocationWMS(Location,FALSE,FALSE,TRUE,FALSE,TRUE);
      CreateOutputCorrectionWithLocation(Item,ProductionOrder,Location.Code,'',FALSE);

      // Exercise and Verify: Post output journal and expect the error pops up
      ASSERTERROR LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
      Assert.ExpectedError(AppliesToEntryErr);
    END;

    LOCAL PROCEDURE CreateOutputCorrectionWithLocation@195(VAR Item@1001 : Record 27;VAR ProductionOrder@1000 : Record 5405;LocationCode@1011 : Code[10];BinCode@1007 : Code[20];SetAppliesToEntry@1002 : Boolean);
    VAR
      RoutingLine@1005 : Record 99000764;
      WorkCenter@1006 : Record 99000754;
    BEGIN
      // Setup: Create Production Item
      Initialize;
      LibraryInventory.CreateItem(Item);
      CreateRoutingAndUpdateItem(Item,WorkCenter); // Set Routing No. for Item
      FindLastRoutingLine(RoutingLine,Item."Routing No."); // The Operation No. for last routing line is needed when posting output with negative quantity

      // Create and refresh release Production Order with setting Location code
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandInt(10),LocationCode,BinCode);
      CreateAndPostOutputJournalWithExplodeRouting(ProductionOrder."No.",ProductionOrder.Quantity);

      // Create output journal with negative quantity
      CreateOutputJournalWithApplyEntryAndOperationNo(
        Item."No.",-ProductionOrder.Quantity,RoutingLine."Operation No.",SetAppliesToEntry);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingHandler,ItemTrackingSummaryPageHandler)]
    PROCEDURE PostOutputCorrectionWithLocationRequirePickAndItemTracking@196();
    VAR
      Item@1003 : Record 27;
      ProductionOrder@1004 : Record 5405;
      Location@1007 : Record 14;
    BEGIN
      // Setup: Create a Require-Pick Location
      LibraryWarehouse.CreateLocationWMS(Location,FALSE,FALSE,TRUE,FALSE,FALSE);

      // Create Output Correction Journal with Location and Item Tracking.
      CreateOutputCorrectionWithLocationAndItemTracking(Item,ProductionOrder,Location.Code,TRUE);

      // Exercise and Verify: Post output journal with negative quantity and expect the post can succeed
      LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);

      // Verify: 2 Item Ledger Entries for the production item exist, one with positive quantity, one with negative quantity
      VerifyOutputItemLedgerEntry(Item."No.",ProductionOrder."Location Code",ProductionOrder.Quantity,-ProductionOrder.Quantity);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingHandler,ItemTrackingSummaryPageHandler)]
    PROCEDURE PostOutputCorrectionWithLocationRequirePickAndItemTrackingWithoutApplyToItemEntry@202();
    VAR
      Item@1003 : Record 27;
      ProductionOrder@1004 : Record 5405;
      Location@1007 : Record 14;
    BEGIN
      // Test to verify the error message pops up when posting production correction journal without setting Apply-to Item Entry using Location with Require Pick.

      // Setup: Create a Require-Pick Location
      LibraryWarehouse.CreateLocationWMS(Location,FALSE,FALSE,TRUE,FALSE,FALSE);

      // Create Output Correction Journal with Location and Item Tracking without " Apply-to Item Entry".
      CreateOutputCorrectionWithLocationAndItemTracking(Item,ProductionOrder,Location.Code,FALSE);

      // Exercise and Verify: Post output journal and verify error pops up.
      ASSERTERROR LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
      Assert.ExpectedError(WHHandlingIsRequiredErr);

      DeleteReservationEntry(Item."No.");
    END;

    [Test]
    [HandlerFunctions(ItemTrackingHandler,ItemTrackingSummaryPageHandler)]
    PROCEDURE PostOutputCorrectionWithLocationRequirePickAndShipmentAndItemTrackingWithoutApplyToItemEntry@147();
    VAR
      Item@1003 : Record 27;
      ProductionOrder@1004 : Record 5405;
      Location@1007 : Record 14;
    BEGIN
      // Test to verify the error message pops up when posting production correction journal without setting Apply-to Item Entry using Location with Require Pick and Require Shipment.

      // Setup: Create a Require-Pick and Require-Shipment Location
      LibraryWarehouse.CreateLocationWMS(Location,FALSE,FALSE,TRUE,FALSE,TRUE);

      // Create Output Correction Journal with Location and Item Tracking without " Apply-to Item Entry".
      CreateOutputCorrectionWithLocationAndItemTracking(Item,ProductionOrder,Location.Code,FALSE);

      // Exercise and Verify: Post output journal and verify error pops up.
      ASSERTERROR LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
      Assert.ExpectedError(AppliesToEntryErr);

      DeleteReservationEntry(Item."No.");
    END;

    [Test]
    [HandlerFunctions(ProductionJournalPageHandler)]
    PROCEDURE OutputQtyWithScrapInProductionJournalAfterCreateReleasedProductionOrder@118();
    VAR
      Item@1001 : Record 27;
      WorkCenter@1000 : Record 99000754;
      ProductionOrder@1002 : Record 5405;
      ItemJournalLine@1004 : Record 83;
      RoutingLine@1005 : Record 99000764;
      Quantity@1003 : Decimal;
      ScrapFactor@1012 : Decimal;
      ScrapFactor2@1008 : Decimal;
      FixedScrapQty@1013 : Decimal;
      FixedScrapQty2@1006 : Decimal;
      RndgPrecision@1011 : Decimal;
      OutputQty@1010 : Decimal;
    BEGIN
      // Test to verify Output Quantity in Production Journal is correct with setting Fixed Scrap Quantity and Scrap Factor % in Routing.

      // Setup: Create Routing with Item. Set "Scrap Factor %" and "Fixed Scrap Quantity" for Routing Lines.
      Initialize;
      LibraryInventory.CreateItem(Item);
      CreateRoutingWithScrapAndFlushingMethod(
        Item,WorkCenter."Flushing Method"::Manual,TRUE,LibraryRandom.RandDec(10,2),LibraryRandom.RandInt(5));

      // Exercise: Create Released Production Order.
      Quantity := LibraryRandom.RandInt(10);
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",Quantity,'','');

      // Calculate the ScrapFactor & FixedScrapQty manually to avoid the rounding issue.
      FindFirstRoutingLine(RoutingLine,Item."Routing No.");
      RndgPrecision := LibraryRandom.RandDec(0,5);
      ScrapFactor := 1 + RoutingLine."Scrap Factor %" / 100;
      FixedScrapQty := RoutingLine."Fixed Scrap Quantity";
      RoutingLine.NEXT;
      ScrapFactor2 := ROUND(ScrapFactor * (1 + RoutingLine."Scrap Factor %" / 100),RndgPrecision);
      FixedScrapQty2 := ROUND(RoutingLine."Fixed Scrap Quantity" * ScrapFactor + FixedScrapQty,RndgPrecision);
      OutputQty := ROUND(Quantity * ScrapFactor2 + FixedScrapQty2,RndgPrecision);

      // Verify: Open Production Journal for the Released Production Order.
      // Verify the Output Quantity on Production Journal through ProductionJournalPageHandler.
      OpenProductionJournalPage(ProductionOrder,Item."No.",Item."No.",OutputQty,ItemJournalLine."Entry Type"::Output);
    END;

    [Test]
    PROCEDURE ActualCapacityCostOnReleasedProductionOrderStatisticsPage@259();
    VAR
      Item@1001 : Record 27;
      ProductionOrder@1000 : Record 5405;
      WorkCenter@1002 : Record 99000754;
      ProductionOrderStatistics@1003 : TestPage 99000816;
      RunTime@1004 : Decimal;
      UnitCost@1005 : Decimal;
    BEGIN
      // Test to verify Capacity Cost should be recognized in Production order Statistics as Actual Cost when posting output journal with Output Quantity = 0.
      Initialize;

      // Setup: Create and refresh release Production Order with setting blank Location code
      LibraryInventory.CreateItem(Item);
      CreateRoutingAndUpdateItem(Item,WorkCenter); // Set Routing No. for Item
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandInt(10),'','');

      // Create and Post Output Journal with Output Quantity = 0
      RunTime := LibraryRandom.RandDec(10,2);
      UnitCost := LibraryRandom.RandDec(10,2);
      CreateAndPostOutputJournalWithRunTimeAndUnitCost(ProductionOrder."No.",0,RunTime,UnitCost);

      // Exercise: Open Release Production Order Statistics Page
      OpenReleasedProductionOrderStatisticsPage(ProductionOrderStatistics,ProductionOrder."No.");

      // Verify: Capacity Cost and Total Cost for Actual Cost column is correct on Release Production Order Statistics Page
      ProductionOrderStatistics.CapacityCost_ActualCost.ASSERTEQUALS(RunTime * UnitCost);
      ProductionOrderStatistics.TotalCost_ActualCost.ASSERTEQUALS(RunTime * UnitCost);
    END;

    [Test]
    [HandlerFunctions(PostProductionJournalHandler,ConfirmHandlerTRUE)]
    PROCEDURE PostProductionJournalWithItemFlushingPickAndBackward@157();
    VAR
      Item@1000 : Record 27;
      ChildItem@1002 : Record 27;
      Bin@1003 : Record 7354;
      ProductionOrder@1004 : Record 5405;
      WarehouseActivityLine@1006 : Record 5767;
      ProdOrderLine@1007 : Record 5406;
      Quantity@1001 : Decimal;
    BEGIN
      // Test to verify an error pops up when posting the Production Journal with Qty. Picked (Base) is zero
      // in Prod. Order Component with Item Flushing Method is Pick + Backward.

      // Setup: Create Item with BOM and Routing. Update Inventory with Item Journal.
      Initialize;
      CreateItemWithBOMAndRouting(Item,ChildItem,LibraryRandom.RandInt(5));
      UpdateLocationAndBins(LocationSilver);
      LibraryWarehouse.FindBin(Bin,LocationSilver.Code,'',1); // Find Bin of Index 1.
      Quantity := LibraryRandom.RandInt(10);
      CreateAndPostItemJournalLine(ChildItem."No.",LibraryRandom.RandIntInRange(50,100),LocationSilver.Code,Bin.Code); // Large Component Quantity is required.

      // Create and refresh 1st Released Production Order. Create and register the Whse. Pick created from Released Production Order.
      CreateAndRefreshReleasedProductionOrder(
        ProductionOrder,Item."No.",Quantity,LocationSilver.Code,'');
      LibraryWarehouse.CreateWhsePickFromProduction(ProductionOrder);
      RegisterWarehouseActivity(ProductionOrder."No.",WarehouseActivityLine."Activity Type"::Pick);

      // Create 2nd Released Production Order.
      CreateAndRefreshReleasedProductionOrder(
        ProductionOrder,Item."No.",Quantity,LocationSilver.Code,LocationSilver."To-Production Bin Code");
      FindReleasedProdOrderLine(ProdOrderLine,Item."No.");

      // Exercise: Open Production Journal, then post it by PostProductionJournalHandler.
      ASSERTERROR LibraryManufacturing.OpenProductionJournal(ProductionOrder,ProdOrderLine."Line No.");

      // Verify: Verify an error pops up when posting Production Journal with Qty. Picked (Base) is zero in Prod. Order Component.
      Assert.ExpectedError(QtyPickedBaseErr);
    END;

    [Test]
    PROCEDURE CarryOutProductionOrderByPlanningWorksheet@162();
    VAR
      Item@1000 : Record 27;
      SalesHeader@1001 : Record 36;
    BEGIN
      // Test to verify Bin Code is correct in production order line after carry out the planning line with Warehouse LocationWhite.
      // Bin Code should be From-Production Bin Code of LocationWhite.

      // Setup: Create Item. Create Sales Order and update Location on Sales Line.
      Initialize;
      CreateItem(Item);
      UpdateItemParametersForPlanning(Item,Item."Replenishment System"::"Prod. Order",Item."Reordering Policy"::"Lot-for-Lot");
      CreateSalesOrder(SalesHeader,Item."No.",LibraryRandom.RandInt(50),FALSE); // Multiple Sales Lines is FALSE.
      UpdateLocationOnSalesLine(SalesHeader."No.",LocationWhite.Code);

      // Calculate Regenerative Plan on WORKDATE.
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item,WORKDATE,WORKDATE);

      // Exercise: Accept and Carry Out Action Message.
      AcceptAndCarryOutActionMessageForPlanningWorksheet(Item."No.");

      // Verify: Verify Bin Code in Production Order Line.
      VerifyBinCodeInProductionOrderLine(Item."No.",LocationWhite."From-Production Bin Code");
    END;

    [Test]
    [HandlerFunctions(PostProductionJournalHandler,ConfirmHandlerTRUE,MessageHandler)]
    PROCEDURE PostProductionJournalAfterChangingUOMOnProdOrdLine@178();
    VAR
      ItemUnitOfMeasure@1002 : Record 5404;
      ProductionOrder@1000 : Record 5405;
      ProdOrderLine@1004 : Record 5406;
      WarehouseEntry@1007 : Record 7312;
      ItemNo@1005 : Code[20];
    BEGIN
      // Test to verify the Quantity in Warehouse Entry is based on the UOM with Posting after changing UOM on Production Order Line.

      // Setup: Create Item with Routing. Create Item UOM. Create and refresh Release Production Order.
      Initialize;
      ItemNo := CreateItemWithRouting;
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,ItemNo,LibraryRandom.RandInt(10));
      CreateAndRefreshReleasedProductionOrder(
        ProductionOrder,ItemNo,LibraryRandom.RandInt(20),
        LocationWhite.Code,LocationWhite."To-Production Bin Code");

      // Change UOM on Production Order Line.
      FindReleasedProdOrderLine(ProdOrderLine,ItemNo);
      UpdateProdOrderLineUnitOfMeasureCode(ProdOrderLine,ItemNo,ItemUnitOfMeasure.Code);

      // Exercise: Open Production Journal and post by handler PostProductionJournalHandler.
      LibraryManufacturing.OpenProductionJournal(ProductionOrder,ProdOrderLine."Line No.");

      // Verify: Verify Quantity on Warehouse Entry is correct.
      VerifyWarehouseEntry(
        WarehouseEntry."Entry Type"::"Positive Adjmt.",ProductionOrder."No.",ItemNo,
        LocationWhite."To-Production Bin Code",LocationWhite.Code,ProdOrderLine.Quantity);
    END;

    [Test]
    [HandlerFunctions(PostProductionJournalHandler,ConfirmHandlerTRUE,MessageHandler)]
    PROCEDURE PostProductionJournalWithDifferentUOMForConsumption@181();
    VAR
      Item@1001 : Record 27;
      ChildItem@1003 : Record 27;
      ItemUnitOfMeasure@1002 : Record 5404;
      ProductionOrder@1000 : Record 5405;
      ProdOrderLine@1004 : Record 5406;
      WarehouseEntry@1007 : Record 7312;
      WarehouseActivityLine@1006 : Record 5767;
      QuantityPer@1005 : Decimal;
    BEGIN
      // Test to verify the Quantity of ChildItem with consumed in Warehouse Entry is based on the UOM of Prod. BOM Line.

      // Setup: Create Item with BOM and Routing. Create ChildItem UOM. Update UOM of Prod. BOM line.
      // Create and refresh Released Production Order.
      Initialize;
      QuantityPer := LibraryRandom.RandIntInRange(2,5); // It must be greater than 1.
      CreateItemWithBOMAndRouting(Item,ChildItem,QuantityPer);
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,ChildItem."No.",QuantityPer);
      UpdateBOMHeaderWithLineUOM(Item."Production BOM No.",ChildItem."No.",ItemUnitOfMeasure.Code);
      UpdateInventoryWithWhseItemJournal(ChildItem,LocationWhite,LibraryRandom.RandInt(10) + 1000);

      CreateAndRefreshReleasedProductionOrder(
        ProductionOrder,Item."No.",LibraryRandom.RandInt(10),
        LocationWhite.Code,LocationWhite."To-Production Bin Code");

      // Create and register Pick from Released Production Order.
      LibraryWarehouse.CreateWhsePickFromProduction(ProductionOrder);
      RegisterWarehouseActivity(ProductionOrder."No.",WarehouseActivityLine."Activity Type"::Pick);

      // Exercise: Open Production Journal and post by PostProductionJournalHandler.
      FindReleasedProdOrderLine(ProdOrderLine,Item."No.");
      LibraryManufacturing.OpenProductionJournal(ProductionOrder,ProdOrderLine."Line No.");

      // Verify: Verify Quantity of ChildItem consumed on Warehouse Entry is correct.
      VerifyWarehouseEntry(
        WarehouseEntry."Entry Type"::"Negative Adjmt.",ProductionOrder."No.",ChildItem."No.",
        LocationWhite."To-Production Bin Code",LocationWhite.Code,-(ProdOrderLine.Quantity * QuantityPer));
    END;

    [Test]
    [HandlerFunctions(ItemTrackingHandlerWithoutApplyToItemEntry,ItemTrackingSummaryPageHandler,PostProductionJournalHandlerWithUpdateQuantity,ConfirmHandlerTRUE,MessageHandler)]
    PROCEDURE FinishProdOrderWhenBackFlushingConsumptionAndManualOutputWithError@296();
    VAR
      Verification@1000 : 'VerifyErr,VerifyItemLedgerEntry';
    BEGIN
      // [FEATURE] [Production]
      // [SCENARIO] Verify Error message is correct when Finish Production Order for Back Flushing Consumption and Manual Flushing Output with Scrap.

      FinishProdOrderWhenBackFlushingConsumptionAndManualFlushingOutputWithScrap(Verification::VerifyErr);
    END;

    [Test]
    [HandlerFunctions(ItemTrackingHandlerWithoutApplyToItemEntry,ItemTrackingSummaryPageHandler,PostProductionJournalHandlerWithUpdateQuantity,ConfirmHandlerTRUE,MessageHandler)]
    PROCEDURE FinishProdOrderWhenBackFlushingConsumptionAndManualOutputWithUpdateTracking@200();
    VAR
      Verification@1000 : 'VerifyErr,VerifyItemLedgerEntry';
    BEGIN
      // [FEATURE] [Production]
      // [SCENARIO] Verify Production Order can be Finished when updating Tracking for Back Flushing Consumption and Manual Flushing Output with Scrap.

      FinishProdOrderWhenBackFlushingConsumptionAndManualFlushingOutputWithScrap(Verification::VerifyItemLedgerEntry);
    END;

    [Test]
    [HandlerFunctions(ItemAvailabilityByBOMPageHandler)]
    PROCEDURE ItemAvailByBOMLevelWithMultipleUOM@130();
    VAR
      Item@1001 : Record 27;
      ChildItem@1003 : Record 27;
      TopItem@1006 : Record 27;
      QuantityPer@1005 : Decimal;
      QuantityPer2@1010 : Decimal;
      QtyPerUnitOfMeasure@1000 : Decimal;
      QtyPerUnitOfMeasure2@1009 : Decimal;
      AvailableQty@1004 : Decimal;
      AvailableQty2@1008 : Decimal;
      ChildItemAbleToMakeParentQty@1002 : Decimal;
      ChildItemAbleToMakeTopItemQty@1007 : Decimal;
    BEGIN
      // Setup: Create Production BOM, Parent Item and attach Production BOM. Create Child Item UOM. Update UOM of Prod. BOM line.
      // Create and post Item Journal Line for Child Item.
      Initialize;
      CreateItem(ChildItem);
      InitSetupForProdBOMWithMultipleUOM(Item,ChildItem,QuantityPer,QtyPerUnitOfMeasure,AvailableQty);
      InitSetupForProdBOMWithMultipleUOM(TopItem,Item,QuantityPer2,QtyPerUnitOfMeasure2,AvailableQty2);

      // Item is a BOM Item, so "Able to Make Parent" = (AvailQty + "Able to Make Parent") / "Qty. per Parent".
      // "Able to Make Top Item" = AvailQty / "Qty. per Top Item" + "Able to Make Top Item".
      // ChildItem is a Leaf Item, so "Able to Make Parent" := AvailQty / "Qty. per Parent", "Able to Make Top Item" := AvailQty / "Qty. per Top Item".
      ChildItemAbleToMakeParentQty := AvailableQty / (QuantityPer * QtyPerUnitOfMeasure);
      ChildItemAbleToMakeTopItemQty := AvailableQty / (QuantityPer * QtyPerUnitOfMeasure) / (QuantityPer2 * QtyPerUnitOfMeasure2);
      EnqueueVariablesForItemAvailByBOMPage(
        Item."No.",(AvailableQty2 + ChildItemAbleToMakeParentQty) / (QuantityPer2 * QtyPerUnitOfMeasure2),
        AvailableQty2 / (QuantityPer2 * QtyPerUnitOfMeasure2) + ChildItemAbleToMakeTopItemQty);
      EnqueueVariablesForItemAvailByBOMPage(ChildItem."No.",ChildItemAbleToMakeParentQty,ChildItemAbleToMakeTopItemQty);

      // Exercise & Verify: Run Item Availablity By BOM Level Page.
      // Verify Able to Make Parent and Able to Make Top Item of Item and ChildItem through ItemAvailabilityByBOMPageHandler.
      RunItemAvailByBOMLevelPage(TopItem);
    END;

    [Test]
    PROCEDURE WhseRequestExistsWhenAddingNewCompWithZeroQty@171();
    VAR
      Location@1006 : Record 14;
      ProductionOrder@1002 : Record 5405;
      ProdOrderComponent@1011 : Record 5407;
      NewProdOrderComponent@1013 : Record 5407;
      Item@1008 : Record 27;
      ChildItem@1007 : Record 27;
      WhseProdRelease@1012 : Codeunit 5774;
    BEGIN
      // [FEATURE] [Warehouse] [Manufacturing] [Warehouse Request]
      // [SCENARIO 109052.1] Verify 'Warehouse Request' exists when adding new component with zero Qty

      Initialize;
      LibraryWarehouse.CreateLocationWMS(Location,FALSE,FALSE,TRUE,FALSE,FALSE);  // Require Pick

      // [GIVEN] Create Released Production Order "PO"
      CreateItemsSetup(Item,ChildItem,10 + LibraryRandom.RandInt(10));
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",10 + LibraryRandom.RandInt(10),Location.Code,'');

      // [GIVEN] Create new Prod. Order Component "C"
      CreateAndInitNewProdOrderComponent(NewProdOrderComponent,ProdOrderComponent,ProductionOrder);

      // [WHEN] Insert new "C" to "PO" line with zero Quantity
      WhseProdRelease.ReleaseLine(NewProdOrderComponent,ProdOrderComponent); // simulate (Rec,xRec) 'Prod. Order Component'.INSERT trigger

      // [THEN] Warehouse Request exists for "PO"
      VerifyWhseRequestExist(ProductionOrder."No.",Location.Code);
    END;

    [Test]
    PROCEDURE WhsePickRequestExistsWhenAddingNewCompAfterFullyConsumpedComp@180();
    VAR
      Location@1006 : Record 14;
      WarehouseEmployee@1004 : Record 7301;
      ProductionOrder@1002 : Record 5405;
      ProdOrderComponent@1011 : Record 5407;
      NewProdOrderComponent@1013 : Record 5407;
      Item@1008 : Record 27;
      ChildItem@1007 : Record 27;
      WhseProdRelease@1012 : Codeunit 5774;
      Quantity@1001 : Decimal;
      QuantityPer@1000 : Decimal;
    BEGIN
      // [FEATURE] [Warehouse] [Manufacturing] [Warehouse Request]
      // [SCENARIO 109052.2] Verify 'Whse. Pick Request' exists when adding new component after fully consumed previous component

      Initialize;
      LibraryWarehouse.CreateLocationWMS(Location,FALSE,FALSE,TRUE,FALSE,TRUE);  // Require Pick, Shipment
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,Location.Code,FALSE);

      // [GIVEN] Create production item, fill inventory with consumption item "CI"
      Quantity := 10 + LibraryRandom.RandInt(10);
      QuantityPer := 10 + LibraryRandom.RandInt(10);
      CreateItemsSetup(Item,ChildItem,QuantityPer);
      CreateAndPostItemJournalLine(ChildItem."No.",Quantity * QuantityPer * 2,Location.Code,'');

      // [GIVEN] Create Released Production Order "PO", make Whse. Pick, register Pick and Post Consumption Journal
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",Quantity,Location.Code,'');
      LibraryWarehouse.CreateWhsePickFromProduction(ProductionOrder);
      FindAndRegisterWhseActivity(Location.Code,ProductionOrder."No.");
      CalculateAndPostConsumptionJournal(ProductionOrder."No.");

      // [GIVEN] Create new Prod. Order Component "C"
      CreateAndInitNewProdOrderComponent(NewProdOrderComponent,ProdOrderComponent,ProductionOrder);

      // [WHEN] Insert "C" after "CI"
      WhseProdRelease.ReleaseLine(NewProdOrderComponent,ProdOrderComponent); // simulate (Rec,xRec) 'Prod. Order Component'.INSERT trigger

      // [THEN] Whse. Pick Request exists for "PO"
      VerifyWhsePickRequestExist(ProductionOrder."No.",Location.Code);
    END;

    [Test]
    PROCEDURE CannotPostOutputJournalWithChangedOrderLineNo@183();
    VAR
      Item@1001 : Record 27;
      Item2@1000 : Record 27;
      ProductionOrder@1003 : Record 5405;
      NewProdOrderLine@1009 : Record 5406;
      ItemJournalLine@1002 : Record 83;
    BEGIN
      // [FEATURE] [Production] [Manufacturing] [Output Journal]
      // [SCENARIO 109053] Posting of Output Journal is not allowed with ItemNo different from Order Line's Item

      Initialize;
      CreateItem(Item);
      CreateItem(Item2);

      // [GIVEN] Create and Refresh Released Production Order "RPO" for Item "X1"
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandInt(100),'','');

      // [GIVEN] Manually add new Prod. Order Line with new Item "X2"
      CreateAddProdOrderLine(NewProdOrderLine,ProductionOrder,Item2."No.");

      // [GIVEN] Open Output Journal and add a line for "RPO" SourceNo Item "X1"
      CreateOutputJournal(ItemJournalLine,ProductionOrder."No.",Item."No.");
      LibraryInventory.OutputJnlExplRoute(ItemJournalLine);
      SelectItemJournalLine(ItemJournalLine,OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);

      // [GIVEN] Modify Output Journal's "Order Line No." to the line with item "X2"
      ItemJournalLine.VALIDATE("Order Line No.",NewProdOrderLine."Line No.");
      ItemJournalLine.MODIFY(TRUE);

      // [WHEN] Post the Output Journal
      ASSERTERROR LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);

      // [THEN] Error occurs: 'Item No. must be equal to "X2" in Item Journal Line... '
      Assert.ExpectedError(
        STRSUBSTNO(OutputJournalItemNoErr,ItemJournalLine.FIELDCAPTION("Item No."),Item2."No.",ItemJournalLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE CheckProdOrderLineGetsBinCodeFromWorkCenterThroughPlanningRoutingLine@207();
    VAR
      RequisitionLine@1000 : Record 246;
      WorkCenter@1005 : Record 99000754;
      ItemNo@1001 : Code[20];
    BEGIN
      // [FEATURE] [Planning] [Bin] [Planning Worksheet] [Work Center]
      // [SCENARIO 360750.1] ProdOrderLine gets BinCode from Work Center through Planning Routing Line

      Initialize;

      // [GIVEN] Create Requisition Line by calculating Regenerative Plan. Update Work Center No on Planning Routing.
      CreateRequisitionLineWithPlanningRouting(RequisitionLine,WorkCenter,ItemNo);

      // [WHEN] Carry out Action Message
      LibraryPlanning.CarryOutActionMsgPlanWksh(RequisitionLine);

      // [THEN] ProdOrderLine's BinCode is same as Work Center's Bin Code
      VerifyProdOrderLineBinCode(ItemNo,WorkCenter."From-Production Bin Code");
    END;

    [Test]
    [HandlerFunctions(ItemSubstEntries_MPH)]
    PROCEDURE ItemSubstitutionALLtoALLHasNoDuplications@212();
    VAR
      TempItem@1007 : TEMPORARY Record 27;
      ProdOrderComponent@1002 : Record 5407;
      ItemNo@1005 : ARRAY [10] OF Code[20];
      ItemCount@1003 : Integer;
      i@1004 : Integer;
    BEGIN
      // [FEATURE] [Production] [Item Substitutions]
      // [SCENARIO] No duplicate items in Substitution list for ALL-to-ALL subtitution setup

      Initialize;
      ItemCount := ARRAYLEN(ItemNo);

      // [GIVEN] N Items with ALL-to-ALL substitution setup
      FOR i := 1 TO ItemCount DO
        ItemNo[i] := CreateSimpleItem;

      FOR i := 1 TO ItemCount DO
        CreateItemSubstitution(ItemNo,i);

      // [WHEN] Show Item substitution list for the first item
      ProdOrderComponent.INIT;
      ProdOrderComponent."Item No." := ItemNo[1];
      ProdOrderComponent.ShowItemSub;

      // [THEN] Number of substitutions are equal to (N - 1)
      Assert.AreEqual(ItemCount - 1,LibraryVariableStorage.Length,ItemSubstCountErr);

      // [THEN] There is no duplications within substitution list
      TempItem.INIT;
      FOR i := 1 TO ItemCount - 1 DO BEGIN
        TempItem."No." := COPYSTR(LibraryVariableStorage.DequeueText,1,MAXSTRLEN(TempItem."No."));
        Assert.IsTrue(TempItem.INSERT,ItemSubstDublicationErr);
      END;

      // [THEN] There are correct substitution Items
      FOR i := 2 TO ItemCount DO
        Assert.IsTrue(TempItem.GET(ItemNo[i]),ItemSubstItemNoErr);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE AdjustCostItemEntriesCreatesValueEntryWithSourceTypeTakenFromoItemLedgerEntryDuringSubcontracting@100();
    VAR
      Item@1000 : Record 27;
      ChildItem@1002 : Record 27;
      WorkCenter@1001 : Record 99000754;
      ProductionOrder@1004 : Record 5405;
      ValueEntry@1005 : Record 5802;
    BEGIN
      // [FEATURE] [Adjust Cost] [Subcontracting]
      // [SCENARIO 361968] Adjust Cost Item Entries creates Value Entry with "Source Type" and "Source No." taken from original VE during Subcontracting
      Initialize;

      // [GIVEN] Subcontracting Work Center
      // [GIVEN] Item with Routing
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(5));
      CreateRoutingAndUpdateItemSubc(Item,WorkCenter,TRUE);
      // [GIVEN] Released Production Order
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,
        ProductionOrder."Source Type"::Item,Item."No.",LibraryRandom.RandInt(5));
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      // [GIVEN] Subcontracting Purchase Order
      // [GIVEN] Post output/consuption. Finish Production Order
      CreateAndPostSubcontractingPurchaseOrder(WorkCenter,Item."No.");
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

      // [WHEN] Run Adjust Cost Item Entries
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // [THEN] Value Entry is created with "Source Type" and "Source No." taken from from Original VE
      VerifyValueEntrySource(ProductionOrder."No.",WorkCenter."Subcontractor No.",ValueEntry."Source Type"::Vendor);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerTRUE,PostProductionJournalHandler,MessageHandler)]
    PROCEDURE AdjustCostItemEntriesCreatesValueEntryWithSourceTypeTakenFromoItemJournalLine@260();
    VAR
      Item@1000 : Record 27;
      ChildItem@1002 : Record 27;
      WorkCenter@1001 : Record 99000754;
      ValueEntry@1006 : Record 5802;
      Quantity@1007 : Decimal;
      ProdOrderNo@1003 : Code[20];
    BEGIN
      // [FEATURE] [Adjust Cost] [Subcontracting]
      // [SCENARIO 361968] Adjust Cost Item Entries creates Value Entry with "Source Type" and "Source No." taken from original VE
      Initialize;

      // [GIVEN] Item with Routing
      Quantity := LibraryRandom.RandInt(5);
      CreateItemsSetup(Item,ChildItem,Quantity);
      CreateAndPostItemJournalLine(ChildItem."No.",Quantity,'','');
      CreateRoutingAndUpdateItem(Item,WorkCenter);
      WorkCenter.VALIDATE("Subcontractor No.",'');
      WorkCenter.MODIFY;
      // [GIVEN] Released Production Order
      // [GIVEN] Post output/consuption. Finish Production Order
      ProdOrderNo := CreateFinishedProdOrder(Item."No.",Quantity);

      // [WHEN] Run Adjust Cost Item Entries
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // [THEN] Value Entry is created with "Source Type" and "Source No." taken from from Original VE
      VerifyValueEntrySource(ProdOrderNo,Item."No.",ValueEntry."Source Type"::Item);
    END;

    [Test]
    [HandlerFunctions(ProductionJournalSubcontractedPageHandler)]
    PROCEDURE CheckProductionJournalOutQtyWithSubcontractedWorkCenter@167();
    VAR
      Item@1000 : Record 27;
      WorkCenter@1001 : Record 99000754;
      ProductionOrder@1002 : Record 5405;
      ProdOrderLine@1003 : Record 5406;
    BEGIN
      // [FEATURE] [Production Journal] [Subcontracting]
      // [SCENARIO 363578] Production Journal should fill "Output Quantity" with zero while linked to Subcontracted Work Center
      Initialize;

      // [GIVEN] Released Production Order with Subcontracting
      LibraryInventory.CreateItem(Item);
      CreateRoutingAndUpdateItemSubc(Item,WorkCenter,TRUE);
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandDec(100,2),'','');

      // [WHEN] Open Production Journal
      ProdOrderLine.SETRANGE("Item No.",Item."No.");
      ProdOrderLine.FINDFIRST;
      LibraryManufacturing.OpenProductionJournal(ProductionOrder,ProdOrderLine."Line No.");

      // [THEN] Production Journal has "Output Quantity" = 0
      // Verify throuhg ProductionJournalSubcontractedPageHandler
    END;

    [Test]
    PROCEDURE CheckSubcontractedItemJournalOutputQuantity@109();
    VAR
      ItemJournalLine@1000 : Record 83;
      WorkCenter@1001 : Record 99000754;
    BEGIN
      // [FEATURE] [Production Journal] [Subcontracting]
      // [SCENARIO 363578] Item Journal Line should keep "Output Quantity" zero while linked to Subcontracted Work Center
      Initialize;

      // [GIVEN] Item Journal Line linked to Subcontracted Workcenter
      MockSubcontractedJournalLine(ItemJournalLine);

      // [WHEN] Set "Output Quantity" to X <> 0
      ASSERTERROR ItemJournalLine.VALIDATE("Output Quantity",LibraryRandom.RandInt(5));

      // [THEN] Error is thrown: "Subcontracor No." must not be
      Assert.ExpectedError(STRSUBSTNO(SubcItemJnlErr,WorkCenter.FIELDCAPTION("Subcontractor No.")));
    END;

    [Test]
    PROCEDURE CheckSubcontractedItemJournalRunTime@227();
    VAR
      ItemJournalLine@1000 : Record 83;
      WorkCenter@1001 : Record 99000754;
    BEGIN
      // [FEATURE] [Production Journal] [Subcontracting]
      // [SCENARIO 363578] Item Journal Line should keep "Run Time" zero while linked to Subcontracted Work Center
      Initialize;

      // [GIVEN] Item Journal Line linked to Subcontracted Workcenter
      MockSubcontractedJournalLine(ItemJournalLine);

      // [WHEN] Set "Run Time" to X <> 0
      ASSERTERROR ItemJournalLine.VALIDATE("Run Time",LibraryRandom.RandInt(5));

      // [THEN] Error is thrown: "Subcontracor No." must not be
      Assert.ExpectedError(STRSUBSTNO(SubcItemJnlErr,WorkCenter.FIELDCAPTION("Subcontractor No.")));
    END;

    [Test]
    PROCEDURE CheckSubcontractedItemJournalSetupTime@244();
    VAR
      ItemJournalLine@1000 : Record 83;
      WorkCenter@1001 : Record 99000754;
    BEGIN
      // [FEATURE] [Production Journal] [Subcontracting]
      // [SCENARIO 363578] Item Journal Line should keep "Setup Time" zero while linked to Subcontracted Work Center
      Initialize;

      // [GIVEN] Item Journal Line linked to Subcontracted Workcenter
      MockSubcontractedJournalLine(ItemJournalLine);

      // [WHEN] Set "Run Time" to X <> 0
      ASSERTERROR ItemJournalLine.VALIDATE("Setup Time",LibraryRandom.RandInt(5));

      // [THEN] Error is thrown: "Subcontracor No." must not be
      Assert.ExpectedError(STRSUBSTNO(SubcItemJnlErr,WorkCenter.FIELDCAPTION("Subcontractor No.")));
    END;

    [Test]
    PROCEDURE ConsumptionJournalForZeroExpectedQuantity@666();
    VAR
      ProdOrderComponent@1004 : Record 5407;
    BEGIN
      // [SCENARIO 378650] Post Consumption Journal Job for Component with Zero Expected Quantity should set Remaining Quantity for this Component to zero.
      Initialize;

      // [GIVEN] Released Production Order.
      // [GIVEN] Prod. Order Component with "Quantity Per" = 0.
      CreateProdOrderAddNewComponentAndCreateConsumptionLine(ProdOrderComponent,0);

      // [WHEN] Post Consumption Journal Line for this Component.
      LibraryInventory.PostItemJournalLine(ConsumptionItemJournalTemplate.Name,ConsumptionItemJournalBatch.Name);

      // [THEN] The Component has "Remaining Qty. (Base)" = 0.
      ProdOrderComponent.FIND;
      ProdOrderComponent.TESTFIELD("Remaining Qty. (Base)",0);
    END;

    [Test]
    PROCEDURE ValidateProdOrderLineExpectedQuantity@168();
    VAR
      ProdOrderComponent@1004 : Record 5407;
    BEGIN
      // [FEATURE] [Prod. Order Component] [UT]
      // [SCENARIO 379075] Remaining Quantity should be 0 if Expected Qty. is validated to 0, regardless of posted consumption quantity.
      Initialize;

      // [GIVEN] Item Ledger Entry with Entry Type = Consumption and Quantity <> 0.
      // [GIVEN] Prod. Order Component.
      MockProdOrderComponent(ProdOrderComponent);
      MockItemLedgerEntryForConsumption(ProdOrderComponent);

      // [WHEN] Revalidate "Expected Quantity" of this Component to 0.
      ProdOrderComponent.VALIDATE("Expected Quantity",0);

      // [THEN] The Component has "Remaining Quantity" = 0.
      ProdOrderComponent.TESTFIELD("Remaining Quantity",0);
    END;

    [Test]
    PROCEDURE PlannedProdOrderRoutingGetsToProdBinFromWorkCenter@241();
    VAR
      RequisitionLine@1000 : Record 246;
      WorkCenter@1006 : Record 99000754;
      ProdOrderRoutingLine@1004 : Record 5409;
      ItemNo@1001 : Code[20];
    BEGIN
      // [FEATURE] [Planning Worksheet] [Work Center] [Bin]
      // [SCENARIO 379347] Prod. Order Routing Line gets "To-Production Bin Code" from Work Center with Manual Flushing Method through Planning.
      Initialize;

      // [GIVEN] Create Work Center with "Flushing Method" = Manual and "To-Production Bin Code" = "B".
      // [GIVEN] Create Requisition Line by calculating Regenerative Plan. Update Work Center on Planning Routing.
      CreateRequisitionLineWithPlanningRouting(RequisitionLine,WorkCenter,ItemNo);

      // [WHEN] Carry out Action Message.
      LibraryPlanning.CarryOutActionMsgPlanWksh(RequisitionLine);

      // [THEN] "To-Production Bin Code" in Prod. Order Routing Line is equal to "B".
      FindProdOrderRoutingLine(ProdOrderRoutingLine,ItemNo);
      Assert.AreEqual(
        WorkCenter."To-Production Bin Code",ProdOrderRoutingLine."To-Production Bin Code",
        STRSUBSTNO(RtngLineBinCodeErr,ProdOrderRoutingLine.FIELDCAPTION("To-Production Bin Code"),ProdOrderRoutingLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE PlannedProdOrderRoutingGetsOpenShopFloorBinFromWorkCenter@261();
    VAR
      RequisitionLine@1000 : Record 246;
      WorkCenter@1006 : Record 99000754;
      ProdOrderRoutingLine@1004 : Record 5409;
      ItemNo@1001 : Code[20];
    BEGIN
      // [FEATURE] [Planning Worksheet] [Work Center] [Bin]
      // [SCENARIO 379347] Prod. Order Routing Line gets "Open Shop Floor Bin Code" from Work Center with non-Manual Flushing Method through Planning.
      Initialize;

      // [GIVEN] Create Work Center with "Flushing Method" <> Manual and "Open Shop Floor Bin Code" = "B".
      // [GIVEN] Create Requisition Line by calculating Regenerative Plan. Update Work Center on Planning Routing.
      CreateRequisitionLineWithPlanningRouting(RequisitionLine,WorkCenter,ItemNo);
      WorkCenter.VALIDATE("Flushing Method",LibraryRandom.RandInt(2)); // forward or backward
      WorkCenter.MODIFY(TRUE);

      // [WHEN] Carry out Action Message.
      LibraryPlanning.CarryOutActionMsgPlanWksh(RequisitionLine);

      // [THEN] "Open Shop Floor Bin Code" in Prod. Order Routing Line is equal to "B".
      FindProdOrderRoutingLine(ProdOrderRoutingLine,ItemNo);
      Assert.AreEqual(
        WorkCenter."Open Shop Floor Bin Code",ProdOrderRoutingLine."Open Shop Floor Bin Code",
        STRSUBSTNO(RtngLineBinCodeErr,ProdOrderRoutingLine.FIELDCAPTION("Open Shop Floor Bin Code"),ProdOrderRoutingLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE BinCodeShouldBeFilledAfterValidatingVariantCodeinProductionOrderLine@229();
    VAR
      ChildItem@1002 : Record 27;
      Item@1003 : Record 27;
      ItemVariant@1004 : Record 5401;
      ProductionOrder@1001 : Record 5405;
      ProdOrderLine@1005 : Record 5406;
      WorkCenter@1000 : Record 99000754;
    BEGIN
      // [FEATURE] [Production] [Bin]
      // [SCENARIO 379950] Released Production Order should successfully post output on changing status to finished if variant code was changed before it in Production Order Line.
      Initialize;

      // [GIVEN] Create parent Item with routing, child Item and Production BOM.
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(5));
      CreateRoutingAndUpdateItemSubc(Item,WorkCenter,FALSE);
      LibraryInventory.CreateItemVariant(ItemVariant,Item."No.");

      // [GIVEN] Update Flushing Method On child Item to Backward.
      UpdateFlushingMethodOnItem(ChildItem,ChildItem."Flushing Method"::Backward);

      // [GIVEN] Inventory of ChildItem in white Location in Open Shop Floor Bin.
      UpdateItemInventoryForLocation(ChildItem,LocationWhite,LibraryRandom.RandDecInRange(11,100,2));

      // [GIVEN] Released Production Order with 1 line.
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,Item."No.",LibraryRandom.RandDec(10,2),LocationWhite.Code,'');
      UpdateFlushingMethodOnProdOrderRoutingLine(ProductionOrder);

      // [WHEN] Change Variant Code in Production Order Line.
      UpdateVariantCodeInProductionOrderLine(ProdOrderLine,ProductionOrder,ItemVariant.Code);

      // [THEN] Bin Code should be filled and production order should change status successfully.
      ProdOrderLine.TESTFIELD("Bin Code",LocationWhite."From-Production Bin Code");
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");
      VerifyProductionOrderIsEmpty(ProductionOrder."No.");
    END;

    LOCAL PROCEDURE Initialize@8();
    BEGIN
      LibraryVariableStorage.Clear;

      // Lazy Setup.
      IF IsInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      CreateLocationSetup;
      LibraryERMCountryData.UpdateInventoryPostingSetup;
      ItemJournalSetup;
      ConsumptionJournalSetup;
      OutputJournalSetup;

      IsInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE InitSetupForProdBOMWithMultipleUOM@156(VAR Item@1005 : Record 27;VAR ChildItem@1004 : Record 27;VAR QuantityPer@1003 : Decimal;VAR QtyPerUnitOfMeasure@1001 : Decimal;VAR AvailableQty@1000 : Decimal);
    VAR
      ItemUnitOfMeasure@1002 : Record 5404;
      ProductionBOMHeader@1007 : Record 99000771;
    BEGIN
      QuantityPer := LibraryRandom.RandIntInRange(2,5);
      QtyPerUnitOfMeasure := LibraryRandom.RandIntInRange(2,5);
      AvailableQty := LibraryRandom.RandIntInRange(50,100);

      CreateCertifiedProductionBOM(ProductionBOMHeader,ChildItem,QuantityPer);
      CreateProductionItem(Item,ProductionBOMHeader."No.");
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,ChildItem."No.",QtyPerUnitOfMeasure);
      UpdateBOMHeaderWithLineUOM(Item."Production BOM No.",ChildItem."No.",ItemUnitOfMeasure.Code);
      CreateAndPostItemJournalLine(ChildItem."No.",AvailableQty,'','');
    END;

    LOCAL PROCEDURE CreateLocationSetup@9();
    VAR
      WarehouseEmployee@1000 : Record 7301;
    BEGIN
      WarehouseEmployee.DELETEALL(TRUE);
      CreateFullWarehouseSetup(LocationWhite);  // Location: White.
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,LocationWhite.Code,TRUE);
      LibraryWarehouse.CreateLocationWMS(LocationRed,TRUE,FALSE,FALSE,FALSE,FALSE);  // Location Red.
      LibraryWarehouse.CreateLocationWMS(LocationBlue,FALSE,FALSE,FALSE,FALSE,FALSE);  // Location Blue.
      LibraryWarehouse.CreateNumberOfBins(LocationRed.Code,'','',LibraryRandom.RandInt(3) + 2,FALSE);  // Value  required for number of Bins.

      LibraryWarehouse.CreateLocationWMS(LocationSilver,TRUE,TRUE,TRUE,FALSE,FALSE);  // Location Silver.
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,LocationSilver.Code,FALSE);
      LibraryWarehouse.CreateNumberOfBins(LocationSilver.Code,'','',LibraryRandom.RandInt(3) + 2,FALSE);  // Value required for Number of Bins.
    END;

    LOCAL PROCEDURE ItemJournalSetup@13();
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      ItemJournalTemplate.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      ItemJournalTemplate.MODIFY(TRUE);

      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      ItemJournalBatch.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      ItemJournalBatch.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ConsumptionJournalSetup@40();
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ConsumptionItemJournalTemplate,ConsumptionItemJournalTemplate.Type::Consumption);
      LibraryInventory.SelectItemJournalBatchName(
        ConsumptionItemJournalBatch,ConsumptionItemJournalTemplate.Type,ConsumptionItemJournalTemplate.Name);
    END;

    LOCAL PROCEDURE OutputJournalSetup@11();
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(OutputItemJournalTemplate,OutputItemJournalTemplate.Type::Output);
      LibraryInventory.SelectItemJournalBatchName(
        OutputItemJournalBatch,OutputItemJournalTemplate.Type,OutputItemJournalTemplate.Name);
    END;

    LOCAL PROCEDURE WarehouseJournalSetup@205(LocationCode@1000 : Code[10]);
    BEGIN
      LibraryWarehouse.SelectWhseJournalTemplateName(WarehouseJournalTemplate,WarehouseJournalTemplate.Type::Item);
      WarehouseJournalTemplate.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      WarehouseJournalTemplate.MODIFY(TRUE);

      LibraryWarehouse.SelectWhseJournalBatchName(
        WarehouseJournalBatch,WarehouseJournalTemplate.Type,WarehouseJournalTemplate.Name,LocationCode);
      WarehouseJournalBatch.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      WarehouseJournalBatch.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE AcceptActionMessage@101(VAR RequisitionLine@1002 : Record 246;ItemNo@1001 : Code[20]);
    VAR
      Vendor@1500000 : Record 23;
    BEGIN
      FindRequisitionLine(RequisitionLine,ItemNo);
      RequisitionLine.VALIDATE("Accept Action Message",TRUE);
      RequisitionLine.MODIFY(TRUE);
      IF Vendor.GET(RequisitionLine."Vendor No.") THEN
        LibraryPurchase.CreateSetupForSubContracting(Vendor);
    END;

    LOCAL PROCEDURE AcceptAndCarryOutActionMessageForPlanningWorksheet@95(ItemNo@1001 : Code[20]);
    VAR
      RequisitionLine@1000 : Record 246;
    BEGIN
      AcceptActionMessage(RequisitionLine,ItemNo);
      LibraryPlanning.CarryOutActionMsgPlanWksh(RequisitionLine);
    END;

    LOCAL PROCEDURE CalculateWhseAdjustmentAndPostCreatedItemJournalLine@268(Item@1000 : Record 27;ItemJournalBatch@1001 : Record 233);
    BEGIN
      LibraryWarehouse.CalculateWhseAdjustment(Item,ItemJournalBatch);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateFullWarehouseSetup@114(VAR Location@1000 : Record 14);
    BEGIN
      LibraryWarehouse.CreateFullWMSLocation(Location,2);  // Value used for number of bin per zone.
    END;

    LOCAL PROCEDURE CreateItem@3(VAR Item@1001 : Record 27);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(100,2));
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemJournalLine@15(VAR ItemJournalLine@1003 : Record 83;ItemNo@1002 : Code[20];Quantity@1001 : Decimal;BinCode@1004 : Code[20];LocationCode@1000 : Code[10]);
    BEGIN
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Quantity);
      ItemJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(10,2));
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.VALIDATE("Bin Code",BinCode);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE MockSubcontractedJournalLine@172(VAR ItemJournalLine@1001 : Record 83);
    VAR
      WorkCenter@1000 : Record 99000754;
    BEGIN
      WITH WorkCenter DO BEGIN
        INIT;
        "No." := LibraryUtility.GenerateGUID;
        "Subcontractor No." := LibraryUtility.GenerateGUID;
        INSERT;
      END;

      WITH ItemJournalLine DO BEGIN
        INIT;
        LibraryUtility.GetNewRecNo(ItemJournalLine,FIELDNO("Line No."));
        "Entry Type" := "Entry Type"::Output;
        Type := Type::"Work Center";
        "Work Center No." := WorkCenter."No.";
        INSERT;
      END;
    END;

    LOCAL PROCEDURE CreateItemsSetup@21(VAR Item@1005 : Record 27;VAR Item2@1001 : Record 27;QuantityPer@1002 : Decimal);
    VAR
      ProductionBOMHeader@1000 : Record 99000771;
    BEGIN
      // Create Child Item.
      CreateItem(Item2);

      // Create Production BOM, Parent Item and attach Production BOM.
      CreateCertifiedProductionBOM(ProductionBOMHeader,Item2,QuantityPer);
      CreateProductionItem(Item,ProductionBOMHeader."No.");
    END;

    LOCAL PROCEDURE CreateItemWithBOMAndRouting@161(VAR Item@1000 : Record 27;VAR ChildItem@1001 : Record 27;QuantityPer@1002 : Decimal);
    VAR
      WorkCenter@1003 : Record 99000754;
    BEGIN
      CreateItemsSetup(Item,ChildItem,QuantityPer);
      UpdateFlushingMethodOnItem(ChildItem,ChildItem."Flushing Method"::"Pick + Backward");
      UpdateBOMHeader(Item."Production BOM No.",ChildItem."No.",CreateRoutingAndUpdateItem(Item,WorkCenter));
      WorkCenter.VALIDATE("Subcontractor No.",'');
      WorkCenter.MODIFY;
    END;

    LOCAL PROCEDURE CreateItemWithRouting@179() : Code[20];
    VAR
      Item@1000 : Record 27;
      WorkCenter@1001 : Record 99000754;
    BEGIN
      CreateItem(Item);
      CreateRoutingAndUpdateItem(Item,WorkCenter);
      WorkCenter.VALIDATE("Subcontractor No.",'');
      WorkCenter.MODIFY;
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateSimpleItem@243() : Code[20];
    VAR
      Item@1000 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateItemSubstitution@245(ItemNo@1000 : ARRAY [10] OF Code[20];ItemIndex@1002 : Integer);
    VAR
      ItemSubstitution@1001 : Record 5715;
      i@1003 : Integer;
    BEGIN
      WITH ItemSubstitution DO BEGIN
        INIT;
        Type := Type::Item;
        "No." := ItemNo[ItemIndex];
        "Substitute Type" := "Substitute Type"::Item;
        FOR i := 0 TO ARRAYLEN(ItemNo) - 2 DO BEGIN
          "Substitute No." := ItemNo[1 + ((ItemIndex + i) MOD ARRAYLEN(ItemNo))]; // all ItemNo except ItemIndex
          INSERT;
        END;
      END;
    END;

    LOCAL PROCEDURE CreateProdItemWithScrapAndFlushingMethod@184(VAR Item@1002 : Record 27;VAR ChildItemNo@1001 : Code[20];FlushingMethod@1000 : Option;QtyPer@1004 : Decimal;MultipleRoutingLine@1007 : Boolean;ScrapFactor@1006 : Decimal;FixedScrapQuantity@1005 : Decimal;Tracking@1008 : Boolean);
    VAR
      ChildItem@1003 : Record 27;
    BEGIN
      CreateItemsSetup(Item,ChildItem,QtyPer);
      ChildItemNo := ChildItem."No.";
      UpdateFlushingMethodOnItem(ChildItem,ChildItem."Flushing Method"::Backward);

      // Create Routing with 2 routing lines, set Scrap % and Fixed Scrap Quantity in Routing Line, set flushing method for work center bound to the routing line
      IF Tracking THEN
        UpdateItemForLotTrackingAndFlushingMethod(ChildItem,ChildItem."Flushing Method"::Backward);
      CreateRoutingWithScrapAndFlushingMethod(Item,FlushingMethod,MultipleRoutingLine,ScrapFactor,FixedScrapQuantity);
    END;

    LOCAL PROCEDURE CreateCertifiedProductionBOM@17(VAR ProductionBOMHeader@1001 : Record 99000771;Item@1002 : Record 27;QuantityPer@1003 : Decimal);
    VAR
      ProductionBOMLine@1000 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,Item."Base Unit of Measure");
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,Item."No.",QuantityPer);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateProductionItem@66(VAR Item@1000 : Record 27;ProductionBOMNo@1001 : Code[20]);
    BEGIN
      CreateItem(Item);
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::"Prod. Order");
      Item.VALIDATE("Production BOM No.",ProductionBOMNo);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndRefreshReleasedProductionOrder@68(VAR ProductionOrder@1000 : Record 5405;SourceNo@1002 : Code[20];Quantity@1003 : Decimal;LocationCode@1004 : Code[10];BinCode@1005 : Code[20]);
    BEGIN
      CreateAndRefreshProductionOrder(ProductionOrder,ProductionOrder.Status::Released,SourceNo,Quantity,LocationCode,BinCode);
    END;

    LOCAL PROCEDURE CreateAndPostItemJournalLine@28(ItemNo@1001 : Code[20];Quantity@1000 : Decimal;LocationCode@1004 : Code[10];BinCode@1003 : Code[20]);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      CreateItemJournalLine(ItemJournalLine,ItemNo,Quantity,BinCode,LocationCode);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateAndPostItemJournalLineWithTracking@201(ItemNo@1000 : Code[20];Quantity@1001 : Decimal);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      CreateItemJournalLine(ItemJournalLine,ItemNo,Quantity,'','');
      LibraryVariableStorage.Enqueue(ItemTrackingMode::AssignLotNo);
      ItemJournalLine.OpenItemTrackingLines(FALSE);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateAndPostOutputJournalWithRunTimeAndUnitCost@250(ProductionOrderNo@1001 : Code[20];OutputQuantity@1003 : Decimal;RunTime@1002 : Decimal;UnitCost@1004 : Decimal);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CreateOutputJournalWithExplodeRouting(ItemJournalLine,ProductionOrderNo);
      WITH ItemJournalLine DO BEGIN
        VALIDATE("Output Quantity",OutputQuantity);
        VALIDATE("Run Time",RunTime);
        VALIDATE("Unit Cost",UnitCost);
        MODIFY(TRUE);
      END;
      LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE AcceptAndCarryOutActionMessageForRequisitionWorksheet@99(ItemNo@1001 : Code[20]);
    VAR
      RequisitionLine@1000 : Record 246;
    BEGIN
      AcceptActionMessage(RequisitionLine,ItemNo);
      LibraryVariableStorage.Enqueue(NewWorksheetMsg);  // Required inside MessageHandler.
      LibraryPlanning.CarryOutReqWksh(RequisitionLine,WORKDATE,WORKDATE,WORKDATE,WORKDATE,'');
    END;

    LOCAL PROCEDURE AssignTrackingOnProdOrderLine@81(ProdOrderNo@1000 : Code[20]);
    VAR
      ProdOrderLine@1001 : Record 5406;
    BEGIN
      ProdOrderLine.SETRANGE("Prod. Order No.",ProdOrderNo);
      ProdOrderLine.FINDFIRST;
      ProdOrderLine.OpenItemTrackingLines;  // Invokes ItemTrackingPageHandler.
    END;

    LOCAL PROCEDURE CalculateAndPostConsumptionJournal@10(ProductionOrderNo@1000 : Code[20]);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      LibraryInventory.ClearItemJournal(ConsumptionItemJournalTemplate,ConsumptionItemJournalBatch);
      LibraryManufacturing.CalculateConsumption(
        ProductionOrderNo,ConsumptionItemJournalTemplate.Name,ConsumptionItemJournalBatch.Name);
      SelectItemJournalLine(ItemJournalLine,ConsumptionItemJournalTemplate.Name,ConsumptionItemJournalBatch.Name);
      LibraryInventory.PostItemJournalLine(ConsumptionItemJournalTemplate.Name,ConsumptionItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateAndPostOutputJournalWithExplodeRouting@31(ProductionOrderNo@1001 : Code[20];Quantity@1003 : Decimal);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CreateOutputJournalWithExplodeRouting(ItemJournalLine,ProductionOrderNo);
      ItemJournalLine.VALIDATE(Quantity,Quantity);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateOutputJournalWithExplodeRouting@50(VAR ItemJournalLine@1000 : Record 83;ProductionOrderNo@1002 : Code[20]);
    BEGIN
      CreateOutputJournal(ItemJournalLine,ProductionOrderNo,'');
      LibraryInventory.OutputJnlExplRoute(ItemJournalLine);
      SelectItemJournalLine(ItemJournalLine,OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateOutputCorrectionWithLocationAndItemTracking@199(VAR Item@1009 : Record 27;VAR ProductionOrder@1008 : Record 5405;LocationCode@1002 : Code[10];ApplyToItemEntry@1000 : Boolean);
    VAR
      RoutingLine@1005 : Record 99000764;
      WorkCenter@1006 : Record 99000754;
    BEGIN
      // Setup: Create Production Item, create a Require-Pick Location
      Initialize;
      CreateItemWithItemTrackingCode(Item);
      CreateRoutingAndUpdateItem(Item,WorkCenter); // Set Routing No. for Item
      FindLastRoutingLine(RoutingLine,Item."Routing No."); // The Operation No. for last routing line is needed when posting output with negative quantity

      // Create and refresh release Production Order with setting Location code
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandInt(10),LocationCode,'');
      CreateAndPostOutputJournalWithItemTracking(ProductionOrder."No.",ProductionOrder.Quantity);

      // Create Output Correction Journal with Location and Item Tracking.
      CreateOutputJournalWithApplyEntryAndItemTracking(
        Item."No.",-ProductionOrder.Quantity,RoutingLine."Operation No.",ApplyToItemEntry);
    END;

    LOCAL PROCEDURE CreateAndPostOutputJournalWithItemTracking@203(ProductionOrderNo@1001 : Code[20];Quantity@1003 : Decimal);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CreateOutputJournalWithExplodeRouting(ItemJournalLine,ProductionOrderNo);

      LibraryVariableStorage.Enqueue(ItemTrackingMode::AssignLotNo);  // Enqueue for ItemTrackingHandler.
      ItemJournalLine.OpenItemTrackingLines(FALSE); // Invokes ItemTrackingHandler.

      ItemJournalLine.VALIDATE(Quantity,Quantity);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateOutputJournalWithApplyEntryAndOperationNo@204(ItemNo@1001 : Code[20];OutputQuantity@1003 : Decimal;OperationNo@1004 : Code[10];SetAppliesToEntry@1005 : Boolean);
    VAR
      ItemJournalLine@1002 : Record 83;
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,ItemJournalLine."Entry Type"::Output,ItemNo);
      CreateOutputJournal(ItemJournalLine,ItemLedgerEntry."Document No.",ItemNo);
      ItemJournalLine.VALIDATE("Output Quantity",OutputQuantity);
      ItemJournalLine.VALIDATE("Operation No.",OperationNo);

      IF SetAppliesToEntry THEN
        ItemJournalLine.VALIDATE("Applies-to Entry",ItemLedgerEntry."Entry No.");
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateOutputJournalWithApplyEntryAndItemTracking@206(ItemNo@1001 : Code[20];OutputQuantity@1003 : Decimal;OperationNo@1004 : Code[10];ApplyToItemEntry@1006 : Boolean);
    VAR
      ItemJournalLine@1002 : Record 83;
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,ItemJournalLine."Entry Type"::Output,ItemNo);
      CreateOutputJournal(ItemJournalLine,ItemLedgerEntry."Document No.",ItemNo);
      ItemJournalLine.VALIDATE("Output Quantity",OutputQuantity);

      LibraryVariableStorage.Enqueue(ItemTrackingMode::SelectEntries);  // Enqueue for ItemTrackingHandler.
      LibraryVariableStorage.Enqueue(ApplyToItemEntry); // Enqueue for ItemTrackingHandler.
      LibraryVariableStorage.Enqueue(ItemLedgerEntry."Entry No.");  // Enqueue for ItemTrackingHandler.
      ItemJournalLine.OpenItemTrackingLines(FALSE); // Invokes ItemTrackingHandler.

      ItemJournalLine.VALIDATE("Operation No.",OperationNo);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesOrder@14(VAR SalesHeader@1000 : Record 36;ItemNo@1002 : Code[20];Quantity@1003 : Decimal;MultipleLines@1004 : Boolean);
    VAR
      SalesLine@1001 : Record 37;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,'');
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
      IF MultipleLines THEN
        LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
    END;

    LOCAL PROCEDURE CreateAndReleaseSalesOrderWithMultipleLines@96(VAR SalesHeader@1004 : Record 36;ItemNo@1001 : Code[20];Quantity@1002 : Decimal);
    BEGIN
      CreateSalesOrder(SalesHeader,ItemNo,Quantity,TRUE);  // Multiple Sales Lines TRUE.
      LibrarySales.ReleaseSalesDocument(SalesHeader);
    END;

    LOCAL PROCEDURE CreateAndRefreshProductionOrder@46(VAR ProductionOrder@1000 : Record 5405;Status@1001 : Option;SourceNo@1002 : Code[20];Quantity@1003 : Decimal;LocationCode@1004 : Code[10];BinCode@1005 : Code[20]);
    BEGIN
      LibraryManufacturing.CreateProductionOrder(ProductionOrder,Status,ProductionOrder."Source Type"::Item,SourceNo,Quantity);
      ProductionOrder.VALIDATE("Location Code",LocationCode);
      ProductionOrder.VALIDATE("Bin Code",BinCode);
      ProductionOrder.MODIFY(TRUE);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateRequisitionWorksheetName@110(VAR RequisitionWkshName@1001 : Record 245;Type@1002 : Option);
    VAR
      ReqWkshTemplate@1000 : Record 244;
    BEGIN
      ReqWkshTemplate.SETRANGE(Type,Type);
      ReqWkshTemplate.SETRANGE(Recurring,FALSE);
      ReqWkshTemplate.FINDFIRST;
      LibraryPlanning.CreateRequisitionWkshName(RequisitionWkshName,ReqWkshTemplate.Name);
    END;

    LOCAL PROCEDURE CreateAndPostSalesOrderAsShip@80(VAR Item@1002 : Record 27;Quantity@1003 : Decimal);
    VAR
      SalesHeader@1001 : Record 36;
    BEGIN
      CreateSalesOrder(SalesHeader,Item."No.",Quantity,FALSE);  // Multiple Sales Lines FALSE.
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);  // Post as Ship only.
    END;

    LOCAL PROCEDURE CalculatePlanForRequisitionWorksheet@69(VAR Item@1001 : Record 27);
    VAR
      RequisitionWkshName@1003 : Record 245;
    BEGIN
      CreateRequisitionWorksheetName(RequisitionWkshName,RequisitionWkshName."Template Type"::"Req.");
      LibraryPlanning.CalculatePlanForReqWksh(
        Item,RequisitionWkshName."Worksheet Template Name",RequisitionWkshName.Name,WORKDATE,WORKDATE);
    END;

    LOCAL PROCEDURE CreateMaximumQtyItem@186(VAR Item@1000 : Record 27;MaximumInventory@1001 : Decimal);
    BEGIN
      CreateItem(Item);
      UpdateItemParametersForPlanning(Item,Item."Replenishment System"::Purchase,Item."Reordering Policy"::"Maximum Qty.");
      Item.VALIDATE("Reorder Point",LibraryRandom.RandDec(10,2) + 10);  // Large Random Value required for test.
      Item.VALIDATE("Maximum Inventory",MaximumInventory);
      Item.VALIDATE("Minimum Order Quantity",LibraryRandom.RandDec(10,2));  // Minimum Order Quantity less than Reorder Point Quantity.
      Item.VALIDATE("Maximum Order Quantity",MaximumInventory + LibraryRandom.RandDec(100,2));  // Maximum Order Quantity more than Maximum Inventory.
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrderAsReceive@137(VAR PurchaseHeader@1000 : Record 38;ItemNo@1001 : Code[20];Quantity@1003 : Decimal);
    VAR
      PurchaseLine@1002 : Record 39;
    BEGIN
      CreatePurchaseOrder(PurchaseHeader,PurchaseLine,ItemNo,Quantity);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateSalesOrderFromBlanketOrder@6(VAR SalesHeader@1000 : Record 36;VAR SalesOrderHeader@1004 : Record 36;ItemNo@1002 : Code[20];Quantity@1003 : Decimal;LocationCode@1006 : Code[10]);
    VAR
      BlanketSalesOrderToOrder@1005 : Codeunit 87;
    BEGIN
      CreateBlanketOrder(SalesHeader,ItemNo,Quantity,LocationCode);
      BlanketSalesOrderToOrder.RUN(SalesHeader);
      BlanketSalesOrderToOrder.GetSalesOrderHeader(SalesOrderHeader);
    END;

    LOCAL PROCEDURE CreateBlanketOrder@51(VAR SalesHeader@1002 : Record 36;ItemNo@1001 : Code[20];Quantity@1000 : Decimal;LocationCode@1005 : Code[10]);
    VAR
      SalesLine@1003 : Record 37;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::"Blanket Order",'');
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
      SalesLine.VALIDATE("Location Code",LocationCode);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemWithItemTrackingCode@25(VAR Item@1001 : Record 27);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(100,2));
      Item.VALIDATE("Item Tracking Code",CreateItemTrackingCode);
      Item.VALIDATE("Lot Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemTrackingCode@24() : Code[10];
    VAR
      ItemTrackingCode@1000 : Record 6502;
    BEGIN
      LibraryItemTracking.CreateItemTrackingCode(ItemTrackingCode,FALSE,TRUE);
      ItemTrackingCode.VALIDATE("Lot Warehouse Tracking",TRUE);
      ItemTrackingCode.MODIFY(TRUE);
      EXIT(ItemTrackingCode.Code);
    END;

    LOCAL PROCEDURE CalculateSubcontractOrder@23(VAR WorkCenter@1000 : Record 99000754);
    BEGIN
      WorkCenter.SETRANGE("No.",WorkCenter."No.");
      LibraryManufacturing.CalculateSubcontractOrder(WorkCenter);
    END;

    LOCAL PROCEDURE CreateWorkCenter@49(VAR WorkCenter@1001 : Record 99000754;IsSubcontracted@1002 : Boolean);
    VAR
      GeneralPostingSetup@1000 : Record 252;
    BEGIN
      LibraryERM.FindGenPostingSetupWithDefVAT(GeneralPostingSetup);
      LibraryManufacturing.CreateWorkCenterWithCalendar(WorkCenter);
      IF IsSubcontracted THEN
        WorkCenter.VALIDATE("Subcontractor No.",LibraryPurchase.CreateVendorNo);
      WorkCenter.VALIDATE("Gen. Prod. Posting Group",GeneralPostingSetup."Gen. Prod. Posting Group");
      WorkCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRoutingLine@90(VAR RoutingLine@1003 : Record 99000764;RoutingHeader@1000 : Record 99000763;CenterNo@1002 : Code[20]);
    VAR
      OperationNo@1001 : Code[10];
    BEGIN
      // Random value used so that the next Operation No is greater than the previous Operation No.
      OperationNo := FindLastOperationNo(RoutingHeader."No.") + FORMAT(LibraryRandom.RandInt(5));
      LibraryManufacturing.CreateRoutingLineSetup(
        RoutingLine,RoutingHeader,CenterNo,OperationNo,LibraryRandom.RandInt(5),LibraryRandom.RandInt(5));
    END;

    LOCAL PROCEDURE CreateRoutingLineWithRoutingLink@299(VAR RoutingLine@1000 : Record 99000764;RoutingHeader@1001 : Record 99000763;WorkCenterNo@1002 : Code[20]);
    VAR
      RoutingLink@1003 : Record 99000777;
    BEGIN
      CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenterNo);
      LibraryManufacturing.CreateRoutingLink(RoutingLink);
      RoutingLine.VALIDATE("Routing Link Code",RoutingLink.Code);
      RoutingLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRoutingAndUpdateItem@87(VAR Item@1000 : Record 27;VAR WorkCenter@1003 : Record 99000754) : Code[10];
    BEGIN
      EXIT(CreateRoutingAndUpdateItemSubc(Item,WorkCenter,FALSE));
    END;

    LOCAL PROCEDURE CreateRoutingAndUpdateItemSubc@217(VAR Item@1000 : Record 27;VAR WorkCenter@1003 : Record 99000754;IsSubcontracted@1005 : Boolean) : Code[10];
    VAR
      RoutingHeader@1001 : Record 99000763;
      RoutingLine@1004 : Record 99000764;
      RoutingLink@1002 : Record 99000777;
    BEGIN
      CreateWorkCenter(WorkCenter,IsSubcontracted);
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);
      CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenter."No.");
      RoutingLink.FINDFIRST;
      RoutingLine.VALIDATE("Routing Link Code",RoutingLink.Code);
      RoutingLine.MODIFY(TRUE);

      // Certify Routing after Routing lines creation.
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);

      // Update Routing No on Item.
      Item.VALIDATE("Routing No.",RoutingHeader."No.");
      Item.MODIFY(TRUE);

      EXIT(RoutingLink.Code);
    END;

    LOCAL PROCEDURE CreatePurchaseOrder@92(VAR PurchaseHeader@1000 : Record 38;VAR PurchaseLine@1001 : Record 39;ItemNo@1002 : Code[20];Quantity@1003 : Decimal);
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity);
    END;

    LOCAL PROCEDURE CreateFamily@85(VAR Family@1005 : Record 99000773;ItemNo@1001 : Code[20];ItemNo2@1002 : Code[20];Quantity@1000 : Decimal);
    VAR
      FamilyLine@1004 : Record 99000774;
    BEGIN
      LibraryManufacturing.CreateFamily(Family);
      LibraryManufacturing.CreateFamilyLine(FamilyLine,Family."No.",ItemNo,Quantity);
      LibraryManufacturing.CreateFamilyLine(FamilyLine,Family."No.",ItemNo2,Quantity);
    END;

    LOCAL PROCEDURE CreateItemHierarchyForFamily@84(VAR ParentItem@1003 : Record 27;VAR ParentItem2@1002 : Record 27;VAR ChildItem@1001 : Record 27;VAR ChildItem2@1000 : Record 27;QuantityPer@1004 : Decimal);
    BEGIN
      CreateItemsSetup(ParentItem,ChildItem,QuantityPer);
      CreateItemsSetup(ParentItem2,ChildItem2,QuantityPer);
      CreateAndPostItemJournalLine(ChildItem."No.",LibraryRandom.RandInt(100),'','');
      CreateAndPostItemJournalLine(ChildItem2."No.",LibraryRandom.RandInt(100),'','');
    END;

    LOCAL PROCEDURE CreateAndRefreshProductionOrderWithSourceTypeFamily@91(VAR ProductionOrder@1000 : Record 5405;Status@1001 : Option;SourceNo@1002 : Code[20];Quantity@1003 : Decimal);
    BEGIN
      LibraryManufacturing.CreateProductionOrder(ProductionOrder,Status,ProductionOrder."Source Type"::Family,SourceNo,Quantity);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateRequisitionLineWithPlanningRouting@239(VAR RequisitionLine@1007 : Record 246;VAR WorkCenter@1003 : Record 99000754;VAR ItemNo@1013 : Code[20]);
    VAR
      Item@1008 : Record 27;
      PlanningRoutingLine@1015 : Record 99000830;
    BEGIN
      CreateWorkCenterWithLocationAndBin(WorkCenter);
      CreateSalesOrderWithItem(Item);
      CreateRequisitionLineWithWorkCenter(RequisitionLine,WorkCenter,Item);
      CreatePlanningRoutingLineWithWorkCenter(PlanningRoutingLine,RequisitionLine,WorkCenter);
      ItemNo := Item."No.";
    END;

    LOCAL PROCEDURE CreateRequisitionLineWithWorkCenter@236(VAR RequisitionLine@1002 : Record 246;WorkCenter@1001 : Record 99000754;Item@1000 : Record 27);
    BEGIN
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item,WORKDATE,WORKDATE);  // Calculate Regenerative Plan on WORKDATE.
      FindRequisitionLine(RequisitionLine,Item."No.");
      WITH RequisitionLine DO BEGIN
        VALIDATE("Location Code",WorkCenter."Location Code");
        VALIDATE("Accept Action Message",TRUE);
        MODIFY;
      END;
    END;

    LOCAL PROCEDURE CreateWorkCenterWithLocationAndBin@213(VAR WorkCenter@1000 : Record 99000754);
    VAR
      BinFrom@1003 : Record 7354;
      BinTo@1001 : Record 7354;
      BinOpenShopFloor@1002 : Record 7354;
    BEGIN
      LibraryWarehouse.FindBin(BinFrom,LocationRed.Code,'',1);  // Find Bin of Index 1.
      LibraryWarehouse.FindBin(BinTo,LocationRed.Code,'',2);
      LibraryWarehouse.FindBin(BinOpenShopFloor,LocationRed.Code,'',3);

      CreateWorkCenter(WorkCenter,FALSE);
      WITH WorkCenter DO BEGIN
        VALIDATE("Location Code",LocationRed.Code);
        VALIDATE("From-Production Bin Code",BinFrom.Code);
        VALIDATE("To-Production Bin Code",BinTo.Code);
        VALIDATE("Open Shop Floor Bin Code",BinOpenShopFloor.Code);
        MODIFY;
      END;
    END;

    LOCAL PROCEDURE CreateSalesOrderWithItem@219(VAR Item@1000 : Record 27);
    VAR
      SalesHeader@1001 : Record 36;
    BEGIN
      LibraryInventory.CreateItem(Item);
      WITH Item DO BEGIN
        VALIDATE("Replenishment System","Replenishment System"::"Prod. Order");
        VALIDATE("Reordering Policy","Reordering Policy"::"Lot-for-Lot");
        MODIFY;
      END;

      CreateSalesOrder(SalesHeader,Item."No.",LibraryRandom.RandInt(10),FALSE);  // Multiple Sales Lines FALSE.
    END;

    LOCAL PROCEDURE CreatePlanningRoutingLineWithWorkCenter@230(VAR PlanningRoutingLine@1000 : Record 99000830;RequisitionLine@1001 : Record 246;WorkCenter@1002 : Record 99000754);
    BEGIN
      CreatePlanningRoutingLine(PlanningRoutingLine,RequisitionLine);
      PlanningRoutingLine.VALIDATE("No.",WorkCenter."No.");
      PlanningRoutingLine.MODIFY;
    END;

    LOCAL PROCEDURE CreateMultipleItemUnitOfMeasureSetup@57(VAR Item@1000 : Record 27;VAR PurchItemUnitOfMeasure@1001 : Record 5404;VAR PutawayItemUnitOfMeasure@1002 : Record 5404);
    VAR
      QtyPerUnitOfMeasure@1004 : Integer;
    BEGIN
      QtyPerUnitOfMeasure := LibraryRandom.RandInt(10);
      LibraryInventory.CreateItemUnitOfMeasureCode(PurchItemUnitOfMeasure,Item."No.",QtyPerUnitOfMeasure);
      LibraryInventory.CreateItemUnitOfMeasureCode(PutawayItemUnitOfMeasure,Item."No.",2 * QtyPerUnitOfMeasure);
      Item.VALIDATE("Purch. Unit of Measure",PurchItemUnitOfMeasure.Code);
      Item.VALIDATE("Put-away Unit of Measure Code",PutawayItemUnitOfMeasure.Code);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndReleasePurchaseOrder@60(VAR PurchaseHeader@1001 : Record 38;ItemNo@1004 : Code[20];LocationCode@1003 : Code[10];Quantity@1002 : Decimal);
    VAR
      PurchaseLine@1000 : Record 39;
    BEGIN
      CreatePurchaseOrder(PurchaseHeader,PurchaseLine,ItemNo,Quantity);
      PurchaseLine.VALIDATE("Location Code",LocationCode);
      PurchaseLine.MODIFY(TRUE);
      LibraryPurchase.ReleasePurchaseDocument(PurchaseHeader);
    END;

    LOCAL PROCEDURE CreateWhseReceiptFromPurchaseOrder@117(VAR PurchaseHeader@1000 : Record 38;ItemNo@1001 : Code[20];LocationCode@1002 : Code[10];Quantity@1003 : Decimal);
    BEGIN
      CreateAndReleasePurchaseOrder(PurchaseHeader,ItemNo,LocationCode,Quantity);
      LibraryWarehouse.CreateWhseReceiptFromPO(PurchaseHeader);
    END;

    LOCAL PROCEDURE CreateWarehouseJournalLine@135(VAR Item@1004 : Record 27;VAR WarehouseJournalLine@1003 : Record 7311;Location@1002 : Record 14;Quantity@1001 : Decimal);
    VAR
      Bin@1000 : Record 7354;
    BEGIN
      Bin.GET(Location.Code,Location."Cross-Dock Bin Code");
      LibraryWarehouse.CreateWhseJournalLine(
        WarehouseJournalLine,WarehouseJournalBatch."Journal Template Name",WarehouseJournalBatch.Name,Location.Code,Bin."Zone Code",
        Bin.Code,WarehouseJournalLine."Entry Type"::"Positive Adjmt.",Item."No.",Quantity);
    END;

    LOCAL PROCEDURE CreateAndCertifyProdBOMWithMultipleComponent@133(VAR Item@1004 : Record 27;VAR Item2@1001 : Record 27;VAR Item3@1002 : Record 27);
    VAR
      ProductionBOMHeader@1003 : Record 99000771;
    BEGIN
      CreateItem(Item);  // Parent Item.
      // Create Component Items.
      CreateItem(Item2);
      CreateItem(Item3);
      LibraryManufacturing.CreateCertifProdBOMWithTwoComp(
        ProductionBOMHeader,Item2."No.",Item3."No.",LibraryRandom.RandInt(5));
      Item.VALIDATE("Production BOM No.",ProductionBOMHeader."No.");
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndPostOutputJournalWithApplyEntry@309(ItemNo@1001 : Code[20];OutputQuantity@1003 : Decimal);
    VAR
      ItemJournalLine@1002 : Record 83;
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,ItemJournalLine."Entry Type"::Output,ItemNo);
      CreateOutputJournal(ItemJournalLine,ItemLedgerEntry."Document No.",ItemNo);
      ItemJournalLine.VALIDATE("Output Quantity",OutputQuantity);
      ItemJournalLine.VALIDATE("Applies-to Entry",ItemLedgerEntry."Entry No.");
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateAndPostOutputJournalWithApplyEntryAndOperationNo@122(ItemNo@1001 : Code[20];OutputQuantity@1003 : Decimal;OperationNo@1004 : Code[10]);
    VAR
      ItemJournalLine@1002 : Record 83;
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,ItemJournalLine."Entry Type"::Output,ItemNo);
      CreateOutputJournal(ItemJournalLine,ItemLedgerEntry."Document No.",ItemNo);
      WITH ItemJournalLine DO BEGIN
        VALIDATE("Output Quantity",OutputQuantity);
        VALIDATE("Applies-to Entry",ItemLedgerEntry."Entry No.");
        VALIDATE("Operation No.",OperationNo);
        MODIFY(TRUE);
      END;
      LibraryInventory.PostItemJournalLine(OutputItemJournalBatch."Journal Template Name",OutputItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateOutputJournal@82(VAR ItemJournalLine@1002 : Record 83;ProductionOrderNo@1000 : Code[20];ItemNo@1001 : Code[20]);
    BEGIN
      LibraryInventory.ClearItemJournal(OutputItemJournalTemplate,OutputItemJournalBatch);
      LibraryManufacturing.CreateOutputJournal(
        ItemJournalLine,OutputItemJournalTemplate,OutputItemJournalBatch,ItemNo,ProductionOrderNo);
    END;

    LOCAL PROCEDURE CreateProdOrderItemSetupWithOutputJournalAndExplodeRouting@131(VAR Item@1000 : Record 27;VAR ChildItem@1001 : Record 27;VAR ProductionOrder@1003 : Record 5405);
    VAR
      PurchaseHeader@1002 : Record 38;
      Quantity@1004 : Decimal;
    BEGIN
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(5));
      Quantity := LibraryRandom.RandInt(10);
      UpdateFlushingMethodOnItem(ChildItem,ChildItem."Flushing Method"::Backward);
      CreateAndPostPurchaseOrderAsReceive(PurchaseHeader,ChildItem."No.",Quantity);
      CreateAndRefreshProductionOrder(ProductionOrder,ProductionOrder.Status::Released,Item."No.",Quantity,'','');
      CreateAndPostOutputJournalWithExplodeRouting(ProductionOrder."No.",ProductionOrder.Quantity);  // Create and post Output Journal for the Production Order.
    END;

    LOCAL PROCEDURE CreateProdOrderComponent@247(ProductionOrder@1003 : Record 5405;VAR NewProdOrderComponent@1001 : Record 5407;QuantityPer@1004 : Decimal);
    VAR
      Item@1000 : Record 27;
      ProdOrderComponent@1002 : Record 5407;
    BEGIN
      LibraryInventory.CreateItem(Item);
      CreateAndInitNewProdOrderComponent(NewProdOrderComponent,ProdOrderComponent,ProductionOrder);
      NewProdOrderComponent.VALIDATE("Item No.",Item."No.");
      NewProdOrderComponent.VALIDATE("Quantity per",QuantityPer);
      NewProdOrderComponent.INSERT(TRUE);
    END;

    LOCAL PROCEDURE CreatePlanningRoutingLine@249(VAR PlanningRoutingLine@1001 : Record 99000830;VAR RequisitionLine@1002 : Record 246);
    BEGIN
      WITH PlanningRoutingLine DO BEGIN
        INIT;
        VALIDATE("Worksheet Template Name",RequisitionLine."Worksheet Template Name");
        VALIDATE("Worksheet Batch Name",RequisitionLine."Journal Batch Name");
        VALIDATE("Worksheet Line No.",RequisitionLine."Line No.");
        VALIDATE("Operation No.",LibraryUtility.GenerateGUID);
        INSERT(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateCertifiedProductionBOMVersionWithCopyBOM@344(ProductionBOMNo@1002 : Code[20];UnitOfMeasureCode@1004 : Code[10]);
    VAR
      ProductionBOMVersion@1000 : Record 99000779;
      ProductionBOMHeader@1001 : Record 99000771;
      ProductionBOMCopy@1003 : Codeunit 99000768;
    BEGIN
      ProductionBOMHeader.GET(ProductionBOMNo);
      LibraryManufacturing.CreateProductionBOMVersion(
        ProductionBOMVersion,ProductionBOMNo,
        LibraryUtility.GenerateRandomCode(ProductionBOMVersion.FIELDNO("Version Code"),DATABASE::"Production BOM Version"),
        UnitOfMeasureCode);
      ProductionBOMCopy.CopyBOM(ProductionBOMNo,'',ProductionBOMHeader,ProductionBOMVersion."Version Code");
      ProductionBOMVersion.VALIDATE(Status,ProductionBOMVersion.Status::Certified);
      ProductionBOMVersion.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrderWithDirectUnitCostAsReceive@94(VAR PurchaseHeader@1000 : Record 38;ItemNo@1001 : Code[20];Quantity@1003 : Decimal);
    VAR
      PurchaseLine@1002 : Record 39;
    BEGIN
      CreatePurchaseOrder(PurchaseHeader,PurchaseLine,ItemNo,Quantity);
      PurchaseLine.VALIDATE("Direct Unit Cost",LibraryRandom.RandDec(10,2));
      PurchaseLine.MODIFY(TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateRoutingWithScrapAndFlushingMethod@123(VAR Item@1007 : Record 27;FlushingMethod@1006 : Option;MultipleRoutingLine@1005 : Boolean;ScrapFactor@1001 : Decimal;FixedScrapQuantity@1000 : Decimal);
    VAR
      WorkCenter@1004 : Record 99000754;
      RoutingHeader@1003 : Record 99000763;
      RoutingLine@1002 : Record 99000764;
    BEGIN
      CreateRoutingAndUpdateItem(Item,WorkCenter);
      WorkCenter.VALIDATE("Subcontractor No.",'');
      WorkCenter.MODIFY;
      UpdateFlushingMethodOnWorkCenter(WorkCenter,FlushingMethod); // The flushing method on work center will be copied to Prod. Order Routing Line
      RoutingHeader.GET(Item."Routing No.");
      UpdateStatusOnRoutingHeader(RoutingHeader,RoutingHeader.Status::"Under Development");

      // Set Scrap on Routing Line
      RoutingLine.SETRANGE("Routing No.",Item."Routing No.");
      RoutingLine.FINDFIRST;
      UpdateScrapOnRoutingLine(RoutingLine,ScrapFactor,FixedScrapQuantity);

      IF MultipleRoutingLine THEN BEGIN
        CreateWorkCenter(WorkCenter,FALSE);
        UpdateFlushingMethodOnWorkCenter(WorkCenter,FlushingMethod); // The flushing method on work center will be copied to Prod. Order Routing Line
        CreateRoutingLineWithRoutingLink(RoutingLine,RoutingHeader,WorkCenter."No.");
        UpdateScrapOnRoutingLine(RoutingLine,LibraryRandom.RandDec(10,2),LibraryRandom.RandInt(5));
      END;
      UpdateStatusOnRoutingHeader(RoutingHeader,RoutingHeader.Status::Certified);
    END;

    LOCAL PROCEDURE CreateAndInitNewProdOrderComponent@208(VAR NewProdOrderComponent@1001 : Record 5407;VAR LastProdOrderComponent@1002 : Record 5407;ProductionOrder@1003 : Record 5405);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      FindProdOrderLine(ProdOrderLine,ProductionOrder.Status,ProductionOrder."No.");
      FindLastProductionOrderCompLine(LastProdOrderComponent,ProdOrderLine);
      InitProdOrderComponent(NewProdOrderComponent,LastProdOrderComponent);
    END;

    LOCAL PROCEDURE CreateAddProdOrderLine@284(VAR NewProdOrderLine@1002 : Record 5406;ProductionOrder@1001 : Record 5405;ItemNo@1003 : Code[20]);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      FindProdOrderLine(ProdOrderLine,ProductionOrder.Status,ProductionOrder."No.");
      WITH NewProdOrderLine DO BEGIN
        Status := ProdOrderLine.Status;
        "Prod. Order No." := ProdOrderLine."Prod. Order No.";
        "Line No." := ProdOrderLine."Line No." + 10000;
        VALIDATE("Item No.",ItemNo);
        INSERT(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateAndPostSubcontractingPurchaseOrder@214(WorkCenter@1000 : Record 99000754;ItemNo@1002 : Code[20]);
    VAR
      RequisitionLine@1001 : Record 246;
      PurchaseLine@1003 : Record 39;
      PurchaseHeader@1004 : Record 38;
    BEGIN
      CalculateSubcontractOrder(WorkCenter);
      AcceptActionMessage(RequisitionLine,ItemNo);
      LibraryPlanning.CarryOutAMSubcontractWksh(RequisitionLine);
      FindPurchaseOrderLine(PurchaseLine,ItemNo);
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      PurchaseHeader."Vendor Invoice No." := LibraryUtility.GenerateGUID;
      PurchaseHeader.MODIFY;
      PurchaseLine."Direct Unit Cost" := LibraryRandom.RandInt(5);
      PurchaseLine.MODIFY;
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE CreateProdOrderAddNewComponentAndCreateConsumptionLine@238(VAR ProdOrderComponent@1008 : Record 5407;CompLineQtyPer@1007 : Decimal);
    VAR
      Location@1005 : Record 14;
      ProductionOrder@1004 : Record 5405;
      Item@1002 : Record 27;
      ChildItem@1001 : Record 27;
      ItemJournalLine@1000 : Record 83;
    BEGIN
      LibraryWarehouse.CreateLocation(Location);
      CreateItemsSetup(Item,ChildItem,LibraryRandom.RandInt(10));
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",LibraryRandom.RandInt(10),Location.Code,'');

      CreateProdOrderComponent(ProductionOrder,ProdOrderComponent,CompLineQtyPer);
      CreateAndPostItemJournalLine(ProdOrderComponent."Item No.",LibraryRandom.RandIntInRange(10,100),'','');

      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ConsumptionItemJournalTemplate.Name,ConsumptionItemJournalBatch.Name,ItemJournalLine."Entry Type"::Consumption,
        ProdOrderComponent."Item No.",LibraryRandom.RandInt(10));
      ItemJournalLine.VALIDATE("Order No.",ProductionOrder."No.");
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateFinishedProdOrder@165(ItemNo@1001 : Code[20];Quantity@1002 : Decimal) : Code[20];
    VAR
      ProductionOrder@1000 : Record 5405;
      ProdOrderLine@1003 : Record 5406;
    BEGIN
      WITH LibraryManufacturing DO BEGIN
        CreateProductionOrder(
          ProductionOrder,ProductionOrder.Status::Released,
          ProductionOrder."Source Type"::Item,ItemNo,Quantity);
        RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
        FindReleasedProdOrderLine(ProdOrderLine,ItemNo);
        OpenProductionJournal(ProductionOrder,ProdOrderLine."Line No.");
        ChangeStatusReleasedToFinished(ProductionOrder."No.");
        EXIT(ProductionOrder."No.");
      END;
    END;

    LOCAL PROCEDURE DeleteReservationEntry@198(ItemNo@1002 : Code[20]);
    VAR
      ReservationEntry@1000 : Record 337;
    BEGIN
      ReservationEntry.SETRANGE("Item No.",ItemNo);
      ReservationEntry.DELETEALL(TRUE);
    END;

    LOCAL PROCEDURE EnqueueVariablesForItemAvailByBOMPage@173(ChildItemNo@1010 : Code[20];AbleToMakeParentQty@1009 : Decimal;AbleToMakeTopItemQty@1008 : Decimal);
    BEGIN
      LibraryVariableStorage.Enqueue(ChildItemNo);
      LibraryVariableStorage.Enqueue(AbleToMakeParentQty);
      LibraryVariableStorage.Enqueue(AbleToMakeTopItemQty);
    END;

    LOCAL PROCEDURE UpdateComponentsInventory@176(ItemNo@1000 : Code[20];ItemNo2@1001 : Code[20];LocationCode@1003 : Code[10];BinCode@1004 : Code[20];Quantity@1002 : Decimal);
    BEGIN
      CreateAndPostItemJournalLine(ItemNo,Quantity,LocationCode,BinCode);
      CreateAndPostItemJournalLine(ItemNo2,Quantity,LocationCode,BinCode);
    END;

    LOCAL PROCEDURE OpenProductionJournalPage@151(VAR ProductionOrder@1000 : Record 5405;ItemNo@1001 : Code[20];ItemNo2@1002 : Code[20];Quantity@1003 : Decimal;EntryType@1004 : Option);
    VAR
      ProdOrderLine@1005 : Record 5406;
    BEGIN
      // Enqueue values for use in ProductionJournalPageHandler.
      LibraryVariableStorage.Enqueue(ItemNo);
      LibraryVariableStorage.Enqueue(Quantity);
      LibraryVariableStorage.Enqueue(EntryType);
      FindReleasedProdOrderLine(ProdOrderLine,ItemNo2);
      LibraryManufacturing.OpenProductionJournal(ProductionOrder,ProdOrderLine."Line No.");
    END;

    LOCAL PROCEDURE FindItemLedgerEntry@41(VAR ItemLedgerEntry@1000 : Record 32;EntryType@1002 : Option;ItemNo@1001 : Code[20]);
    BEGIN
      ItemLedgerEntry.SETRANGE("Entry Type",EntryType);
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindRequisitionLine@189(VAR RequisitionLine@1001 : Record 246;No@1000 : Code[20]);
    BEGIN
      RequisitionLine.SETRANGE(Type,RequisitionLine.Type::Item);
      RequisitionLine.SETRANGE("No.",No);
      RequisitionLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindFirmPlannedProdOrderLine@124(VAR ProdOrderLine@1001 : Record 5406;ItemNo@1000 : Code[20]);
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProdOrderLine.Status::"Firm Planned");
      ProdOrderLine.SETRANGE("Item No.",ItemNo);
      ProdOrderLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindProdOrderLine@211(VAR ProdOrderLine@1000 : Record 5406;ProdOrderStatus@1001 : Option;ProdOrderNo@1002 : Code[20]);
    BEGIN
      WITH ProdOrderLine DO BEGIN
        SETRANGE(Status,ProdOrderStatus);
        SETRANGE("Prod. Order No.",ProdOrderNo);
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE FindLastOperationNo@455(RoutingNo@1000 : Code[20]) : Code[10];
    VAR
      RoutingLine@1001 : Record 99000764;
    BEGIN
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      IF RoutingLine.FINDLAST THEN
        EXIT(RoutingLine."Operation No.");
    END;

    LOCAL PROCEDURE FindPurchaseOrderLine@144(VAR PurchaseLine@1001 : Record 39;No@1000 : Code[20]);
    BEGIN
      PurchaseLine.SETRANGE("Document Type",PurchaseLine."Document Type"::Order);
      PurchaseLine.SETRANGE(Type,PurchaseLine.Type::Item);
      PurchaseLine.SETRANGE("No.",No);
      PurchaseLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindWarehouseReceiptNo@62(VAR WarehouseReceiptLine@1000 : Record 7317;SourceDocument@1002 : Option;SourceNo@1003 : Code[20]);
    BEGIN
      WarehouseReceiptLine.SETRANGE("Source Document",SourceDocument);
      WarehouseReceiptLine.SETRANGE("Source No.",SourceNo);
      WarehouseReceiptLine.FINDFIRST;
    END;

    LOCAL PROCEDURE PostPurchaseOrderAsShip@113(ItemNo@1001 : Code[20]);
    VAR
      PurchaseHeader@1002 : Record 38;
      PurchaseLine@1000 : Record 39;
    BEGIN
      FindPurchaseOrderLine(PurchaseLine,ItemNo);
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);  // Post as Ship only.
    END;

    LOCAL PROCEDURE FindProductionOrderRoutingLine@97(VAR ProdOrderRoutingLine@1000 : Record 5409;ProductionOrderNo@1001 : Code[20]);
    BEGIN
      ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderRoutingLine.SETRANGE(Status,ProdOrderRoutingLine.Status::Released);
      ProdOrderRoutingLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindLastProductionOrderCompLine@221(VAR ProdOrderComponent@1002 : Record 5407;ProdOrderLine@1001 : Record 5406);
    BEGIN
      WITH ProdOrderComponent DO BEGIN
        SETRANGE(Status,ProdOrderLine.Status);
        SETRANGE("Prod. Order No.",ProdOrderLine."Prod. Order No.");
        SETRANGE("Line No.",ProdOrderLine."Line No.");
        FINDLAST;
      END;
    END;

    LOCAL PROCEDURE FindReleasedProdOrderLine@218(VAR ProdOrderLine@1001 : Record 5406;ItemNo@1000 : Code[20]);
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProdOrderLine.Status::Released);
      ProdOrderLine.SETRANGE("Item No.",ItemNo);
      ProdOrderLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindWhseActivityLine@74(VAR WarehouseActivityLine@1001 : Record 5767;ActivityType@1000 : Option;LocationCode@1002 : Code[10];SourceNo@1003 : Code[20];ActionType@1004 : Option);
    BEGIN
      FindWarehouseActivityNo(WarehouseActivityLine,SourceNo,ActivityType);
      WarehouseActivityLine.SETRANGE("Location Code",LocationCode);
      WarehouseActivityLine.SETRANGE("Action Type",ActionType);
      WarehouseActivityLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindWarehouseActivityNo@73(VAR WarehouseActivityLine@1000 : Record 5767;SourceNo@1002 : Code[20];ActivityType@1003 : Option);
    BEGIN
      WarehouseActivityLine.SETRANGE("Source No.",SourceNo);
      WarehouseActivityLine.SETRANGE("Activity Type",ActivityType);
      WarehouseActivityLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindRegisteredWhseActivityLine@77(VAR RegisteredWhseActivityLine@1001 : Record 5773;SourceNo@1002 : Code[20];ActionType@1004 : Option;ActivityType@1000 : Option);
    BEGIN
      RegisteredWhseActivityLine.SETRANGE("Source No.",SourceNo);
      RegisteredWhseActivityLine.SETRANGE("Activity Type",ActivityType);
      RegisteredWhseActivityLine.SETRANGE("Action Type",ActionType);
      RegisteredWhseActivityLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindWarehouseActivityHeader@136(VAR WarehouseActivityHeader@1001 : Record 5766;SourceNo@1002 : Code[20];ActionType@1004 : Option;LocationCode@1005 : Code[10]);
    VAR
      WarehouseActivityLine@1000 : Record 5767;
    BEGIN
      FindWhseActivityLine(WarehouseActivityLine,WarehouseActivityLine."Activity Type"::"Invt. Pick",LocationCode,SourceNo,ActionType);
      WarehouseActivityHeader.GET(WarehouseActivityLine."Activity Type"::"Invt. Pick",WarehouseActivityLine."No.");
    END;

    LOCAL PROCEDURE FindAndRegisterWhseActivity@235(LocationCode@1001 : Code[10];ProdOrderNo@1002 : Code[20]);
    VAR
      WarehouseActivityHeader@1003 : Record 5766;
      WarehouseActivityLine@1000 : Record 5767;
    BEGIN
      FindWhseActivityLine(WarehouseActivityLine,WarehouseActivityLine."Activity Type"::Pick,LocationCode,ProdOrderNo,0);
      WarehouseActivityHeader.GET(WarehouseActivityLine."Activity Type"::Pick,WarehouseActivityLine."No.");
      LibraryWarehouse.RegisterWhseActivity(WarehouseActivityHeader);
    END;

    LOCAL PROCEDURE FindLastRoutingLine@152(VAR RoutingLine@1000 : Record 99000764;RoutingNo@1001 : Code[20]);
    BEGIN
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      RoutingLine.FINDLAST;
    END;

    LOCAL PROCEDURE FindFirstRoutingLine@150(VAR RoutingLine@1001 : Record 99000764;RoutingNo@1000 : Code[20]);
    BEGIN
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      RoutingLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindProdOrderRoutingLine@252(VAR ProdOrderRoutingLine@1000 : Record 5409;ItemNo@1001 : Code[20]);
    VAR
      ProdOrderLine@1003 : Record 5406;
    BEGIN
      ProdOrderLine.SETRANGE("Item No.",ItemNo);
      ProdOrderLine.FINDFIRST;
      ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProdOrderLine."Prod. Order No.");
      ProdOrderRoutingLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindProdBOMLine@190(VAR ProductionBOMLine@1002 : Record 99000772;ProductionBOMHeaderNo@1001 : Code[20];ItemNo@1000 : Code[20]);
    BEGIN
      WITH ProductionBOMLine DO BEGIN
        SETRANGE("Production BOM No.",ProductionBOMHeaderNo);
        SETRANGE(Type,Type::Item);
        SETRANGE("No.",ItemNo);
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE FinishProdOrderWhenBackFlushingConsumptionAndManualFlushingOutputWithScrap@253(Verification@1002 : 'VerifyErr,VerifyItemLedgerEntry');
    VAR
      Item@1003 : Record 27;
      ProductionOrder@1004 : Record 5405;
      WorkCenter@1000 : Record 99000754;
      ItemJournalLine@1006 : Record 83;
      ChildItemNo@1001 : Code[20];
      Quantity@1008 : Decimal;
      QtyPer@1011 : Decimal;
      FixedScrapQuantity@1009 : Decimal;
    BEGIN
      // Setup: Create a Product Item for Manual Flushing and scrap Routing
      // Create Child Item for Backward Flushing and Lot Tracking
      Initialize;
      Quantity := LibraryRandom.RandInt(100);
      QtyPer := 0.01 * LibraryRandom.RandInt(99); // Qty per need less than 1
      FixedScrapQuantity := LibraryRandom.RandInt(10);
      CreateProdItemWithScrapAndFlushingMethod(
        Item,ChildItemNo,WorkCenter."Flushing Method"::Manual,QtyPer,FALSE,0,FixedScrapQuantity,TRUE);

      // Update Inventory for Component Item
      CreateAndPostItemJournalLineWithTracking(ChildItemNo,Quantity); // Invoke ItemTrackingHandlerWithoutApplyToItemEntry

      // Create and Refresh Production Order and Assign Lot Item Tracking for Component Item
      CreateAndRefreshReleasedProductionOrder(ProductionOrder,Item."No.",Quantity,'','');
      SelectItemTrackingForProdOrderComponents(ChildItemNo); // Invoke ItemTrackingHandlerWithoutApplyToItemEntry

      // Open Production Journal Page, update Output Quantity and Post Production Journal on PostProductionJournalHandlerWithUpdateQuantity
      OpenProductionJournalPage(ProductionOrder,Item."No.",Item."No.",Quantity,ItemJournalLine."Entry Type"::Output);

      CASE Verification OF
        Verification::VerifyErr:
          BEGIN
            // Exercise: Change Status to Finished
            // Verify: Error message pops up and error info is correct.
            ASSERTERROR LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");
            Assert.IsTrue(STRPOS(GETLASTERRORTEXT,STRSUBSTNO(QtyToHandleBaseInTrackingErr,Quantity * QtyPer)) > 0,GETLASTERRORTEXT);
          END;
        Verification::VerifyItemLedgerEntry:
          BEGIN
            // Update Quantity (Base) in Item Tracking for Prod. Order Components.
            // Exercise: Change Status to Finished
            UpdateQuantityBaseInTrackingForProdOrderComponents(ChildItemNo,Quantity * QtyPer); // Invoke ItemTrackingHandlerWithoutApplyToItemEntry
            LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

            // Verify:  There is no error pops up when change status
            // Verify Item Ledger Entries are correct for Consumption and Output Quantity
            VerifyItemLedgerEntry(ItemJournalLine."Entry Type"::Consumption,ChildItemNo,-Quantity * QtyPer,'');
            VerifyItemLedgerEntry(ItemJournalLine."Entry Type"::Output,Item."No.",Quantity,'');
          END;
      END;
    END;

    LOCAL PROCEDURE FilterValueEntry@143(VAR ValueEntry@1003 : Record 5802;DocumentNo@1001 : Code[20];ItemLedgerEntryType@1002 : Option);
    BEGIN
      ValueEntry.SETRANGE("Item Ledger Entry Type",ItemLedgerEntryType);
      ValueEntry.SETRANGE("Document No.",DocumentNo);
    END;

    LOCAL PROCEDURE MockItemLedgerEntryForConsumption@191(VAR ProdOrderComponent@1003 : Record 5407);
    VAR
      ItemLedgerEntry@1000 : Record 32;
      RecRef@1001 : RecordRef;
    BEGIN
      WITH ItemLedgerEntry DO BEGIN
        INIT;
        RecRef.GETTABLE(ItemLedgerEntry);
        "Entry No." := LibraryUtility.GetNewLineNo(RecRef,FIELDNO("Entry No."));
        "Entry Type" := "Entry Type"::Consumption;
        "Order Type" := "Order Type"::Production;
        "Order No." := ProdOrderComponent."Prod. Order No.";
        "Prod. Order Comp. Line No." := ProdOrderComponent."Line No.";
        Quantity := LibraryRandom.RandInt(10);
        INSERT;
      END;
    END;

    LOCAL PROCEDURE MockProdOrderComponent@193(VAR ProdOrderComponent@1002 : Record 5407);
    BEGIN
      WITH ProdOrderComponent DO BEGIN
        INIT;
        Status := Status::Released;
        "Prod. Order No." := LibraryUtility.GenerateGUID;
        "Line No." := LibraryRandom.RandInt(10);
        "Item No." := LibraryUtility.GenerateGUID;
        "Qty. per Unit of Measure" := LibraryRandom.RandInt(10);
        INSERT;

        BlockDynamicTracking(TRUE); // prevents calling of VerifyQuantity function
      END;
    END;

    LOCAL PROCEDURE OpenReleasedProductionOrderStatisticsPage@256(VAR ProductionOrderStatistics@1002 : TestPage 99000816;ProductionOrderNo@1001 : Code[20]);
    VAR
      ReleasedProductionOrder@1000 : TestPage 99000831;
    BEGIN
      ReleasedProductionOrder.OPENEDIT;
      ReleasedProductionOrder.FILTER.SETFILTER("No.",ProductionOrderNo);
      ProductionOrderStatistics.TRAP;
      ReleasedProductionOrder."Page Production Order Statistics".INVOKE;
    END;

    LOCAL PROCEDURE PostWarehouseReceipt@63(SourceNo@1001 : Code[20]);
    VAR
      WarehouseReceiptHeader@1002 : Record 7316;
      WarehouseReceiptLine@1003 : Record 7317;
    BEGIN
      FindWarehouseReceiptNo(WarehouseReceiptLine,WarehouseReceiptLine."Source Document"::"Purchase Order",SourceNo);
      WarehouseReceiptHeader.GET(WarehouseReceiptLine."No.");
      LibraryWarehouse.PostWhseReceipt(WarehouseReceiptHeader);
    END;

    LOCAL PROCEDURE RegisterWarehouseActivity@64(SourceNo@1002 : Code[20];Type@1000 : Option);
    VAR
      WarehouseActivityHeader@1003 : Record 5766;
      WarehouseActivityLine@1001 : Record 5767;
    BEGIN
      FindWarehouseActivityNo(WarehouseActivityLine,SourceNo,Type);
      WarehouseActivityHeader.GET(Type,WarehouseActivityLine."No.");
      LibraryWarehouse.RegisterWhseActivity(WarehouseActivityHeader);
    END;

    LOCAL PROCEDURE RunItemAvailByBOMLevelPage@170(VAR Item@1001 : Record 27);
    VAR
      ItemAvailabilityByBOMLevel@1000 : Page 5871;
    BEGIN
      ItemAvailabilityByBOMLevel.InitItem(Item);
      ItemAvailabilityByBOMLevel.RUN;
    END;

    LOCAL PROCEDURE SelectItemJournalBatch@251(VAR ItemJournalBatch@1000 : Record 233);
    VAR
      ItemJournalTemplate@1001 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
    END;

    LOCAL PROCEDURE SelectItemJournalLine@16(VAR ItemJournalLine@1000 : Record 83;JournalTemplateName@1001 : Code[10];JournalBatchName@1002 : Code[10]);
    BEGIN
      ItemJournalLine.SETRANGE("Journal Template Name",JournalTemplateName);
      ItemJournalLine.SETRANGE("Journal Batch Name",JournalBatchName);
      ItemJournalLine.FINDFIRST;
    END;

    LOCAL PROCEDURE SelectSalesOrderLine@42(VAR SalesLine@1000 : Record 37;DocumentNo@1001 : Code[20]);
    BEGIN
      SalesLine.SETRANGE("Document No.",DocumentNo);
      SalesLine.SETRANGE("Document Type",SalesLine."Document Type"::Order);
      SalesLine.FINDFIRST;
    END;

    LOCAL PROCEDURE SelectItemTrackingForProdOrderComponents@197(ItemNo@1001 : Code[20]);
    VAR
      ProdOrderComponents@1000 : TestPage 99000818;
    BEGIN
      ProdOrderComponents.OPENEDIT;
      ProdOrderComponents.FILTER.SETFILTER("Item No.",ItemNo);
      LibraryVariableStorage.Enqueue(ItemTrackingMode::SelectEntries);

      ProdOrderComponents.ItemTrackingLines.INVOKE;
    END;

    LOCAL PROCEDURE UpdateBlanketOrderNoAndLocationOnSalesLine@61(VAR SalesLine@1000 : Record 37;BlanketOrderNo@1001 : Code[20];LocationCode@1002 : Code[10]);
    BEGIN
      SalesLine.VALIDATE("Location Code",LocationCode);
      SalesLine.VALIDATE("Blanket Order No.",BlanketOrderNo);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateManufacturingSetupComponentsAtLocation@37(NewComponentsAtLocation@1000 : Code[10]) ComponentsAtLocation : Code[10];
    VAR
      ManufacturingSetup@1001 : Record 99000765;
    BEGIN
      ManufacturingSetup.GET;
      ComponentsAtLocation := ManufacturingSetup."Components at Location";
      ManufacturingSetup.VALIDATE("Components at Location",NewComponentsAtLocation);
      ManufacturingSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateOrderTrackingPolicyOnItem@53(VAR Item@1001 : Record 27;OrderTrackingPolicy@1000 : Option);
    BEGIN
      LibraryVariableStorage.Enqueue(TrackingMsg);  // Enqueue variable for use in MessageHandler.
      Item.VALIDATE("Order Tracking Policy",OrderTrackingPolicy);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemParametersForPlanning@1(VAR Item@1000 : Record 27;ReplenishmentSystem@1002 : Option;ReorderingPolicy@1003 : Option);
    VAR
      Vendor@1001 : Record 23;
    BEGIN
      LibraryPurchase.CreateVendor(Vendor);
      Item.VALIDATE("Vendor No.",Vendor."No.");
      Item.VALIDATE("Replenishment System",ReplenishmentSystem);
      Item.VALIDATE("Reordering Policy",ReorderingPolicy);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateSalesReceivablesSetup@71(VAR OldStockoutWarning@1000 : Boolean;VAR OldCreditWarnings@1002 : Option;NewStockoutWarning@1004 : Boolean;NewCreditWarnings@1005 : Option);
    VAR
      SalesReceivablesSetup@1001 : Record 311;
    BEGIN
      SalesReceivablesSetup.GET;
      OldStockoutWarning := SalesReceivablesSetup."Stockout Warning";
      OldCreditWarnings := SalesReceivablesSetup."Credit Warnings";
      SalesReceivablesSetup.VALIDATE("Stockout Warning",NewStockoutWarning);
      SalesReceivablesSetup.VALIDATE("Credit Warnings",NewCreditWarnings);
      SalesReceivablesSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateLocationSetup@119(VAR Location@1001 : Record 14;NewAlwaysCreatePickLine@1000 : Boolean) AlwaysCreatePickLine : Boolean;
    BEGIN
      AlwaysCreatePickLine := Location."Always Create Pick Line";
      Location.VALIDATE("Always Create Pick Line",NewAlwaysCreatePickLine);
      Location.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateInventoryWithWhseItemJournal@79(VAR Item@1001 : Record 27;Location@1000 : Record 14;Quantity@1002 : Decimal);
    VAR
      WarehouseJournalLine@1003 : Record 7311;
    BEGIN
      // Create and register the Warehouse Item Journal Line.
      WarehouseJournalSetup(Location.Code);
      CreateWarehouseJournalLine(Item,WarehouseJournalLine,Location,Quantity);
      LibraryWarehouse.RegisterWhseJournalLine(
        WarehouseJournalBatch."Journal Template Name",WarehouseJournalBatch.Name,Location.Code,TRUE);

      // Calculate Warehouse adjustment and post Item Journal.
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
      CalculateWhseAdjustmentAndPostCreatedItemJournalLine(Item,ItemJournalBatch);
    END;

    LOCAL PROCEDURE UpdateQuantityOnWarehouseActivityLine@134(SourceNo@1001 : Code[20];ActionType@1003 : Option;Quantity@1002 : Decimal;LocationCode@1006 : Code[10]);
    VAR
      WarehouseActivityLine@1005 : Record 5767;
    BEGIN
      FindWhseActivityLine(WarehouseActivityLine,WarehouseActivityLine."Activity Type"::"Invt. Pick",LocationCode,SourceNo,ActionType);
      WarehouseActivityLine.VALIDATE(Quantity,Quantity);
      WarehouseActivityLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateFlushingMethodOnItem@155(VAR Item@1000 : Record 27;FlushingMethod@1001 : Option);
    BEGIN
      Item.VALIDATE("Flushing Method",FlushingMethod);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateFlushingMethodOnProdOrderRoutingLine@246(ProductionOrder@1000 : Record 5405);
    VAR
      ProdOrderRoutingLine@1001 : Record 5409;
    BEGIN
      ProdOrderRoutingLine.SETRANGE(Status,ProdOrderRoutingLine.Status::Released);
      ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderRoutingLine.FINDFIRST;
      ProdOrderRoutingLine.VALIDATE("Flushing Method",ProdOrderRoutingLine."Flushing Method"::Backward);
      ProdOrderRoutingLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateProdBOMVersionCodeOnProdOrderLine@304(Item@1000 : Record 27);
    VAR
      ProductionBOMVersion@1002 : Record 99000779;
      ProdOrderLine@1001 : Record 5406;
    BEGIN
      ProductionBOMVersion.SETRANGE("Production BOM No.",Item."Production BOM No.");
      ProductionBOMVersion.FINDFIRST;
      FindReleasedProdOrderLine(ProdOrderLine,Item."No.");
      ProdOrderLine.VALIDATE("Production BOM Version Code",ProductionBOMVersion."Version Code");
      ProdOrderLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemFlushingMethodPickAndBackward@372(VAR Item@1000 : Record 27);
    BEGIN
      Item.VALIDATE("Flushing Method",Item."Flushing Method"::"Pick + Backward");
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemForLotTrackingAndFlushingMethod@188(VAR Item@1001 : Record 27;FlushingMethod@1000 : Option);
    VAR
      GeneralLedgerSetup@1002 : Record 98;
    BEGIN
      GeneralLedgerSetup.GET;
      WITH Item DO BEGIN
        VALIDATE("Item Tracking Code",CreateItemTrackingCode);
        VALIDATE("Lot Nos.",LibraryERM.CreateNoSeriesCode);
        VALIDATE("Flushing Method",FlushingMethod);
        VALIDATE("Rounding Precision",GeneralLedgerSetup."Amount Rounding Precision");
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE UpdateInventorySetup@105(VAR InventorySetup@1001 : Record 313);
    VAR
      InventorySetup2@1000 : Record 313;
    BEGIN
      // Enqueue values for use in MessageHandler.
      LibraryVariableStorage.Enqueue(ChangeExpectedCostPostingToGLMsg);
      LibraryVariableStorage.Enqueue(ExpectedCostPostingChangedMsg);
      LibraryVariableStorage.Enqueue(UnadjustedValueEntriesNotCoveredMsg);
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      InventorySetup.GET;  // To maintain the original state of setup.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup2,TRUE,TRUE,InventorySetup2."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");  // Update few parameters to effect restore.
    END;

    LOCAL PROCEDURE UpdateItemOverheadRate@139(VAR Item@1000 : Record 27);
    BEGIN
      Item.VALIDATE("Overhead Rate",LibraryRandom.RandInt(5));
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemInventoryForLocation@255(Item@1006 : Record 27;Location@1003 : Record 14;Quantity@1008 : Decimal);
    VAR
      Bin@1009 : Record 7354;
      ItemJournalBatch@1001 : Record 233;
      WarehouseJournalLine@1004 : Record 7311;
      WarehouseJournalBatch@1005 : Record 7310;
      WarehouseJournalTemplate@1007 : Record 7309;
      Zone@1002 : Record 7300;
    BEGIN
      SelectItemJournalBatch(ItemJournalBatch);
      Bin.GET(Location.Code,Location."Open Shop Floor Bin Code");
      Zone.GET(Location.Code,Bin."Zone Code");
      LibraryWarehouse.SelectWhseJournalTemplateName(WarehouseJournalTemplate,WarehouseJournalTemplate.Type::Item);
      LibraryWarehouse.CreateWhseJournalBatch(WarehouseJournalBatch,WarehouseJournalTemplate.Name,Location.Code);
      LibraryWarehouse.CreateWhseJournalLine(
        WarehouseJournalLine,WarehouseJournalBatch."Journal Template Name",WarehouseJournalBatch.Name,Location.Code,Zone.Code,
        Location."Open Shop Floor Bin Code",WarehouseJournalLine."Entry Type"::"Positive Adjmt.",Item."No.",Quantity);
      LibraryWarehouse.RegisterWhseJournalLine(
        WarehouseJournalBatch."Journal Template Name",WarehouseJournalBatch.Name,Location.Code,TRUE);
      CalculateWhseAdjustmentAndPostCreatedItemJournalLine(Item,ItemJournalBatch);
    END;

    LOCAL PROCEDURE UpdateLocationAndBins@159(VAR Location@1000 : Record 14);
    VAR
      Bin2@1002 : Record 7354;
      Bin3@1001 : Record 7354;
    BEGIN
      LibraryWarehouse.FindBin(Bin2,Location.Code,'',2); // Find Bin of Index 2.
      LibraryWarehouse.FindBin(Bin3,Location.Code,'',3); // Find Bin of Index 3.
      WITH Location DO BEGIN
        VALIDATE("Require Shipment",TRUE);
        VALIDATE("Require Put-away",FALSE);
        VALIDATE("To-Production Bin Code",Bin2.Code);
        VALIDATE("From-Production Bin Code",Bin3.Code);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE UpdateBOMHeader@160(ProductionBOMNo@1000 : Code[20];ItemNo@1004 : Code[20];RoutingLinkCode@1003 : Code[10]);
    VAR
      ProductionBOMHeader@1002 : Record 99000771;
    BEGIN
      // Update Routing link Code on specified BOM component Lines.
      WITH ProductionBOMHeader DO BEGIN
        SETRANGE("No.",ProductionBOMNo);
        FINDFIRST;
        VALIDATE(Status,Status::"Under Development");
        MODIFY(TRUE);
      END;
      UpdateBOMLineRoutingLinkCode(ProductionBOMNo,ItemNo,RoutingLinkCode);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateBOMLineRoutingLinkCode@158(ProductionBOMHeaderNo@1002 : Code[20];ItemNo@1004 : Code[20];RoutingLinkCode@1003 : Code[10]);
    VAR
      ProductionBOMLine@1000 : Record 99000772;
    BEGIN
      FindProdBOMLine(ProductionBOMLine,ProductionBOMHeaderNo,ItemNo);
      ProductionBOMLine.VALIDATE("Routing Link Code",RoutingLinkCode);
      ProductionBOMLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateBOMHeaderWithLineUOM@187(ProductionBOMNo@1000 : Code[20];ItemNo@1004 : Code[20];UnitOfMeasureCode@1001 : Code[10]);
    VAR
      ProductionBOMHeader@1002 : Record 99000771;
    BEGIN
      // Update Unit of Measure Code on specified BOM component Line.
      WITH ProductionBOMHeader DO BEGIN
        SETRANGE("No.",ProductionBOMNo);
        FINDFIRST;
        VALIDATE(Status,Status::"Under Development");
        MODIFY(TRUE);
      END;
      UpdateBOMLineUOM(ProductionBOMNo,ItemNo,UnitOfMeasureCode);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateBOMLineUOM@222(ProductionBOMHeaderNo@1002 : Code[20];ItemNo@1004 : Code[20];UnitOfMeasureCode@1003 : Code[10]);
    VAR
      ProductionBOMLine@1000 : Record 99000772;
    BEGIN
      FindProdBOMLine(ProductionBOMLine,ProductionBOMHeaderNo,ItemNo);
      ProductionBOMLine.VALIDATE("Unit of Measure Code",UnitOfMeasureCode);
      ProductionBOMLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateLocationOnSalesLine@163(DocumentNo@1000 : Code[20];LocationCode@1001 : Code[10]);
    VAR
      SalesLine@1002 : Record 37;
    BEGIN
      SelectSalesOrderLine(SalesLine,DocumentNo);
      SalesLine.VALIDATE("Location Code",LocationCode);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateVariantCodeInProductionOrderLine@240(VAR ProdOrderLine@1000 : Record 5406;ProductionOrder@1002 : Record 5405;ItemVariantCode@1001 : Code[10]);
    BEGIN
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderLine.FINDFIRST;
      ProdOrderLine.VALIDATE("Variant Code",ItemVariantCode);
      ProdOrderLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateQuantityBaseInTrackingForProdOrderComponents@298(ItemNo@1001 : Code[20];Qty@1002 : Decimal);
    VAR
      ProdOrderComponents@1000 : TestPage 99000818;
    BEGIN
      ProdOrderComponents.OPENEDIT;
      ProdOrderComponents.FILTER.SETFILTER("Item No.",ItemNo);
      LibraryVariableStorage.Enqueue(ItemTrackingMode::UpdateQuantityBase);
      LibraryVariableStorage.Enqueue(Qty);

      ProdOrderComponents.ItemTrackingLines.INVOKE;
    END;

    LOCAL PROCEDURE UpdateStatusOnRoutingHeader@233(VAR RoutingHeader@1000 : Record 99000763;Status@1001 : Option);
    BEGIN
      RoutingHeader.VALIDATE(Status,Status);
      RoutingHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateScrapOnRoutingLine@234(VAR RoutingLine@1000 : Record 99000764;ScrapFactor@1001 : Decimal;FixedScrapQuantity@1004 : Decimal);
    BEGIN
      RoutingLine.VALIDATE("Scrap Factor %",ScrapFactor);
      RoutingLine.VALIDATE("Fixed Scrap Quantity",FixedScrapQuantity);
      RoutingLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateFlushingMethodOnWorkCenter@232(VAR WorkCenter@1000 : Record 99000754;FlushingMethod@1001 : Option);
    BEGIN
      WorkCenter.VALIDATE("Flushing Method",FlushingMethod);
      WorkCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ResetInventorySetup@102(VAR InventorySetup@1000 : Record 313);
    BEGIN
      LibraryVariableStorage.Enqueue(ChangeExpectedCostPostingToGLMsg);
      LibraryVariableStorage.Enqueue(UnadjustedValueEntriesNotCoveredMsg);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,InventorySetup."Automatic Cost Posting",InventorySetup."Expected Cost Posting to G/L",
        InventorySetup."Automatic Cost Adjustment",InventorySetup."Average Cost Calc. Type",InventorySetup."Average Cost Period");
    END;

    LOCAL PROCEDURE UpdateProdOrderLineUnitOfMeasureCode@98(VAR ProdOrderLine@1000 : Record 5406;ItemNo@1001 : Code[20];UnitOfMeasureCode@1002 : Code[10]);
    BEGIN
      FindReleasedProdOrderLine(ProdOrderLine,ItemNo);
      ProdOrderLine.VALIDATE("Unit of Measure Code",UnitOfMeasureCode);
      ProdOrderLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdatePurchaseHeaderVATBusPostingGroup@121(VAR PurchaseHeader@1000 : Record 38);
    BEGIN
      PurchaseHeader.VALIDATE("VAT Bus. Posting Group",GetDifferentVATBusPostingGroup(PurchaseHeader."VAT Bus. Posting Group"));
      PurchaseHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE GetDifferentVATBusPostingGroup@108(VATBusPostingGroupCode@1000 : Code[10]) : Code[10];
    VAR
      VATBusPostingGroup@1001 : Record 323;
    BEGIN
      VATBusPostingGroup.SETFILTER(Code,'<>%1',VATBusPostingGroupCode);
      VATBusPostingGroup.FINDFIRST;
      EXIT(VATBusPostingGroup.Code);
    END;

    LOCAL PROCEDURE InitProdOrderComponent@182(VAR NewProdOrderComponent@1000 : Record 5407;OldProdOrderComponent@1001 : Record 5407);
    BEGIN
      WITH NewProdOrderComponent DO BEGIN
        INIT;
        Status := OldProdOrderComponent.Status;
        "Prod. Order No." := OldProdOrderComponent."Prod. Order No.";
        "Prod. Order Line No." := OldProdOrderComponent."Prod. Order Line No.";
        "Line No." := OldProdOrderComponent."Line No." + 10000;
        VALIDATE("Item No.",OldProdOrderComponent."Item No.");
        VALIDATE("Location Code",OldProdOrderComponent."Location Code");
      END;
    END;

    LOCAL PROCEDURE VerifyValueEntryForEntryType@140(EntryType@1000 : Option;DocumentNo@1001 : Code[20];ItemLedgerEntryQuantity@1002 : Decimal;CostPostedToGL@1003 : Decimal;InvoicedQuantity@1004 : Decimal;CostPerUnit@1005 : Decimal;CostAmountActual@1006 : Decimal);
    VAR
      ValueEntry@1007 : Record 5802;
    BEGIN
      FilterValueEntry(ValueEntry,DocumentNo,ValueEntry."Item Ledger Entry Type"::Output);
      ValueEntry.SETRANGE("Entry Type",EntryType);
      ValueEntry.FINDFIRST;
      ValueEntry.TESTFIELD("Item Ledger Entry Quantity",ItemLedgerEntryQuantity);
      ValueEntry.TESTFIELD("Cost Posted to G/L",CostPostedToGL);
      ValueEntry.TESTFIELD("Invoiced Quantity",InvoicedQuantity);
      ValueEntry.TESTFIELD("Cost per Unit",CostPerUnit);
      ValueEntry.TESTFIELD("Cost Amount (Actual)",CostAmountActual);
    END;

    LOCAL PROCEDURE VerifyUOMOnWhseActivityLine@67(VAR WarehouseActivityLine@1000 : Record 5767;UnitOfMeasureCode@1007 : Code[10];QtyPerUnitOfMeasure@1008 : Integer);
    BEGIN
      WarehouseActivityLine.TESTFIELD("Unit of Measure Code",UnitOfMeasureCode);
      WarehouseActivityLine.TESTFIELD("Qty. per Unit of Measure",QtyPerUnitOfMeasure);
    END;

    LOCAL PROCEDURE VerifyProdOrderLine@56(ItemNo@1001 : Code[20];LocationCode@1002 : Code[10];Quantity@1003 : Decimal;DueDate@1004 : Date);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      FindFirmPlannedProdOrderLine(ProdOrderLine,ItemNo);
      ProdOrderLine.TESTFIELD("Location Code",LocationCode);
      ProdOrderLine.TESTFIELD(Quantity,Quantity);
      ProdOrderLine.TESTFIELD("Due Date",DueDate);
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntry@55(EntryType@1001 : Option;ItemNo@1002 : Code[20];Quantity@1003 : Decimal;LocationCode@1004 : Code[10]);
    VAR
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,EntryType,ItemNo);
      ItemLedgerEntry.TESTFIELD(Quantity,Quantity);
      ItemLedgerEntry.TESTFIELD("Location Code",LocationCode)
    END;

    LOCAL PROCEDURE VerifyWarehouseEntry@65(EntryType@1001 : Option;SourceNo@1005 : Code[20];ItemNo@1000 : Code[20];BinCode@1004 : Code[20];LocationCode@1006 : Code[10];Qty@1002 : Decimal);
    VAR
      WarehouseEntry@1003 : Record 7312;
    BEGIN
      WITH WarehouseEntry DO BEGIN
        SETRANGE("Entry Type",EntryType);
        SETRANGE("Item No.",ItemNo);
        SETRANGE("Source No.",SourceNo);
        FINDFIRST;
        TESTFIELD("Location Code",LocationCode);
        TESTFIELD("Bin Code",BinCode);
        TESTFIELD(Quantity,Qty);
      END;
    END;

    LOCAL PROCEDURE VerifyOrderTrackingForProductionOrder@52(ItemNo@1003 : Code[20];Quantity@1004 : Decimal);
    VAR
      ProdOrderLine@1001 : Record 5406;
      OrderTracking@1000 : Page 99000822;
      OrderTracking2@1002 : TestPage 99000822;
    BEGIN
      FindFirmPlannedProdOrderLine(ProdOrderLine,ItemNo);
      OrderTracking.SetProdOrderLine(ProdOrderLine);
      OrderTracking2.TRAP;
      OrderTracking.RUN;
      REPEAT
        OrderTracking2."Item No.".ASSERTEQUALS(ItemNo);
        OrderTracking2.Quantity.ASSERTEQUALS(Quantity);
      UNTIL NOT OrderTracking2.NEXT;
    END;

    LOCAL PROCEDURE VerifyProdOrderLineBinCode@216(ItemNo@1001 : Code[20];WorkCenterBinCode@1002 : Code[20]);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      WITH ProdOrderLine DO BEGIN
        SETRANGE("Item No.",ItemNo);
        FINDFIRST;
        Assert.AreEqual(WorkCenterBinCode,"Bin Code",ProdOrderLineBinCodeErr);
      END;
    END;

    LOCAL PROCEDURE VerifyPurchaseLine@72(No@1000 : Code[20];Quantity@1002 : Decimal);
    VAR
      PurchaseLine@1003 : Record 39;
    BEGIN
      PurchaseLine.SETRANGE("Document Type",PurchaseLine."Document Type"::Order);
      PurchaseLine.SETRANGE(Type,PurchaseLine.Type::Item);
      PurchaseLine.SETRANGE("No.",No);
      PurchaseLine.FINDFIRST;
      PurchaseLine.TESTFIELD(Quantity,Quantity);
    END;

    LOCAL PROCEDURE VerifyRecreatedPurchaseLine@115(PurchaseLine@1000 : Record 39;VATBusPostingGroupCode@1002 : Code[10]);
    VAR
      RecreatedPurchaseLine@1001 : Record 39;
    BEGIN
      WITH RecreatedPurchaseLine DO BEGIN
        GET(PurchaseLine."Document Type",PurchaseLine."Document No.",PurchaseLine."Line No.");
        TESTFIELD(Description,PurchaseLine.Description);
        TESTFIELD("Unit Cost (LCY)",PurchaseLine."Unit Cost (LCY)");
        TESTFIELD("Gen. Prod. Posting Group",PurchaseLine."Gen. Prod. Posting Group");
        TESTFIELD("VAT Prod. Posting Group",PurchaseLine."VAT Prod. Posting Group");
        TESTFIELD("VAT Identifier",PurchaseLine."VAT Identifier");
        TESTFIELD("Qty. per Unit of Measure",PurchaseLine."Qty. per Unit of Measure");
        TESTFIELD("Expected Receipt Date",PurchaseLine."Expected Receipt Date");
        TESTFIELD("Requested Receipt Date",PurchaseLine."Requested Receipt Date");
        TESTFIELD("VAT Bus. Posting Group",VATBusPostingGroupCode);
      END;
    END;

    LOCAL PROCEDURE VerifyRequisitionLine@104(No@1001 : Code[20];ActionMessage@1003 : Option;Quantity@1007 : Decimal;DueDate@1002 : Date);
    VAR
      RequisitionLine@1000 : Record 246;
    BEGIN
      FindRequisitionLine(RequisitionLine,No);
      RequisitionLine.TESTFIELD(Quantity,Quantity);
      RequisitionLine.TESTFIELD("Action Message",ActionMessage);
      RequisitionLine.TESTFIELD("Due Date",DueDate);
    END;

    LOCAL PROCEDURE VerifyRequisitionLineWithLocation@18(ItemNo@1004 : Code[20];Quantity@1001 : Decimal;LocationCode@1002 : Code[10];ActionMessage@1003 : Option);
    VAR
      RequisitionLine@1000 : Record 246;
    BEGIN
      FindRequisitionLine(RequisitionLine,ItemNo);
      RequisitionLine.TESTFIELD(Quantity,Quantity);
      RequisitionLine.TESTFIELD("Action Message",ActionMessage);
      RequisitionLine.TESTFIELD("Location Code",LocationCode);
    END;

    LOCAL PROCEDURE VerifyCostAmountActualOnFinishedProductionOrderStatisticsPage@33(ProductionOrderNo@1001 : Code[20];ActualCost@1003 : Decimal);
    VAR
      FinishedProductionOrder@1000 : TestPage 99000867;
      ProductionOrderStatistics@1002 : TestPage 99000816;
    BEGIN
      FinishedProductionOrder.OPENEDIT;
      FinishedProductionOrder.FILTER.SETFILTER("No.",ProductionOrderNo);
      ProductionOrderStatistics.TRAP;
      FinishedProductionOrder."Page Production Order Statistics".INVOKE;
      ProductionOrderStatistics.MaterialCost_ActualCost.ASSERTEQUALS(ActualCost);
    END;

    LOCAL PROCEDURE VerifyTotalActualCostOnFinishedProductionOrderStatisticsPage@146(ProductionOrderNo@1001 : Code[20];ActualCost@1003 : Decimal);
    VAR
      FinishedProductionOrder@1000 : TestPage 99000867;
      ProductionOrderStatistics@1002 : TestPage 99000816;
    BEGIN
      FinishedProductionOrder.OPENEDIT;
      FinishedProductionOrder.FILTER.SETFILTER("No.",ProductionOrderNo);
      ProductionOrderStatistics.TRAP;
      FinishedProductionOrder."Page Production Order Statistics".INVOKE;
      ProductionOrderStatistics.TotalCost_ActualCost.ASSERTEQUALS(ActualCost);
    END;

    LOCAL PROCEDURE VerifyCostAmountActualOnReleasedProductionOrderStatisticsPage@194(ProductionOrderNo@1001 : Code[20];ActualCost@1003 : Decimal);
    VAR
      ReleasedProductionOrder@1000 : TestPage 99000831;
      ProductionOrderStatistics@1002 : TestPage 99000816;
    BEGIN
      ReleasedProductionOrder.OPENEDIT;
      ReleasedProductionOrder.FILTER.SETFILTER("No.",ProductionOrderNo);
      ProductionOrderStatistics.TRAP;
      ReleasedProductionOrder."Page Production Order Statistics".INVOKE;
      ProductionOrderStatistics.MaterialCost_ActualCost.ASSERTEQUALS(ActualCost);
    END;

    LOCAL PROCEDURE VerifyReservationEntry@220(ItemNo@1000 : Code[20];Quantity@1001 : Decimal;ReservationStatus@1002 : Option;LocationCode@1004 : Code[10]);
    VAR
      ReservationEntry@1003 : Record 337;
    BEGIN
      ReservationEntry.SETRANGE("Item No.",ItemNo);
      ReservationEntry.FINDFIRST;
      ReservationEntry.TESTFIELD(Quantity,Quantity);
      ReservationEntry.TESTFIELD("Reservation Status",ReservationStatus);
      ReservationEntry.TESTFIELD("Lot No.");
      ReservationEntry.TESTFIELD("Location Code",LocationCode);
    END;

    LOCAL PROCEDURE VerifyRequisitionLineForSubcontract@26(ProductionOrder@1001 : Record 5405;WorkCenter@1000 : Record 99000754;ItemNo@1003 : Code[20]);
    VAR
      RequisitionLine@1002 : Record 246;
    BEGIN
      FindRequisitionLine(RequisitionLine,ItemNo);
      RequisitionLine.TESTFIELD("Prod. Order No.",ProductionOrder."No.");
      RequisitionLine.TESTFIELD(Quantity,ProductionOrder.Quantity);
      RequisitionLine.TESTFIELD("Work Center No.",WorkCenter."No.");
      RequisitionLine.TESTFIELD("Vendor No.",WorkCenter."Subcontractor No.");
    END;

    LOCAL PROCEDURE VerifyReleasedProdOrderLine@225(ItemNo@1001 : Code[20];Quantity@1003 : Decimal);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      FindReleasedProdOrderLine(ProdOrderLine,ItemNo);
      ProdOrderLine.TESTFIELD(Quantity,Quantity);
      ProdOrderLine.TESTFIELD("Finished Quantity",Quantity);
    END;

    LOCAL PROCEDURE VerifyRegisteredWhseActivityLine@78(RegisteredWhseActivityLine@1000 : Record 5773;UnitOfMeasureCode@1007 : Code[10];QtyPerUnitOfMeasure@1005 : Integer;Quantity@1006 : Decimal);
    BEGIN
      RegisteredWhseActivityLine.TESTFIELD("Unit of Measure Code",UnitOfMeasureCode);
      RegisteredWhseActivityLine.TESTFIELD("Qty. per Unit of Measure",QtyPerUnitOfMeasure);
      RegisteredWhseActivityLine.TESTFIELD(Quantity,Quantity);
    END;

    LOCAL PROCEDURE VerifyFinishedProdOrderLine@254(ItemNo@1001 : Code[20];Quantity@1003 : Decimal);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProdOrderLine.Status::Finished);
      ProdOrderLine.SETRANGE("Item No.",ItemNo);
      ProdOrderLine.FINDFIRST;
      ProdOrderLine.TESTFIELD(Quantity,Quantity);
      ProdOrderLine.TESTFIELD("Finished Quantity",Quantity);
    END;

    LOCAL PROCEDURE VerifyPostedInventoryPickLine@138(SourceNo@1000 : Code[20];ItemNo@1002 : Code[20];BinCode@1004 : Code[20];Quantity@1006 : Decimal;LocationCode@1001 : Code[10]);
    VAR
      PostedInvtPickLine@1005 : Record 7343;
    BEGIN
      PostedInvtPickLine.SETRANGE("Source No.",SourceNo);
      PostedInvtPickLine.SETRANGE("Item No.",ItemNo);
      PostedInvtPickLine.FINDSET;
      REPEAT
        PostedInvtPickLine.TESTFIELD("Bin Code",BinCode);
        PostedInvtPickLine.TESTFIELD(Quantity,Quantity);
        PostedInvtPickLine.TESTFIELD("Location Code",LocationCode);
      UNTIL PostedInvtPickLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyWarehouseActivityLine@164(VAR WarehouseActivityLine@1000 : Record 5767;ItemNo@1001 : Code[20];Quantity@1006 : Decimal);
    BEGIN
      WarehouseActivityLine.SETRANGE("Item No.",ItemNo);
      WarehouseActivityLine.FINDFIRST;
      WarehouseActivityLine.TESTFIELD(Quantity,Quantity);
      WarehouseActivityLine.TESTFIELD("Qty. (Base)",Quantity);
    END;

    LOCAL PROCEDURE VerifyValueEntry@83(ItemNo@1001 : Code[20];DocumentNo@1002 : Code[20];ItemLedgerEntryType@1003 : Option;CostAmountActual@1004 : Decimal);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      FilterValueEntry(ValueEntry,DocumentNo,ItemLedgerEntryType);
      ValueEntry.SETRANGE("Item No.",ItemNo);
      ValueEntry.FINDFIRST;
      ValueEntry.TESTFIELD("Cost Amount (Actual)",CostAmountActual);
    END;

    LOCAL PROCEDURE VerifyValueEntrySource@242(ProdOrderNo@1002 : Code[20];SourceNo@1001 : Code[20];SourceType@1003 : ' ,Customer,Vendor,Item');
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      WITH ValueEntry DO BEGIN
        SETRANGE("Order No.",ProdOrderNo);
        FINDSET;
        REPEAT
          Assert.AreEqual(SourceType,"Source Type",STRSUBSTNO(ValueEntrySourceTypeErr,SourceType));
          Assert.AreEqual(SourceNo,"Source No.",STRSUBSTNO(ValueEntrySourceNoErr,SourceNo));
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE VerifyProdOrderComponent@89(ProdOrderNo@1004 : Code[20];Status@1003 : Option;ItemNo@1002 : Code[20];QtyPicked@1001 : Decimal);
    VAR
      ProdOrderComponent@1000 : Record 5407;
    BEGIN
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProdOrderNo);
      ProdOrderComponent.SETRANGE("Item No.",ItemNo);
      ProdOrderComponent.FINDFIRST;
      ProdOrderComponent.TESTFIELD(Status,Status);
      ProdOrderComponent.TESTFIELD("Qty. Picked",QtyPicked);
      ProdOrderComponent.TESTFIELD("Qty. Picked (Base)",QtyPicked);
    END;

    LOCAL PROCEDURE VerifyProductionOrderIsEmpty@248(ProductionOrderNo@1000 : Code[20]);
    VAR
      ProductionOrder@1001 : Record 5405;
    BEGIN
      ProductionOrder.SETRANGE("No.",ProductionOrderNo);
      ProductionOrder.SETRANGE(Status,ProductionOrder.Status::Released);
      Assert.RecordIsEmpty(ProductionOrder);
    END;

    LOCAL PROCEDURE VerifyOutputItemLedgerEntry@128(ItemNo@1000 : Code[20];Location@1003 : Code[10];Qty@1002 : Decimal;Qty2@1004 : Decimal);
    VAR
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      WITH ItemLedgerEntry DO BEGIN
        SETRANGE("Entry Type","Entry Type"::Output);
        SETRANGE("Item No.",ItemNo);
        FINDSET;
        TESTFIELD(Quantity,Qty);
        TESTFIELD("Location Code",Location);
        NEXT;
        TESTFIELD(Quantity,Qty2);
        TESTFIELD("Location Code",Location);
      END;
    END;

    LOCAL PROCEDURE VerifyBinCodeInProductionOrderLine@166(ItemNo@1001 : Code[20];BinCode@1003 : Code[20]);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      FindFirmPlannedProdOrderLine(ProdOrderLine,ItemNo);
      ProdOrderLine.TESTFIELD("Bin Code",BinCode);
    END;

    LOCAL PROCEDURE VerifyItemAvailabilityByBOMPage@174(VAR ItemAvailByBOMLevel@1000 : TestPage 5871);
    VAR
      ChildItemNo@1001 : Variant;
      AbleToMakeParentQty@1002 : Variant;
      AbleToMakeTopItemQty@1004 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ChildItemNo);
      LibraryVariableStorage.Dequeue(AbleToMakeParentQty);
      LibraryVariableStorage.Dequeue(AbleToMakeTopItemQty);

      ItemAvailByBOMLevel."No.".ASSERTEQUALS(ChildItemNo);
      ItemAvailByBOMLevel."Able to Make Parent".ASSERTEQUALS(AbleToMakeParentQty);
      ItemAvailByBOMLevel."Able to Make Top Item".ASSERTEQUALS(AbleToMakeTopItemQty);
    END;

    LOCAL PROCEDURE VerifyWhseRequestExist@215(DocumentNo@1001 : Code[20];LocationCode@1002 : Code[10]);
    VAR
      WarehouseRequest@1000 : Record 5765;
    BEGIN
      WITH WarehouseRequest DO BEGIN
        SETRANGE("Source Type",DATABASE::"Prod. Order Component");
        SETRANGE("Source Subtype",3); // Released
        SETRANGE("Source No.",DocumentNo);
        SETRANGE("Location Code",LocationCode);
        Assert.IsTrue(FINDFIRST,STRSUBSTNO(WhseRequestErr,DocumentNo));
      END;
    END;

    LOCAL PROCEDURE VerifyWhsePickRequestExist@175(DocumentNo@1001 : Code[20];LocationCode@1002 : Code[10]);
    VAR
      WhsePickRequest@1000 : Record 7325;
    BEGIN
      WITH WhsePickRequest DO BEGIN
        SETRANGE("Document Type","Document Type"::Production);
        SETRANGE("Document Subtype",3); // Released
        SETRANGE("Document No.",DocumentNo);
        SETRANGE("Location Code",LocationCode);
        Assert.IsTrue(FINDFIRST,STRSUBSTNO(WhsePickRequestErr,DocumentNo));
      END;
    END;

    LOCAL PROCEDURE AreSameMessages@149(Message@1001 : Text[1024];Message2@1000 : Text[1024]) : Boolean;
    BEGIN
      EXIT(STRPOS(Message,Message2) > 0);
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@348(Message@1000 : Text[1024]);
    VAR
      ExpectedMessage@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ExpectedMessage);
      Assert.IsTrue(AreSameMessages(Message,ExpectedMessage),Message);
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandlerTRUE@111(ConfirmMessage@1000 : Text[1024];VAR Reply@1001 : Boolean);
    VAR
      ExpectedMessage@1002 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ExpectedMessage);
      Assert.IsTrue(AreSameMessages(ConfirmMessage,ExpectedMessage),ConfirmMessage);
      Reply := TRUE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@120(ConfirmMessage@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemTrackingPageHandler@47(VAR ItemTrackingLines@1000 : TestPage 6510);
    BEGIN
      ItemTrackingLines."Assign Lot No.".INVOKE;
      ItemTrackingLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemTrackingHandler@209(VAR ItemTrackingLines@1000 : TestPage 6510);
    VAR
      DequeueVariable@1002 : Variant;
      ApplToItemEntryNo@1003 : Integer;
      LotNo@1004 : Code[10];
      SerialNo@1005 : Code[10];
      Quantity@1006 : Code[10];
      ApplyToItemEntry@1007 : Boolean;
    BEGIN
      LibraryVariableStorage.Dequeue(DequeueVariable);
      ItemTrackingMode := DequeueVariable;

      CASE ItemTrackingMode OF
        ItemTrackingMode::AssignLotNo:
          BEGIN
            ItemTrackingLines."Assign Lot No.".INVOKE;  // Assign Lot No.
            LotNo := ItemTrackingLines."Lot No.".VALUE;
          END;
        ItemTrackingMode::AssignSerialNo:
          BEGIN
            ItemTrackingLines."Assign Serial No.".INVOKE;  // Assign Serial No.
            SerialNo := ItemTrackingLines."Serial No.".VALUE;
          END;
        ItemTrackingMode::SelectEntries:
          BEGIN
            ItemTrackingLines."Select Entries".INVOKE;  // Item Tracking Summary Page is handled in 'ItemTrackingSummaryPageHandler'.
            LibraryVariableStorage.Dequeue(DequeueVariable);
            ApplyToItemEntry := DequeueVariable;
            IF ApplyToItemEntry THEN BEGIN
              LibraryVariableStorage.Dequeue(DequeueVariable);
              ApplToItemEntryNo := DequeueVariable;
              ItemTrackingLines."Appl.-to Item Entry".SETVALUE(ApplToItemEntryNo);
            END;
          END;
        ItemTrackingMode::SetValue:
          BEGIN
            LibraryVariableStorage.Dequeue(DequeueVariable);
            LotNo := DequeueVariable;
            LibraryVariableStorage.Dequeue(DequeueVariable);
            SerialNo := DequeueVariable;
            LibraryVariableStorage.Dequeue(DequeueVariable);
            Quantity := DequeueVariable;

            ItemTrackingLines."Lot No.".SETVALUE(LotNo);
            ItemTrackingLines."Serial No.".SETVALUE(SerialNo);
            ItemTrackingLines."Quantity (Base)".SETVALUE(Quantity);
          END;
      END;

      ItemTrackingLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemTrackingHandlerWithoutApplyToItemEntry@145(VAR ItemTrackingLines@1000 : TestPage 6510);
    VAR
      DequeueVariable@1002 : Variant;
      LotNo@1004 : Code[10];
      SerialNo@1005 : Code[10];
      Quantity@1006 : Decimal;
    BEGIN
      LibraryVariableStorage.Dequeue(DequeueVariable);
      ItemTrackingMode := DequeueVariable;

      CASE ItemTrackingMode OF
        ItemTrackingMode::AssignLotNo:
          BEGIN
            ItemTrackingLines."Assign Lot No.".INVOKE;  // Assign Lot No.
            LotNo := ItemTrackingLines."Lot No.".VALUE;
          END;
        ItemTrackingMode::AssignSerialNo:
          BEGIN
            ItemTrackingLines."Assign Serial No.".INVOKE;  // Assign Serial No.
            SerialNo := ItemTrackingLines."Serial No.".VALUE;
          END;
        ItemTrackingMode::SelectEntries:
          ItemTrackingLines."Select Entries".INVOKE;  // Item Tracking Summary Page is handled in 'ItemTrackingSummaryPageHandler'.
        ItemTrackingMode::SetValue:
          BEGIN
            LibraryVariableStorage.Dequeue(DequeueVariable);
            LotNo := DequeueVariable;
            LibraryVariableStorage.Dequeue(DequeueVariable);
            SerialNo := DequeueVariable;
            LibraryVariableStorage.Dequeue(DequeueVariable);
            Quantity := DequeueVariable;

            ItemTrackingLines."Lot No.".SETVALUE(LotNo);
            ItemTrackingLines."Serial No.".SETVALUE(SerialNo);
            ItemTrackingLines."Quantity (Base)".SETVALUE(Quantity);
          END;
        ItemTrackingMode::UpdateQuantityBase:
          BEGIN
            LibraryVariableStorage.Dequeue(DequeueVariable);
            ItemTrackingLines."Quantity (Base)".SETVALUE(DequeueVariable);
          END;
      END;

      ItemTrackingLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemTrackingSummaryPageHandler@210(VAR ItemTrackingSummary@1000 : TestPage 6500);
    BEGIN
      ItemTrackingSummary.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ProductionJournalPageHandler@76(VAR ProductionJournal@1000 : TestPage 5510);
    VAR
      ItemNo@1003 : Variant;
      Quantity@1002 : Variant;
      EntryType@1004 : Variant;
      EntryType2@1005 : Option;
    BEGIN
      LibraryVariableStorage.Dequeue(ItemNo);
      LibraryVariableStorage.Dequeue(Quantity);
      LibraryVariableStorage.Dequeue(EntryType);
      EntryType2 := EntryType;
      ProductionJournal.FILTER.SETFILTER("Item No.",ItemNo);
      ProductionJournal.FILTER.SETFILTER("Entry Type",FORMAT(EntryType2));
      ProductionJournal.Quantity.ASSERTEQUALS(Quantity);
      ProductionJournal."Output Quantity".ASSERTEQUALS(Quantity);
    END;

    [ModalPageHandler]
    PROCEDURE PostProductionJournalHandler@112(VAR ProductionJournal@1000 : TestPage 5510);
    BEGIN
      LibraryVariableStorage.Enqueue(PostJournalLinesConfirmationMsg);  // Required inside ConfirmHandlerTRUE.
      LibraryVariableStorage.Enqueue(JournalLinesPostedMsg);  // Required inside MessageHandler.
      ProductionJournal.Post.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE PostProductionJournalHandlerWithUpdateQuantity@185(VAR ProductionJournal@1000 : TestPage 5510);
    VAR
      ItemNo@1003 : Variant;
      Quantity@1002 : Variant;
      EntryType@1004 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ItemNo);
      LibraryVariableStorage.Dequeue(Quantity);
      LibraryVariableStorage.Dequeue(EntryType);
      ProductionJournal.FILTER.SETFILTER("Item No.",ItemNo);
      ProductionJournal.FILTER.SETFILTER("Entry Type",FORMAT(EntryType));
      ProductionJournal.LAST;
      ProductionJournal."Output Quantity".SETVALUE(Quantity);

      LibraryVariableStorage.Enqueue(PostJournalLinesConfirmationMsg); // Required inside ConfirmHandlerTRUE.
      LibraryVariableStorage.Enqueue(JournalLinesPostedMsg); // Required inside MessageHandler.
      LibraryVariableStorage.Enqueue(LeaveProductionJournalQst); // Required inside MessageHandler.
      ProductionJournal.Post.INVOKE;
    END;

    [PageHandler]
    PROCEDURE ItemAvailabilityByBOMPageHandler@169(VAR ItemAvailByBOMLevel@1000 : TestPage 5871);
    BEGIN
      ItemAvailByBOMLevel.EXPAND(TRUE);
      ItemAvailByBOMLevel.NEXT;
      VerifyItemAvailabilityByBOMPage(ItemAvailByBOMLevel);

      ItemAvailByBOMLevel.EXPAND(TRUE);
      ItemAvailByBOMLevel.NEXT;
      VerifyItemAvailabilityByBOMPage(ItemAvailByBOMLevel);
    END;

    [ModalPageHandler]
    PROCEDURE ItemSubstEntries_MPH@228(VAR ItemSubstitutionEntries@1000 : TestPage 5718);
    BEGIN
      ItemSubstitutionEntries.FIRST;
      REPEAT
        LibraryVariableStorage.Enqueue(ItemSubstitutionEntries."Substitute No.".VALUE);
      UNTIL NOT ItemSubstitutionEntries.NEXT;
      ItemSubstitutionEntries.Cancel.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ProductionJournalSubcontractedPageHandler@264(VAR ProductionJournal@1000 : TestPage 5510);
    BEGIN
      ProductionJournal.FIRST;
      Assert.AreEqual(0,ProductionJournal."Output Quantity".ASDECIMAL,ProdJournalOutQtyErr);
    END;

    BEGIN
    {
      // [FEATURE] [Production Order]
      // [FEATURE] [Manufacturing] [Production Order] [SCM]
      Test cases for SCM Production Order:

        1. Verify Consumption Quantity, Location and Bin for the Child Item in Item Ledger Entry and Warehouse Entry.
        2. Verify the posted partial Output Quantity, Location and Bin for the Parent Item in Item Ledger Entry and Warehouse Entry.
        3. Verify the error posting Consumption for the already consumed Component Item with Location.
        4. Verify the error posting Consumption for the already consumed Component Item without Location.
        5. Test to verify the Order Tracking for Firm Planned Production Order.
        6. Test to verify the multiple Lines of Order Tracking for Firm Planned Production Order after Calculate Plan and Carry Out Action Message.
        7. Test to verify Requisition Line after Calculate Plan On Req. Worksheet with maximum Quantity Item for Equal Demand.
        8. Test to verify Purchase Line created after Calculate Plan On Req. Worksheet and Carry Out Action with maximum Quantity Item for Equal Demand.
        9. Test to verify Requisition Line after Calculate Plan On Plan. Worksheet with Demand generated from Blanket Order with Location.
       10. Test to verify Prod. Order Line created after Calculate Plan On Plan. Worksheet and Carry Out Action with Demand generated from Blanket Order with Location.
       11. Test to verify Requisition Line after Calculate Plan twice On Plan. Worksheet with Demand generated from Blanket Order with Location.
       12. Test to verify Requisition Line after Calculate Plan On Plan. Worksheet with Blanket Order No updated on Sales Order with Location.
       13. Test to Verify Reservation Entry for Status and Tracking after Calculate Subcontracts. Verify Production Quantity and WorkCenter Subcontractor on Subcontracting Worksheet.
       14. Test to Verify Reservation Entry for Status, Location Code and Tracking after Calculate Subcontracts. Verify Production Quantity and WorkCenter Subcontractor on Subcontracting Worksheet.
       15. Test to verify the Tracking error on Purchase Line after Calculate Subcontracts and Carry Out.
       16. Test to verify the Purchase Line created after Calculate Subcontracts and Carry Out on Subcontracting Worksheet.
       17. Test to verify that Finished Quantity on Prod. Order Line exist after Purchase Order posting after Calculate Subcontracts and Carry Out on Subcontracting Worksheet.
       18. Test to verify that Starting Date is less than or equal to the Due Date on Production Order Routing Line when Refreshing Prod. Order with Scheduling Direction Back.
       19. Test to verify that Ending Date is greater than or equal to the Due Date on Production Order Routing Line when Refreshing Prod. Order with Scheduling Direction Forward.
       20. Test to verify the Cost Amount Actual on Released Production Order Statistics Page after posting Consumption.
       21. Test to verify the Cost Amount Actual on Finished Production Order Statistics Page after posting Consumption and Output.
       22. Test to verify the Production Order Lines for Firm Planned Prod Order with Family.
       23. Test to verify the Total Cost on Production Order Statistics page for Released Production Order with Family.
       24. Test to verify the Unit of Measure on Whse Receipt.
       25. Test to verify the Unit of Measure on Whse Put away.
       26. Test to verify the Unit of Measure on Whse Pick for Released Production Order at White Location.
       27. Test to verify the Unit of Measure on Registered Whse Put Away with Production BOM at White Location.
       28. Test to verify the Output Entry on Production Journal for Released Production Order with Location.
       29. Test to verify Consumption Entry on Production Journal for Production Order after create and Register Warehouse Pick.
       30. Test to verify the Inventory Pick created for Released Production Order with multiple Components.
       31. Test to verify posted partial Inventory Pick for Production Order with multiple Components.
       32. Test to verify that Consumption of component Item can not be posted if the Flushing method on Component Item is Backward with Routing Link code.
       33. Test to verify that Output of parent Item can be posted and Production Order can be Finished without posting Consumption, if the Flushing method on Component Item is Backward with Routing Link code.
       34. Test to verify the Cost Amount Actual in Value Entry after posting Output and negative Output for Production Order with Component Backward Flushing.
       35. Test to verify the Cost Amount Actual in Value Entry after posting Output and Finish Released Production Order with Component Backward Flushing.
       36. Test to verify that Unit of Measure Code remains same on Prod Order Line with BOM Version Code.
       37. Test to verify Quantity Picked after Register Whse Pick for Production Order.
       38. Test to verify the Whse Pick after Refresh Production Order for already Picked Item with Component.
       39. Test to verify Whse Pick for Released Production Order with Item Flushing Pick + Backward.
       40. Test to verify Whse Entries after Register Pick for Released Production Order with Item Flushing Pick + Backward.
       41. Test to verify Whse Entry after Put Away for Released Production Order with Item Flushing Backward.
       42. Test to verify the Whse Entries after Register Put Away for Released Production Order with Item Flushing Backward.
       43. Test to verify the Cost Entries on Value Entry after change UOM on Released Production Order and change status to Finished after posting Production Journal.
       44. Test that after changing VAT bus posting group from Purchase Header created from subcontacting worksheet, Purchase line should not be updated with Item card.
       45. Verify production journal with negative quantity on output line can be posted with Require Pick Location for Item with routing.
       46. Verify production journal with negative quantity on output line can be posted with Require Pick Location for Item without routing.
       47. Test to verify the production journal with negative quantity can be posted with Bin Mandatory Location for Item with routing.
       48. Test to verify the error message pops up when posting production correction journal without setting Apply-to Entry using Location with Require Pick.
       49. Test to verify the error message pops up when posting production correction journal without setting Apply-to Entry using Location with Require Pick and Require Shipment.
       50. Test to verify the production journal with negative quantity can be posted with Require Pick Location and Item Tracking for Item with routing.
       51. Test to verify the error message pops up when posting production correction journal without setting Apply-to Item Entry using Location with Require Pick.
       52. Test to verify the error message pops up when posting production correction journal without setting Apply-to Item Entry using Location with Require Pick and Require Shipment.
       53. Test to verify Output Quantity in Production Journal is correct with setting Fixed Scrap Quantity and Scrap Factor % in Routing.
       54. Test to verify Capacity Cost should be recognized in Production order Statistics as Actual Cost when posting output journal with Output Quantity = 0.
       55. Test to verify an error pops up when posting the Production Journal with Qty. Picked (Base) is zero in Prod. Order Component with Item Flushing Method is Pick + Backward.
       56. Test to verify Bin Code is correct in production order line after carry out the planning line. Bin Code should be From-Production Bin Code of LocationWhite.
       57. Test to verify the Quantity in Warehouse Entry is based on the UOM with Posting after changing UOM on Production Order Line.
       58. Test to verify the Quantity of ChildItem with consumed in Warehouse Entry is based on the UOM of Prod. BOM Line.
       59. Test to verify Error message is correct when Finish Production Order for Back Flushing Consumption and Manual Flushing Output with Scrap.
       60. Test to verify Production Order can be Finished when updating Tracking for Back Flushing Consumption and Manual Flushing Output with Scrap.
       61. Test to verify columns "Able to Make Parent" and "Able to Make Top Item" on Item Availability by BOM Level should be calculated against Unit of Measure Code of the Production BOM Component.
       62. Verify "Warehouse Request" exists when adding new component with zero Qty
       63. Verify "Whse. Pick Request" exists when adding new component after fully consumed previous component
       64. Posting of Output Journal is not allowed with ItemNo different from Order Line's Item
       65. No duplicate items in Substitution list for ALL-to-ALL subtitution setup

        Covers Test Cases for WI - 298239
        -------------------------------------------------------------------------------
        Test Function Name                                                     TFS ID
        -------------------------------------------------------------------------------
        PostConsumptionForReleasedProductionOrderWithLocationAndBin            135424
        PostPartialOutputForReleasedProductionOrderWithLocationAndBin          135424
        ErrorPostConsumptionForAlreadyConsumedComponentItemWithLocation        127517
        ErrorPostConsumptionForAlreadyConsumedComponentItemWithoutLocation     127517

        Covers Test Cases for WI - 302710
        ------------------------------------------------------------------------------------------------------
        Test Function Name                                                                              TFS ID
        ------------------------------------------------------------------------------------------------------
        OrderTrackingForMultiLineSalesWithFirmPlannedProdOrder                                          135510
        OrderTrackingForMultiLineSalesWithFirmPlannedProdOrderCalcRegenPlanAndCarryOut                  135510
        RequisitionLineAfterCalcPlanReqWkshWithMaximumQuantityItemForEqualDemand                        124843
        PurchaseLineAfterCalcPlanReqWkshWithMaximumQuantityItemForEqualDemand                           124843

        Covers Test Cases for WI - 304282
        -------------------------------------------------------------------------------------------------
        Test Function Name                                                                         TFS ID
        -------------------------------------------------------------------------------------------------
        RequisitionLineAfterCalcPlanOnPlanWkshForDemandFromBlanketOrderWithLocation                124862
        ProdOrderLineAfterAcceptAndCarryOutPlanWkshForDemandFromBlanketOrderWithLocation           124862
        RequisitionLineAfterCalcPlanTwiceOnPlanWkshForDemandFromBlanketOrderWithLocation           124862
        RequisitionLineAfterCalcPlanOnPlanWkshForSalesOrderWithUpdatedBlanketOrderNoWithLocation   124862

        Covers Test Cases for WI - 302711
        ------------------------------------------------------------------------------------------------------------
        Test Function Name                                                                                   TFS ID
        ------------------------------------------------------------------------------------------------------------
        CalcSubcontractOrderForReleasedProdOrderWithTracking                                                 127668
        PurchaseLineAfterCalcSubcontractOrderAndCarryOutForProdOrderWithTracking                             127668
        ErrorAssignTrackingOnPurchLineAfterCalcSubcontractOrderAndCarryOutForProdOrderWithTracking           127668
        PostPurchOrderWithCalcSubcontractOrderAndCarryOutForProdOrderWithTracking                            127668
        CalcSubcontractOrderForReleasedProductionOrderWithLocationAndTracking                                127668
        StartingDateOnProdOrderRoutingLineForReleasedProdOrderSchedulingBack                                 127672
        EndingDateOnProdOrderRoutingLineForReleasedProdOrderSchedulingForward                                127672
        CostAmountActualAfterPostConsumptionForReleasedProductionOrder                                       127580
        CostAmountActualAfterPostConsumptionAndOutputForReleasedProductionOrder                              127580

        Covers Test Cases for WI - 302712
        -------------------------------------------------------------------------------------
        Test Function Name                                                             TFS ID
        -------------------------------------------------------------------------------------
        FirmPlannedProductionOrderWithFamily                                           127675
        TotalCostOnFinishedProductionOrderStatisticsPageForFamily                      127675
        UnitOfMeasureOnWhseReceiptWithLocation                                         142005
        UnitOfMeasureOnWhsePutAwayWithLocation                                         142005
        NewUnitOfMeasureOnWhsePickForReleasedProdOrder                                 142005
        NewUnitOfMeasureOnRegisteredWhsePutAwayWithProductionBOM                       142005

        Covers Test Cases for WI - 302715
        -------------------------------------------------------------------------------------------------
        Test Function Name                                                                        TFS ID
        -------------------------------------------------------------------------------------------------
        OutputEntryOnProductionJournalForReleasedProductionOrder                                  262061
        ConsumptionEntryOnProductionJournalForProductionOrderAfterCreateAndRegisterPick           262061
        InventoryPickForProductionOrderWithMultipleComponents                                     232350
        PostedPartialInventoryPickForProductionOrderWithMultipleComponents                        232350
        PostConsumptionCompItemWithBackwardFlushingForReleasedProdOrderError                      143088
        PostOutputAndFinishReleasedProdOrderWithComponentBackwardFlushing                         143088

        Covers Test Cases for WI - 302713
        -------------------------------------------------------------------------------------------------
        Test Function Name                                                                        TFS ID
        -------------------------------------------------------------------------------------------------
        CostAmountActualAfterPostNegativeOutputForProdOrderWithComponentBackwardFlushing          251699
        CostAmountActualAfterPostOutputAndFinishReleasedProdOrderWithComponentBackwardFlushing    251699

        Covers Test Cases for WI - 302714
        -----------------------------------------------------------------------------
        Test Function Name                                                    TFS ID
        -----------------------------------------------------------------------------
        UnitOfMeasureCodeOnProdOrderLineWithBOMVersionCode                    255850

        Covers Test Cases for WI - 308660
        -------------------------------------------------------------------------------------------------
        Test Function Name                                                                        TFS ID
        -------------------------------------------------------------------------------------------------
        QuantityPickedAfterRegisterWhsePickForProductionOrder                                     278493
        WhsePickAfterRefreshProductionOrderForAlreadyPickedItem                                   278493
        WhsePickForReleasedProductionOrderWithItemFlushingPickAndBackward                         266275
        WhseEntryAfterRegisterPickForReleasedProductionOrderWithItemFlushingPickAndBackward       266275
        WhseEntryAfterPutAwayForReleasedProductionOrderWithItemFlushingBackward                   266275
        WhseEntriesAfterRegisterPutAwayForReleasedProductionOrderWithItemFlushingBackward         266275
        ValueEntriesForFinishedProdOrderWithNewUOM                                               297901

        Covers Test cases for Bug: 7690
       -----------------------------------------------------------------------------------------------------------------
        Test Function                                                                                             TFS ID
       ------------------------------------------------------------------------------------------------------------------
       PurchaseLineAfterUpdatingVATBusPostingGroupFromHeader

        Covers Test cases for Sicily Merge Bug
       -----------------------------------------------------------------------------------------------------------------
        Test Function                                                                                             TFS ID
       ------------------------------------------------------------------------------------------------------------------
        PostOutputCorrectionWithRequirePickLocationForItemWithRouting                                       50509
        PostOutputCorrectionWithRequirePickLocationForItemWithoutRouting                                    50509

        Covers Test Cases for WI - 345650
        -----------------------------------------------------------------------------------------------------------------
        Test Function Name                                                                                        TFS ID
        -----------------------------------------------------------------------------------------------------------------
        PostOutputCorrectionWithLocationBinMandatory                                                              345650
        PostOutputCorrectionWithLocationRequirePickWithoutApplyToEntry                                            345650
        PostOutputCorrectionWithLocationRequirePickAndShipmentWithoutApplyToEntry                                 345650
        PostOutputCorrectionWithLocationRequirePickAndItemTracking                                                345650
        PostOutputCorrectionWithLocationRequirePickAndItemTrackingWithoutApplyToItemEntry                         345650
        PostOutputCorrectionWithLocationRequirePickAndShipmentAndItemTrackingWithoutApplyToItemEntry              345650

        Covers Test Cases for WI - 57574
        -----------------------------------------------------------------------------------------------------------------
        Test Function Name                                                                                        TFS ID
        -----------------------------------------------------------------------------------------------------------------
        OutputQtyWithScrapInProductionJournalAfterCreateReleasedProductionOrder                                   57574

        Covers Test Cases for WI - 58909
        -------------------------------------------------------------------------------------
        Test Function Name                                                             TFS ID
        -------------------------------------------------------------------------------------
        ActualCapacityCostOnReleasedProductionOrderStatisticsPage                      58909
        Covers Test Cases for WI
        -------------------------------------------------------------------------------------
        Test Function Name                                                             TFS ID
        -------------------------------------------------------------------------------------
        PostProductionJournalWithItemFlushingPickAndBackward                           72636
        PostProductionJournalAfterChangingUOMOnProdOrdLine                             87929
        PostProductionJournalWithDifferentUOMForConsumption                            88672

        Covers Test Cases for WI - 73514
        -------------------------------------------------------------------------------------
        Test Function Name                                                             TFS ID
        -------------------------------------------------------------------------------------
        CarryOutProductionOrderByPlanningWorksheet                                     73514

        Covers Test Cases for WI
        ---------------------------------------------------------------------------------------
        Test Function Name                                                              TFS ID
        ---------------------------------------------------------------------------------------
        FinishProdOrderWhenBackFlushingConsumptionAndManualOutputWithError              95219
        FinishProdOrderWhenBackFlushingConsumptionAndManualOutputWithUpdateTracking     95219

        Covers Test Cases for Merge bug
        ---------------------------------------------------------------------------------------
        Test Function Name                                                              TFS ID
        ---------------------------------------------------------------------------------------
        ItemAvailByBOMLevelWithMultipleUOM                                              100903

        WhseRequestExistsWhenAddingNewCompWithZeroQty,
        WhsePickRequestExistsWhenAddingNewCompAfterFullyConsumpedComp                   109052
        CannotPostOutputJournalWithChangedOrderLineNo                                   109053
        ItemSubstitutionALLtoALLHasNoDuplications                                       109054
    }
    END.
  }
}

