OBJECT Codeunit 137621 SCM Costing Bugs II
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Permissions=TableData 339=rimd;
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LibraryCosting@1015 : Codeunit 132200;
      LibraryERM@1003 : Codeunit 131300;
      LibraryInventory@1017 : Codeunit 132201;
      LibraryManufacturing@1018 : Codeunit 132202;
      LibraryPurchase@1019 : Codeunit 130512;
      LibrarySales@1016 : Codeunit 130509;
      LibraryWarehouse@1002 : Codeunit 132204;
      LibraryRandom@1004 : Codeunit 130440;
      LibraryPatterns@1001 : Codeunit 132212;
      LibrarySetupStorage@1118 : Codeunit 131009;
      LibraryVariableStorage@1020 : Codeunit 131004;
      Assert@1005 : Codeunit 130000;
      isInitialized@1000 : Boolean;
      TooLowErr@1007 : TextConst 'ENU=is too low';
      InventoryValueErr@1008 : TextConst 'ENU=Inventory value must be 0 after adjustment.';
      ItemNoAdjustedErr@1009 : TextConst 'ENU=Item cost was not adjusted.';
      OutbndEntryIsNotUpdatedErr@1010 : TextConst 'ENU="""Outbound Entry is Updated"" must be TRUE after adjustment."';
      WrongStandardCostVarianceErr@1011 : TextConst 'ENU=Item standard cost variance is incorrect.';
      WrongCostAmountErr@1014 : TextConst '@@@=Field name (Cost Amount (Expected) or Cost Amount (Actual)): Cost Amount (Expected) after adjustment is incorrect;ENU=%1 after adjustment is incorrect';
      InsufficientQtyErr@1038 : TextConst '@@@=%1 - Item No.;ENU=You have insufficient quantity of Item %1';
      STRMENUWasNotCalledTxt@1006 : TextConst 'ENU=STRMENU was not called';
      ValueIsNotPopulatedTxt@1012 : TextConst 'ENU=Value is not populated';

    [Test]
    [HandlerFunctions(ViewAppliedEntriesHandler,ViewUnappliedEntriesModalHandler,ConfirmYesHandler)]
    PROCEDURE TFS219011@1();
    VAR
      ValueEntry@1010 : Record 5802;
      ItemApplicationEntry@1009 : Record 339;
      TempItemLedgerEntry@1008 : TEMPORARY Record 32;
      SalesHeader@1004 : Record 36;
      PurchaseHeader@1003 : Record 38;
      Item@1000 : Record 27;
      ApplicationWorksheet@1005 : TestPage 521;
      Day1@1001 : Date;
      Qty@1002 : Decimal;
    BEGIN
      Initialize;

      // Setup Item.
      LibraryPatterns.MAKEItem(Item,Item."Costing Method"::Average,0,0,0,'');

      // Post negative adjustment for item.
      Day1 := WORKDATE;
      Qty := LibraryRandom.RandIntInRange(2,10);
      LibraryPatterns.POSTNegativeAdjustment(Item,'','','',Qty,Day1,LibraryRandom.RandDec(100,2));
      LibraryPatterns.InsertTempILEFromLast(TempItemLedgerEntry);

      // Post positive adjustment for item.
      LibraryPatterns.POSTPositiveAdjustment(Item,'','','',Qty,Day1,LibraryRandom.RandDec(100,2));

      // Post and invoice Purchase.
      LibraryPatterns.POSTPurchaseOrder(PurchaseHeader,Item,'','',Qty,Day1,LibraryRandom.RandDec(100,2),TRUE,TRUE);

      // Ship and Invoice Sales.
      LibraryPatterns.POSTSalesOrder(SalesHeader,Item,'','',Qty,Day1,LibraryRandom.RandDec(100,2),TRUE,TRUE);

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Remove application between positive and negative adjustment.
      ApplicationWorksheet.OPENEDIT;
      ApplicationWorksheet.FILTER.SETFILTER("Item No.",Item."No.");
      ApplicationWorksheet.FILTER.SETFILTER("Entry Type",FORMAT(TempItemLedgerEntry."Entry Type"::"Positive Adjmt."));
      IF ApplicationWorksheet.FIRST THEN
        ApplicationWorksheet.AppliedEntries.INVOKE;

      // Remove application is executed in the page handler.

      // Reapply from the Unapplied Entries page.
      ApplicationWorksheet.FILTER.SETFILTER("Item No.",Item."No.");
      ApplicationWorksheet.FILTER.SETFILTER("Entry Type",FORMAT(TempItemLedgerEntry."Entry Type"::"Negative Adjmt."));
      IF ApplicationWorksheet.FIRST THEN
        ApplicationWorksheet.UnappliedEntries.INVOKE;

      // On page exit, reapplication of entries is confirmed.
      ApplicationWorksheet.OK.INVOKE;

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Verify.
      // Item Application Entry is generated correctly.
      ItemApplicationEntry.SETRANGE("Outbound Item Entry No.",TempItemLedgerEntry."Entry No.");
      ItemApplicationEntry.FINDFIRST;
      ItemApplicationEntry.TESTFIELD(Quantity,-Qty);
      ItemApplicationEntry.TESTFIELD("Cost Application",TRUE);

      // Value Entries for the reapplied Item Ledger Entry are exempted from average cost calculation.
      ValueEntry.SETRANGE("Item Ledger Entry No.",TempItemLedgerEntry."Entry No.");
      ValueEntry.FINDSET;
      REPEAT
        ValueEntry.TESTFIELD("Valued By Average Cost",FALSE);
      UNTIL ValueEntry.NEXT = 0;

      LibraryCosting.CheckAdjustment(Item);
    END;

    [Test]
    [HandlerFunctions(ViewAppliedEntriesHandler,ConfirmYesHandler)]
    PROCEDURE TFS234879@2();
    VAR
      ValueEntry@1010 : Record 5802;
      ItemApplicationEntry@1009 : Record 339;
      TempItemLedgerEntry@1008 : TEMPORARY Record 32;
      Item@1000 : Record 27;
      ApplicationWorksheet@1003 : TestPage 521;
      Day1@1001 : Date;
      Qty@1002 : Decimal;
    BEGIN
      Initialize;

      // Setup Item.
      LibraryPatterns.MAKEItem(Item,Item."Costing Method"::Average,0,0,0,'');

      Day1 := WORKDATE;
      Qty := LibraryRandom.RandIntInRange(2,10);
      // Post positive adjustment for item.
      LibraryPatterns.POSTPositiveAdjustment(Item,'','','',Qty,Day1,LibraryRandom.RandDec(100,2));

      // Post negative adjustment.
      LibraryPatterns.POSTNegativeAdjustment(Item,'','','',Qty,Day1 + 7,LibraryRandom.RandDec(100,2));

      // Post positive adjustment for item.
      LibraryPatterns.POSTPositiveAdjustment(Item,'','','',Qty,Day1 + 4,LibraryRandom.RandDec(100,2));

      // Post negative adjustment.
      LibraryPatterns.POSTNegativeAdjustment(Item,'','','',Qty,Day1 + 1,LibraryRandom.RandDec(100,2));
      LibraryPatterns.InsertTempILEFromLast(TempItemLedgerEntry);

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Remove application between positive and negative adjustment.
      ApplicationWorksheet.OPENEDIT;
      ApplicationWorksheet.FILTER.SETFILTER("Item No.",Item."No.");
      ApplicationWorksheet.FILTER.SETFILTER("Entry Type",FORMAT(TempItemLedgerEntry."Entry Type"::"Negative Adjmt."));
      IF ApplicationWorksheet.FIRST THEN
        ApplicationWorksheet.AppliedEntries.INVOKE;
      IF ApplicationWorksheet.NEXT THEN
        ApplicationWorksheet.AppliedEntries.INVOKE;

      // Remove application is executed in the page handler.

      // On page exit, reapplication of entries is confirmed.
      ApplicationWorksheet.OK.INVOKE;

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Verify.
      // Item Application Entry is generated correctly.
      ItemApplicationEntry.SETRANGE("Outbound Item Entry No.",TempItemLedgerEntry."Entry No.");
      ItemApplicationEntry.FINDFIRST;
      ItemApplicationEntry.TESTFIELD(Quantity,-Qty);
      ItemApplicationEntry.TESTFIELD("Cost Application",FALSE);

      // Value Entries for the reapplied Item Ledger Entry have the Valuation date equal to Posting date.
      ValueEntry.SETRANGE("Item Ledger Entry No.",TempItemLedgerEntry."Entry No.");
      ValueEntry.FINDSET;
      REPEAT
        ValueEntry.TESTFIELD("Valued By Average Cost",TRUE);
        ValueEntry.TESTFIELD("Valuation Date",TempItemLedgerEntry."Posting Date");
      UNTIL ValueEntry.NEXT = 0;

      LibraryCosting.CheckAdjustment(Item);
    END;

    [Test]
    [HandlerFunctions(UnadjustedEntriesExistMessageHandler,ViewUnappliedEntriesModalHandler)]
    PROCEDURE TFS251070TFS256704@14();
    VAR
      InventorySetup@1001 : Record 313;
      ItemJournalLine@1010 : Record 83;
      TempItemLedgerEntry@1012 : TEMPORARY Record 32;
      ItemJournalBatch@1011 : Record 233;
      ProdOrderLine@1016 : Record 5406;
      CompItem@1000 : Record 27;
      Location@1002 : Record 14;
      ApplicationWorksheet@1004 : TestPage 521;
      Qty@1003 : Decimal;
    BEGIN
      // [FEATURE] [Output Journal] [Production Order]
      // [SCENARIO 251070] Check Adjustment after applying negative Consumption on Production Order
      Initialize;

      // [GIVEN] Setup Parent and Component item.
      // [GIVEN] BOM and Routing.
      // [GIVEN] Purchase Component Item.
      // [GIVEN] Released Production Order.
      LibraryPatterns.SETInventorySetup(
        InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type"::Item,
        InventorySetup."Average Cost Period"::Day);

      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      CreateRelProdOrder(ProdOrderLine,Location.Code,CompItem,Qty);

      // [GIVEN] Post Output.
      LibraryManufacturing.OutputJournalExplodeOrderLineRouting(ItemJournalBatch,ProdOrderLine,WORKDATE);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
      LibraryPatterns.InsertTempILEFromLast(TempItemLedgerEntry);

      // [GIVEN] Post Negative Output applied to previous Output.
      PostNegativeOutput(ItemJournalBatch,ProdOrderLine,Qty,TempItemLedgerEntry."Entry No.");

      // [GIVEN] Post Consumtion Reversal for Component Item
      LibraryPatterns.MAKEConsumptionJournalLine(ItemJournalBatch,ProdOrderLine,CompItem,WORKDATE,Location.Code,'',-Qty,0);
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.FINDFIRST;
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      // [GIVEN] Apply Consumption to Negative Consumption from the Unapplied Entries page.
      ApplicationWorksheet.OPENEDIT;
      ApplicationWorksheet.FILTER.SETFILTER("Item No.",CompItem."No.");
      ApplicationWorksheet.FILTER.SETFILTER("Entry Type",FORMAT(TempItemLedgerEntry."Entry Type"::Consumption));
      ApplicationWorksheet.FILTER.SETFILTER(Positive,FORMAT(TRUE));
      IF ApplicationWorksheet.FIRST THEN
        ApplicationWorksheet.UnappliedEntries.INVOKE;

      // [THEN] Verify Adjustment.
      LibraryCosting.CheckAdjustment(CompItem);
    END;

    [Test]
    PROCEDURE TFS217346@4();
    VAR
      ItemJournalBatch@1011 : Record 233;
      ProductionOrder@1009 : Record 5405;
      ProdOrderLine@1016 : Record 5406;
      PurchaseHeader@1007 : Record 38;
      ProductionBOMHeader@1004 : Record 99000771;
      ParentItem@1001 : Record 27;
      CompItem@1002 : Record 27;
      ProdOrderStatusManagement@1000 : Codeunit 5407;
      Status@1006 : 'Quote,Planned,Firm Planned,Released,Finished';
      Qty@1008 : Decimal;
      QtyPer@1015 : Decimal;
    BEGIN
      Initialize;

      // Setup produced and component item.
      LibraryPatterns.MAKEItem(ParentItem,ParentItem."Costing Method"::Standard,LibraryRandom.RandDec(100,2),0,0,'');
      ParentItem.VALIDATE("Replenishment System",ParentItem."Replenishment System"::"Prod. Order");
      ParentItem.MODIFY;

      LibraryPatterns.MAKEItem(CompItem,CompItem."Costing Method"::FIFO,0,0,0,'');
      CompItem.MODIFY;

      // Setup BOM and Routing.
      QtyPer := LibraryRandom.RandInt(10);
      LibraryPatterns.MAKEProductionBOM(ProductionBOMHeader,ParentItem,CompItem,QtyPer,'');

      // Purchase component item.
      Qty := LibraryRandom.RandInt(100);
      LibraryPatterns.POSTPurchaseOrder(PurchaseHeader,CompItem,'','',Qty * QtyPer,WORKDATE,0,TRUE,FALSE);

      // Released production order.
      LibraryPatterns.MAKEProductionOrder(ProductionOrder,ProductionOrder.Status::Released,ParentItem,'','',Qty,WORKDATE);
      FindProdOrderLine(ProdOrderLine,ProductionOrder);

      // Post output.
      LibraryPatterns.MAKEOutputJournalLine(ItemJournalBatch,ProdOrderLine,WORKDATE,Qty,0);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      // Post consumption.
      LibraryPatterns.MAKEConsumptionJournalLine(ItemJournalBatch,ProdOrderLine,CompItem,WORKDATE,'','',Qty * QtyPer,0);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      // Finish Prod. Order.
      ProdOrderStatusManagement.ChangeStatusOnProdOrder(ProductionOrder,Status::Finished,WORKDATE,FALSE);

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(ParentItem."No." + '|' + CompItem."No.",'');

      // Invoice purchase with a cost.
      LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);
      PurchaseHeader.GET(PurchaseHeader."Document Type",PurchaseHeader."No.");
      PostPurchaseInvoiceWithNewUnitCost(PurchaseHeader,LibraryRandom.RandDec(100,2));

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(ParentItem."No." + '|' + CompItem."No.",'');

      // Verify.
      VerifyPostValueEntryToGL(ProductionOrder);
      LibraryCosting.CheckAdjustment(CompItem);
    END;

    [Test]
    [HandlerFunctions(ViewAppliedEntriesHandler,ViewUnapplEntrSelectNextModalHandler,ConfirmYesHandler)]
    PROCEDURE TFS330379@3();
    VAR
      Item@1000 : Record 27;
      ApplicationWorksheet@1003 : TestPage 521;
      PostingDate@1001 : ARRAY [5] OF Date;
      Interval@1002 : DateFormula;
    BEGIN
      // Repro steps
      Initialize;
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Average,0);

      // Post item journal lines and adjust cost
      EVALUATE(Interval,'<5D>');
      PostingDate[1] := WORKDATE;
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',1,PostingDate[1],1000);
      PostingDate[2] := CALCDATE(Interval,WORKDATE);
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',1,PostingDate[2],1000);
      PostingDate[3] := CALCDATE(Interval,PostingDate[2]);
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',2,PostingDate[3],1200);
      PostingDate[4] := CALCDATE(Interval,PostingDate[3]);
      LibraryPatterns.POSTNegativeAdjustment(Item,'','','',1,PostingDate[4],0);

      AdjustCostAndVerify(Item."No.",1100);

      // Reapply the negative adjustment to the 2nd purchase
      ApplicationWorksheet.OPENEDIT;
      ApplicationWorksheet.FILTER.SETFILTER("Item No.",Item."No.");
      ApplicationWorksheet.FILTER.SETFILTER("Entry Type",FORMAT(3)); // Negative Adjustment
      IF ApplicationWorksheet.FIRST THEN
        ApplicationWorksheet.AppliedEntries.INVOKE; // Remove application is executed in the page handler.

      ApplicationWorksheet.FILTER.SETFILTER("Item No.",Item."No.");
      ApplicationWorksheet.FILTER.SETFILTER("Entry Type",FORMAT(3)); // Negative Adjustment
      IF ApplicationWorksheet.FIRST THEN
        ApplicationWorksheet.UnappliedEntries.INVOKE;
      ApplicationWorksheet.OK.INVOKE;

      AdjustCostAndVerify(Item."No.",3400 / 3);

      // Post Sales of the remaining quantity
      LibraryPatterns.POSTSaleJournal(Item,'','','',3,PostingDate[3],0);

      AdjustCostAndVerify(Item."No.",3400 / 3);
    END;

    [Test]
    [HandlerFunctions(ViewAppliedEntriesHandler,ConfirmYesHandler)]
    PROCEDURE TFS330379NotFixedApplication@7();
    VAR
      Item@1000 : Record 27;
      ApplicationWorksheet@1003 : TestPage 521;
      PostingDate@1001 : ARRAY [5] OF Date;
      Interval@1002 : DateFormula;
    BEGIN
      // Repro steps
      Initialize;
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Average,0);

      // Post item journal lines and adjust cost
      EVALUATE(Interval,'<5D>');
      PostingDate[1] := WORKDATE;
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',1,PostingDate[1],1000);
      PostingDate[2] := CALCDATE(Interval,WORKDATE);
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',1,PostingDate[2],1000);
      PostingDate[3] := CALCDATE(Interval,PostingDate[2]);
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',2,PostingDate[3],1200);
      PostingDate[4] := CALCDATE(Interval,PostingDate[3]);
      LibraryPatterns.POSTNegativeAdjustment(Item,'','','',1,PostingDate[4],0);

      AdjustCostAndVerify(Item."No.",1100);

      // Reapply the negative adjustment by closing worksheet
      ApplicationWorksheet.OPENEDIT;
      ApplicationWorksheet.FILTER.SETFILTER("Item No.",Item."No.");
      ApplicationWorksheet.FILTER.SETFILTER("Entry Type",FORMAT(3)); // Negative Adjustment
      IF ApplicationWorksheet.FIRST THEN
        ApplicationWorksheet.AppliedEntries.INVOKE; // Remove application is executed in the page handler.

      ApplicationWorksheet.OK.INVOKE;

      AdjustCostAndVerify(Item."No.",1100);

      // Post Sales of the remaining quantity
      LibraryPatterns.POSTSaleJournal(Item,'','','',3,PostingDate[3],0);

      AdjustCostAndVerify(Item."No.",1100);
    END;

    [Test]
    PROCEDURE TFS330379ApplyInJnl@5();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1004 : Record 32;
      ItemJournalBatch@1003 : Record 233;
      ItemJournalLine@1005 : Record 83;
      PostingDate@1001 : ARRAY [5] OF Date;
      Interval@1002 : DateFormula;
    BEGIN
      // Same scenario as in TFS330379 - the negative adjustment is applied to 2nd purchase in item journal
      Initialize;
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Average,0);

      // Post item journal lines
      EVALUATE(Interval,'<5D>');
      PostingDate[1] := WORKDATE;
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',1,PostingDate[1],1000);
      PostingDate[2] := CALCDATE(Interval,WORKDATE);
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',1,PostingDate[2],1000);
      PostingDate[3] := CALCDATE(Interval,PostingDate[2]);
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',2,PostingDate[3],1200);

      // Post negative adjustment and make a fixed application to second entry
      PostingDate[4] := CALCDATE(Interval,PostingDate[3]);
      LibraryInventory.CreateItemJournalBatchByType(ItemJournalBatch,0);
      LibraryInventory.MakeItemJournalLine(
        ItemJournalLine,ItemJournalBatch,Item,PostingDate[4],ItemLedgerEntry."Entry Type"::"Negative Adjmt.",1);
      ItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgerEntry.SETRANGE("Posting Date",PostingDate[2]);
      ItemLedgerEntry.FINDFIRST;
      ItemJournalLine."Applies-to Entry" := ItemLedgerEntry."Entry No.";
      ItemJournalLine.INSERT;
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      // Post Sales of the remaining quantity
      LibraryPatterns.POSTSaleJournal(Item,'','','',3,PostingDate[3],0);

      AdjustCostAndVerify(Item."No.",3400 / 3);
    END;

    [Test]
    PROCEDURE TFS330379ApplyInJnlTryManyInbndFixed@11();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1004 : Record 32;
      ItemJournalBatch@1003 : Record 233;
      ItemJournalLine@1005 : Record 83;
      PostingDate@1001 : ARRAY [5] OF Date;
      Interval@1002 : DateFormula;
    BEGIN
      // Same scenario as in TFS330379 - the negative adjustment is applied to 2nd purchase in item journal
      Initialize;
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Average,0);

      // Post item journal lines
      EVALUATE(Interval,'<5D>');
      PostingDate[1] := WORKDATE;
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',1,PostingDate[1],1000);
      PostingDate[2] := CALCDATE(Interval,WORKDATE);
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',1,PostingDate[2],1000);
      PostingDate[3] := CALCDATE(Interval,PostingDate[2]);
      LibraryPatterns.POSTPurchaseJournal(Item,'','','',2,PostingDate[3],1200);

      // Post negative adjustment and make a fixed application to second purchase
      // The negative quantity should be higher than the purchase
      PostingDate[4] := CALCDATE(Interval,PostingDate[3]);
      LibraryInventory.CreateItemJournalBatchByType(ItemJournalBatch,0);
      LibraryInventory.MakeItemJournalLine(
        ItemJournalLine,ItemJournalBatch,Item,PostingDate[4],ItemLedgerEntry."Entry Type"::"Negative Adjmt.",3);
      ItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgerEntry.SETRANGE("Posting Date",PostingDate[2]);
      ItemLedgerEntry.FINDFIRST;
      ItemJournalLine."Applies-to Entry" := ItemLedgerEntry."Entry No."; // Quantity in ILE cannot cover negative adjustment
      ItemJournalLine.INSERT;

      ASSERTERROR LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
      Assert.ExpectedError(TooLowErr);
    END;

    [Test]
    [HandlerFunctions(ViewAppliedEntriesHandler,ViewUnapplEntrSelectNextModalHandler,ConfirmYesHandler)]
    PROCEDURE NoErrorWhenCloseApplicationWorksheetPage@111();
    VAR
      Item@1000 : Record 27;
      TempItemLedgerEntry@1001 : TEMPORARY Record 32;
      ApplicationWorksheet@1005 : TestPage 521;
    BEGIN
      Initialize;

      // [GIVEN] Set Automatic Cost Adjustment = Always
      LibraryInventory.SetAutomaticCostAdjmtAlways;

      // [GIVEN] Create Item and update Inventory
      CreateItemAndUpdateInventory(Item);

      // [GIVEN] Remove application between positive and negative adjustment.
      ApplicationWorksheet.OPENEDIT;
      LibraryPatterns.InsertTempILEFromLast(TempItemLedgerEntry);
      FindApplicationWorksheetLine(ApplicationWorksheet,Item."No.",FORMAT(TempItemLedgerEntry."Entry Type"::"Negative Adjmt."));
      ApplicationWorksheet.AppliedEntries.INVOKE;

      // Remove application is executed in the ViewAppliedEntriesHandler.

      // [GIVEN] Click Unapplied Entries button on the Application Worksheet page.
      FindApplicationWorksheetLine(ApplicationWorksheet,Item."No.",FORMAT(TempItemLedgerEntry."Entry Type"::"Negative Adjmt."));
      ApplicationWorksheet.UnappliedEntries.INVOKE;

      // [GIVEN] Select 2nd entry, click OK to Reapply.
      // Executed in the ViewUnapplEntrSelectNextModalHandler.

      // [GIVEN] Click OK button on the Application Worksheet page.
      ApplicationWorksheet.OK.INVOKE;

      // [WHEN] Click Yes to confirm reapplication message.
      // Executed in the ReapplyOpenEntriesConfirmHandler.

      // [THEN] Application Worksheet close without error message.
      // [THEN] Item is not blocked by Application Worksheet.
      Item.FIND;
      Item.TESTFIELD("Application Wksh. User ID",'');
    END;

    [Test]
    PROCEDURE TFS354142_RoundingAfterTwoAdjustments@12();
    VAR
      Item@1000 : Record 27;
      Quantity@1001 : Decimal;
      CostAmount@1002 : Decimal;
    BEGIN
      Initialize;
      LibraryPatterns.MAKEItem(Item,Item."Costing Method"::FIFO,0,0,0,'');

      Quantity := 3;
      CostAmount := 10;
      PostPositiveAdjustment(Item,'',Quantity,CostAmount,0);

      PostNegativeAdjmtAndVerify(Item,Item."Unit Cost",1);
      VerifyOutboudEntriesUpdated(Item."No.");
    END;

    [Test]
    PROCEDURE TFS354142_AdjmtRoundingPartialShipmentApplication@16();
    VAR
      Item@1002 : Record 27;
      I@1000 : Integer;
      Quantity@1003 : Decimal;
      CostAmount@1001 : Decimal;
    BEGIN
      Initialize;
      Quantity := 3;
      CostAmount := 10;
      LibraryPatterns.MAKEItem(Item,Item."Costing Method"::FIFO,0,0,0,'');
      FOR I := 1 TO 3 DO
        PostPositiveAdjustment(Item,'',Quantity,CostAmount,0);

      PostNegativeAdjmtAndVerify(Item,Item."Unit Cost",7);
    END;

    [Test]
    [HandlerFunctions(ConfirmYesHandler)]
    PROCEDURE TFS355737_AdjmtRoundingAfterReturn@1171();
    VAR
      ItemNo@1000 : Code[20];
      OrderNo@1001 : Code[20];
      InventoryQty@1002 : Decimal;
      InventoryAmt@1003 : Decimal;
    BEGIN
      InventoryQty := LibraryRandom.RandIntInRange(100,200);
      InventoryAmt := LibraryRandom.RandDecInRange(100,200,2);

      ItemNo := CreateItemPostPositiveAdjmt(InventoryQty,InventoryAmt);
      OrderNo := CreateOrderAndShip(ItemNo,InventoryQty - 1);
      UndoSalesShipment(OrderNo);
      ChangeSalesLineQuantityAndPost(OrderNo,InventoryQty);

      LibraryCosting.AdjustCostItemEntries(ItemNo,'');

      VerifyInventoryAmountIsZero(ItemNo);
    END;

    [Test]
    [HandlerFunctions(ConfirmYesHandler)]
    PROCEDURE TFS356239_ShipAndReturnOnNegativeInventory@25();
    VAR
      Item@1000 : Record 27;
      Qty@1003 : Integer;
      Amt@1004 : Decimal;
    BEGIN
      Qty := LibraryRandom.RandIntInRange(10,20);
      Amt := LibraryRandom.RandDec(100,2);

      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Average,0);

      PostSalesShipmentAndUndo(Item,Qty,Amt);
      PostSalesShipmentAndUndo(Item,Qty + 1,Amt);

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      Assert.IsTrue(Item."Cost is Adjusted",ItemNoAdjustedErr);
    END;

    [Test]
    PROCEDURE TFS359257_VerifyStandardCostVarianceRounding@27();
    VAR
      Item@1002 : Record 27;
    BEGIN
      ReadjustStandardCostItem(Item);
      VerifyItemStandardCost(Item."No.");
    END;

    [Test]
    PROCEDURE TFS359257_VerifyStandardCostVarianceRoundingACY@28();
    VAR
      Item@1002 : Record 27;
      CurrencyCode@1012 : Code[10];
      CurrExchRate@1000 : Decimal;
    BEGIN
      CurrExchRate := LibraryRandom.RandDecInRange(5,10,2);
      CurrencyCode := LibraryERM.CreateCurrencyWithExchangeRate(WORKDATE,CurrExchRate,CurrExchRate);
      LibraryERM.SetAddReportingCurrency(CurrencyCode);

      ReadjustStandardCostItem(Item);
      VerifyItemStandardCostACY(Item."No.",CurrencyCode);
    END;

    [Test]
    PROCEDURE TFS359756_AdjustCostRoundingAfterTwoAdjmts@43();
    VAR
      Item@1000 : Record 27;
      PurchaseHeader@1001 : Record 38;
    BEGIN
      // Verify that adjustment rounding is posted after the purchase is completely invoiced

      SaleReceivedAndTransferredItem(Item,PurchaseHeader);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE);

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      VerifyInventoryAmountIsZero(Item."No.");
    END;

    [Test]
    PROCEDURE TFS359532_OpenEntriesWithNoCostingChainExcluded@77();
    VAR
      Item@1000 : Record 27;
      InventorySetup@1001 : Record 313;
      SalesHeader@1002 : Record 36;
      SalesLine@1003 : Record 37;
      LocationBlue@1004 : Record 14;
      LocationRed@1005 : Record 14;
      BaseQty@1006 : Integer;
      SaleQty@1008 : Integer;
      UnitCost@1007 : Decimal;
    BEGIN
      Initialize;

      WITH InventorySetup DO
        LibraryPatterns.SETInventorySetup(
          "Automatic Cost Adjustment"::Never,"Average Cost Calc. Type"::Item,
          "Average Cost Period"::Day);

      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Average,0);

      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(LocationBlue);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(LocationRed);

      BaseQty := LibraryRandom.RandIntInRange(50,100);
      SaleQty := BaseQty * 4;
      UnitCost := LibraryRandom.RandDecInRange(100,200,2);

      LibraryPatterns.MAKESalesOrder(SalesHeader,SalesLine,Item,LocationBlue.Code,'',SaleQty,WORKDATE,0);
      MakeSalesLine(SalesHeader,Item."No.",BaseQty * 2);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);

      LibraryPatterns.POSTPositiveAdjustment(Item,LocationRed.Code,'','',BaseQty * 2,CALCDATE('<1D>',WORKDATE),UnitCost);
      LibraryPatterns.POSTReclassificationJournalLine(
        Item,CALCDATE('<2D>',WORKDATE),LocationRed.Code,LocationBlue.Code,'','','',BaseQty);

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      VerifyILECostAmount(Item."No.",-SaleQty * UnitCost);
    END;

    [Test]
    PROCEDURE ACIEPurchaseReturnWithValuationDateOtherThanPostingAppliedToTransfer@45();
    VAR
      Item@1000 : Record 27;
      Location@1001 : ARRAY [2] OF Record 14;
      ItemJnlTemplate@1005 : Record 82;
      ItemJnlLine@1006 : Record 83;
      ItemLedgEntry@1007 : Record 32;
      Amount@1008 : ARRAY [2] OF Decimal;
      ExpectedCost@1009 : Decimal;
    BEGIN
      // [FEATURE] [Adjust Cost Item Entries]
      // [SCENARIO 371768] Item ledger entries receive average cost when a purchase return having valuation date earlier than its posting date, is applied to a transfer

      Amount[1] := 3.33333;
      Amount[2] := 7.73737;

      // [GIVEN] Item "I" with "Average" costign method
      LibraryPatterns.MAKEItem(Item,Item."Costing Method"::Average,0,0,0,'');

      // [GIVEN] 2 locations: "L1", "L2"
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location[1]);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location[2]);

      // [GIVEN] Item "I" is received on "L1" location (2 pcs + 3 pcs with different cost amount)
      // [GIVEN] 2 psc of item "I" are sold from location "L1"
      LibraryPatterns.POSTPositiveAdjustment(Item,Location[1].Code,'','',3,WORKDATE,Amount[1]);
      LibraryPatterns.POSTPositiveAdjustment(Item,Location[1].Code,'','',2,WORKDATE,Amount[2]);
      LibraryPatterns.POSTNegativeAdjustment(Item,Location[1].Code,'','',2,WORKDATE,Amount[1]);

      // [GIVEN] 2 pcs of item "I" are moved from location "L1" to "L2", Posting Date = WORKDATE + 1 day
      PostItemJournalTransfer(Item,Location[1].Code,Location[2].Code,2,CALCDATE('<1D>',WORKDATE));
      // [GIVEN] 2 pcs of item "I" are moved from location "L2" to "L1", Posting Date = WORKDATE + 1 day
      PostItemJournalTransfer(Item,Location[2].Code,Location[1].Code,2,CALCDATE('<1D>',WORKDATE));

      // [GIVEN] Post purchase return of 2 pcs of item "I" and apply to the transfer entry, Posting Date = WORKDATE + 2 days
      ItemLedgEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgEntry.SETRANGE("Entry Type",ItemLedgEntry."Entry Type"::Transfer);
      ItemLedgEntry.FINDLAST;
      LibraryPatterns.POSTItemJournalLineWithApplication(
        ItemJnlTemplate.Type::Item,ItemJnlLine."Entry Type"::Purchase,Item,Location[1].Code,'',-2,
        CALCDATE('<2D>',WORKDATE),Amount[1],ItemLedgEntry."Entry No.");

      // [WHEN] Adjust Cost - Item Entries
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // [THEN] Average cost amount on WORKDATE is equal to average cost amount on WORKDATE + 2 days
      WITH ItemLedgEntry DO BEGIN
        SETRANGE("Item No.",Item."No.");
        SETRANGE("Entry Type","Entry Type"::"Negative Adjmt.");
        FINDFIRST;
        CALCFIELDS("Cost Amount (Actual)");
        ExpectedCost := "Cost Amount (Actual)";

        SETRANGE("Entry Type","Entry Type"::Purchase);
        FINDFIRST;
        CALCFIELDS("Cost Amount (Actual)");
        TESTFIELD("Cost Amount (Actual)",ExpectedCost);
      END;
    END;

    [Test]
    PROCEDURE AdjustRevaluedTransferWithStandardCost@46();
    VAR
      GLSetup@1005 : Record 98;
      Item@1000 : Record 27;
      Location1@1002 : Record 14;
      Location2@1003 : Record 14;
      PurchaseHeader@1001 : Record 38;
      ReleasePurchDoc@1010 : Codeunit 415;
      StandardCost@1004 : Decimal;
    BEGIN
      // [FEATURE] [Adjust Cost Item Entries] [Partial Revaluation]
      // [SCENARIO 372019] Revalued inbound transfer entry is adjusted correctly for an item with "Standard" costing method

      StandardCost := LibraryRandom.RandIntInRange(100,200);

      // [GIVEN] Item "I" with "Standard" costing method, standard cost = "X"
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Standard,StandardCost);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location1);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location2);

      // [GIVEN] Purchase order for 3 pcs of item "I" on location "L1". Order is posted as received, not invoiced
      LibraryPatterns.POSTPurchaseOrder(PurchaseHeader,Item,Location1.Code,'',3,WORKDATE,Item."Unit Cost",TRUE,FALSE);
      // [GIVEN] Move 3 pcs of item "I" from location "L1" to location "L2"
      LibraryPatterns.POSTReclassificationJournalLine(Item,WORKDATE,Location1.Code,Location2.Code,'','','',3);
      // [GIVEN] Sell 1 item, posting date = WORKDATE + 1
      LibraryPatterns.POSTNegativeAdjustment(Item,Location2.Code,'','',1,CALCDATE('<1D>',WORKDATE),StandardCost * 2);

      // [GIVEN] Remaining 2 pcs of item "I" are revalued on WORKDATE + 2, revalued unit cost = "X" * 1.1
      PostRevaluationJournalLine(Item,CALCDATE('<2D>',WORKDATE),StandardCost * 1.1);
      // [GIVEN] 1 item is sold on WORKDATE + 3
      LibraryPatterns.POSTNegativeAdjustment(Item,Location2.Code,'','',1,CALCDATE('<3D>',WORKDATE),StandardCost * 2);

      // [GIVEN] Purchase order is invoiced, cost adjusted
      ReleasePurchDoc.Reopen(PurchaseHeader);
      PostPurchaseInvoiceWithNewUnitCost(PurchaseHeader,StandardCost * 3);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // [GIVEN] The last remaining item is revalued, new cost = "X" * 1.2
      PostRevaluationJournalLine(Item,CALCDATE('<4D>',WORKDATE),StandardCost * 1.2);
      // [GIVEN] Last item is sold
      LibraryPatterns.POSTNegativeAdjustment(Item,Location2.Code,'','',1,CALCDATE('<5D>',WORKDATE),StandardCost * 2);

      // [WHEN] Run "Adjust Cost - Item Entries"
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // [THEN] Cost amount in the inbound transfer entry on location "L2" is "X" * 3.4 (= 2 * 1.1 * X + 1.2 * X)
      GLSetup.GET;
      VerifyRevaluedTransferCostAmount(Item."No.",Location2.Code,ROUND(StandardCost * 3.4,GLSetup."Amount Rounding Precision"));
    END;

    [Test]
    PROCEDURE ConsumptionCreatingLoopFailsOnDifferentLocations@49();
    VAR
      Item@1000 : Record 27;
      ProdOrder@1002 : Record 5405;
      ProdOrderLine@1003 : ARRAY [2] OF Record 5406;
      LocationBlue@1004 : Record 14;
      LocationRed@1005 : Record 14;
    BEGIN
      // [FEATURE] [Manufacturing]
      // [SCENARIO 375615] It is not allowed to post prod. order consumption that would create loop in cost application on 2 different locations

      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(LocationBlue);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(LocationRed);

      // [GIVEN] Item "I"
      LibraryInventory.CreateItem(Item);

      // [GIVEN] Production order "P1" producing 2 pcs of item "I" on "Red" location
      LibraryManufacturing.CreateProductionOrder(ProdOrder,ProdOrder.Status::Released,ProdOrder."Source Type"::Item,Item."No.",2);
      ProdOrder.VALIDATE("Location Code",LocationRed.Code);
      ProdOrder.MODIFY(TRUE);
      LibraryManufacturing.RefreshProdOrder(ProdOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      FindProdOrderLine(ProdOrderLine[1],ProdOrder);

      // [GIVEN] Stock of 1 item "I" on "Blue" location
      LibraryPatterns.POSTPositiveAdjustment(Item,LocationBlue.Code,'','',1,WORKDATE,0);
      // [GIVEN] Post output of 2 pcs of item "I" on "Red" location
      LibraryPatterns.POSTOutput(ProdOrderLine[1],2,WORKDATE,Item."Unit Cost");

      // [GIVEN] Production order "P2" consuming and producing the same item "I" on "Blue" location
      LibraryManufacturing.CreateProductionOrder(ProdOrder,ProdOrder.Status::Released,ProdOrder."Source Type"::Item,Item."No.",2);
      ProdOrder.VALIDATE("Location Code",LocationBlue.Code);
      ProdOrder.MODIFY(TRUE);
      LibraryManufacturing.RefreshProdOrder(ProdOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      FindProdOrderLine(ProdOrderLine[2],ProdOrder);

      // [GIVEN] Consume 2 pcs of item "I" from "Red" location for order "P2"
      LibraryPatterns.POSTConsumption(ProdOrderLine[2],Item,LocationRed.Code,'',2,WORKDATE,Item."Unit Cost");
      // [GIVEN] Post output of 2 pcs of item "I" on "Blue" location for order "P2"
      LibraryPatterns.POSTOutput(ProdOrderLine[2],2,WORKDATE,Item."Unit Cost");

      // [WHEN] Try to consume 2 pcs of item "I" from "Blue" location for production order "P1"
      ASSERTERROR LibraryPatterns.POSTConsumption(ProdOrderLine[1],Item,LocationBlue.Code,'',2,WORKDATE,Item."Unit Cost");
      // [THEN] Receive an error message "Insufficient quantity of item I", since this consumption would create a loop in cost application
      Assert.ExpectedError(STRSUBSTNO(InsufficientQtyErr,Item."No."));
    END;

    [Test]
    PROCEDURE ConsumptionCreatingLoopFailsOnOneLocation@53();
    VAR
      Item@1000 : Record 27;
      ProdOrder@1002 : Record 5405;
      ProdOrderLine@1003 : ARRAY [2] OF Record 5406;
    BEGIN
      // [FEATURE] [Manufacturing]
      // [SCENARIO 375615] It is not allowed to post prod. order consumption that would create loop in cost application on one location

      // [GIVEN] Item "I"
      LibraryInventory.CreateItem(Item);

      // [GIVEN] Production Order "P1" producing item "I"
      LibraryManufacturing.CreateProductionOrder(ProdOrder,ProdOrder.Status::Released,ProdOrder."Source Type"::Item,Item."No.",1);
      LibraryManufacturing.RefreshProdOrder(ProdOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      FindProdOrderLine(ProdOrderLine[1],ProdOrder);
      // [GIVEN] Post output of 1 pcs of item "I"
      LibraryPatterns.POSTOutput(ProdOrderLine[1],1,WORKDATE,Item."Unit Cost");

      // [GIVEN] Post inventory stock of 1 item "I"
      LibraryPatterns.POSTPositiveAdjustment(Item,'','','',1,WORKDATE,0);

      // [GIVEN] Production order "P2" producing and consuming item "I"
      LibraryManufacturing.CreateProductionOrder(ProdOrder,ProdOrder.Status::Released,ProdOrder."Source Type"::Item,Item."No.",1);
      LibraryManufacturing.RefreshProdOrder(ProdOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      FindProdOrderLine(ProdOrderLine[2],ProdOrder);
      // [GIVEN] Consume item "I" in order "P2"
      LibraryPatterns.POSTConsumption(ProdOrderLine[2],Item,'','',1,WORKDATE,Item."Unit Cost");
      // [GIVEN] Post output of item "I" in order "P2"
      LibraryPatterns.POSTOutput(ProdOrderLine[2],1,WORKDATE,Item."Unit Cost");

      // [WHEN] Try posting consumption of item "I" for production order "P1"
      ASSERTERROR LibraryPatterns.POSTConsumption(ProdOrderLine[1],Item,'','',2,WORKDATE,Item."Unit Cost");

      // [THEN] Receive an error message "Insufficient quantity of item I", since this consumption would create a loop in cost application
      Assert.ExpectedError(STRSUBSTNO(InsufficientQtyErr,Item."No."));
    END;

    [Test]
    PROCEDURE TwoConsumptionsCycle@58();
    VAR
      Item@1000 : Record 27;
      ProductionOrder@1001 : ARRAY [3] OF Record 5405;
      ItemJournalBatchCons@1003 : Record 233;
      ItemJournalBatchOutput@1004 : Record 233;
      ItemJournalLine@1005 : Record 83;
      I@1002 : Integer;
    BEGIN
      // [FEATURE] [Adjust Cost - Item Entries]
      // [SCENARIO 381650] Posting of two consumption entries in one batch, when only the second entry creates a cycle in cost application, should fail

      // [GIVEN] Item "I"
      LibraryInventory.CreateItem(Item);

      // [GIVEN] 3 released production orders "P1", "P2" and "P3". Source item is "I" for all orders.
      FOR I := 1 TO 3 DO BEGIN
        LibraryManufacturing.CreateProductionOrder(
          ProductionOrder[I],ProductionOrder[I].Status::Released,ProductionOrder[I]."Source Type"::Item,Item."No.",2);
        LibraryManufacturing.RefreshProdOrder(ProductionOrder[I],FALSE,TRUE,TRUE,TRUE,FALSE);
      END;

      InitItemJournalBatch(ItemJournalBatchCons,ItemJournalBatchCons."Template Type"::Consumption);
      InitItemJournalBatch(ItemJournalBatchOutput,ItemJournalBatchOutput."Template Type"::Output);

      // [GIVEN] Post output of 1 item "I" in order "P2"
      CreateAndPostOutputJournalLine(ItemJournalBatchOutput,Item."No.",ProductionOrder[2]."No.",1);

      // [GIVEN] Post consumption of 1 item "I" in order "P1"
      CreateAndPostConsumptionJournalLine(ItemJournalBatchCons,Item."No.",ProductionOrder[1]."No.",1);

      // [GIVEN] Post output of 1 item "I" in order "P1"
      CreateAndPostOutputJournalLine(ItemJournalBatchOutput,Item."No.",ProductionOrder[1]."No.",1);

      // [GIVEN] Post output of 1 item "I" in order "P1"
      CreateAndPostOutputJournalLine(ItemJournalBatchOutput,Item."No.",ProductionOrder[1]."No.",1);

      // [GIVEN] Create consumption journal line - 1 item "I" in order "P3"
      CreateConsumptionJournalLine(ItemJournalLine,ItemJournalBatchCons,ProductionOrder[3]."No.",Item."No.",1);
      // [GIVEN] Create consumption journal line - 1 item "I" in order "P2"
      CreateConsumptionJournalLine(ItemJournalLine,ItemJournalBatchCons,ProductionOrder[2]."No.",Item."No.",1);

      // [WHEN] Post consumption journal
      ASSERTERROR LibraryManufacturing.PostConsumptionJournal;

      // [THEN] Error is raised: "You have insufficient quantity of Item I on inventory"
      Assert.ExpectedError(STRSUBSTNO(InsufficientQtyErr,Item."No."));
    END;

    [Test]
    [HandlerFunctions(UnadjustedEntriesExistMessageHandler)]
    PROCEDURE CheckConsumptionAfterPostingNegativeOutput@50();
    VAR
      Location@1002 : Record 14;
      ItemLedgerEntry@1003 : Record 32;
      ItemJournalBatch@1004 : Record 233;
      ProdOrderLine@1005 : Record 5406;
      TempItemLedgerEntry@1008 : TEMPORARY Record 32;
      CompItem@1001 : Record 27;
      InventorySetup@1006 : Record 313;
      Qty@1000 : Decimal;
    BEGIN
      // [FEATURE] [Output Journal] [Production Order]
      // [SCENARIO 376642] No Consupmtion should be posted for Journal Line with negative "Output Quantity"
      Initialize;

      // [GIVEN] Released Prod Order
      LibraryPatterns.SETInventorySetup(
        InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type"::Item,
        InventorySetup."Average Cost Period"::Day);

      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      CreateRelProdOrder(ProdOrderLine,Location.Code,CompItem,Qty);

      // [GIVEN] Post Output
      LibraryManufacturing.OutputJournalExplodeOrderLineRouting(ItemJournalBatch,ProdOrderLine,WORKDATE);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
      LibraryPatterns.InsertTempILEFromLast(TempItemLedgerEntry);

      // [WHEN] Post Negative Output applied to previous Output
      PostNegativeOutput(ItemJournalBatch,ProdOrderLine,Qty,TempItemLedgerEntry."Entry No.");

      // [THEN] Consumtion is not posted for Component Item
      WITH ItemLedgerEntry DO BEGIN
        SETRANGE("Item No.",CompItem."No.");
        SETRANGE(Positive,TRUE);
        SETRANGE("Entry Type","Entry Type"::Consumption);
        Assert.RecordIsEmpty(ItemLedgerEntry);
      END;
    END;

    [Test]
    PROCEDURE ItemEntriesReappliedOnApplWorksheetCrashAndOpenBack@51();
    VAR
      Item@1000 : Record 27;
      PositiveItemLedgerEntry@1003 : Record 32;
      NegativeItemLedgerEntry@1005 : Record 32;
      ApplicationWorksheet@1004 : TestPage 521;
    BEGIN
      // [FEATURE] [Application Worksheet]
      // [SCENARIO 380140] Item Ledger Entries that are unapplied by Application Worksheet and not reapplied back due to a its accidental crash, are reapplied back on next opening of the Worksheet.
      Initialize;

      // [GIVEN] Posted positive and negative Item Ledger Entries applied to each other.
      // [GIVEN] Item Ledger Entries are unapplied with Application Worksheet.
      LibraryInventory.CreateItem(Item);
      PostAndUnapplyPositiveAndNegativeAdjustments(
        Item,LibraryRandom.RandInt(20),PositiveItemLedgerEntry,NegativeItemLedgerEntry,TRUE);

      // [GIVEN] Item is blocked by Application Worksheet.
      BlockItemWithApplWorksheet(Item);

      // [WHEN] Open Application Worksheet.
      ApplicationWorksheet.OPENVIEW;

      // [THEN] Item Ledger Entries are applied back.
      PositiveItemLedgerEntry.FIND;
      PositiveItemLedgerEntry.TESTFIELD("Remaining Quantity",PositiveItemLedgerEntry.Quantity + NegativeItemLedgerEntry.Quantity);
      NegativeItemLedgerEntry.FIND;
      NegativeItemLedgerEntry.TESTFIELD("Remaining Quantity",0);

      // [THEN] Item is not blocked by Application Worksheet.
      Item.FIND;
      Item.TESTFIELD("Application Wksh. User ID",'');

      // [THEN] Item Application Entry History is cleared off.
      VeriryItemApplicationEntryHistory(PositiveItemLedgerEntry);
      VeriryItemApplicationEntryHistory(NegativeItemLedgerEntry);
    END;

    [Test]
    PROCEDURE CostAdjustedAndItemReleasedOnApplWorksheetOpen@37();
    VAR
      Item@1000 : Record 27;
      PosItemLedgerEntry@1008 : ARRAY [2] OF Record 32;
      NegItemLedgerEntry@1009 : ARRAY [2] OF Record 32;
      ItemJnlPostLine@1006 : Codeunit 22;
      ApplicationWorksheet@1004 : TestPage 521;
      Quantity@1007 : Decimal;
    BEGIN
      // [FEATURE] [Application Worksheet]
      // [SCENARIO 380525] Cost of Item Ledger Entries that is not adjusted due to an accidental crash of Application Worksheet is adjusted on the next opening of the Worksheet. Blocked items are released.
      Initialize;

      // [GIVEN] Automatic Cost Adjustment = Always in Inventory Setup.
      LibraryInventory.SetAutomaticCostAdjmtAlways;

      // [GIVEN] Posted two pairs of positive and negative Item Ledger Entries ("E1+", "E1-"), ("E2+", "E2-").
      LibraryInventory.CreateItem(Item);
      Quantity := LibraryRandom.RandInt(20);
      PostPositiveAndNegativeEntries(Item,Quantity,PosItemLedgerEntry[1],NegItemLedgerEntry[1]);
      PostPositiveAndNegativeEntries(Item,Quantity,PosItemLedgerEntry[2],NegItemLedgerEntry[2]);

      // [GIVEN] Both pairs of Item Ledger Entries are unapplied with Application Worksheet.
      UnapplyItemLedgerEntries(PosItemLedgerEntry[1]."Entry No.",NegItemLedgerEntry[1]."Entry No.",TRUE);
      UnapplyItemLedgerEntries(PosItemLedgerEntry[2]."Entry No.",NegItemLedgerEntry[2]."Entry No.",TRUE);

      // [GIVEN] Item is blocked by Application Worksheet.
      BlockItemWithApplWorksheet(Item);

      // [GIVEN] Item Ledger Entries are applied back criss-cross ("E1+" to "E2-", "E2+" to "E1-").
      ItemJnlPostLine.ReApply(PosItemLedgerEntry[1],NegItemLedgerEntry[2]."Entry No.");
      ItemJnlPostLine.ReApply(PosItemLedgerEntry[2],NegItemLedgerEntry[1]."Entry No.");

      // [WHEN] Open Application Worksheet.
      ApplicationWorksheet.OPENVIEW;

      // [THEN] Cost of negative entries "E1-" and "E2-" is adjusted.
      VerifyItemLedgerEntriesCostEquality(PosItemLedgerEntry[1],NegItemLedgerEntry[2]);
      VerifyItemLedgerEntriesCostEquality(PosItemLedgerEntry[2],NegItemLedgerEntry[1]);

      // [THEN] Item is not blocked by Application Worksheet.
      Item.FIND;
      Item.TESTFIELD("Application Wksh. User ID",'');
    END;

    [Test]
    PROCEDURE ItemEntriesNotReappliedOnApplWorksheetOpenIfTheyNotUnappliedByTheWorksheet@112();
    VAR
      Item@1000 : Record 27;
      PositiveItemLedgerEntry@1003 : Record 32;
      NegativeItemLedgerEntry@1005 : Record 32;
      ApplicationWorksheet@1004 : TestPage 521;
    BEGIN
      // [FEATURE] [Application Worksheet]
      // [SCENARIO 380140] Item Ledger Entries that are unapplied not by Application Worksheet, remain unapplied on next opening of the Worksheet.
      Initialize;

      // [GIVEN] Posted positive and negative Item Ledger Entries applied to each other.
      // [GIVEN] Item Ledger Entries are unapplied not with Application Worksheet.
      LibraryInventory.CreateItem(Item);
      PostAndUnapplyPositiveAndNegativeAdjustments(
        Item,LibraryRandom.RandInt(20),PositiveItemLedgerEntry,NegativeItemLedgerEntry,FALSE);

      // [WHEN] Open Application Worksheet.
      ApplicationWorksheet.OPENVIEW;

      // [THEN] Item Ledger Entries are not applied.
      WITH PositiveItemLedgerEntry DO BEGIN
        FIND;
        TESTFIELD("Remaining Quantity",Quantity);
      END;

      WITH NegativeItemLedgerEntry DO BEGIN
        FIND;
        TESTFIELD("Remaining Quantity",Quantity);
      END;

      // [THEN] Item is not blocked by Application Worksheet.
      Item.FIND;
      Item.TESTFIELD("Application Wksh. User ID",'');
    END;

    [Test]
    [HandlerFunctions(ViewAppliedEntriesHandler,ConfirmYesHandler)]
    PROCEDURE SavedItemApplHistoryEntriesAreClearedOffOnClosingApplicationWorksheet@63();
    VAR
      Item@1003 : Record 27;
      PositiveItemLedgerEntry@1002 : Record 32;
      NegativeItemLedgerEntry@1001 : Record 32;
      ApplicationWorksheet@1000 : TestPage 521;
    BEGIN
      // [FEATURE] [Application Worksheet]
      // [SCENARIO 380140] Item Application Entry History in which unapplied Item Entries are saved for reapplication in case of a sudden crash, is cleared off when Application Worksheet is safely closed.
      Initialize;

      // [GIVEN] Posted positive and negative Item Ledger Entries applied to each other.
      LibraryInventory.CreateItem(Item);
      PostPositiveAndNegativeEntries(Item,LibraryRandom.RandInt(20),PositiveItemLedgerEntry,NegativeItemLedgerEntry);

      // [GIVEN] Item Ledger Entries are unapplied by Application Worksheet.
      // Remove application is done in the page handler.
      ApplicationWorksheet.OPENEDIT;
      ApplicationWorksheet.FILTER.SETFILTER("Item No.",Item."No.");
      ApplicationWorksheet.FILTER.SETFILTER("Entry Type",FORMAT(PositiveItemLedgerEntry."Entry Type"));
      IF ApplicationWorksheet.FIRST THEN
        ApplicationWorksheet.AppliedEntries.INVOKE;

      // [WHEN] Close the Application Worksheet.
      ApplicationWorksheet.OK.INVOKE;

      // [THEN] Item Application Entry History is cleared off.
      VeriryItemApplicationEntryHistory(PositiveItemLedgerEntry);
      VeriryItemApplicationEntryHistory(NegativeItemLedgerEntry);
    END;

    [Test]
    [HandlerFunctions(ChargeAssignmentStrMenuHandler)]
    PROCEDURE CheckSuggestAssgntDialogueForReceipt@52();
    VAR
      PurchaseLine@1002 : Record 39;
      ItemChargeAssgntPurch@1000 : Codeunit 5805;
      StrMenuCalled@1001 : Boolean;
    BEGIN
      // [FEATURE] [Item Charge] [Suggest Assignment]
      // [SCENARIO 380487] If all "Item Charge Assignment (Purch)" have "Applies-to Doc. Type" Sales Shipment then Suggest Item Charge Assignment function provides Dialog with Options Equally,Amount.
      Initialize;

      // [GIVEN] "Item Charge Assignment (Purch)" for "Sales Shipment Line"
      CreateItemChargeAssgntPurchForSalesShptLine(PurchaseLine);

      LibraryVariableStorage.Enqueue(StrMenuCalled); // Enque FALSE for handler

      // [WHEN] Suggest Assignment
      ItemChargeAssgntPurch.SuggestAssgnt(PurchaseLine,PurchaseLine.Quantity,PurchaseLine."Line Amount");

      // [THEN] STRMENU occurs
      StrMenuCalled := LibraryVariableStorage.DequeueBoolean; // STRMENU called flag
      Assert.IsTrue(StrMenuCalled,STRMENUWasNotCalledTxt);
    END;

    [Test]
    PROCEDURE CheckSuggestAssgntDialogueForTransferReceipt@54();
    VAR
      PurchaseLine@1003 : Record 39;
      ItemChargeAssignmentPurch@1000 : Record 5805;
      ItemChargeAssgntPurch@1009 : Codeunit 5805;
    BEGIN
      // [FEATURE] [Item Charge] [Suggest Assignment]
      // [SCENARIO 380487] If all "Item Charge Assignment (Purch)" have "Applies-to Doc. Type" Transfer Receipt then Suggest Item Charge Assignment function doesn't provide any Dialog.
      Initialize;

      // [GIVEN] "Item Charge Assignment (Purch)" for "Transfer Receipt Line"
      CreateItemChargeAssgntPurchForTransferReceiptLine(PurchaseLine,ItemChargeAssignmentPurch);

      // [WHEN] Suggest Assignment
      ItemChargeAssgntPurch.SuggestAssgnt(PurchaseLine,PurchaseLine.Quantity,PurchaseLine."Line Amount");

      // [THEN] "Qty. to Assign" is populated. No Dialogue occurs.
      Assert.AreEqual(1,ItemChargeAssignmentPurch."Qty. to Assign",ValueIsNotPopulatedTxt);
    END;

    [Test]
    [HandlerFunctions(ChargeAssignmentStrMenuHandler)]
    PROCEDURE CheckSuggestAssgntDialogueForDifferentReceipts@69();
    VAR
      PurchaseLine@1003 : Record 39;
      ItemChargeAssgntPurch@1009 : Codeunit 5805;
      StrMenuCalled@1002 : Boolean;
    BEGIN
      // [FEATURE] [Item Charge] [Suggest Assignment]
      // [SCENARIO 380487] If "Item Charge Assignment (Purch)" have different "Applies-to Doc. Type" then Suggest Item Charge Assignment function provides Dialog with Options Equally,Amount.
      Initialize;

      // [GIVEN] "Item Charge Assignment (Purch)" for "Sales Shipment Line" and "Transfer Receipt Line"
      CreateItemChargeAssgntPurchForSalesShptLineAndTransferReceiptLine(PurchaseLine);

      LibraryVariableStorage.Enqueue(StrMenuCalled); // Enque FALSE for handler

      // [WHEN] Suggest Assignment
      ItemChargeAssgntPurch.SuggestAssgnt(PurchaseLine,PurchaseLine.Quantity,PurchaseLine."Line Amount");

      // [THEN] STRMENU occurs
      StrMenuCalled := LibraryVariableStorage.DequeueBoolean; // STRMENU called flag
      Assert.IsTrue(StrMenuCalled,STRMENUWasNotCalledTxt);
    END;

    [Test]
    PROCEDURE DirectTransferCausingApplicationCycleIsPostedUnapplied@64();
    VAR
      LocationBlue@1000 : Record 14;
      LocationRed@1001 : Record 14;
      Item@1002 : Record 27;
      ItemLedgerEntry@1003 : Record 32;
    BEGIN
      // [FEATURE] [Item Application] [Transfer] [Reclassification Journal]
      // [SCENARIO 217342] Direct transfer created in Reclassification Journal should be posted with no item application on its positive side when the posting causes a loop in item application.
      Initialize;

      // [GIVEN] Item "I", locations "A" and "B".
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(LocationBlue);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(LocationRed);
      LibraryPatterns.MAKEItem(Item,Item."Costing Method"::FIFO,0,0,0,'');

      // [GIVEN] Positive adjustment for "q" pcs. of item "I" is posted on location "A".
      LibraryPatterns.POSTPositiveAdjustment(Item,LocationBlue.Code,'','',LibraryRandom.RandInt(10),WORKDATE,0);

      // [GIVEN] Negative adjustment for "Q" ("Q" > "q") pcs. of item "I" is posted on location "A". The inventory is now negative on "A" as the negative adjustment is not fully applied.
      // [GIVEN] Posted item entry no. = "1".
      LibraryPatterns.POSTNegativeAdjustment(Item,LocationBlue.Code,'','',LibraryRandom.RandIntInRange(11,20),WORKDATE,0);
      FindItemLedgerEntry(ItemLedgerEntry,Item."No.",ItemLedgerEntry."Entry Type"::"Negative Adjmt.",LocationBlue.Code,FALSE);

      // [GIVEN] Positive adjustment for "Q" pcs. of item "I" is posted on "A". The positive adjustment journal line is set to be applied from item entry "1".
      // [GIVEN] Posted item entry no. = "2".
      PostPositiveAdjustment(Item,LocationBlue.Code,ABS(ItemLedgerEntry.Quantity),0,ItemLedgerEntry."Entry No.");

      // [GIVEN] Transfer 1 pc. of "I" from location "A" to "B" is posted in reclassification journal.
      // [GIVEN] Posted item entries nos. = "3" and "4".
      LibraryPatterns.POSTReclassificationJournalLine(Item,WORKDATE,LocationBlue.Code,LocationRed.Code,'','','',1);

      // [WHEN] Post transfer 1 pc. of "I" back from "B" to "A" in reclassification journal. Posted item entries nos. = "5" and "6". That could make an application loop: "1" -> "2" -> "3" -> "4" -> "5" -> "6" -> "1".
      LibraryPatterns.POSTReclassificationJournalLine(Item,WORKDATE,LocationRed.Code,LocationBlue.Code,'','','',1);

      // [THEN] The item entry "6" has been successfully posted and not applied to "1", thereby avoiding the loop.
      FindItemLedgerEntry(ItemLedgerEntry,Item."No.",ItemLedgerEntry."Entry Type"::Transfer,LocationBlue.Code,TRUE);
      ItemLedgerEntry.TESTFIELD("Remaining Quantity",1);
    END;

    LOCAL PROCEDURE Initialize@9();
    VAR
      LibraryERMCountryData@1000 : Codeunit 131305;
    BEGIN
      LibrarySetupStorage.Restore;
      LibraryVariableStorage.Clear;
      // Lazy Setup.

      IF isInitialized THEN
        EXIT;

      LibraryPatterns.SETNoSeries;
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralLedgerSetup;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      isInitialized := TRUE;
      COMMIT;

      LibrarySetupStorage.Save(DATABASE::"Inventory Setup");
    END;

    LOCAL PROCEDURE BlockItemWithApplWorksheet@56(VAR Item@1000 : Record 27);
    BEGIN
      WITH Item DO BEGIN
        FIND;
        VALIDATE("Application Wksh. User ID",USERID);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateAndPostConsumptionJournalLine@60(ItemJournalBatch@1003 : Record 233;ItemNo@1002 : Code[20];ProdOrderNo@1001 : Code[20];Quantity@1000 : Decimal);
    VAR
      ItemJournalLine@1004 : Record 83;
    BEGIN
      CreateConsumptionJournalLine(ItemJournalLine,ItemJournalBatch,ProdOrderNo,ItemNo,Quantity);
      LibraryManufacturing.PostConsumptionJournal;
    END;

    LOCAL PROCEDURE CreateAndPostOutputJournalLine@61(ItemJournalBatch@1001 : Record 233;ItemNo@1002 : Code[20];ProdOrderNo@1003 : Code[20];Quantity@1004 : Decimal);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CreateOutputJournalLine(ItemJournalLine,ItemJournalBatch,ItemNo,ProdOrderNo,Quantity);
      LibraryManufacturing.PostOutputJournal;
    END;

    LOCAL PROCEDURE CreateConsumptionJournalLine@75(VAR ItemJournalLine@1000 : Record 83;ItemJournalBatch@1001 : Record 233;ProdOrderNo@1003 : Code[20];ItemNo@1004 : Code[20];Qty@1005 : Decimal);
    VAR
      ItemJournalTemplate@1002 : Record 82;
    BEGIN
      ItemJournalLine.INIT;
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::Consumption;

      ItemJournalTemplate.GET(ItemJournalBatch."Journal Template Name");
      LibraryInventory.CreateItemJnlLineWithNoItem(
        ItemJournalLine,ItemJournalBatch,ItemJournalTemplate.Name,ItemJournalBatch.Name,ItemJournalLine."Entry Type"::Consumption);
      ItemJournalLine.VALIDATE("Order Type",ItemJournalLine."Order Type"::Production);
      ItemJournalLine.VALIDATE("Order No.",ProdOrderNo);
      ItemJournalLine.VALIDATE("Item No.",ItemNo);
      ItemJournalLine.VALIDATE(Quantity,Qty);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItem@34(VAR Item@1000 : Record 27;CostingMethod@1001 : Option;UnitCost@1002 : Decimal;ReplenishmentSystem@1003 : Option;RoundingPrecision@1004 : Decimal);
    BEGIN
      LibraryPatterns.MAKEItemSimple(Item,CostingMethod,UnitCost);

      WITH Item DO BEGIN
        VALIDATE("Replenishment System",ReplenishmentSystem);
        VALIDATE("Rounding Precision",RoundingPrecision);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateItemAndUpdateInventory@122(VAR Item@1002 : Record 27);
    VAR
      LocationBlue@1003 : Record 14;
      Qty@1001 : Decimal;
      i@1000 : Integer;
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(LocationBlue);
      LibraryPatterns.MAKEItem(Item,Item."Costing Method"::FIFO,0,0,0,'');
      Qty := LibraryRandom.RandDec(100,2);
      FOR i := 1 TO 2 DO
        LibraryPatterns.POSTPositiveAdjustment(Item,LocationBlue.Code,'','',Qty,WORKDATE,LibraryRandom.RandDec(100,2));
      LibraryPatterns.POSTNegativeAdjustment(Item,LocationBlue.Code,'','',Qty,WORKDATE,LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE CreateItemPostPositiveAdjmt@21(Quantity@1001 : Decimal;CostAmount@1002 : Decimal) : Code[20];
    VAR
      Item@1000 : Record 27;
    BEGIN
      LibraryPatterns.MAKEItem(Item,Item."Costing Method"::Average,0,0,0,'');
      LibraryPatterns.POSTPositiveAdjustmentAmount(Item,'','',Quantity,WORKDATE,CostAmount);

      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateRelProdOrder@84(VAR ProdOrderLine@1002 : Record 5406;LocationCode@1006 : Code[10];VAR CompItem@1004 : Record 27;VAR Qty@1001 : Decimal);
    VAR
      RoutingHeader@1016 : Record 99000763;
      ProductionOrder@1012 : Record 5405;
      PurchaseHeader@1010 : Record 38;
      RoutingLink@1009 : Record 99000777;
      ProductionBOMHeader@1008 : Record 99000771;
      ParentItem@1005 : Record 27;
      QtyPer@1000 : Decimal;
    BEGIN
      LibraryPatterns.MAKEItem(ParentItem,ParentItem."Costing Method"::FIFO,0,0,0,'');
      ParentItem.VALIDATE("Flushing Method",ParentItem."Flushing Method"::Backward);
      ParentItem.VALIDATE("Replenishment System",ParentItem."Replenishment System"::"Prod. Order");
      ParentItem.MODIFY;

      LibraryPatterns.MAKEItem(CompItem,CompItem."Costing Method"::FIFO,0,0,0,'');
      CompItem.VALIDATE("Flushing Method",CompItem."Flushing Method"::Backward);
      CompItem.MODIFY;

      QtyPer := LibraryRandom.RandInt(10);
      RoutingLink.FINDFIRST;
      LibraryPatterns.MAKEProductionBOM(ProductionBOMHeader,ParentItem,CompItem,QtyPer,RoutingLink.Code);
      LibraryPatterns.MAKERouting(RoutingHeader,ParentItem,RoutingLink.Code,0);

      Qty := LibraryRandom.RandInt(100);
      LibraryPatterns.POSTPurchaseOrder(
        PurchaseHeader,CompItem,LocationCode,'',Qty * QtyPer,WORKDATE,LibraryRandom.RandDec(100,5),TRUE,TRUE);

      LibraryPatterns.MAKEProductionOrder(ProductionOrder,ProductionOrder.Status::Released,ParentItem,LocationCode,'',Qty,WORKDATE);
      FindProdOrderLine(ProdOrderLine,ProductionOrder);
    END;

    LOCAL PROCEDURE CreateOrderAndShip@23(ItemNo@1001 : Code[20];Quantity@1002 : Decimal) : Code[20];
    VAR
      SalesHeader@1003 : Record 36;
      Item@1005 : Record 27;
    BEGIN
      Item.GET(ItemNo);
      LibraryPatterns.POSTSalesOrder(SalesHeader,Item,'','',Quantity,WORKDATE,Item."Unit Cost",TRUE,FALSE);

      EXIT(SalesHeader."No.");
    END;

    LOCAL PROCEDURE CreateLocationsChain@62(VAR FromLocation@1007 : Record 14;VAR ToLocation@1005 : Record 14;VAR TransitLocation@1004 : Record 14);
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(FromLocation);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(ToLocation);
      LibraryWarehouse.CreateInTransitLocation(TransitLocation);
    END;

    LOCAL PROCEDURE CreateOutputJournalLine@72(VAR ItemJournalLine@1000 : Record 83;ItemJournalBatch@1001 : Record 233;ItemNo@1003 : Code[20];ProdOrderNo@1004 : Code[20];OutputQty@1005 : Decimal);
    VAR
      ItemJournalTemplate@1002 : Record 82;
    BEGIN
      ItemJournalTemplate.GET(ItemJournalBatch."Journal Template Name");
      LibraryManufacturing.CreateOutputJournal(ItemJournalLine,ItemJournalTemplate,ItemJournalBatch,ItemNo,ProdOrderNo);
      ItemJournalLine.VALIDATE("Output Quantity",OutputQty);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesShptLine@89(VAR SalesShptLine@1000 : Record 111);
    VAR
      TempItemLedgerEntry@1005 : TEMPORARY Record 32;
      Item@1004 : Record 27;
      PurchaseHeader@1003 : Record 38;
      SalesHeader@1001 : Record 36;
      Qty@1006 : Decimal;
    BEGIN
      // All numbers aren't a matter.
      Qty := LibraryRandom.RandInt(10);
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::FIFO,LibraryRandom.RandDec(100,2));
      LibraryPatterns.POSTPurchaseOrder(PurchaseHeader,Item,'','',Qty,WORKDATE,LibraryRandom.RandDec(100,2),TRUE,TRUE);
      LibraryPatterns.POSTSalesOrder(SalesHeader,Item,'','',Qty,WORKDATE,LibraryRandom.RandDec(100,2),TRUE,TRUE);
      LibraryPatterns.InsertTempILEFromLast(TempItemLedgerEntry);
      SalesShptLine.GET(TempItemLedgerEntry."Document No.",TempItemLedgerEntry."Document Line No.");
    END;

    LOCAL PROCEDURE CreateTransferReceiptLine@97(VAR TransferReceiptLine@1006 : Record 5747);
    VAR
      FromLocation@1008 : Record 14;
      ToLocation@1007 : Record 14;
      TransitLocation@1005 : Record 14;
      TempItemLedgerEntry@1004 : TEMPORARY Record 32;
      Item@1003 : Record 27;
      TransferHeader@1000 : Record 5740;
      PurchaseHeader@1001 : Record 38;
      Qty@1002 : Decimal;
    BEGIN
      // All numbers aren't a matter.
      Qty := LibraryRandom.RandInt(10);
      CreateLocationsChain(FromLocation,ToLocation,TransitLocation);
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::FIFO,LibraryRandom.RandDec(100,2));
      LibraryPatterns.POSTPurchaseOrder(
        PurchaseHeader,Item,FromLocation.Code,'',Qty,WORKDATE,LibraryRandom.RandDec(100,2),TRUE,TRUE);
      LibraryPatterns.POSTTransferOrder(
        TransferHeader,Item,FromLocation,ToLocation,TransitLocation,'',Qty,WORKDATE,WORKDATE,TRUE,TRUE);
      LibraryPatterns.InsertTempILEFromLast(TempItemLedgerEntry);
      TransferReceiptLine.GET(TempItemLedgerEntry."Document No.",TempItemLedgerEntry."Document Line No.");
    END;

    LOCAL PROCEDURE CreateItemCharge@107(VAR PurchaseLine@1000 : Record 39;VAR ItemCharge@1002 : Record 5800);
    VAR
      PurchaseHeader@1001 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      LibraryPatterns.MAKEItemChargePurchaseLine(PurchaseLine,ItemCharge,PurchaseHeader,1,LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE InitItemJournalBatch@65(VAR ItemJournalBatch@1000 : Record 233;TemplateType@1001 : Option);
    VAR
      ItemJournalTemplate@1002 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,TemplateType);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,TemplateType,ItemJournalTemplate.Name);
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
    END;

    LOCAL PROCEDURE InsertItemChargeAssgntPurchForSalesShptLine@123(PurchaseLine@1004 : Record 39);
    VAR
      SalesShptLine@1002 : Record 111;
      ItemChargeAssignmentPurch@1000 : Record 5805;
    BEGIN
      CreateSalesShptLine(SalesShptLine);
      LibraryInventory.CreateItemChargeAssignPurchase(
        ItemChargeAssignmentPurch,PurchaseLine,ItemChargeAssignmentPurch."Applies-to Doc. Type"::"Sales Shipment",
        SalesShptLine."Document No.",SalesShptLine."Line No.",SalesShptLine."No.");
    END;

    LOCAL PROCEDURE InsertItemChargeAssgntPurchForTransferReceiptLine@130(VAR ItemChargeAssignmentPurch@1000 : Record 5805;PurchaseLine@1001 : Record 39);
    VAR
      TransferReceiptLine@1002 : Record 5747;
    BEGIN
      CreateTransferReceiptLine(TransferReceiptLine);
      LibraryInventory.CreateItemChargeAssignPurchase(
        ItemChargeAssignmentPurch,PurchaseLine,ItemChargeAssignmentPurch."Applies-to Doc. Type"::"Transfer Receipt",
        TransferReceiptLine."Document No.",TransferReceiptLine."Line No.",TransferReceiptLine."Item No.");
    END;

    LOCAL PROCEDURE CreateItemChargeAssgntPurchForSalesShptLine@153(VAR PurchaseLine@1004 : Record 39);
    VAR
      ItemCharge@1003 : Record 5800;
    BEGIN
      CreateItemCharge(PurchaseLine,ItemCharge);
      InsertItemChargeAssgntPurchForSalesShptLine(PurchaseLine);
    END;

    LOCAL PROCEDURE CreateItemChargeAssgntPurchForTransferReceiptLine@152(VAR PurchaseLine@1004 : Record 39;VAR ItemChargeAssignmentPurch@1000 : Record 5805);
    VAR
      ItemCharge@1003 : Record 5800;
    BEGIN
      CreateItemCharge(PurchaseLine,ItemCharge);
      InsertItemChargeAssgntPurchForTransferReceiptLine(ItemChargeAssignmentPurch,PurchaseLine);
    END;

    LOCAL PROCEDURE CreateItemChargeAssgntPurchForSalesShptLineAndTransferReceiptLine@159(VAR PurchaseLine@1004 : Record 39);
    VAR
      ItemCharge@1003 : Record 5800;
      ItemChargeAssignmentPurch@1000 : Record 5805;
    BEGIN
      CreateItemCharge(PurchaseLine,ItemCharge);
      InsertItemChargeAssgntPurchForSalesShptLine(PurchaseLine);
      InsertItemChargeAssgntPurchForTransferReceiptLine(ItemChargeAssignmentPurch,PurchaseLine);
    END;

    LOCAL PROCEDURE ChangeSalesLineQuantityAndPost@26(OrderNo@1000 : Code[20];NewQuantity@1003 : Decimal);
    VAR
      SalesHeader@1001 : Record 36;
      SalesLine@1004 : Record 37;
    BEGIN
      SalesHeader.GET(SalesHeader."Document Type"::Order,OrderNo);
      LibrarySales.ReopenSalesDocument(SalesHeader);
      SalesHeader.FIND;

      WITH SalesLine DO BEGIN
        SETRANGE("Document Type","Document Type"::Order);
        SETRANGE("Document No.",OrderNo);
        FINDFIRST;
        VALIDATE(Quantity,NewQuantity);
        MODIFY(TRUE);
      END;

      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE FindApplicationWorksheetLine@19(VAR ApplicationWorksheet@1000 : TestPage 521;ItemNo@1002 : Code[20];EntryType@1001 : Text[50]);
    BEGIN
      ApplicationWorksheet.FILTER.SETFILTER("Item No.",ItemNo);
      ApplicationWorksheet.FILTER.SETFILTER("Entry Type",EntryType);
      ApplicationWorksheet.FIRST;
    END;

    LOCAL PROCEDURE FindItemLedgerEntry@76(VAR ItemLedgerEntry@1000 : Record 32;ItemNo@1001 : Code[20];EntryType@1002 : Option;LocationCode@1003 : Code[10];IsPositive@1004 : Boolean);
    BEGIN
      WITH ItemLedgerEntry DO BEGIN
        SETRANGE("Item No.",ItemNo);
        SETRANGE("Entry Type",EntryType);
        SETRANGE("Location Code",LocationCode);
        SETRANGE(Positive,IsPositive);
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE FindProdOrderLine@15(VAR ProdOrderLine@1000 : Record 5406;ProductionOrder@1001 : Record 5405);
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderLine.FINDFIRST;
    END;

    LOCAL PROCEDURE MakeItemJournalBatch@74(VAR ItemJournalBatch@1000 : Record 233;TemplateType@1001 : Option);
    BEGIN
      LibraryInventory.CreateItemJournalBatchByType(ItemJournalBatch,TemplateType);
    END;

    LOCAL PROCEDURE MakeSalesLine@47(SalesHeader@1000 : Record 36;ItemNo@1001 : Code[20];Qty@1002 : Decimal);
    VAR
      SalesLine@1003 : Record 37;
    BEGIN
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Qty);
    END;

    LOCAL PROCEDURE PostProductionOrderAndFinish@32(ProductionOrder@1000 : Record 5405;ComponentItem@1003 : Record 27;QtyToConsume@1004 : Decimal;QtyToProduce@1005 : Decimal);
    VAR
      ProdOrderLine@1001 : Record 5406;
      ItemJournalBatch@1002 : Record 233;
    BEGIN
      FindProdOrderLine(ProdOrderLine,ProductionOrder);
      LibraryPatterns.MAKEConsumptionJournalLine(
        ItemJournalBatch,ProdOrderLine,ComponentItem,WORKDATE,'','',QtyToConsume,ComponentItem."Unit Cost");
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
      LibraryPatterns.MAKEOutputJournalLine(ItemJournalBatch,ProdOrderLine,WORKDATE,QtyToProduce,0);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
      LibraryManufacturing.ChangeProdOrderStatus(ProductionOrder,ProductionOrder.Status::Finished,WORKDATE,FALSE);
    END;

    LOCAL PROCEDURE ReadjustStandardCostItem@38(VAR Item@1000 : Record 27);
    VAR
      ComponentItem@1011 : Record 27;
      ProductionBOMHeader@1010 : Record 99000771;
      PurchaseHeader@1009 : Record 38;
      PurchaseLine@1008 : Record 39;
      ProductionOrder@1007 : Record 5405;
      ItemStandardCost@1004 : Decimal;
      InitialComponentCost@1003 : Decimal;
      NewComponentCost@1002 : Decimal;
      Qty@1001 : Decimal;
    BEGIN
      Initialize;

      Qty := 100000;
      ItemStandardCost := ROUND(0.00755,LibraryERM.GetUnitAmountRoundingPrecision);
      InitialComponentCost := ROUND(0.00855,LibraryERM.GetUnitAmountRoundingPrecision);
      NewComponentCost := ROUND(0.00875,LibraryERM.GetUnitAmountRoundingPrecision);

      CreateItem(
        ComponentItem,ComponentItem."Costing Method"::FIFO,0,ComponentItem."Replenishment System"::Purchase,
        LibraryERM.GetUnitAmountRoundingPrecision);
      CreateItem(
        Item,Item."Costing Method"::Standard,ItemStandardCost,Item."Replenishment System"::"Prod. Order",
        LibraryERM.GetUnitAmountRoundingPrecision);
      LibraryPatterns.MAKEProductionBOM(ProductionBOMHeader,Item,ComponentItem,1,'');

      LibraryPatterns.MAKEPurchaseOrder(PurchaseHeader,PurchaseLine,ComponentItem,'','',Qty,WORKDATE,InitialComponentCost);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);
      PurchaseLine.FIND;

      PostItemConsumptionAndOutput(ProductionOrder,Item,ComponentItem,Qty,Qty);
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',Item."No.",ComponentItem."No."),'');

      LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);
      PurchaseLine.FIND;
      UpdateUnitCostOnPurchaseLine(PurchaseLine,NewComponentCost);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE);

      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',Item."No.",ComponentItem."No."),'');
    END;

    LOCAL PROCEDURE UpdateUnitCostOnPurchaseLine@39(VAR PurchaseLine@1000 : Record 39;DirectUnitCost@1001 : Decimal);
    BEGIN
      PurchaseLine.VALIDATE("Direct Unit Cost",DirectUnitCost);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UndoSalesShipment@24(OrderNo@1000 : Code[20]);
    VAR
      SalesShptLine@1001 : Record 111;
    BEGIN
      SalesShptLine.SETRANGE("Order No.",OrderNo);
      LibrarySales.UndoSalesShipmentLine(SalesShptLine);
    END;

    LOCAL PROCEDURE VerifyOutboudEntriesUpdated@30(ItemNo@1000 : Code[20]);
    VAR
      ItemLedgerEntry@1001 : Record 32;
      ItemApplnEntry@1002 : Record 339;
    BEGIN
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.SETRANGE(Positive,FALSE);
      ItemLedgerEntry.FINDSET;
      REPEAT
        ItemApplnEntry.SETRANGE("Item Ledger Entry No.",ItemLedgerEntry."Entry No.");
        ItemApplnEntry.FINDFIRST;
        Assert.IsTrue(ItemApplnEntry."Outbound Entry is Updated",OutbndEntryIsNotUpdatedErr);
      UNTIL ItemLedgerEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyPostValueEntryToGL@17(ProductionOrder@1000 : Record 5405);
    VAR
      PostValueEntryToGL@1001 : Record 5811;
      ValueEntry@1002 : Record 5802;
    BEGIN
      ValueEntry.SETRANGE("Item No.",ProductionOrder."Source No.");
      ValueEntry.SETRANGE("Order Type",ValueEntry."Order Type"::Production);
      ValueEntry.SETRANGE("Order No.",ProductionOrder."No.");
      ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::Output);
      ValueEntry.SETRANGE("Cost Amount (Actual)",0);
      IF ValueEntry.FINDSET THEN
        REPEAT
          PostValueEntryToGL.SETRANGE("Value Entry No.",ValueEntry."Entry No.");
          PostValueEntryToGL.SETRANGE("Item No.",ValueEntry."Item No.");
          Assert.AreEqual(
            0,PostValueEntryToGL.COUNT,
            'Value Entry ' + FORMAT(ValueEntry."Entry No.") + 'has Cost Amount Actual of 0 and should not be posted to G/L');
        UNTIL ValueEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyILECostAmount@44(ItemNo@1000 : Code[20];ExpectedCostAmount@1003 : Decimal);
    VAR
      ItemLedgerEntry@1004 : Record 32;
    BEGIN
      WITH ItemLedgerEntry DO BEGIN
        SETRANGE("Item No.",ItemNo);
        FINDFIRST;
        CALCFIELDS("Cost Amount (Expected)");
        Assert.AreEqual(
          ExpectedCostAmount,"Cost Amount (Expected)",STRSUBSTNO(WrongCostAmountErr,FIELDCAPTION("Cost Amount (Expected)")));
      END;
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntriesCostEquality@31(VAR PosItemLedgerEntry@1000 : Record 32;VAR NegItemLedgerEntry@1001 : Record 32);
    BEGIN
      PosItemLedgerEntry.FIND;
      PosItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      NegItemLedgerEntry.FIND;
      NegItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      Assert.AreEqual(PosItemLedgerEntry."Cost Amount (Actual)",-NegItemLedgerEntry."Cost Amount (Actual)",ItemNoAdjustedErr);
    END;

    LOCAL PROCEDURE VerifyInventoryAmountIsZero@22(ItemNo@1001 : Code[20]);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      ValueEntry.SETRANGE("Item No.",ItemNo);
      ValueEntry.CALCSUMS("Cost Amount (Expected)","Cost Amount (Actual)");
      Assert.AreEqual(0,ValueEntry."Cost Amount (Expected)",InventoryValueErr);
      Assert.AreEqual(0,ValueEntry."Cost Amount (Actual)",InventoryValueErr);
    END;

    LOCAL PROCEDURE VerifyItemStandardCost@33(ItemNo@1000 : Code[20]);
    VAR
      Item@1002 : Record 27;
      ValueEntry@1001 : Record 5802;
    BEGIN
      Item.GET(ItemNo);
      Item.CALCFIELDS(Inventory);
      ValueEntry.SETRANGE("Item No.",ItemNo);
      ValueEntry.CALCSUMS("Cost Amount (Actual)");
      Assert.AreEqual(Item."Standard Cost" * Item.Inventory,ValueEntry."Cost Amount (Actual)",WrongStandardCostVarianceErr);
    END;

    LOCAL PROCEDURE VerifyItemStandardCostACY@42(ItemNo@1000 : Code[20];ACYCode@1003 : Code[10]);
    VAR
      Item@1002 : Record 27;
      ValueEntry@1001 : Record 5802;
      Currency@1005 : Record 4;
      CurrExchRate@1004 : Record 330;
    BEGIN
      Item.GET(ItemNo);
      Item.CALCFIELDS(Inventory);
      ValueEntry.SETRANGE("Item No.",ItemNo);
      ValueEntry.CALCSUMS("Cost Amount (Actual) (ACY)","Invoiced Quantity");

      Currency.GET(ACYCode);
      Assert.AreNearlyEqual(
        Item."Standard Cost" * CurrExchRate.ExchangeRate(WORKDATE,ACYCode),
        ValueEntry."Cost Amount (Actual) (ACY)" / ValueEntry."Invoiced Quantity",
        Currency."Unit-Amount Rounding Precision",
        WrongStandardCostVarianceErr);
    END;

    LOCAL PROCEDURE VerifyRevaluedTransferCostAmount@78(ItemNo@1001 : Code[20];LocationCode@1002 : Code[10];CostAmount@1003 : Decimal);
    VAR
      ItemLedgEntry@1000 : Record 32;
    BEGIN
      WITH ItemLedgEntry DO BEGIN
        SETRANGE("Entry Type","Entry Type"::Transfer);
        SETRANGE("Item No.",ItemNo);
        SETRANGE("Location Code",LocationCode);
        SETRANGE(Positive,TRUE);
        FINDFIRST;
        CALCFIELDS("Cost Amount (Actual)");
        Assert.AreEqual(
          CostAmount,"Cost Amount (Actual)",STRSUBSTNO(WrongCostAmountErr,FIELDCAPTION("Cost Amount (Actual)")));
      END;
    END;

    LOCAL PROCEDURE VeriryItemApplicationEntryHistory@55(VAR ItemLedgerEntry@1000 : Record 32);
    VAR
      ItemApplicationEntryHistory@1002 : Record 343;
    BEGIN
      ItemLedgerEntry.FINDSET;
      REPEAT
        ItemApplicationEntryHistory.INIT;
        ItemApplicationEntryHistory.SETRANGE("Entry No.",0);
        ItemApplicationEntryHistory.SETRANGE("Item Ledger Entry No.",ItemLedgerEntry."Entry No.");
        Assert.RecordIsEmpty(ItemApplicationEntryHistory);
      UNTIL ItemLedgerEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE AdjustCostAndVerify@10(ItemNo@1000 : Code[20];ExpectedUnitCost@1001 : Decimal);
    VAR
      Item@1002 : Record 27;
    BEGIN
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');
      Item.GET(ItemNo);
      Assert.AreNearlyEqual(ExpectedUnitCost,Item."Unit Cost",LibraryERM.GetUnitAmountRoundingPrecision,'');
    END;

    LOCAL PROCEDURE PostItemConsumptionAndOutput@40(VAR ProductionOrder@1004 : Record 5405;ProdItem@1000 : Record 27;ComponentItem@1001 : Record 27;QtyToProduce@1003 : Decimal;QtyToConsume@1002 : Decimal);
    BEGIN
      LibraryPatterns.MAKEProductionOrder(ProductionOrder,ProductionOrder.Status::Released,ProdItem,'','',QtyToProduce,WORKDATE);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,TRUE,TRUE,TRUE,TRUE,TRUE);
      PostProductionOrderAndFinish(ProductionOrder,ComponentItem,QtyToConsume,QtyToProduce);
    END;

    LOCAL PROCEDURE PostNegativeOutput@70(ItemJournalBatch@1000 : Record 233;ProdOrderLine@1001 : Record 5406;Qty@1002 : Decimal;EntryNo@1004 : Integer);
    VAR
      ItemJournalLine@1003 : Record 83;
    BEGIN
      LibraryPatterns.MAKEOutputJournalLine(ItemJournalBatch,ProdOrderLine,WORKDATE,-Qty,0);
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE("Applies-to Entry",EntryNo);
      ItemJournalLine.MODIFY;
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
    END;

    LOCAL PROCEDURE PostItemJournalSaleByItem@73(Item@1002 : Record 27;LocationCode@1003 : Code[10];Qty@1004 : Integer);
    VAR
      ItemJournalBatch@1000 : Record 233;
      ItemJournalLine@1001 : Record 83;
      I@1005 : Integer;
    BEGIN
      MakeItemJournalBatch(ItemJournalBatch,ItemJournalBatch."Template Type"::Item);
      FOR I := 1 TO Qty DO
        LibraryPatterns.MAKEItemJournalLine(
          ItemJournalLine,ItemJournalBatch,Item,LocationCode,'',WORKDATE,ItemJournalLine."Entry Type"::Sale,1,
          LibraryRandom.RandDec(100,2) + 1);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
    END;

    LOCAL PROCEDURE PostItemJournalTransfer@71(Item@1002 : Record 27;FromLocationCode@1003 : Code[10];ToLocationCode@1004 : Code[10];Qty@1005 : Decimal;PostingDate@1006 : Date);
    VAR
      ItemJournalBatch@1000 : Record 233;
      ItemJournalLine@1001 : Record 83;
    BEGIN
      LibraryInventory.CreateItemJournalBatchByType(ItemJournalBatch,ItemJournalBatch."Template Type"::Transfer);
      LibraryPatterns.MAKEItemReclassificationJournalLine(
        ItemJournalLine,ItemJournalBatch,Item,'',FromLocationCode,ToLocationCode,'','',PostingDate,Qty);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
    END;

    LOCAL PROCEDURE PostPositiveAdjustment@13(Item@1000 : Record 27;LocationCode@1006 : Code[10];Quantity@1001 : Decimal;Amount@1002 : Decimal;AppliesFromEntryNo@1007 : Integer);
    VAR
      ItemJournalTemplate@1003 : Record 82;
      ItemJournalBatch@1004 : Record 233;
      ItemJournalLine@1005 : Record 83;
    BEGIN
      LibraryInventory.CreateItemJournalBatchByType(ItemJournalBatch,ItemJournalTemplate.Type::Item);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJournalLine,ItemJournalBatch,Item,LocationCode,'',WORKDATE,ItemJournalLine."Entry Type"::"Positive Adjmt.",Quantity,0);
      ItemJournalLine.VALIDATE(Amount,Amount);
      ItemJournalLine.VALIDATE("Applies-from Entry",AppliesFromEntryNo);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
    END;

    LOCAL PROCEDURE PostPositiveAndNegativeEntries@68(Item@1002 : Record 27;Quantity@1004 : Decimal;VAR PositiveItemLedgerEntry@1001 : Record 32;VAR NegativeItemLedgerEntry@1000 : Record 32);
    BEGIN
      LibraryPatterns.POSTPositiveAdjustment(Item,'','','',Quantity,WORKDATE,LibraryRandom.RandDec(100,2));
      LibraryPatterns.POSTNegativeAdjustment(Item,'','','',Quantity,WORKDATE,LibraryRandom.RandDec(100,2));

      PositiveItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      PositiveItemLedgerEntry.SETRANGE(Positive,TRUE);
      PositiveItemLedgerEntry.FINDLAST;

      NegativeItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      NegativeItemLedgerEntry.SETRANGE(Positive,FALSE);
      NegativeItemLedgerEntry.FINDLAST;
    END;

    LOCAL PROCEDURE PostAndUnapplyPositiveAndNegativeAdjustments@101(Item@1006 : Record 27;Quantity@1000 : Decimal;VAR PositiveItemLedgerEntry@1001 : Record 32;VAR NegativeItemLedgerEntry@1002 : Record 32;AreUnappliedWithApplWorksheet@1003 : Boolean);
    BEGIN
      PostPositiveAndNegativeEntries(Item,Quantity,PositiveItemLedgerEntry,NegativeItemLedgerEntry);
      UnapplyItemLedgerEntries(
        PositiveItemLedgerEntry."Entry No.",NegativeItemLedgerEntry."Entry No.",AreUnappliedWithApplWorksheet);
    END;

    LOCAL PROCEDURE PostPurchaseInvoiceWithNewUnitCost@66(VAR PurchaseHeader@1000 : Record 38;NewUnitCost@1002 : Decimal);
    VAR
      PurchaseLine@1001 : Record 39;
    BEGIN
      PurchaseLine.SETRANGE("Document Type",PurchaseHeader."Document Type");
      PurchaseLine.SETRANGE("Document No.",PurchaseHeader."No.");
      PurchaseLine.FINDFIRST;
      PurchaseLine.VALIDATE("Direct Unit Cost",NewUnitCost);
      PurchaseLine.MODIFY(TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE PostNegativeAdjmtAndVerify@20(Item@1000 : Record 27;UnitCost@1001 : Decimal;FirstShipmentQty@1002 : Decimal);
    BEGIN
      LibraryPatterns.POSTNegativeAdjustment(Item,'','','',FirstShipmentQty,WORKDATE,Item."Unit Cost");
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      LibraryPatterns.POSTNegativeAdjustment(Item,'','','',1,WORKDATE,UnitCost);
      LibraryPatterns.POSTNegativeAdjustment(Item,'','','',1,WORKDATE,UnitCost);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      VerifyInventoryAmountIsZero(Item."No.");
    END;

    LOCAL PROCEDURE PostRevaluationJournalLine@59(VAR Item@1003 : Record 27;PostingDate@1002 : Date;RevaluedUnitCost@1005 : Decimal);
    VAR
      ItemJournalTemplate@1001 : Record 82;
      ItemJournalBatch@1000 : Record 233;
      ItemJournalLine@1004 : Record 83;
      CalculatePer@1006 : 'Item Ledger Entry,Item';
    BEGIN
      MakeItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Type::Revaluation);
      LibraryPatterns.MAKERevaluationJournalLine(ItemJournalBatch,Item,PostingDate,CalculatePer::Item,FALSE,FALSE,TRUE,0);

      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.SETRANGE("Item No.",Item."No.");
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE("Unit Cost (Revalued)",RevaluedUnitCost);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
    END;

    LOCAL PROCEDURE PostSalesShipmentAndUndo@29(Item@1003 : Record 27;Quantity@1001 : Decimal;Amount@1002 : Decimal);
    VAR
      SalesHeader@1000 : Record 36;
    BEGIN
      LibraryPatterns.POSTSalesOrder(SalesHeader,Item,'','',Quantity,WORKDATE,Amount,TRUE,FALSE);
      UndoSalesShipment(SalesHeader."No.");
    END;

    LOCAL PROCEDURE SaleReceivedAndTransferredItem@48(VAR Item@1005 : Record 27;VAR PurchaseHeader@1006 : Record 38);
    VAR
      Location@1004 : ARRAY [2] OF Record 14;
      Qty@1001 : Integer;
      UnitCost@1000 : Decimal;
    BEGIN
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::FIFO,0);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location[1]);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location[2]);

      // Hardcoded numbers to reproduce rounding issue
      Qty := 6;
      UnitCost := 8.74444;
      LibraryPatterns.POSTPurchaseOrder(PurchaseHeader,Item,Location[1].Code,'',Qty,WORKDATE,UnitCost,TRUE,FALSE);
      PostItemJournalTransfer(Item,Location[1].Code,Location[2].Code,Qty,WORKDATE);

      PostItemJournalSaleByItem(Item,Location[2].Code,Qty);
    END;

    LOCAL PROCEDURE UnapplyItemLedgerEntries@35(PosItemLedgEntryNo@1000 : Integer;NegItemLedgEntryNo@1001 : Integer;AreUnappliedWithApplWorksheet@1004 : Boolean);
    VAR
      ItemApplicationEntry@1003 : Record 339;
      ItemJnlPostLine@1002 : Codeunit 22;
    BEGIN
      ItemJnlPostLine.SetCalledFromApplicationWorksheet(AreUnappliedWithApplWorksheet);

      WITH ItemApplicationEntry DO BEGIN
        SETRANGE("Inbound Item Entry No.",PosItemLedgEntryNo);
        SETRANGE("Outbound Item Entry No.",NegItemLedgEntryNo);
        FINDFIRST;
        ItemJnlPostLine.UnApply(ItemApplicationEntry);
      END;
    END;

    [PageHandler]
    PROCEDURE ViewAppliedEntriesHandler@18(VAR ViewAppliedEntries@1000 : TestPage 522);
    BEGIN
      ViewAppliedEntries.RemoveAppButton.INVOKE;
      ViewAppliedEntries.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ViewUnappliedEntriesModalHandler@41(VAR ViewAppliedEntries@1000 : TestPage 522);
    BEGIN
      ViewAppliedEntries.FIRST;
      ViewAppliedEntries.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ViewUnapplEntrSelectNextModalHandler@6(VAR ViewAppliedEntries@1000 : TestPage 522);
    BEGIN
      ViewAppliedEntries.FIRST;
      ViewAppliedEntries.NEXT;
      ViewAppliedEntries.OK.INVOKE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmYesHandler@36(Question@1000 : Text;VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [MessageHandler]
    PROCEDURE UnadjustedEntriesExistMessageHandler@8(Message@1000 : Text);
    BEGIN
    END;

    [StrMenuHandler]
    PROCEDURE ChargeAssignmentStrMenuHandler@57(Options@1000 : Text[1024];VAR Choice@1001 : Integer;Instruction@1002 : Text[1024]);
    VAR
      StrMenuCalled@1003 : Boolean;
    BEGIN
      StrMenuCalled := LibraryVariableStorage.DequeueBoolean; // Decrements queue counter
      StrMenuCalled := TRUE; // STRMENU called flag
      LibraryVariableStorage.Enqueue(StrMenuCalled); // Enqueue for Assert.IsTrue
      Choice := 0;
    END;

    BEGIN
    {
      // [FEATURE] [SCM]
      Test cases for SCM Reservation:

       1 ~ 8. Fix related bugs.
       9. Test to verify that Released Prod. Order Components page is open successfully with Location.
       10 ~ 11. Post purchase and sale with partial application, adjust cost, sale remaining quantity, ajust again. Verify that amount is rounded.
       12. Post sale shipment ending in negative inventory, return and adjust cost. Verify that cost adjusted without errors.
       13 ~ 14. Test to verify that standard cost variance posting uses correct rounding settings (first in local currency, then in additional reporting currency).
       15. Post purchase receipt, sell (ship and invoice), adjust cost, then invoice purchase and adjust again. Verify that sale cost is rounded.
       17. Verify that open ILE not included in valuation chains are excluded from average cost calculation.

        Covers Test Cases for WI - 346686
        -------------------------------------------------------------------------------
        Test Function Name                                                     TFS ID
        -------------------------------------------------------------------------------
        NoErrorWhenCloseApplicationWorksheetPage                               346686
        TFS354142_RoundingAfterTwoAdjustments                                  354142
        TFS354142_AdjmtRoundingPartialShipmentApplication                      354142
        TFS355737_AdjmtRndAfterReturn                                          355737
        TFS359257_VerifyStandardCostVarianceRounding                           359257,103939
        TFS359257_VerifyStandardCostVarianceRoundingACY                        359257,103939
        TFS359756_AdjustCostRoundingAfterTwoAdjmts                             359756,106728
        TFS359532_OpenEntriesWithNoCostingChainExcluded                        359532
    }
    END.
  }
}

