OBJECT Codeunit 137603 SCM CETAF Costing Revaluation
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LibraryCosting@1003 : Codeunit 132200;
      LibraryERM@1000 : Codeunit 131300;
      LibraryInventory@1012 : Codeunit 132201;
      LibraryWarehouse@1002 : Codeunit 132204;
      LibraryPatterns@1001 : Codeunit 132212;
      LibraryPurchase@1013 : Codeunit 130512;
      LibraryUtility@1014 : Codeunit 131000;
      Assert@1007 : Codeunit 130000;
      LibraryRandom@1009 : Codeunit 130440;
      CalculatePer@1006 : 'Item Ledger Entry,Item';
      CalculationBase@1005 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
      isInitialized@1008 : Boolean;
      TXTCalcPerILEAvgCostErr@1004 : TextConst 'ENU=You must not revalue items with Costing Method Average, if Calculate Per is Item Ledger Entry.';
      TXTIncorrectUnitCostErr@1011 : TextConst 'ENU=Incorrect value in Unit Cost (Calculated) field in revaluation line.';

    LOCAL PROCEDURE Initialize@6();
    VAR
      InventorySetup@1001 : Record 313;
      LibraryERMCountryData@1000 : Codeunit 131305;
    BEGIN
      // Lazy Setup.
      IF isInitialized THEN
        EXIT;

      InventorySetup.GET;
      InventorySetup.TESTFIELD("Average Cost Period",InventorySetup."Average Cost Period"::Day);
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.UpdateLocalData;
      LibraryERMCountryData.UpdateGeneralLedgerSetup;
      LibraryPatterns.SETNoSeries;
      isInitialized := TRUE;
      COMMIT;
    END;

    [Test]
    PROCEDURE TestFIFOwLoc_RevalueExInvPerItem@3();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInv(Item."Costing Method"::FIFO,0,CalculatePer::Item,TRUE);
    END;

    [Test]
    PROCEDURE TestAvgwLoc_RevalueExInvPerItem@2();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInv(Item."Costing Method"::Average,0,CalculatePer::Item,FALSE);
    END;

    [Test]
    PROCEDURE TestStdwLoc_RevalueExInvPerItem@9();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInv(Item."Costing Method"::Standard,50,CalculatePer::Item,TRUE);
    END;

    [Test]
    PROCEDURE TestLIFOwLoc_RevalueExInvPerItem@4();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInv(Item."Costing Method"::LIFO,0,CalculatePer::Item,TRUE);
    END;

    [Test]
    PROCEDURE TestFIFOwLoc_RevalueInboundILE@5();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueInboundILEwLoc(Item."Costing Method"::FIFO,0);
    END;

    [Test]
    PROCEDURE TestAvgwLoc_RevalueInboundILE@14();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueInboundILEwLoc(Item."Costing Method"::Average,0);
    END;

    [Test]
    PROCEDURE TestStdwLoc_RevalueInboundILE@15();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueInboundILEwLoc(Item."Costing Method"::Standard,50);
    END;

    [Test]
    PROCEDURE TestLIFO_RevalueExInvPerItemNegZeroInv@22();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInvNegZeroInv(Item."Costing Method"::LIFO,0,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestAvg_RevalueExInvPerItemNegZeroInv@20();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInvNegZeroInv(Item."Costing Method"::Average,0,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestStd_RevalueExInvPerItemNegZeroInv@21();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInvNegZeroInv(Item."Costing Method"::Standard,50,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestFIFOwLoc_RevalueExInvPerILE@24();
    VAR
      Item@1004 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInv(Item."Costing Method"::FIFO,0,CalculatePer::"Item Ledger Entry",TRUE);
    END;

    [Test]
    PROCEDURE TestAvgwLoc_RevalueExInvPerILE@28();
    VAR
      Item@1004 : Record 27;
    BEGIN
      Initialize;
      ASSERTERROR TestRevalueExistingInv(Item."Costing Method"::Average,0,CalculatePer::"Item Ledger Entry",TRUE);
      Assert.ExpectedError(TXTCalcPerILEAvgCostErr);
    END;

    [Test]
    PROCEDURE TestStdwLoc_RevalueExInvPerILE@30();
    VAR
      Item@1004 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInv(Item."Costing Method"::Standard,50,CalculatePer::"Item Ledger Entry",TRUE);
    END;

    [Test]
    PROCEDURE TestAvgwLocVar_RevalueExInvPerItem@25();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInvwLocVar(Item."Costing Method"::Average,0,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestStdwLocVar_RevalueExInvPerItem@27();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevalueExistingInvwLocVar(Item."Costing Method"::Standard,50,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestFIFORounding@46();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRounding(Item."Costing Method"::FIFO);
    END;

    [Test]
    PROCEDURE TestAvgRounding@47();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRounding(Item."Costing Method"::Average);
    END;

    [Test]
    PROCEDURE TestStdRounding@59();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRounding(Item."Costing Method"::Standard);
    END;

    [Test]
    PROCEDURE TestFIFORevaluationCircularTransfer@53();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevaluationCircularTransfer(Item."Costing Method"::FIFO,0);
    END;

    [Test]
    PROCEDURE TestLIFORevaluationCircularTransfer@60();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevaluationCircularTransfer(Item."Costing Method"::LIFO,0);
    END;

    [Test]
    PROCEDURE TestAvgRevaluationCircularTransfer@54();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevaluationCircularTransfer(Item."Costing Method"::Average,0);
    END;

    [Test]
    PROCEDURE TestStdRevaluationCircularTransfer@55();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevaluationCircularTransfer(Item."Costing Method"::Standard,50);
    END;

    [Test]
    PROCEDURE TestFIFORevaluationSalesReturn@57();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevaluationSalesReturn(Item."Costing Method"::FIFO,0);
    END;

    [Test]
    PROCEDURE TestLIFORevaluationSalesReturn@56();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevaluationSalesReturn(Item."Costing Method"::LIFO,0);
    END;

    [Test]
    PROCEDURE TestAvgRevaluationSalesReturn@52();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevaluationSalesReturn(Item."Costing Method"::Average,0);
    END;

    [Test]
    PROCEDURE TestStdRevaluationSalesReturn@51();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestRevaluationSalesReturn(Item."Costing Method"::Standard,50);
    END;

    [Test]
    PROCEDURE VSTF265306@17();
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1002 : Record 83;
      ItemJournalBatch@1006 : Record 233;
      ItemLedgerEntry@1001 : Record 32;
      CalculatePer@1004 : 'Item Ledger Entry,Item';
      Day1@1003 : Date;
      CalculationBase@1005 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
      Qty@1007 : Decimal;
    BEGIN
      // Test to reproduce Bug265306
      Initialize;

      // Make item
      LibraryPatterns.MAKEItem(Item,Item."Costing Method"::Average,LibraryRandom.RandInt(10),0,0,'');

      Day1 := 030311D;
      Qty := LibraryRandom.RandInt(100);

      // Post item journals
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::"Positive Adjmt.",Item,'','','',Qty,Day1,
        LibraryRandom.RandInt(10));
      Item.GET(Item."No.");
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::"Negative Adjmt.",Item,'','','',Qty,Day1 + 4,
        Item."Last Direct Cost");
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::"Positive Adjmt.",Item,'','','',Qty,Day1 + 4,
        LibraryRandom.RandInt(10));
      ItemLedgerEntry.FINDLAST; // store the ILE for last posistive adjustment

      // Adjust cost
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Revaluation journal
      LibraryPatterns.MAKERevaluationJournalLine(
        ItemJournalBatch,Item,Day1 + 4,CalculatePer::Item,FALSE,FALSE,FALSE,CalculationBase::" ");
      FindFirstItemJnlLine(ItemJournalLine,ItemJournalBatch);
      ItemJournalLine.VALIDATE("Unit Cost (Revalued)",LibraryRandom.RandInt(10));
      ItemJournalLine.MODIFY;
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      // Post negative adjustment
      LibraryInventory.CreateItemJournalBatchByType(ItemJournalBatch,ItemJournalBatch."Template Type"::Item);
      Item.GET(Item."No.");
      LibraryPatterns.MAKEItemJournalLine(
        ItemJournalLine,ItemJournalBatch,Item,'','',Day1 + 4,ItemJournalLine."Entry Type"::"Negative Adjmt.",Qty,Item."Unit Cost");
      ItemJournalLine.VALIDATE("Applies-to Entry",ItemLedgerEntry."Entry No.");
      ItemJournalLine.MODIFY;
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      // Adjust cost
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Verify
      LibraryCosting.CheckAdjustment(Item);
    END;

    [Test]
    PROCEDURE TFS245517@16();
    VAR
      Location@1004 : Record 14;
      TempItemLedgerEntry@1003 : TEMPORARY Record 32;
      ItemJournalBatch@1006 : Record 233;
      ItemLedgerEntry@1005 : Record 32;
      Item@1000 : Record 27;
      Day1@1001 : Date;
      Qty@1002 : Decimal;
      CalculatePer@1009 : 'Item Ledger Entry,Item';
      CalculationBase@1007 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
    BEGIN
      // Test to reproduce Bug245517 in TFS
      Initialize;

      // Setup Item.
      LibraryPatterns.MAKEItem(Item,Item."Costing Method"::Average,0,0,0,'');
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);

      Day1 := WORKDATE;
      Qty := LibraryRandom.RandIntInRange(2,10);
      // Post positive adjustment for item.
      LibraryPatterns.POSTPositiveAdjustment(Item,Location.Code,'','',Qty,Day1,LibraryRandom.RandDec(100,2));
      LibraryPatterns.InsertTempILEFromLast(TempItemLedgerEntry);

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Revalue.
      LibraryPatterns.CalculateInventoryValueRun(
        ItemJournalBatch,Item,Day1,CalculatePer::Item,FALSE,FALSE,FALSE,CalculationBase::" ",FALSE,'','');
      LibraryPatterns.ModifyPostRevaluation(ItemJournalBatch,LibraryRandom.RandDecInRange(1,3,2));

      // Post positive adjustment at different location.
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      LibraryPatterns.POSTPositiveAdjustment(Item,Location.Code,'','',Qty,Day1,0);
      LibraryPatterns.InsertTempILEFromLast(TempItemLedgerEntry);

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Revalue to a lesser unit cost.
      LibraryPatterns.CalculateInventoryValueRun(
        ItemJournalBatch,Item,Day1,CalculatePer::Item,FALSE,FALSE,FALSE,CalculationBase::" ",FALSE,'','');
      LibraryPatterns.ModifyPostRevaluation(ItemJournalBatch,LibraryRandom.RandDecInRange(0,1,2));

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Verify.
      LibraryCosting.CheckAdjustment(Item);
      Item.GET(Item."No.");
      REPEAT
        ItemLedgerEntry.GET(TempItemLedgerEntry."Entry No.");
        ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
        Assert.AreEqual(
          ROUND(TempItemLedgerEntry.Quantity * Item."Unit Cost",LibraryERM.GetAmountRoundingPrecision),
          ItemLedgerEntry."Cost Amount (Actual)",'Wrong revalued cost amount in entry ' + FORMAT(ItemLedgerEntry."Entry No."));
      UNTIL TempItemLedgerEntry.NEXT = 0;
    END;

    [Test]
    PROCEDURE VSTF311425@23();
    VAR
      FIFOItem@1000 : Record 27;
      LIFOItem@1002 : Record 27;
      RevalueItem@1006 : Record 27;
      ItemJournalLine@1004 : Record 83;
      ItemJournalBatch@1003 : Record 233;
      Day1@1001 : Date;
      Qty@1005 : Decimal;
    BEGIN
      // Test to reproduce Bug311425
      Initialize;
      Day1 := WORKDATE;

      // Make item
      LibraryPatterns.MAKEItem(FIFOItem,FIFOItem."Costing Method"::FIFO,LibraryRandom.RandInt(10),0,0,'');
      LibraryPatterns.MAKEItem(LIFOItem,LIFOItem."Costing Method"::LIFO,LibraryRandom.RandInt(10),0,0,'');

      // Post Item Journals
      Qty := LibraryRandom.RandInt(100);
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::"Positive Adjmt.",FIFOItem,'','','',Qty,Day1,
        FIFOItem."Unit Cost");
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::"Positive Adjmt.",LIFOItem,'','','',Qty,Day1,
        LIFOItem."Unit Cost");

      // Do Revaluation and Verify
      RevalueItem.SETFILTER("No.",'%1|%2',FIFOItem."No.",LIFOItem."No.");
      RevalueItem.SETFILTER("Costing Method",'%1|%2',RevalueItem."Costing Method"::FIFO,RevalueItem."Costing Method"::LIFO);

      LibraryPatterns.CalculateInventoryValueRun(
        ItemJournalBatch,RevalueItem,Day1,CalculatePer::"Item Ledger Entry",FALSE,FALSE,FALSE,CalculationBase::" ",FALSE,'','');
      LibraryPatterns.CHECKCalcInvPost(FIFOItem,ItemJournalBatch,Day1,CalculatePer::"Item Ledger Entry",FALSE,FALSE,'','');
      LibraryPatterns.CHECKCalcInvPost(LIFOItem,ItemJournalBatch,Day1,CalculatePer::"Item Ledger Entry",FALSE,FALSE,'','');
    END;

    [Test]
    PROCEDURE VSTF177847@29();
    VAR
      Item@1000 : Record 27;
      ItemJournalBatch@1003 : Record 233;
      ItemJournalBatch2@1007 : Record 233;
      ItemJournalLine@1004 : Record 83;
      ItemJournalLine2@1008 : Record 83;
      TotalQty@1001 : Decimal;
      SalesQty@1002 : Decimal;
      UnitCost@1006 : Decimal;
      PostingDate@1005 : Date;
    BEGIN
      // [FEATURE] [Standard Cost] [Revaluation]
      // [SCENARIO] Calc. Inventory Value for Standard Cost Item does not take into account later Revaluation.

      // [GIVEN] Purchase Item of Standard Cost = 0, Purchase Cost = "X".
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Standard,0);
      UnitCost := LibraryRandom.RandDec(2,2);

      // Purchase Item
      TotalQty := LibraryRandom.RandDecInRange(2,100,2);
      PostingDate := WORKDATE;
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::Purchase,Item,'','','',TotalQty,PostingDate,UnitCost);

      // [GIVEN] Sell Part of Item in Inventory
      SalesQty := LibraryRandom.RandDecInRange(1,ROUND(TotalQty - 1,1),2);
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::Sale,Item,'','','',SalesQty,PostingDate + 1,
        Item."Unit Cost");

      // [GIVEN] Adjust - both inbound and outbound should have a cost of 0
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // [GIVEN] Revalue the remaining quantity in Day 2 - set Unit Cost to the intended value
      LibraryPatterns.CalculateInventoryValueRun(
        ItemJournalBatch,Item,PostingDate + 1,CalculatePer::"Item Ledger Entry",FALSE,FALSE,FALSE,CalculationBase::" ",FALSE,'','');
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE("Unit Cost (Revalued)",UnitCost);
      ItemJournalLine.MODIFY;
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      // [GIVEN] Adjust
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // [WHEN] Run Calc. Inventory Value on Day 1
      LibraryPatterns.CalculateInventoryValueRun(
        ItemJournalBatch2,Item,PostingDate,CalculatePer::"Item Ledger Entry",FALSE,FALSE,FALSE,CalculationBase::" ",FALSE,'','');
      ItemJournalLine2.SETRANGE("Journal Batch Name",ItemJournalBatch2.Name);
      ItemJournalLine2.FINDFIRST;

      // [THEN] Check Unit Cost = 0 (since the total cost was 0 on Day 1)
      Assert.AreEqual(0,ItemJournalLine2."Unit Cost (Calculated)",TXTIncorrectUnitCostErr);
    END;

    [Test]
    PROCEDURE VSTF343888@31();
    VAR
      Item@1000 : Record 27;
      ItemJournalBatch@1001 : Record 233;
      CalculatePer@1002 : 'Item Ledger Entry,Item';
      TotalQty@1006 : Decimal;
      TotalAmount@1007 : Decimal;
      i@1003 : Integer;
    BEGIN
      // Check that revaluation journal lines correctly created for simple item and option "Calculate ByVariant"

      Initialize;
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::FIFO,0);
      FOR i := 1 TO 2 DO
        PostPositiveAdjmtOnNewLocation(TotalQty,TotalAmount,Item);

      LibraryPatterns.MAKERevaluationJournalLine(
        ItemJournalBatch,Item,WORKDATE,CalculatePer::Item,FALSE,TRUE,FALSE,CalculationBase::" "); // pass true for ByVariant
      VerifyAmountsOnItemJnlLine(ItemJournalBatch,TotalQty,TotalAmount);
    END;

    [Test]
    PROCEDURE CalculateUnitCostStandardWithLaterValueEntry@32();
    VAR
      Item@1000 : Record 27;
      PurchaseHeader@1009 : Record 38;
      PurchaseLine@1010 : Record 39;
      ItemJournalBatch@1003 : Record 233;
      ItemJournalLine@1004 : Record 83;
      UnitCost@1006 : Decimal;
    BEGIN
      // [FEATURE] [Standard Cost] [Calculate Inventory Value]
      // [SCENARIO 137138] Calc. Inventory Value on date "A" for Standard Cost Item takes into account Value Entry with "Posting Date" > "A" but "Valuation Date" <= "A".

      // [GIVEN] Create Purchase Order for Item of Standard Cost = "X".
      Initialize;
      UnitCost := LibraryRandom.RandInt(10);
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Standard,UnitCost);
      LibraryPatterns.MAKEPurchaseOrder(
        PurchaseHeader,PurchaseLine,Item,'','',LibraryRandom.RandInt(5),WORKDATE,UnitCost);

      // [GIVEN] Post Receipt.
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);

      // [GIVEN] Post Invoice of Posting Date = WORKDATE + 2 days.
      WITH PurchaseHeader DO BEGIN
        VALIDATE("Posting Date",WORKDATE + 2);
        VALIDATE("Vendor Invoice No.",LibraryUtility.GenerateGUID);
        MODIFY(TRUE);
      END;
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE);

      // [WHEN] Run Calc. Inventory Value on WORKDATE + 1 day.
      LibraryPatterns.CalculateInventoryValueRun(
        ItemJournalBatch,Item,WORKDATE + 1,CalculatePer::Item,
        FALSE,FALSE,FALSE,CalculationBase::" ",FALSE,'','');
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.FINDFIRST;

      // [THEN] Check "Unit Cost (Calculated)" = "X" (since the cost was posted on WORKDATE + 2 days)
      Assert.AreEqual(UnitCost,ItemJournalLine."Unit Cost (Calculated)",TXTIncorrectUnitCostErr);
    END;

    LOCAL PROCEDURE TestRevalueExistingInv@11(CostingMethod@1005 : Option;StandardCost@1006 : Decimal;CalcPer@1001 : Option;FilterByLocation@1003 : Boolean);
    VAR
      Item@1000 : Record 27;
      TempItemLedgerEntry@1007 : TEMPORARY Record 32;
      ItemJnlBatch@1002 : Record 233;
      Location1@1004 : Record 14;
      Location2@1009 : Record 14;
      LocationFilter@1008 : Code[10];
      LocationCode@1010 : ARRAY [2] OF Code[10];
    BEGIN
      LibraryPatterns.MAKEItem(Item,CostingMethod,StandardCost,0,0,'');
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location1);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location2);
      LocationCode[1] := Location1.Code;
      LocationCode[2] := Location2.Code;
      CreateSetupEntrieswLocInbndandOutbnd(Item,LocationCode,TempItemLedgerEntry,WORKDATE);
      TempItemLedgerEntry.FINDFIRST;
      IF FilterByLocation THEN
        LocationFilter := TempItemLedgerEntry."Location Code";
      ExecuteRevalueExistingInventory(Item,ItemJnlBatch,WORKDATE + 3,CalcPer,FALSE,FALSE,FALSE,CalculationBase::" ",LocationFilter,'');
      ModifyPostRevaluation(ItemJnlBatch,Item."No.",1.1);
      LibraryCosting.CheckAdjustment(Item);
    END;

    LOCAL PROCEDURE TestRevalueExistingInvNegZeroInv@26(CostingMethod@1005 : Option;StandardCost@1006 : Decimal;CalcPer@1001 : Option);
    VAR
      Item@1003 : Record 27;
      TempItemLedgerEntry@1007 : TEMPORARY Record 32;
      ItemJnlBatch@1000 : Record 233;
    BEGIN
      LibraryPatterns.MAKEItem(Item,CostingMethod,StandardCost,0,0,'');
      CreateSetupEntriesNegInv(Item,TempItemLedgerEntry,WORKDATE);
      ExecuteRevalueExistingInventory(Item,ItemJnlBatch,WORKDATE + 2,CalcPer,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
      ExecuteRevalueExistingInventory(Item,ItemJnlBatch,WORKDATE + 1,CalcPer,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
      ExecuteRevalueExistingInventory(Item,ItemJnlBatch,WORKDATE,CalcPer,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
    END;

    LOCAL PROCEDURE TestRevalueExistingInvwLocVar@49(CostingMethod@1002 : Option;StandardCost@1001 : Decimal;CalcPer@1000 : Option);
    VAR
      Item@1003 : Record 27;
      ItemVariant@1005 : Record 5401;
      StockkeepingUnit@1004 : Record 5700;
      TempItemLedgerEntry@1008 : TEMPORARY Record 32;
      ItemJnlBatch@1009 : Record 233;
      Location1@1006 : Record 14;
      Location2@1010 : Record 14;
      LocationCode@1007 : ARRAY [2] OF Code[10];
    BEGIN
      LibraryPatterns.MAKEItem(Item,CostingMethod,StandardCost,3.33,11.33,'');
      LibraryInventory.CreateItemVariant(ItemVariant,Item."No.");
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location1);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location2);
      LocationCode[1] := Location1.Code;
      LocationCode[2] := Location2.Code;
      LibraryInventory.CreateStockkeepingUnitForLocationAndVariant(StockkeepingUnit,LocationCode[1],Item."No.",'');
      LibraryInventory.CreateStockkeepingUnitForLocationAndVariant(StockkeepingUnit,LocationCode[1],Item."No.",ItemVariant.Code);
      LibraryInventory.CreateStockkeepingUnitForLocationAndVariant(StockkeepingUnit,LocationCode[2],Item."No.",'');
      LibraryInventory.CreateStockkeepingUnitForLocationAndVariant(StockkeepingUnit,LocationCode[2],Item."No.",ItemVariant.Code);

      CreateSetupEntrieswSKU2Loc2Var(Item,TempItemLedgerEntry,WORKDATE,LocationCode,ItemVariant.Code);

      ExecuteRevalueExistingInventory(
        Item,ItemJnlBatch,WORKDATE + 2,CalcPer,CostingMethod <> Item."Costing Method"::Average,
        CostingMethod <> Item."Costing Method"::Average,FALSE,CalculationBase::" ",'','');
      ModifyPostRevaluation(ItemJnlBatch,Item."No.",1.1);
      LibraryCosting.CheckAdjustment(Item);

      LibraryPatterns.POSTReclassificationJournalLine(Item,WORKDATE + 9,'',LocationCode[1],'','','',5);
      LibraryPatterns.POSTReclassificationJournalLine(Item,WORKDATE + 9,LocationCode[2],LocationCode[1],ItemVariant.Code,'','',5);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      ExecuteRevalueExistingInventory(
        Item,ItemJnlBatch,WORKDATE + 9,CalcPer,CostingMethod <> Item."Costing Method"::Average,
        CostingMethod <> Item."Costing Method"::Average,FALSE,CalculationBase::" ",'','');
      ModifyPostRevaluation(ItemJnlBatch,Item."No.",1.1);
      LibraryCosting.CheckAdjustment(Item);
    END;

    LOCAL PROCEDURE TestRevalueInboundILEwLoc@10(CostingMethod@1002 : Option;StandardCost@1005 : Decimal);
    VAR
      Item@1000 : Record 27;
      TempItemLedgerEntry@1006 : TEMPORARY Record 32;
      Location1@1003 : Record 14;
      Location2@1004 : Record 14;
      LocationCode@1001 : ARRAY [2] OF Code[10];
    BEGIN
      LibraryPatterns.MAKEItem(Item,CostingMethod,StandardCost,0,0,'');
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location1);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location2);
      LocationCode[1] := Location1.Code;
      LocationCode[2] := Location2.Code;
      CreateSetupEntrieswLocInbndandOutbnd(Item,LocationCode,TempItemLedgerEntry,WORKDATE);
      TempItemLedgerEntry.FINDFIRST;
      LibraryPatterns.ExecutePostRevalueInboundILE(Item,TempItemLedgerEntry,1.1);
    END;

    LOCAL PROCEDURE TestRounding@18(CostingMethod@1001 : Option);
    VAR
      Item@1000 : Record 27;
      ItemJnlBatch@1005 : Record 233;
      TempItemLedgerEntry@1002 : TEMPORARY Record 32;
      TempRefValueEntry@1003 : TEMPORARY Record 5802;
      ValueEntry@1004 : Record 5802;
    BEGIN
      LibraryPatterns.MAKEItem(Item,CostingMethod,3.33333,0,0,'');
      CreateSetupEntriesRounding(Item,TempItemLedgerEntry,WORKDATE);
      TempItemLedgerEntry.FINDFIRST;
      IF CostingMethod = Item."Costing Method"::Average THEN BEGIN
        ExecuteRevalueExistingInventory(Item,ItemJnlBatch,WORKDATE,CalculatePer::Item,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
        ModifyPostRevaluation(ItemJnlBatch,Item."No.",1.2);
      END ELSE
        LibraryPatterns.ExecutePostRevalueInboundILE(Item,TempItemLedgerEntry,1.2);
      LibraryCosting.CheckAdjustment(Item);

      IF CostingMethod <> Item."Costing Method"::Average THEN BEGIN
        ValueEntry.SETRANGE("Item No.",Item."No.");
        ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::Rounding);
        ValueEntry.FINDSET;

        TempRefValueEntry."Cost Amount (Expected)" := 0;
        TempRefValueEntry."Cost Amount (Actual)" := -0.01;
        TempRefValueEntry."Valued Quantity" := 3;
        TempRefValueEntry."Cost per Unit" := 0;
        TempRefValueEntry."Valuation Date" := TempItemLedgerEntry."Posting Date";
        TempRefValueEntry."Entry Type" := TempRefValueEntry."Entry Type"::Rounding;
        TempRefValueEntry."Variance Type" := TempRefValueEntry."Variance Type"::" ";

        LibraryPatterns.CHECKValueEntry(TempRefValueEntry,ValueEntry);

        ValueEntry.NEXT;
        TempRefValueEntry."Cost Amount (Actual)" := 0.01;
        LibraryPatterns.CHECKValueEntry(TempRefValueEntry,ValueEntry);
      END;
    END;

    LOCAL PROCEDURE TestRevaluationCircularTransfer@12(CostingMethod@1000 : Option;StandardCost@1005 : Decimal);
    VAR
      Item@1001 : Record 27;
      TempItemLedgerEntry@1004 : TEMPORARY Record 32;
      ItemJnlBatch@1003 : Record 233;
      Location@1002 : Record 14;
    BEGIN
      LibraryPatterns.MAKEItem(Item,CostingMethod,StandardCost,0,0,'');
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      CreateSetupEntriesCircularTransfer(Item,TempItemLedgerEntry,Location.Code,WORKDATE);
      ExecuteRevalueExistingInventory(Item,ItemJnlBatch,WORKDATE,CalculatePer::Item,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
      ModifyPostRevaluation(ItemJnlBatch,Item."No.",1.1);
      LibraryCosting.CheckAdjustment(Item);

      TempItemLedgerEntry.SETRANGE(Positive,TRUE);
      LibraryCosting.CheckInboundEntriesCost(TempItemLedgerEntry);
    END;

    LOCAL PROCEDURE TestRevaluationSalesReturn@44(CostingMethod@1001 : Option;StandardCost@1000 : Decimal);
    VAR
      Item@1002 : Record 27;
      TempItemLedgerEntry@1003 : TEMPORARY Record 32;
      ItemJnlBatch@1004 : Record 233;
    BEGIN
      LibraryPatterns.MAKEItem(Item,CostingMethod,StandardCost,0,0,'');
      CreateSetupEntriesSalesReturn(Item,TempItemLedgerEntry,WORKDATE);
      ExecuteRevalueExistingInventory(Item,ItemJnlBatch,WORKDATE,CalculatePer::Item,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
      ModifyPostRevaluation(ItemJnlBatch,Item."No.",1.1);
      LibraryCosting.CheckAdjustment(Item);

      TempItemLedgerEntry.SETRANGE(Positive,TRUE);
      LibraryCosting.CheckInboundEntriesCost(TempItemLedgerEntry);
    END;

    LOCAL PROCEDURE CreateSetupEntrieswLocInbndandOutbnd@8(Item@1000 : Record 27;LocationCode@1005 : ARRAY [2] OF Code[10];VAR TempItemLedgerEntry@1008 : TEMPORARY Record 32;StartDate@1007 : Date);
    VAR
      ItemJnlBatch@1001 : Record 233;
      ItemJnlLine@1002 : Record 83;
      ItemLedgerEntry@1009 : Record 32;
      Qty1@1006 : Decimal;
      Qty2@1010 : Decimal;
      Qty3@1011 : Decimal;
      Qty4@1012 : Decimal;
      Qty5@1013 : Decimal;
      Qty6@1014 : Decimal;
      Cost1@1015 : Decimal;
      Cost3@1016 : Decimal;
      Cost5@1017 : Decimal;
    BEGIN
      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatch,ItemJnlBatch."Template Type"::Item);

      Qty1 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Qty2 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Qty3 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Qty4 := LibraryRandom.RandDecInDecimalRange(10,50,2);
      Qty5 := LibraryRandom.RandDecInDecimalRange(10,100,2);
      Qty6 := LibraryRandom.RandDecInDecimalRange(10,50,2);
      Cost1 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Cost3 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Cost5 := LibraryRandom.RandDecInDecimalRange(100,200,2);

      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,LocationCode[1],'',StartDate,ItemJnlLine."Entry Type"::"Positive Adjmt.",Qty1,Cost1);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,LocationCode[2],'',StartDate,ItemJnlLine."Entry Type"::"Positive Adjmt.",Qty2,Cost1);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,LocationCode[1],'',StartDate + 1,ItemJnlLine."Entry Type"::"Positive Adjmt.",Qty3,Cost3);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,LocationCode[1],'',StartDate + 2,ItemJnlLine."Entry Type"::"Negative Adjmt.",Qty4,0);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,LocationCode[1],'',StartDate + 3,ItemJnlLine."Entry Type"::"Positive Adjmt.",Qty5,Cost5);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,LocationCode[1],'',StartDate + 5,ItemJnlLine."Entry Type"::"Negative Adjmt.",Qty6,0);

      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);

      ItemLedgerEntry.SETCURRENTKEY("Item No.");
      ItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgerEntry.FINDSET;
      REPEAT
        TempItemLedgerEntry := ItemLedgerEntry;
        TempItemLedgerEntry.INSERT;
      UNTIL ItemLedgerEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE CreateSetupEntriesNegInv@37(Item@1002 : Record 27;VAR TempItemLedgerEntry@1001 : TEMPORARY Record 32;StartDate@1000 : Date);
    VAR
      ItemJnlBatch@1004 : Record 233;
      ItemJnlLine@1003 : Record 83;
      ItemLedgerEntry@1005 : Record 32;
      Qty1@1006 : Decimal;
      Qty2@1007 : Decimal;
      Qty3@1008 : Decimal;
      Cost1@1009 : Decimal;
    BEGIN
      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatch,ItemJnlBatch."Template Type"::Item);

      Qty1 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Qty3 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Qty2 := Qty1 + Qty3;
      Cost1 := LibraryRandom.RandDecInDecimalRange(100,200,2);

      LibraryPatterns.MAKEItemJournalLine(ItemJnlLine,ItemJnlBatch,Item,'','',StartDate,ItemJnlLine."Entry Type"::Purchase,Qty1,Cost1);
      LibraryPatterns.MAKEItemJournalLine(ItemJnlLine,ItemJnlBatch,Item,'','',StartDate + 1,ItemJnlLine."Entry Type"::Sale,Qty2,0);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,'','',StartDate + 2,ItemJnlLine."Entry Type"::Purchase,Qty3,Cost1);

      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);

      ItemLedgerEntry.SETCURRENTKEY("Item No.");
      ItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgerEntry.FINDSET;
      REPEAT
        TempItemLedgerEntry := ItemLedgerEntry;
        TempItemLedgerEntry.INSERT;
      UNTIL ItemLedgerEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE CreateSetupEntrieswSKU2Loc2Var@58(Item@1000 : Record 27;VAR TempItemLedgerEntry@1002 : TEMPORARY Record 32;StartDate@1001 : Date;Location@1003 : ARRAY [2] OF Code[10];ItemVariant@1004 : Code[10]);
    VAR
      ItemJnlBatch@1009 : Record 233;
      ItemJnlLine@1010 : Record 83;
      ItemLedgerEntry@1005 : Record 32;
      Cost1@1008 : Decimal;
      Cost2@1007 : Decimal;
      Cost3@1006 : Decimal;
      Cost4@1025 : Decimal;
      Cost5@1024 : Decimal;
      Cost6@1023 : Decimal;
      QtyNoLocPur1@1026 : Decimal;
      QtyNoLocPur2@1027 : Decimal;
      QtyNoLocSal1@1028 : Decimal;
      QtyNoLocSal2@1029 : Decimal;
      QtyLoc1VarPur1@1033 : Decimal;
      QtyLoc1VarPur2@1032 : Decimal;
      QtyLoc1VarSal1@1031 : Decimal;
      QtyLoc1VarSal2@1030 : Decimal;
      QtyLoc2VarPur1@1037 : Decimal;
      QtyLoc2VarPur2@1036 : Decimal;
      QtyLoc2VarSal1@1035 : Decimal;
      QtyLoc2VarSal2@1034 : Decimal;
    BEGIN
      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatch,ItemJnlBatch."Template Type"::Item);

      QtyNoLocSal1 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      // Applies to Sal1, with some leftovers
      QtyNoLocPur1 := LibraryRandom.RandDecInDecimalRange(QtyNoLocSal1,300,2);
      QtyNoLocPur2 := LibraryRandom.RandDecInDecimalRange(50,100,2);
      // Applies to only one of previous purchases
      QtyNoLocSal2 := LibraryRandom.RandDecInDecimalRange(1,Minimum(QtyNoLocPur1 - QtyNoLocSal1,QtyNoLocPur2) - 5,2);

      QtyLoc1VarSal1 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      // Applies to Sal1, with some leftovers
      QtyLoc1VarPur1 := LibraryRandom.RandDecInDecimalRange(QtyLoc1VarSal1,300,2);
      QtyLoc1VarPur2 := LibraryRandom.RandDecInDecimalRange(50,100,2);
      // Applies to only one of previous purchases
      QtyLoc1VarSal2 := LibraryRandom.RandDecInDecimalRange(1,Minimum(QtyLoc1VarPur1 - QtyLoc1VarSal1,QtyLoc1VarPur2) - 5,2);

      QtyLoc2VarSal1 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      // Applies to Sal1, with some leftovers
      QtyLoc2VarPur1 := LibraryRandom.RandDecInDecimalRange(QtyLoc2VarSal1,300,2);
      QtyLoc2VarPur2 := LibraryRandom.RandDecInDecimalRange(50,100,2);
      // Applies to only one of previous purchases
      QtyLoc2VarSal2 := LibraryRandom.RandDecInDecimalRange(1,Minimum(QtyLoc2VarPur1 - QtyLoc2VarSal1,QtyLoc2VarPur2) - 5,2);

      Cost1 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Cost2 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Cost3 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Cost4 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Cost5 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Cost6 := LibraryRandom.RandDecInDecimalRange(100,200,2);

      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,'','',StartDate + 2,ItemJnlLine."Entry Type"::Sale,QtyNoLocSal1,0);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,Location[1],ItemVariant,StartDate + 2,ItemJnlLine."Entry Type"::Sale,QtyLoc1VarSal1,0);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,Location[2],ItemVariant,StartDate + 2,ItemJnlLine."Entry Type"::Sale,QtyLoc2VarSal1,0);

      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,'','',StartDate + 1,ItemJnlLine."Entry Type"::Purchase,QtyNoLocPur1,Cost1);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,Location[1],ItemVariant,StartDate + 1,ItemJnlLine."Entry Type"::Purchase,QtyLoc1VarPur1,Cost2);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,Location[2],ItemVariant,StartDate + 1,ItemJnlLine."Entry Type"::Purchase,QtyLoc2VarPur1,Cost3);

      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,'','',StartDate,ItemJnlLine."Entry Type"::Purchase,QtyNoLocPur2,Cost4);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,Location[1],ItemVariant,StartDate,ItemJnlLine."Entry Type"::Purchase,QtyLoc1VarPur2,Cost5);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,Location[2],ItemVariant,StartDate,ItemJnlLine."Entry Type"::Purchase,QtyLoc2VarPur2,Cost6);

      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,'','',StartDate + 7,ItemJnlLine."Entry Type"::Sale,QtyNoLocSal2,0);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,Location[1],ItemVariant,StartDate + 7,ItemJnlLine."Entry Type"::Sale,QtyLoc1VarSal2,0);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,Location[2],ItemVariant,StartDate + 7,ItemJnlLine."Entry Type"::Sale,QtyLoc2VarSal2,0);

      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);

      ItemLedgerEntry.SETCURRENTKEY("Item No.");
      ItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgerEntry.FINDSET;
      REPEAT
        TempItemLedgerEntry := ItemLedgerEntry;
        TempItemLedgerEntry.INSERT;
      UNTIL ItemLedgerEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE CreateSetupEntriesRounding@7(Item@1000 : Record 27;VAR TempItemLedgerEntry@1005 : TEMPORARY Record 32;StartDate@1001 : Date);
    VAR
      ItemJnlBatch@1003 : Record 233;
      ItemJnlLine@1002 : Record 83;
      ItemLedgerEntry@1004 : Record 32;
    BEGIN
      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatch,ItemJnlBatch."Template Type"::Item);

      // 3 items are purchased at Unit Cost of 3.33333, and sold individually, to force creation of extra rounding Value Entry for non-average costed items
      LibraryPatterns.MAKEItemJournalLine(ItemJnlLine,ItemJnlBatch,Item,'','',StartDate,ItemJnlLine."Entry Type"::Purchase,3,3.33333);
      LibraryPatterns.MAKEItemJournalLine(ItemJnlLine,ItemJnlBatch,Item,'','',StartDate + 1,ItemJnlLine."Entry Type"::Sale,1,0);
      LibraryPatterns.MAKEItemJournalLine(ItemJnlLine,ItemJnlBatch,Item,'','',StartDate + 1,ItemJnlLine."Entry Type"::Sale,1,0);
      LibraryPatterns.MAKEItemJournalLine(ItemJnlLine,ItemJnlBatch,Item,'','',StartDate + 1,ItemJnlLine."Entry Type"::Sale,1,0);
      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);
      ItemLedgerEntry.SETCURRENTKEY("Item No.");
      ItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgerEntry.FINDSET;
      REPEAT
        TempItemLedgerEntry := ItemLedgerEntry;
        TempItemLedgerEntry.INSERT;
      UNTIL ItemLedgerEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE CreateSetupEntriesCircularTransfer@19(Item@1000 : Record 27;VAR TempItemLedgerEntry@1009 : TEMPORARY Record 32;LocationCode@1004 : Code[10];StartDate@1002 : Date);
    VAR
      ItemJnlBatch@1001 : Record 233;
      ItemJnlBatchTransfer@1010 : Record 233;
      ItemJnlLine@1008 : Record 83;
      ItemLedgerEntry@1003 : Record 32;
      Qty1@1005 : Decimal;
      Qty2@1006 : Decimal;
      Cost1@1007 : Decimal;
    BEGIN
      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatch,ItemJnlBatch."Template Type"::Item);

      Qty1 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Qty2 := LibraryRandom.RandDecInDecimalRange(10,Qty1,2);

      Cost1 := LibraryRandom.RandDecInDecimalRange(100,200,2);

      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,Item,'','',StartDate,ItemJnlLine."Entry Type"::"Positive Adjmt.",Qty1,Cost1);
      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);

      ItemLedgerEntry.SETCURRENTKEY("Item No.");
      ItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgerEntry.FINDFIRST;

      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatchTransfer,ItemJnlBatch."Template Type"::Transfer);

      LibraryPatterns.MAKEItemReclassificationJournalLine(ItemJnlLine,ItemJnlBatchTransfer,Item,'','',LocationCode,
        '','',StartDate + 2,Qty2);
      ItemJnlLine.VALIDATE("Applies-to Entry",ItemLedgerEntry."Entry No.");
      ItemJnlLine.MODIFY;

      LibraryInventory.PostItemJournalBatch(ItemJnlBatchTransfer);

      LibraryPatterns.POSTReclassificationJournalLine(Item,StartDate + 3,LocationCode,'','','','',Qty2);

      ItemLedgerEntry.FINDSET;

      REPEAT
        TempItemLedgerEntry := ItemLedgerEntry;
        TempItemLedgerEntry.INSERT;
      UNTIL ItemLedgerEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE CreateSetupEntriesSalesReturn@13(Item@1001 : Record 27;VAR TempItemLedgerEntry@1008 : TEMPORARY Record 32;StartDate@1006 : Date);
    VAR
      ItemJnlBatch@1000 : Record 233;
      ItemJnlBatchSalesReturn@1010 : Record 233;
      ItemJnlLine@1002 : Record 83;
      ItemLedgerEntry@1007 : Record 32;
      Qty1@1005 : Decimal;
      Qty2@1004 : Decimal;
      Cost1@1003 : Decimal;
    BEGIN
      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatch,ItemJnlBatch."Template Type"::Item);

      Qty1 := LibraryRandom.RandDecInDecimalRange(100,200,2);
      Qty2 := LibraryRandom.RandDecInDecimalRange(10,Qty1,2);

      Cost1 := LibraryRandom.RandDecInDecimalRange(100,200,2);

      LibraryPatterns.MAKEItemJournalLine(ItemJnlLine,ItemJnlBatch,Item,'','',StartDate,ItemJnlLine."Entry Type"::Purchase,Qty1,Cost1);
      LibraryPatterns.MAKEItemJournalLine(ItemJnlLine,ItemJnlBatch,Item,'','',StartDate + 2,ItemJnlLine."Entry Type"::Sale,Qty2,0);
      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);
      ItemLedgerEntry.SETCURRENTKEY("Item No.");
      ItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgerEntry.FINDSET;
      REPEAT
        TempItemLedgerEntry := ItemLedgerEntry;
        TempItemLedgerEntry.INSERT;
      UNTIL ItemLedgerEntry.NEXT = 0;

      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatchSalesReturn,ItemJnlBatchSalesReturn."Template Type"::Item);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatchSalesReturn,Item,'','',StartDate + 3,ItemJnlLine."Entry Type"::Sale,-Qty2,0);
      ItemJnlLine.VALIDATE("Applies-from Entry",ItemLedgerEntry."Entry No.");
      ItemJnlLine.MODIFY;
      LibraryInventory.PostItemJournalBatch(ItemJnlBatchSalesReturn);

      ItemLedgerEntry.FINDLAST;
      TempItemLedgerEntry := ItemLedgerEntry;
      TempItemLedgerEntry.INSERT;
    END;

    LOCAL PROCEDURE ExecuteRevalueExistingInventory@63(VAR Item@1000 : Record 27;VAR ItemJnlBatch@1002 : Record 233;PostingDate@1011 : Date;CalculatePer@1009 : Option;ByLocation@1008 : Boolean;ByVariant@1007 : Boolean;UpdStdCost@1006 : Boolean;CalcBase@1005 : Option;LocationFilter@1014 : Code[20];VariantFilter@1004 : Code[20]);
    BEGIN
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
      LibraryCosting.CheckAdjustment(Item);

      LibraryPatterns.CalculateInventoryValueRun(
        ItemJnlBatch,Item,PostingDate,CalculatePer,ByLocation,ByVariant,UpdStdCost,CalcBase,FALSE,LocationFilter,VariantFilter);

      LibraryPatterns.CHECKCalcInvPost(Item,ItemJnlBatch,PostingDate,CalculatePer,ByLocation,ByVariant,LocationFilter,VariantFilter);
    END;

    LOCAL PROCEDURE ModifyPostRevaluation@50(ItemJnlBatch@1000 : Record 233;ItemNoFilter@1002 : Code[20];Factor@1004 : Decimal);
    VAR
      ItemJnlLine@1001 : Record 83;
    BEGIN
      ItemJnlLine.SETRANGE("Journal Template Name",ItemJnlBatch."Journal Template Name");
      ItemJnlLine.SETRANGE("Journal Batch Name",ItemJnlBatch.Name);
      IF ItemJnlLine.FINDSET THEN
        REPEAT
          ItemJnlLine.VALIDATE(
            "Inventory Value (Revalued)",ROUND(ItemJnlLine."Inventory Value (Revalued)" * Factor,LibraryERM.GetAmountRoundingPrecision));
          ItemJnlLine.MODIFY;
        UNTIL (ItemJnlLine.NEXT = 0);
      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);
      LibraryCosting.AdjustCostItemEntries(ItemNoFilter,'');
    END;

    LOCAL PROCEDURE FindFirstItemJnlLine@40(VAR ItemJnlLine@1000 : Record 83;ItemJnlBatch@1001 : Record 233);
    BEGIN
      WITH ItemJnlLine DO BEGIN
        SETRANGE("Journal Template Name",ItemJnlBatch."Journal Template Name");
        SETRANGE("Journal Batch Name",ItemJnlBatch.Name);
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE PostPositiveAdjmtOnNewLocation@35(VAR TotalQty@1000 : Decimal;VAR TotalAmount@1001 : Decimal;Item@1003 : Record 27);
    VAR
      Location@1002 : Record 14;
      Qty@1004 : Decimal;
      UnitAmount@1005 : Decimal;
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      Qty := LibraryRandom.RandInt(100);
      UnitAmount := LibraryRandom.RandDec(100,2);
      LibraryPatterns.POSTPositiveAdjustment(Item,Location.Code,'','',Qty,WORKDATE,UnitAmount);
      TotalQty += Qty;
      TotalAmount += Qty * UnitAmount;
    END;

    LOCAL PROCEDURE Minimum@1(Value1@1000 : Decimal;Value2@1001 : Decimal) : Decimal;
    BEGIN
      IF Value1 < Value2 THEN
        EXIT(Value1);

      EXIT(Value2);
    END;

    LOCAL PROCEDURE VerifyAmountsOnItemJnlLine@42(ItemJnlBatch@1000 : Record 233;ExpectedQty@1001 : Decimal;ExpectedInvValue@1002 : Decimal);
    VAR
      ItemJnlLine@1003 : Record 83;
    BEGIN
      FindFirstItemJnlLine(ItemJnlLine,ItemJnlBatch);
      ItemJnlLine.TESTFIELD(Quantity,ExpectedQty);
      ItemJnlLine.TESTFIELD("Inventory Value (Calculated)",ExpectedInvValue);
    END;

    BEGIN
    {
      // [FEATURE] [Adjust Cost Item Entries] [Revaluation] [SCM]
    }
    END.
  }
}

