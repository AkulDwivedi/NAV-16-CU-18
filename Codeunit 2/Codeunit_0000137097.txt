OBJECT Codeunit 137097 SCM Kitting - Undo
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      ItemJournalTemplate@1006 : Record 82;
      ItemJournalBatch@1001 : Record 233;
      LocationBlue@1008 : Record 14;
      LocationSilver@1002 : Record 14;
      LocationSilverWithPick@1022 : Record 14;
      LocationWhite@1023 : Record 14;
      Assert@1010 : Codeunit 130000;
      LibraryUtility@1004 : Codeunit 131000;
      LibraryInventory@1003 : Codeunit 132201;
      LibrarySales@1020 : Codeunit 130509;
      LibraryManufacturing@1014 : Codeunit 132202;
      LibraryWarehouse@1013 : Codeunit 132204;
      LibraryAssembly@1005 : Codeunit 132207;
      LibraryRandom@1012 : Codeunit 130440;
      GenProdPostingGr@1019 : Code[10];
      AsmInvtPostingGr@1018 : Code[10];
      CompInvtPostingGr@1017 : Code[10];
      isInitialized@1000 : Boolean;
      WorkDate2@1021 : Date;
      ATO_MUST_BE_NO@1011 : TextConst 'ENU="Assemble to Order must be equal to ''No''  in "';
      MSG_CANNOT_RESTORE@1015 : TextConst 'ENU=must be equal';
      MSG_UPDATE@1009 : TextConst 'ENU=Do you want to update the';
      MSG_CREATE_INVT_MOVM@1024 : TextConst 'ENU=Do you want to create Inventory Movement?';
      MSG_ACTIVITY_CREATED@1025 : TextConst 'ENU=has been created.';
      MSG_REMAINING_QTY@1016 : TextConst 'ENU=Remaining Quantity';
      MSG_RESERVED_QTY@1026 : TextConst 'ENU=Reserved Quantity';
      MSG_INSUFFICIENT_QTY@1027 : TextConst 'ENU=it is not available';
      MSG_CANNOT_RESTORE_2@1028 : TextConst 'ENU=number of lines';
      MSG_REVERSED@1029 : TextConst 'ENU=Reversed';
      ConfirmUndoCount@1030 : Integer;
      MSG_WANT_RECREATE@1031 : TextConst 'ENU=Do you want to recreate the assembly order from the posted assembly order?';
      MSG_WANT_UNDO@1032 : TextConst 'ENU=Do you want to undo posting of the posted assembly order?';

    [Normal]
    LOCAL PROCEDURE Initialize@8();
    VAR
      LibraryERMCountryData@1001 : Codeunit 131305;
    BEGIN
      ConfirmUndoCount := 0;

      IF isInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.UpdateSalesReceivablesSetup;

      GlobalSetup;

      isInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE GlobalSetup@1();
    VAR
      WarehouseEmployee@1000 : Record 7301;
    BEGIN
      SetupAssembly;
      SetupItemJournal;
      SetupManufacturingSetup;
      WarehouseEmployee.RESET;
      WarehouseEmployee.DELETEALL(TRUE);
      LibraryAssembly.SetupPostingToGL(GenProdPostingGr,AsmInvtPostingGr,CompInvtPostingGr,'');
      LocationSetup(LocationBlue,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
      LocationSetup(LocationSilver,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE);
      LocationSetup(LocationSilverWithPick,FALSE,FALSE,FALSE,FALSE,TRUE,TRUE);
      LocationSetup(LocationWhite,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE SetupAssembly@127();
    VAR
      InventorySetup@1001 : Record 313;
      AssemblySetup@1002 : Record 905;
      PurchasesPayablesSetup@1006 : Record 312;
      SalesSetup@1005 : Record 311;
      ManufacturingSetupRec@1004 : Record 99000765;
    BEGIN
      InventorySetup.GET;
      InventorySetup.VALIDATE("Transfer Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      InventorySetup.MODIFY(TRUE);

      AssemblySetup.GET;
      AssemblySetup.VALIDATE("Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Posted Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Assembly Quote Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Blanket Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Default Location for Orders",'');
      AssemblySetup.VALIDATE("Copy Component Dimensions from",AssemblySetup."Copy Component Dimensions from"::"Order Header");
      AssemblySetup.VALIDATE("Copy Comments when Posting",AssemblySetup."Copy Comments when Posting"::"1");
      AssemblySetup.VALIDATE("Stockout Warning",FALSE);
      AssemblySetup.MODIFY(TRUE);

      SalesSetup.GET;
      SalesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Return Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Blanket Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Quote Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Invoice Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Posted Invoice Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Posted Shipment Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Stockout Warning",FALSE);
      SalesSetup.VALIDATE("Credit Warnings",SalesSetup."Credit Warnings"::"No Warning");
      SalesSetup.MODIFY(TRUE);

      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      PurchasesPayablesSetup.MODIFY(TRUE);

      ManufacturingSetupRec.GET;
      ManufacturingSetupRec.VALIDATE("Planned Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      ManufacturingSetupRec.VALIDATE("Firm Planned Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      ManufacturingSetupRec.VALIDATE("Released Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      ManufacturingSetupRec.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE SetupItemJournal@138();
    BEGIN
      CLEAR(ItemJournalTemplate);
      ItemJournalTemplate.INIT;
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      ItemJournalTemplate.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      ItemJournalTemplate.MODIFY(TRUE);

      CLEAR(ItemJournalBatch);
      ItemJournalBatch.INIT;
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      ItemJournalBatch.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      ItemJournalBatch.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE LocationSetup@62(VAR Location@1000 : Record 14;Directed@1005 : Boolean;RequireReceive@1009 : Boolean;RequireShipment@1007 : Boolean;RequirePutAway@1010 : Boolean;RequirePick@1008 : Boolean;BinMandatory@1001 : Boolean);
    VAR
      WarehouseEmployee@1004 : Record 7301;
      Bin@1003 : Record 7354;
      BinCount@1002 : Integer;
    BEGIN
      IF Directed THEN
        LibraryWarehouse.CreateFullWMSLocation(Location,8)
      ELSE BEGIN
        LibraryWarehouse.CreateLocationWMS(Location,BinMandatory,RequirePutAway,RequirePick,RequireReceive,RequireShipment);
        FOR BinCount := 1 TO 8 DO
          LibraryWarehouse.CreateBin(Bin,Location.Code,'Bin ' + FORMAT(BinCount),'','');
      END;
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,Location.Code,Directed);
    END;

    LOCAL PROCEDURE SetupManufacturingSetup@168();
    VAR
      ManufacturingSetup@1000 : Record 99000765;
    BEGIN
      CLEAR(ManufacturingSetup);
      ManufacturingSetup.GET;
      EVALUATE(ManufacturingSetup."Default Safety Lead Time",'<1D>');
      ManufacturingSetup.MODIFY(TRUE);

      WorkDate2 := CALCDATE(ManufacturingSetup."Default Safety Lead Time",WORKDATE); // to avoid Due Date Before Work Date message.
    END;

    [Normal]
    LOCAL PROCEDURE CreateAssemblyList@20(ParentItem@1000 : Record 27;NoOfComponents@1001 : Integer;NoOfResources@1002 : Integer;NoOfTexts@1003 : Integer;QtyPer@1004 : Decimal);
    VAR
      Item@1008 : Record 27;
      AssemblyLine@1005 : Record 901;
      Resource@1009 : Record 156;
      BOMComponent@1006 : Record 90;
      CompCount@1007 : Integer;
    BEGIN
      // Add components - qty per is increasing same as no of components
      FOR CompCount := 1 TO NoOfComponents DO BEGIN
        CLEAR(Item);
        LibraryInventory.CreateItem(Item);
        LibraryAssembly.AddEntityDimensions(AssemblyLine.Type::Item,Item."No.");
        AddComponentToAssemblyList(
          BOMComponent,BOMComponent.Type::Item,Item."No.",ParentItem."No.",'',
          BOMComponent."Resource Usage Type"::Direct,Item."Base Unit of Measure",QtyPer);
      END;

      // Add resources - qty per is increasing same as no of components
      FOR CompCount := 1 TO NoOfResources DO BEGIN
        LibraryAssembly.CreateResource(Resource,TRUE,GenProdPostingGr);
        LibraryAssembly.AddEntityDimensions(AssemblyLine.Type::Resource,Resource."No.");
        AddComponentToAssemblyList(
          BOMComponent,BOMComponent.Type::Resource,Resource."No.",ParentItem."No.",'',
          BOMComponent."Resource Usage Type"::Direct,Resource."Base Unit of Measure",QtyPer);
      END;

      // Add simple text
      FOR CompCount := 1 TO NoOfTexts DO
        AddComponentToAssemblyList(BOMComponent,BOMComponent.Type::" ",'',ParentItem."No.",'',
          BOMComponent."Resource Usage Type"::Direct,'',0);
    END;

    LOCAL PROCEDURE CreateInternalMovementGetBin@88(VAR InternalMovementHeader@1004 : Record 7346;ItemNo@1000 : Code[20];LocationCode@1003 : Code[10];ToBinCode@1005 : Code[20];BinContentFilter@1001 : Code[100]);
    BEGIN
      LibraryWarehouse.CreateInternalMovementHeader(InternalMovementHeader,LocationCode,ToBinCode);
      LibraryWarehouse.GetBinContentInternalMovement(InternalMovementHeader,LocationCode,ItemNo,BinContentFilter);
    END;

    [Normal]
    LOCAL PROCEDURE AddComponentToAssemblyList@12(VAR BOMComponent@1008 : Record 90;ComponentType@1000 : Option;ComponentNo@1001 : Code[20];ParentItemNo@1005 : Code[20];VariantCode@1007 : Code[10];ResourceUsage@1006 : Option;UOM@1003 : Code[10];QuantityPer@1002 : Decimal);
    BEGIN
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentItemNo,ComponentType,ComponentNo,QuantityPer,UOM);
      IF ComponentType = BOMComponent.Type::Resource THEN
        BOMComponent.VALIDATE("Resource Usage Type",ResourceUsage);
      BOMComponent.VALIDATE("Variant Code",VariantCode);
      IF ComponentNo = '' THEN
        BOMComponent.VALIDATE(Description,
          LibraryUtility.GenerateRandomCode(BOMComponent.FIELDNO(Description),DATABASE::"BOM Component"));
      BOMComponent.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CreateAssemblyOrder@9(VAR AssemblyHeader@1001 : Record 900;ParentItem@1000 : Record 27;LocationCode@1002 : Code[10];BinCode@1006 : Code[20];VariantCode@1005 : Code[10];DueDate@1004 : Date;Quantity@1003 : Decimal);
    BEGIN
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,DueDate,ParentItem."No.",LocationCode,Quantity,VariantCode);
      AssemblyHeader.VALIDATE("Bin Code",BinCode);
      AssemblyHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAssemblyOrderWithInventory@95(VAR AssemblyHeader@1003 : Record 900;VAR Item@1004 : Record 27;OrderQty@1005 : Decimal;LocationCode@1002 : Code[10];HeaderBinCode@1001 : Code[20];ComponentsBinCode@1000 : Code[20]);
    VAR
      DueDate@1006 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),1);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,HeaderBinCode,'',DueDate,OrderQty);

      // Add enough inventory for comp and post
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,ComponentsBinCode);
    END;

    LOCAL PROCEDURE CreateAssembledItem@10(VAR Item@1000 : Record 27;AssemblyPolicy@1001 : Option;NoOfComponents@1005 : Integer;NoOfResources@1004 : Integer;NoOfTexts@1003 : Integer;QtyPer@1002 : Decimal);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::Assembly);
      Item.VALIDATE("Assembly Policy",AssemblyPolicy);
      Item.MODIFY(TRUE);
      CreateAssemblyList(Item,NoOfComponents,NoOfResources,NoOfTexts,QtyPer);
    END;

    LOCAL PROCEDURE AddCommentsToOrder@26(AssemblyHeader@1000 : Record 900);
    VAR
      AssemblyLine@1001 : Record 901;
    BEGIN
      LibraryAssembly.AddAssemblyHeaderComment(AssemblyHeader,0);
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      IF NOT AssemblyLine.FINDSET THEN
        EXIT;

      REPEAT
        LibraryAssembly.AddAssemblyHeaderComment(AssemblyHeader,AssemblyLine."Line No.");
      UNTIL AssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE CopyPostedAOToTemp@137(PostedAssemblyHeader@1000 : Record 910;VAR TempPostedAssemblyHeader@1003 : TEMPORARY Record 910;VAR TempPostedAssemblyLine@1001 : TEMPORARY Record 911);
    VAR
      PostedAssemblyLine@1002 : Record 911;
    BEGIN
      // Header
      TempPostedAssemblyHeader.DELETEALL;
      TempPostedAssemblyHeader := PostedAssemblyHeader;
      TempPostedAssemblyHeader.INSERT;

      // Lines
      TempPostedAssemblyLine.DELETEALL;
      PostedAssemblyLine.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      IF NOT PostedAssemblyLine.FINDSET THEN
        EXIT;

      REPEAT
        TempPostedAssemblyLine := PostedAssemblyLine;
        TempPostedAssemblyLine.INSERT;
      UNTIL PostedAssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE CopyAOToTemp@11(AssemblyHeader@1000 : Record 900;VAR TempAssemblyHeader@1003 : TEMPORARY Record 900;VAR TempAssemblyLine@1001 : TEMPORARY Record 901);
    VAR
      AssemblyLine@1002 : Record 901;
    BEGIN
      // Header
      TempAssemblyHeader.RESET;
      TempAssemblyHeader.DELETEALL;
      TempAssemblyHeader := AssemblyHeader;
      TempAssemblyHeader.INSERT;

      // Lines
      TempAssemblyLine.RESET;
      TempAssemblyLine.DELETEALL;
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      IF NOT AssemblyLine.FINDSET THEN
        EXIT;

      REPEAT
        TempAssemblyLine := AssemblyLine;
        TempAssemblyLine.INSERT;
      UNTIL AssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE CreateSaleDocType@65(VAR SalesHeader@1000 : Record 36;DocumentType@1005 : Option;ItemNo@1006 : Code[20];VariantCode@1003 : Code[10];SalesQty@1002 : Decimal;ShipmentDate@1001 : Date;LocationCode@1007 : Code[10]);
    VAR
      SalesLine@1004 : Record 37;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,DocumentType,'');
      SalesHeader.VALIDATE("Location Code",LocationCode);
      SalesHeader.VALIDATE("Shipment Date",ShipmentDate);
      SalesHeader.MODIFY(TRUE);
      LibrarySales.CreateSalesLineWithShipmentDate(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,ShipmentDate,SalesQty);
      SalesLine.VALIDATE("Variant Code",VariantCode);
      SalesLine.VALIDATE("Location Code",LocationCode);
      SalesLine.VALIDATE("Shipment Date",ShipmentDate);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesOrder@77(VAR SalesHeader@1000 : Record 36;ItemNo@1001 : Code[20];VariantCode@1004 : Code[10];SalesQty@1003 : Decimal;ShipmentDate@1002 : Date;LocationCode@1006 : Code[10]);
    BEGIN
      CreateSaleDocType(SalesHeader,SalesHeader."Document Type"::Order,ItemNo,VariantCode,SalesQty,ShipmentDate,LocationCode);
    END;

    LOCAL PROCEDURE FindSOL@15(SalesHeader@1004 : Record 36;VAR SalesLine@1005 : Record 37;SOLIndex@1003 : Integer);
    BEGIN
      CLEAR(SalesLine);
      SalesLine.SETRANGE("Document Type",SalesHeader."Document Type");
      SalesLine.SETRANGE("Document No.",SalesHeader."No.");
      SalesLine.FINDSET(TRUE);

      IF SOLIndex > 1 THEN
        SalesLine.NEXT(SOLIndex - 1);
    END;

    LOCAL PROCEDURE GetMaxValue@6(Value1@1000 : Decimal;Value2@1001 : Decimal) : Decimal;
    BEGIN
      IF Value1 >= Value2 THEN
        EXIT(Value1);

      EXIT(Value2);
    END;

    LOCAL PROCEDURE GetTotalPostedQuantityBaseHeader@3(AssemblyOrderNo@1000 : Code[20]) : Decimal;
    VAR
      PostedAssemblyHeader@1001 : Record 910;
      Quantity@1002 : Decimal;
    BEGIN
      Quantity := 0;

      // Consider the postings of this initial AO without the undone (reversed) orders - and assumes no posted AO has been deleted
      PostedAssemblyHeader.SETRANGE("Order No.",AssemblyOrderNo);
      PostedAssemblyHeader.SETRANGE(Reversed,FALSE);
      IF NOT PostedAssemblyHeader.FINDSET THEN
        EXIT(Quantity);

      REPEAT
        Quantity += PostedAssemblyHeader."Quantity (Base)";
      UNTIL PostedAssemblyHeader.NEXT = 0;

      EXIT(Quantity);
    END;

    LOCAL PROCEDURE GetTotalPostedQuantityBaseLine@28(AssemblyOrderNo@1000 : Code[20];LineNo@1003 : Integer) : Decimal;
    VAR
      PostedAssemblyHeader@1001 : Record 910;
      PostedAssemblyLine@1004 : Record 911;
      Quantity@1002 : Decimal;
    BEGIN
      Quantity := 0;

      // Consider the postings of this initial AO without the undone (reversed) orders - and assumes no posted AO has been deleted
      PostedAssemblyHeader.SETRANGE("Order No.",AssemblyOrderNo);
      PostedAssemblyHeader.SETRANGE(Reversed,FALSE);
      IF NOT PostedAssemblyHeader.FINDSET THEN
        EXIT(Quantity);

      REPEAT
        PostedAssemblyLine.SETRANGE("Document No.",PostedAssemblyHeader."No.");
        PostedAssemblyLine.SETRANGE("Line No.",LineNo);
        PostedAssemblyLine.FINDFIRST; // let it fail if doesn't exist
        Quantity += PostedAssemblyLine."Quantity (Base)";
      UNTIL PostedAssemblyHeader.NEXT = 0;

      EXIT(Quantity);
    END;

    LOCAL PROCEDURE SetLocAndBinCodeOnAsmLines@71(AssemblyHeader@1000 : Record 900;Bin@1001 : Record 7354);
    VAR
      AssemblyLine@1002 : Record 901;
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);

      IF AssemblyLine.FINDSET THEN
        REPEAT
          AssemblyLine.VALIDATE("Location Code",Bin."Location Code");
          AssemblyLine.VALIDATE("Bin Code",Bin.Code);
          AssemblyLine.MODIFY(TRUE);
        UNTIL AssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE PostAssemblyOrderQty@24(VAR AssemblyHeader@1001 : Record 900;Qty@1002 : Decimal);
    VAR
      AssemblyPost@1000 : Codeunit 900;
    BEGIN
      CLEAR(AssemblyPost);
      AssemblyHeader.VALIDATE("Quantity to Assemble",Qty);
      AssemblyHeader.MODIFY(TRUE);

      AssemblyPost.RUN(AssemblyHeader);
    END;

    LOCAL PROCEDURE FindAssemblyHeader@22(VAR AssemblyHeader@1007 : Record 900;DocumentType@1006 : Option;Item@1005 : Record 27;VariantCode@1004 : Code[10];LocationCode@1003 : Code[10];BinCode@1008 : Code[10];DueDate@1002 : Date;UOM@1001 : Code[10];Qty@1000 : Decimal);
    BEGIN
      CLEAR(AssemblyHeader);
      AssemblyHeader.SETRANGE("Document Type",DocumentType);
      AssemblyHeader.SETRANGE("Item No.",Item."No.");
      IF VariantCode = '' THEN
        AssemblyHeader.SETRANGE(Description,Item.Description)
      ELSE
        AssemblyHeader.SETRANGE(Description,VariantCode);
      AssemblyHeader.SETFILTER("Variant Code",'%1',VariantCode);
      AssemblyHeader.SETFILTER("Location Code",'%1',LocationCode);
      AssemblyHeader.SETFILTER("Bin Code",'%1',BinCode);
      AssemblyHeader.SETRANGE("Due Date",DueDate);
      AssemblyHeader.SETRANGE("Unit of Measure Code",UOM);
      AssemblyHeader.SETRANGE(Quantity,Qty);
      AssemblyHeader.SETRANGE("Quantity (Base)",Qty * LibraryInventory.GetQtyPerForItemUOM(Item."No.",UOM));

      AssemblyHeader.FINDSET;
    END;

    LOCAL PROCEDURE FindPostedAssemblyHeaderNotReversed@23(VAR PostedAssemblyHeader@1001 : Record 910;SourceAssemblyHeaderNo@1007 : Code[20]);
    BEGIN
      CLEAR(PostedAssemblyHeader);
      PostedAssemblyHeader.SETRANGE("Order No.",SourceAssemblyHeaderNo);
      PostedAssemblyHeader.SETRANGE(Reversed,FALSE);
      PostedAssemblyHeader.FINDFIRST;
    END;

    LOCAL PROCEDURE FindSalesShptLine@93(SalesLine@1008 : Record 37;VAR SalesShptLine@1006 : Record 111);
    BEGIN
      CLEAR(SalesShptLine);
      SalesShptLine.SETRANGE("Order No.",SalesLine."Document No.");
      SalesShptLine.SETRANGE("Order Line No.",SalesLine."Line No.");
      SalesShptLine.SETRANGE("Quantity Invoiced",0);
      SalesShptLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindWhseActivityLine@130(VAR WarehouseActivityLine@1000 : Record 5767;AssemblyHeader@1002 : Record 900);
    VAR
      WarehouseActivityHeader@1001 : Record 5766;
      WarehouseRequest@1003 : Record 5765;
    BEGIN
      WITH WarehouseActivityLine DO BEGIN
        SETRANGE("Activity Type",WarehouseActivityHeader.Type::Pick);
        SETRANGE("Source No.",AssemblyHeader."No.");
        SETRANGE("Source Document",WarehouseRequest."Source Document"::"Assembly Consumption");
        SETRANGE("Source Type",DATABASE::"Assembly Line");
        SETRANGE("Source Subtype",AssemblyHeader."Document Type");
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE MockWhseEntry@122(Item@1001 : Record 27;Qty@1002 : Decimal);
    VAR
      WarehouseEntry@1000 : Record 7312;
    BEGIN
      WITH WarehouseEntry DO BEGIN
        INIT;
        "Entry No." := LibraryUtility.GetNewRecNo(WarehouseEntry,FIELDNO("Entry No."));
        "Location Code" := LocationWhite.Code;
        "Item No." := Item."No.";
        "Qty. (Base)" := Qty;
        "Unit of Measure Code" := Item."Base Unit of Measure";
        "Bin Code" := LocationWhite."From-Assembly Bin Code";
        INSERT;
      END;
    END;

    LOCAL PROCEDURE AssertMergedAOAfterUndo@7(VAR TempAssemblyHeader@1003 : TEMPORARY Record 900;VAR TempAssemblyLine@1002 : TEMPORARY Record 901;VAR TempPostedAssemblyHeader@1001 : TEMPORARY Record 910;VAR TempPostedAssemblyLine@1000 : TEMPORARY Record 911);
    VAR
      FinalAssemblyHeader@1005 : Record 900;
      FinalAssemblyLine@1004 : Record 901;
    BEGIN
      // Check header
      CLEAR(FinalAssemblyHeader);
      FinalAssemblyHeader.GET(TempAssemblyHeader."Document Type",TempAssemblyHeader."No.");
      FinalAssemblyHeader.TESTFIELD("Item No.",TempAssemblyHeader."Item No.");
      FinalAssemblyHeader.TESTFIELD("Variant Code",TempAssemblyHeader."Variant Code");
      FinalAssemblyHeader.TESTFIELD("Location Code",TempAssemblyHeader."Location Code");
      FinalAssemblyHeader.TESTFIELD("Bin Code",TempAssemblyHeader."Bin Code");
      FinalAssemblyHeader.TESTFIELD("Due Date",TempAssemblyHeader."Due Date");
      FinalAssemblyHeader.TESTFIELD("Quantity (Base)",TempAssemblyHeader."Quantity (Base)");
      FinalAssemblyHeader.TESTFIELD(
        "Remaining Quantity (Base)",TempAssemblyHeader."Remaining Quantity (Base)" + TempPostedAssemblyHeader."Quantity (Base)");
      FinalAssemblyHeader.TESTFIELD(
        "Assembled Quantity (Base)",TempAssemblyHeader."Assembled Quantity (Base)" - TempPostedAssemblyHeader."Quantity (Base)");
      FinalAssemblyHeader.TESTFIELD(
        "Quantity to Assemble (Base)",TempAssemblyHeader."Quantity to Assemble (Base)" + TempPostedAssemblyHeader."Quantity (Base)");
      FinalAssemblyHeader.TESTFIELD("Unit of Measure Code",TempAssemblyHeader."Unit of Measure Code");
      FinalAssemblyHeader.TESTFIELD("Dimension Set ID",TempAssemblyHeader."Dimension Set ID");

      // Check Lines
      TempAssemblyLine.SETRANGE("Document Type",FinalAssemblyHeader."Document Type");
      TempAssemblyLine.SETRANGE("Document No.",FinalAssemblyHeader."No.");
      IF TempAssemblyLine.FINDSET THEN
        REPEAT
          FinalAssemblyLine.GET(TempAssemblyLine."Document Type",TempAssemblyLine."Document No.",TempAssemblyLine."Line No.");
          TempPostedAssemblyLine.GET(TempPostedAssemblyHeader."No.",TempAssemblyLine."Line No.");
          FinalAssemblyLine.TESTFIELD("No.",TempAssemblyLine."No.");
          FinalAssemblyLine.TESTFIELD("Variant Code",TempAssemblyLine."Variant Code");
          FinalAssemblyLine.TESTFIELD("Location Code",TempAssemblyLine."Location Code");
          FinalAssemblyLine.TESTFIELD("Bin Code",TempAssemblyLine."Bin Code");
          FinalAssemblyLine.TESTFIELD("Quantity (Base)",FinalAssemblyHeader."Quantity (Base)" * FinalAssemblyLine."Quantity per");
          FinalAssemblyLine.TESTFIELD(
            "Consumed Quantity (Base)",TempAssemblyLine."Consumed Quantity (Base)" - TempPostedAssemblyLine."Quantity (Base)");
          FinalAssemblyLine.TESTFIELD(
            "Remaining Quantity (Base)",FinalAssemblyLine."Quantity (Base)" - FinalAssemblyLine."Consumed Quantity (Base)");
          FinalAssemblyLine.TESTFIELD("Quantity to Consume (Base)",FinalAssemblyLine."Quantity to Consume (Base)");
          FinalAssemblyLine.TESTFIELD(
            "Quantity per",GetMaxValue(TempAssemblyLine."Quantity per",TempPostedAssemblyLine."Quantity per"));
          FinalAssemblyLine.TESTFIELD("Unit of Measure Code",FinalAssemblyLine."Unit of Measure Code");
          FinalAssemblyLine.TESTFIELD("Dimension Set ID",TempAssemblyLine."Dimension Set ID");
        UNTIL TempAssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE AssertNewAOAfterUndo@47(VAR TempPostedAssemblyHeader@1001 : TEMPORARY Record 910;VAR TempPostedAssemblyLine@1000 : TEMPORARY Record 911);
    VAR
      FinalAssemblyHeader@1005 : Record 900;
      FinalAssemblyLine@1004 : Record 901;
    BEGIN
      // Check header
      CLEAR(FinalAssemblyHeader);
      FinalAssemblyHeader.GET(FinalAssemblyHeader."Document Type"::Order,TempPostedAssemblyHeader."Order No.");
      FinalAssemblyHeader.TESTFIELD("Item No.",TempPostedAssemblyHeader."Item No.");
      FinalAssemblyHeader.TESTFIELD("Variant Code",TempPostedAssemblyHeader."Variant Code");
      FinalAssemblyHeader.TESTFIELD("Location Code",TempPostedAssemblyHeader."Location Code");
      FinalAssemblyHeader.TESTFIELD("Bin Code",TempPostedAssemblyHeader."Bin Code");
      FinalAssemblyHeader.TESTFIELD("Due Date",TempPostedAssemblyHeader."Due Date");
      FinalAssemblyHeader.TESTFIELD(
        "Quantity (Base)",
        TempPostedAssemblyHeader."Quantity (Base)" + GetTotalPostedQuantityBaseHeader(TempPostedAssemblyHeader."Order No."));
      FinalAssemblyHeader.TESTFIELD(
        "Remaining Quantity (Base)",FinalAssemblyHeader."Quantity (Base)" - FinalAssemblyHeader."Assembled Quantity (Base)");
      FinalAssemblyHeader.TESTFIELD(
        "Assembled Quantity (Base)",GetTotalPostedQuantityBaseHeader(TempPostedAssemblyHeader."Order No."));
      FinalAssemblyHeader.TESTFIELD("Quantity to Assemble (Base)",TempPostedAssemblyHeader."Quantity (Base)");
      FinalAssemblyHeader.TESTFIELD("Unit of Measure Code",TempPostedAssemblyHeader."Unit of Measure Code");
      FinalAssemblyHeader.TESTFIELD("Dimension Set ID",TempPostedAssemblyHeader."Dimension Set ID");

      // Check Lines
      TempPostedAssemblyLine.RESET;
      TempPostedAssemblyLine.SETRANGE("Document No.",TempPostedAssemblyHeader."No.");
      IF TempPostedAssemblyLine.FINDSET THEN
        REPEAT
          FinalAssemblyLine.GET(
            FinalAssemblyLine."Document Type"::Order,TempPostedAssemblyHeader."Order No.",TempPostedAssemblyLine."Line No.");
          FinalAssemblyLine.TESTFIELD("No.",TempPostedAssemblyLine."No.");
          FinalAssemblyLine.TESTFIELD("Variant Code",TempPostedAssemblyLine."Variant Code");
          FinalAssemblyLine.TESTFIELD("Location Code",TempPostedAssemblyLine."Location Code");
          FinalAssemblyLine.TESTFIELD("Bin Code",TempPostedAssemblyLine."Bin Code");
          FinalAssemblyLine.TESTFIELD(
            "Quantity (Base)",
            TempPostedAssemblyLine."Quantity (Base)" +
            GetTotalPostedQuantityBaseLine(TempPostedAssemblyLine."Order No.",TempPostedAssemblyLine."Line No."));
          FinalAssemblyLine.TESTFIELD(
            "Consumed Quantity (Base)",
            GetTotalPostedQuantityBaseLine(TempPostedAssemblyLine."Order No.",TempPostedAssemblyLine."Line No."));
          FinalAssemblyLine.TESTFIELD("Quantity per",TempPostedAssemblyLine."Quantity per");
          FinalAssemblyLine.TESTFIELD(
            "Remaining Quantity (Base)",FinalAssemblyLine."Quantity (Base)" - FinalAssemblyLine."Consumed Quantity (Base)");
          FinalAssemblyLine.TESTFIELD("Quantity to Consume (Base)",TempPostedAssemblyLine."Quantity (Base)");
          FinalAssemblyLine.TESTFIELD("Unit of Measure Code",TempPostedAssemblyLine."Unit of Measure Code");
          FinalAssemblyLine.TESTFIELD("Dimension Set ID",TempPostedAssemblyLine."Dimension Set ID");
        UNTIL TempPostedAssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE AssertReversedDoc@33(VAR PostedAssemblyHeader@1003 : Record 910;VAR TempPostedAssemblyHeader@1001 : TEMPORARY Record 910);
    BEGIN
      // Check header few fields - re-get the header first
      PostedAssemblyHeader.GET(PostedAssemblyHeader."No.");
      PostedAssemblyHeader.TESTFIELD(Reversed,TRUE); // this should be the only one changed...
      TempPostedAssemblyHeader.TESTFIELD("Order No.",PostedAssemblyHeader."Order No.");
      TempPostedAssemblyHeader.TESTFIELD("Item No.",PostedAssemblyHeader."Item No.");
      TempPostedAssemblyHeader.TESTFIELD("Location Code",PostedAssemblyHeader."Location Code");
      TempPostedAssemblyHeader.TESTFIELD("Bin Code",PostedAssemblyHeader."Bin Code");
      TempPostedAssemblyHeader.TESTFIELD("Due Date",PostedAssemblyHeader."Due Date");
      TempPostedAssemblyHeader.TESTFIELD("Quantity (Base)",PostedAssemblyHeader."Quantity (Base)");
      TempPostedAssemblyHeader.TESTFIELD("Cost Amount",PostedAssemblyHeader."Cost Amount");
    END;

    LOCAL PROCEDURE ProcessWMSPick@68(VAR AssemblyHeader@1001 : Record 900);
    VAR
      WarehouseActivityHeader@1000 : Record 5766;
      WarehouseActivityLine@1003 : Record 5767;
    BEGIN
      // Release and create whse pick
      LibraryAssembly.ReleaseAO(AssemblyHeader);
      LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);

      // Find the whse pick
      FindWhseActivityLine(WarehouseActivityLine,AssemblyHeader);

      WarehouseActivityHeader.GET(WarehouseActivityLine."Activity Type",WarehouseActivityLine."No.");

      // Register pick
      LibraryWarehouse.RegisterWhseActivity(WarehouseActivityHeader);
    END;

    LOCAL PROCEDURE RegisterPickWithQtyToHandle@118(VAR AssemblyHeader@1001 : Record 900;Qty@1004 : Decimal);
    VAR
      WarehouseActivityHeader@1000 : Record 5766;
      WarehouseActivityLine@1003 : Record 5767;
    BEGIN
      FindWhseActivityLine(WarehouseActivityLine,AssemblyHeader);
      WITH WarehouseActivityLine DO
        REPEAT
          VALIDATE("Qty. to Handle",Qty);
          MODIFY(TRUE);
        UNTIL NEXT = 0;

      WarehouseActivityHeader.GET(WarehouseActivityLine."Activity Type",WarehouseActivityLine."No.");
      LibraryWarehouse.RegisterWhseActivity(WarehouseActivityHeader);
    END;

    LOCAL PROCEDURE ReserveSalesLine@29(VAR SalesLine@1000 : Record 37;FullReservation@1001 : Boolean;QtyToReserve@1002 : Decimal);
    VAR
      ReservationManagement@1004 : Codeunit 99000845;
    BEGIN
      ReservationManagement.SetSalesLine(SalesLine);
      ReservationManagement.AutoReserve(FullReservation,'',SalesLine."Shipment Date",
        ROUND(QtyToReserve / SalesLine."Qty. per Unit of Measure",0.00001),QtyToReserve);
      SalesLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmUpdateNo@2(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,MSG_UPDATE) > 0,'Actual:' + GETLASTERRORTEXT);
      Reply := FALSE; // Don't change - as test is verifying this option
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmCreateMvmt@74(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,MSG_CREATE_INVT_MOVM) > 0,'Actual:' + GETLASTERRORTEXT);
      Reply := TRUE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmUndo@90(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      ConfirmUndoCount += 1;

      CASE ConfirmUndoCount OF
        1:
          BEGIN
            Assert.IsTrue(STRPOS(Question,MSG_WANT_UNDO) > 0,PADSTR('Actual' + FORMAT(ConfirmUndoCount) + ':' + Question + ';Expected:' + MSG_WANT_UNDO,1024));
            Reply := FALSE;
          END;
        2:
          BEGIN
            Assert.IsTrue(STRPOS(Question,MSG_WANT_UNDO) > 0,PADSTR('Actual' + FORMAT(ConfirmUndoCount) + ':' + Question + ';Expected:' + MSG_WANT_UNDO,1024));
            Reply := TRUE;
          END;
        3:
          BEGIN
            Assert.IsTrue(STRPOS(Question,MSG_WANT_RECREATE) > 0,PADSTR('Actual' + FORMAT(ConfirmUndoCount) + ':' + Question + ';Expected:' + MSG_WANT_RECREATE,1024));
            Reply := TRUE;
          END;
        ELSE BEGIN
          Assert.Fail(PADSTR('Actual' + FORMAT(ConfirmUndoCount) + ':' + Question + ';Expected:',1024));
          Reply := FALSE;
        END;
      END;
    END;

    [MessageHandler]
    PROCEDURE MessageActivityCreated@78(Text@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(STRPOS(Text,MSG_ACTIVITY_CREATED) > 0,'Actual:' + GETLASTERRORTEXT);
    END;

    [Test]
    PROCEDURE CannotUndoOutputOutboundedBlank@125();
    VAR
      Flow@1000 : 'PostOutput,ReserveOutput';
    BEGIN
      Initialize;
      TCCannotUndoOutput('',Flow::PostOutput);
    END;

    [Test]
    PROCEDURE CannotUndoOutputOutboundedBlue@16();
    VAR
      Flow@1000 : 'PostOutput,ReserveOutput';
    BEGIN
      Initialize;
      TCCannotUndoOutput(LocationBlue.Code,Flow::PostOutput);
    END;

    [Test]
    PROCEDURE CannotUndoOutputReservedBlank@27();
    VAR
      Flow@1000 : 'PostOutput,ReserveOutput';
    BEGIN
      Initialize;
      TCCannotUndoOutput('',Flow::ReserveOutput);
    END;

    [Test]
    PROCEDURE CannotUndoOutputReservedBlue@25();
    VAR
      Flow@1000 : 'PostOutput,ReserveOutput';
    BEGIN
      Initialize;
      TCCannotUndoOutput(LocationBlue.Code,Flow::ReserveOutput);
    END;

    LOCAL PROCEDURE TCCannotUndoOutput@4(LocationCode@1003 : Code[10];Flow@1002 : 'PostOutput,ReserveOutput');
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1005 : Record 900;
      PostedAssemblyHeader@1008 : Record 910;
      SalesHeader@1001 : Record 36;
      SalesLine@1004 : Record 37;
      OrderQty@1006 : Decimal;
      DueDate@1007 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));

      // create AO
      OrderQty := LibraryRandom.RandDec(1000,2);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,'','',DueDate,OrderQty);

      // Add enough inventory for comp and post
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,'');
      PostAssemblyOrderQty(AssemblyHeader,OrderQty);

      // Exercise - create SalesOrder and post
      CreateSalesOrder(
        SalesHeader,Item."No.",'',OrderQty,CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',DueDate),LocationCode);

      CASE Flow OF
        Flow::PostOutput:
          LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
        Flow::ReserveOutput:
          BEGIN
            FindSOL(SalesHeader,SalesLine,1);
            ReserveSalesLine(SalesLine,TRUE,1);
          END;
      END;

      // Exercise - undo - can't undo
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
      CASE Flow OF
        Flow::PostOutput:
          LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,MSG_REMAINING_QTY);
        Flow::ReserveOutput:
          LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,MSG_RESERVED_QTY);
      END;
    END;

    [Test]
    PROCEDURE CannotUndoATOBlank@21();
    BEGIN
      Initialize;
      TCCannotUndoATO('',LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE CannotUndoATOBlue@19();
    BEGIN
      Initialize;
      TCCannotUndoATO(LocationBlue.Code,LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE TCCannotUndoATO@18(LocationCode@1003 : Code[10];QtyPercentage@1004 : Decimal);
    VAR
      Item@1000 : Record 27;
      PostedAssemblyHeader@1002 : Record 910;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1008 : Record 37;
      OrderQty@1006 : Decimal;
      DueDate@1007 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));

      // create AO
      OrderQty := LibraryRandom.RandDec(1000,2);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);

      // Exercise - create SalesOrder with ATO
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,LocationCode);

      // Make it mix ATO - if percentage < 100
      FindSOL(SalesHeader,SalesLine,1);
      SalesLine.VALIDATE("Qty. to Assemble to Order",(OrderQty * QtyPercentage) / 100);
      SalesLine.MODIFY(TRUE);

      // Post
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,Item,'',LocationCode,'',DueDate,
        Item."Base Unit of Measure",SalesLine."Qty. to Assemble to Order");
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,'');
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Exercise - undo - can't undo
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,ATO_MUST_BE_NO);
    END;

    [Test]
    PROCEDURE CannotUndoReversedDocBlank@43();
    BEGIN
      Initialize;
      TCCannotUndoUndoneDoc('');
    END;

    [Test]
    PROCEDURE CannotUndoReversedDocBlue@42();
    BEGIN
      Initialize;
      TCCannotUndoUndoneDoc(LocationBlue.Code);
    END;

    LOCAL PROCEDURE TCCannotUndoUndoneDoc@41(LocationCode@1003 : Code[10]);
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1005 : Record 900;
      PostedAssemblyHeader@1002 : Record 910;
      OrderQty@1006 : Decimal;
      DueDate@1007 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));

      // create AO
      OrderQty := LibraryRandom.RandDec(1000,2);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,'','',DueDate,OrderQty);

      // Add enough inventory for comp and post
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,'');
      PostAssemblyOrderQty(AssemblyHeader,OrderQty);

      // Undo
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,'');

      // Exercise - can't undo the already reversed order
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,MSG_REVERSED);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckDocBlank@30();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',TRUE,AssertOption::ReversedDocs,FALSE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckDocBlue@17();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,TRUE,AssertOption::ReversedDocs,FALSE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckDocBlank@44();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',FALSE,AssertOption::ReversedDocs,FALSE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckDocBlue@40();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,FALSE,AssertOption::ReversedDocs,FALSE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckILEsBlank@48();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',TRUE,AssertOption::ILEs,FALSE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckILEsBlue@46();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,TRUE,AssertOption::ILEs,FALSE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckILEsBlank@45();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',FALSE,AssertOption::ILEs,FALSE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckILEsBlue@39();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,FALSE,AssertOption::ILEs,FALSE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckCapEntriesBlank@54();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',TRUE,AssertOption::CapacityEntries,FALSE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckCapEntriesBlue@53();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,TRUE,AssertOption::CapacityEntries,FALSE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckCapEntriesBlank@52();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',FALSE,AssertOption::CapacityEntries,FALSE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckCapEntriesBlue@49();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,FALSE,AssertOption::CapacityEntries,FALSE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckDocBlankATO@110();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',TRUE,AssertOption::ReversedDocs,TRUE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckDocBlueATO@109();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,TRUE,AssertOption::ReversedDocs,TRUE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckDocBlankATO@108();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',FALSE,AssertOption::ReversedDocs,TRUE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckDocBlueATO@107();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,FALSE,AssertOption::ReversedDocs,TRUE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckILEsBlankATO@106();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',TRUE,AssertOption::ILEs,TRUE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckILEsBlueATO@105();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,TRUE,AssertOption::ILEs,TRUE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckILEsBlankATO@104();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',FALSE,AssertOption::ILEs,TRUE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckILEsBlueATO@103();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,FALSE,AssertOption::ILEs,TRUE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckCapEntriesBlankATO@102();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',TRUE,AssertOption::CapacityEntries,TRUE);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckCapEntriesBlueATO@101();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,TRUE,AssertOption::CapacityEntries,TRUE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckCapEntriesBlankATO@97();
    VAR
      AssertOption@1001 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc('',FALSE,AssertOption::CapacityEntries,TRUE);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckCapEntriesBlueATO@96();
    VAR
      AssertOption@1000 : 'ReversedDocs,ILEs,CapacityEntries';
    BEGIN
      Initialize;
      TCUndoCheckDoc(LocationBlue.Code,FALSE,AssertOption::CapacityEntries,TRUE);
    END;

    LOCAL PROCEDURE TCUndoCheckDoc@14(LocationCode@1003 : Code[10];FullPosting@1010 : Boolean;AssertOption@1011 : 'ReversedDocs,ILEs,CapacityEntries';IsATO@1012 : Boolean);
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1013 : Record 36;
      SalesLine@1014 : Record 37;
      SalesShptLine@1015 : Record 111;
      TempAssemblyHeader@1008 : TEMPORARY Record 900;
      TempAssemblyLine@1009 : TEMPORARY Record 901;
      PostedAssemblyHeader@1002 : Record 910;
      TempPostedAssemblyHeader@1001 : TEMPORARY Record 910;
      TempPostedAssemblyLine@1004 : TEMPORARY Record 911;
      UndoSalesShptLine@1016 : Codeunit 5815;
      OrderQty@1006 : Decimal;
      DueDate@1007 : Date;
    BEGIN
      // Create AO
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));
      OrderQty := LibraryRandom.RandDec(1000,2) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);

      IF IsATO THEN BEGIN
        CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,LocationCode);
        FindSOL(SalesHeader,SalesLine,1);
        SalesLine.AsmToOrderExists(AssemblyHeader);
      END ELSE
        CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,'','',DueDate,OrderQty);

      // Add enough inventory for comp and post
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,'');
      IF FullPosting THEN BEGIN
        IF IsATO THEN
          LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE)
        ELSE
          PostAssemblyOrderQty(AssemblyHeader,OrderQty)
      END ELSE BEGIN
        IF IsATO THEN BEGIN
          SalesLine.FIND;
          SalesLine.VALIDATE("Qty. to Ship",ROUND(SalesLine."Qty. to Ship" / 2,0.00001));
          SalesLine.MODIFY(TRUE);
          LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);
          AssemblyHeader.FIND;
        END ELSE
          PostAssemblyOrderQty(AssemblyHeader,OrderQty / 2);
      END;

      // Copy docs to temp
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
      CopyPostedAOToTemp(PostedAssemblyHeader,TempPostedAssemblyHeader,TempPostedAssemblyLine);
      IF NOT FullPosting THEN
        CopyAOToTemp(AssemblyHeader,TempAssemblyHeader,TempAssemblyLine);

      // Exercise - undo
      IF IsATO THEN BEGIN
        FindSalesShptLine(SalesLine,SalesShptLine);
        UndoSalesShptLine.SetHideDialog(TRUE);
        UndoSalesShptLine.RUN(SalesShptLine);
      END ELSE
        LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,'');

      // Verify
      CASE AssertOption OF
        // Check reversed docs
        AssertOption::ReversedDocs:
          BEGIN
            AssertReversedDoc(PostedAssemblyHeader,TempPostedAssemblyHeader);
            IF FullPosting THEN
              AssertNewAOAfterUndo(TempPostedAssemblyHeader,TempPostedAssemblyLine)
            ELSE
              AssertMergedAOAfterUndo(TempAssemblyHeader,TempAssemblyLine,TempPostedAssemblyHeader,TempPostedAssemblyLine);
          END;
        AssertOption::ILEs:
          BEGIN
            // Verify ILEs
            LibraryAssembly.VerifyILEsUndo(TempPostedAssemblyHeader,TempPostedAssemblyLine,FALSE);
            LibraryAssembly.VerifyILEsUndo(TempPostedAssemblyHeader,TempPostedAssemblyLine,TRUE);
          END;
        AssertOption::CapacityEntries:
          BEGIN
            // Verify Cap Ledger
            LibraryAssembly.VerifyCapEntriesUndo(TempPostedAssemblyHeader,TempPostedAssemblyLine,FALSE);
            LibraryAssembly.VerifyCapEntriesUndo(TempPostedAssemblyHeader,TempPostedAssemblyLine,TRUE);
          END;
      END;
    END;

    [Test]
    PROCEDURE CannotUndoDocNewLineBlank@34();
    VAR
      ChangeOption@1000 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines';
    BEGIN
      Initialize;
      TCCannotUndoChangedDoc('',ChangeOption::"New Line");
    END;

    [Test]
    PROCEDURE CannotUndoDocNewLineBlue@32();
    VAR
      ChangeOption@1000 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines';
    BEGIN
      Initialize;
      TCCannotUndoChangedDoc(LocationBlue.Code,ChangeOption::"New Line");
    END;

    [Test]
    PROCEDURE CannotUndoDocDeletedLineBlank@51();
    VAR
      ChangeOption@1001 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines';
    BEGIN
      Initialize;
      TCCannotUndoChangedDoc('',ChangeOption::"Delete Line");
    END;

    [Test]
    PROCEDURE CannotUndoDocDeletedLineBlue@50();
    VAR
      ChangeOption@1000 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines';
    BEGIN
      Initialize;
      TCCannotUndoChangedDoc(LocationBlue.Code,ChangeOption::"Delete Line");
    END;

    [Test]
    PROCEDURE CannotUndoNewLocationLinesBlank@86();
    VAR
      ChangeOption@1000 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines';
    BEGIN
      Initialize;
      TCCannotUndoChangedDoc('',ChangeOption::"Change Location Lines");
    END;

    [Test]
    PROCEDURE CannotUndoNewLocationLinesBlue@85();
    VAR
      ChangeOption@1000 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines';
    BEGIN
      Initialize;
      TCCannotUndoChangedDoc(LocationBlue.Code,ChangeOption::"Change Location Lines");
    END;

    [Test]
    PROCEDURE CannotUndoNewBinLinesSilver@87();
    VAR
      ChangeOption@1000 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines';
    BEGIN
      Initialize;
      TCCannotUndoChangedDoc(LocationSilver.Code,ChangeOption::"Change Bin Lines");
    END;

    [Test]
    [HandlerFunctions(ConfirmUpdateNo)]
    PROCEDURE CannotUndoNewLocationBlank@100();
    VAR
      ChangeOption@1000 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines';
    BEGIN
      Initialize;
      TCCannotUndoChangedDoc('',ChangeOption::"Change Location");
    END;

    [Test]
    [HandlerFunctions(ConfirmUpdateNo)]
    PROCEDURE CannotUndoNewLocationBlue@99();
    VAR
      ChangeOption@1000 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines';
    BEGIN
      Initialize;
      TCCannotUndoChangedDoc(LocationBlue.Code,ChangeOption::"Change Location");
    END;

    [Test]
    PROCEDURE CannotUndoNewBinSilver@98();
    VAR
      ChangeOption@1000 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines';
    BEGIN
      Initialize;
      TCCannotUndoChangedDoc(LocationSilver.Code,ChangeOption::"Change Bin");
    END;

    LOCAL PROCEDURE TCCannotUndoChangedDoc@13(LocationCode@1003 : Code[10];ChangeOption@1010 : 'New Line,Delete Line,Change Location,Change Bin,Change Location Lines,Change Bin Lines');
    VAR
      Item@1000 : Record 27;
      Location@1014 : Record 14;
      NewItem@1008 : Record 27;
      AssemblyHeader@1005 : Record 900;
      AssemblyLine@1004 : Record 901;
      HeaderBin@1009 : Record 7354;
      ComponentsBin@1011 : Record 7354;
      BinSilver1@1012 : Record 7354;
      BinSilver2@1013 : Record 7354;
      PostedAssemblyHeader@1002 : Record 910;
      OrderQty@1006 : Decimal;
      DueDate@1007 : Date;
      BinIndex@1001 : Integer;
    BEGIN
      // Get bins
      BinIndex := 1;
      IF LocationCode <> '' THEN BEGIN
        Location.GET(LocationCode);
        LibraryWarehouse.FindBin(HeaderBin,LocationCode,'',BinIndex + 2);
        LibraryWarehouse.FindBin(ComponentsBin,LocationCode,'',BinIndex);
      END;

      LibraryWarehouse.FindBin(BinSilver1,LocationSilver.Code,'',BinIndex + 2);
      LibraryWarehouse.FindBin(BinSilver2,LocationSilver.Code,'',BinIndex + 1);

      // Create AO item
      LibraryInventory.CreateItem(NewItem);
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));
      OrderQty := LibraryRandom.RandDec(1000,2) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);

      // Create AO and add enough inventory for comp
      IF (LocationCode <> '') AND Location."Bin Mandatory" THEN BEGIN
        CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,HeaderBin.Code,'',DueDate,OrderQty);
        SetLocAndBinCodeOnAsmLines(AssemblyHeader,ComponentsBin);
        LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,ComponentsBin.Code);
      END ELSE BEGIN
        CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,'','',DueDate,OrderQty);
        LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,'');
      END;

      // Post partial
      PostAssemblyOrderQty(AssemblyHeader,OrderQty / 2);
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
      LibraryAssembly.ReopenAO(AssemblyHeader);

      // Change the initial AO
      CASE ChangeOption OF
        ChangeOption::"New Line":
          LibraryAssembly.CreateAssemblyLine(
            AssemblyHeader,AssemblyLine,AssemblyLine.Type::Item,NewItem."No.",NewItem."Base Unit of Measure",
            LibraryRandom.RandDec(1000,2),0,NewItem.Description);
        ChangeOption::"Delete Line":
          LibraryAssembly.DeleteAssemblyLine(AssemblyLine.Type::Item,AssemblyHeader."No.");
        ChangeOption::"Change Location Lines": // Assumes current function is called with Location <> Location Silver as param
          SetLocAndBinCodeOnAsmLines(AssemblyHeader,BinSilver1);
        ChangeOption::"Change Bin Lines": // Assumes current function is called with Location Silver as param
          SetLocAndBinCodeOnAsmLines(AssemblyHeader,BinSilver1);
        ChangeOption::"Change Location": // Assumes current function is called with Location <> Location Silver as param
          BEGIN
            AssemblyHeader.VALIDATE("Location Code",LocationSilver.Code);
            AssemblyHeader.MODIFY(TRUE);
          END;
        ChangeOption::"Change Bin": // Assumes current function is called with Location Silver as param
          BEGIN
            AssemblyHeader.VALIDATE("Bin Code",BinSilver2.Code);
            AssemblyHeader.MODIFY(TRUE);
          END;
      END;

      // Undo - error
      IF ChangeOption IN [ChangeOption::"New Line",ChangeOption::"Delete Line"] THEN
        LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,MSG_CANNOT_RESTORE_2)
      ELSE
        LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,MSG_CANNOT_RESTORE);
    END;

    [Test]
    PROCEDURE UndoCheckCommentsBlank@36();
    BEGIN
      Initialize;
      TCUndoCheckComments('');
    END;

    [Test]
    PROCEDURE UndoCheckCommentsBlue@35();
    BEGIN
      Initialize;
      TCUndoCheckComments(LocationBlue.Code);
    END;

    LOCAL PROCEDURE TCUndoCheckComments@31(LocationCode@1003 : Code[10]);
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1005 : Record 900;
      PostedAssemblyHeader@1002 : Record 910;
      OrderQty@1006 : Decimal;
      DueDate@1007 : Date;
    BEGIN
      // Create AO
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));
      OrderQty := LibraryRandom.RandDec(1000,2) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,'','',DueDate,OrderQty);
      AddCommentsToOrder(AssemblyHeader);

      // Add enough inventory for comp and post
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,'');
      PostAssemblyOrderQty(AssemblyHeader,OrderQty);

      // Undo
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,'');

      // Exercise - verify comments
      LibraryAssembly.VerifyComments(AssemblyHeader);
    END;

    [Test]
    PROCEDURE UndoCheckDimensionsBlank@55();
    BEGIN
      Initialize;
      TCUndoCheckDimensions('');
    END;

    [Test]
    PROCEDURE UndoCheckDimensionsBlue@38();
    BEGIN
      Initialize;
      TCUndoCheckDimensions(LocationBlue.Code);
    END;

    LOCAL PROCEDURE TCUndoCheckDimensions@37(LocationCode@1003 : Code[10]);
    VAR
      Item@1000 : Record 27;
      AssemblySetup@1001 : Record 905;
      AssemblyHeader@1005 : Record 900;
      PostedAssemblyHeader@1002 : Record 910;
      OrderQty@1006 : Decimal;
      DueDate@1007 : Date;
    BEGIN
      // Create AO
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));
      OrderQty := LibraryRandom.RandDec(1000,2) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,'','',DueDate,OrderQty);

      // Add enough inventory for comp and post
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,'');
      PostAssemblyOrderQty(AssemblyHeader,OrderQty);

      // Undo
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,'');

      // Exercise - verify dimensions
      LibraryAssembly.CheckOrderDimensions(AssemblyHeader,AssemblySetup."Copy Component Dimensions from"::"Order Header");
    END;

    [Test]
    PROCEDURE UndoMultipleCheckDocBlank@58();
    BEGIN
      Initialize;
      TCUndoMultipleCheckDoc('');
    END;

    [Test]
    PROCEDURE UndoMultipleCheckDocBlue@57();
    BEGIN
      Initialize;
      TCUndoMultipleCheckDoc(LocationBlue.Code);
    END;

    LOCAL PROCEDURE TCUndoMultipleCheckDoc@56(LocationCode@1003 : Code[10]);
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1005 : Record 900;
      TempAssemblyHeader@1008 : TEMPORARY Record 900;
      TempAssemblyLine@1009 : TEMPORARY Record 901;
      PostedAssemblyHeader@1002 : Record 910;
      TempPostedAssemblyHeader@1001 : TEMPORARY Record 910;
      TempPostedAssemblyLine@1004 : TEMPORARY Record 911;
      OrderQty@1006 : Decimal;
      DueDate@1007 : Date;
      i@1012 : Integer;
    BEGIN
      // Create AO
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));
      OrderQty := LibraryRandom.RandDec(1000,2) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,'','',DueDate,OrderQty);

      // Add enough inventory for comp and post 4 times
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,'');

      // Post full in 4 partial postings
      FOR i := 1 TO 4 DO
        PostAssemblyOrderQty(AssemblyHeader,OrderQty / 4);

      // Undo and verify
      FOR i := 1 TO 4 DO BEGIN
        // Copy docs to temp
        FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
        CopyPostedAOToTemp(PostedAssemblyHeader,TempPostedAssemblyHeader,TempPostedAssemblyLine);
        IF i > 1 THEN BEGIN
          AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,AssemblyHeader."No.");
          CopyAOToTemp(AssemblyHeader,TempAssemblyHeader,TempAssemblyLine);
        END;

        // Exercise - undo
        LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,'');

        // Verify
        AssertReversedDoc(PostedAssemblyHeader,TempPostedAssemblyHeader);
        IF i = 1 THEN
          AssertNewAOAfterUndo(TempPostedAssemblyHeader,TempPostedAssemblyLine)
        ELSE
          AssertMergedAOAfterUndo(TempAssemblyHeader,TempAssemblyLine,TempPostedAssemblyHeader,TempPostedAssemblyLine);
      END;
    END;

    [Test]
    PROCEDURE UndoDontCreateAOBlank@61();
    BEGIN
      Initialize;
      TCUndoDontCreateAO('');
    END;

    [Test]
    PROCEDURE UndoDontCreateAOBlue@60();
    BEGIN
      Initialize;
      TCUndoDontCreateAO(LocationBlue.Code);
    END;

    LOCAL PROCEDURE TCUndoDontCreateAO@59(LocationCode@1003 : Code[10]);
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1005 : Record 900;
      PostedAssemblyHeader@1002 : Record 910;
      OrderQty@1006 : Decimal;
      DueDate@1007 : Date;
    BEGIN
      // Create AO
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));
      OrderQty := LibraryRandom.RandDec(1000,2) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,'','',DueDate,OrderQty);

      // Add enough inventory for comp and post
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,'');
      PostAssemblyOrderQty(AssemblyHeader,OrderQty);

      // Exercise - undo
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,FALSE,'');

      // Verify - order should not be created
      ASSERTERROR AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
    END;

    [Test]
    PROCEDURE PostFullUndoCheckWhseEntriesSilver@67();
    VAR
      AssertOption@1001 : 'WhseEntries,BinContents';
    BEGIN
      Initialize;
      TCUndoCheckWhse(LocationSilver,TRUE,AssertOption::WhseEntries);
    END;

    [Test]
    PROCEDURE PostFullUndoCheckBinContentsSilver@66();
    VAR
      AssertOption@1000 : 'WhseEntries,BinContents';
    BEGIN
      Initialize;
      TCUndoCheckWhse(LocationSilver,TRUE,AssertOption::BinContents);
    END;

    [Test]
    PROCEDURE PostPartialUndoChecWhseEntriesSilver@64();
    VAR
      AssertOption@1000 : 'WhseEntries,BinContents';
    BEGIN
      Initialize;
      TCUndoCheckWhse(LocationSilver,FALSE,AssertOption::WhseEntries);
    END;

    [Test]
    PROCEDURE PostPartialUndoCheckBinContentsSilver@63();
    VAR
      AssertOption@1000 : 'WhseEntries,BinContents';
    BEGIN
      Initialize;
      TCUndoCheckWhse(LocationSilver,FALSE,AssertOption::BinContents);
    END;

    [Test]
    [HandlerFunctions(MessageActivityCreated)]
    PROCEDURE PostFullUndoCheckWhseEntriesWhite@73();
    VAR
      AssertOption@1001 : 'WhseEntries,BinContents';
    BEGIN
      Initialize;
      TCUndoCheckWhse(LocationWhite,TRUE,AssertOption::WhseEntries);
    END;

    [Test]
    [HandlerFunctions(MessageActivityCreated)]
    PROCEDURE PostFullUndoCheckBinContentsWhite@72();
    VAR
      AssertOption@1000 : 'WhseEntries,BinContents';
    BEGIN
      Initialize;
      TCUndoCheckWhse(LocationWhite,TRUE,AssertOption::BinContents);
    END;

    [Test]
    [HandlerFunctions(MessageActivityCreated)]
    PROCEDURE PostPartialUndoChecWhseEntriesWhite@70();
    VAR
      AssertOption@1000 : 'WhseEntries,BinContents';
    BEGIN
      Initialize;
      TCUndoCheckWhse(LocationWhite,FALSE,AssertOption::WhseEntries);
    END;

    [Test]
    [HandlerFunctions(MessageActivityCreated)]
    PROCEDURE PostPartialUndoCheckBinContentsWhite@69();
    VAR
      AssertOption@1000 : 'WhseEntries,BinContents';
    BEGIN
      Initialize;
      TCUndoCheckWhse(LocationWhite,FALSE,AssertOption::BinContents);
    END;

    LOCAL PROCEDURE TCUndoCheckWhse@5(Location@1003 : Record 14;FullPosting@1010 : Boolean;AssertOption@1011 : 'WhseEntries,BinContents');
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1005 : Record 900;
      TempAssemblyHeader@1008 : TEMPORARY Record 900;
      TempAssemblyLine@1009 : TEMPORARY Record 901;
      PostedAssemblyHeader@1002 : Record 910;
      HeaderBin@1012 : Record 7354;
      ComponentsBin@1013 : Record 7354;
      OrderQty@1006 : Decimal;
      BinIndex@1004 : Integer;
    BEGIN
      // Get Bin codes
      BinIndex := 1;

      IF NOT Location."Directed Put-away and Pick" THEN BEGIN// if not Full WMS
        LibraryWarehouse.FindBin(HeaderBin,Location.Code,'',BinIndex);
        LibraryWarehouse.FindBin(ComponentsBin,Location.Code,'',BinIndex + 1);
      END ELSE BEGIN
        HeaderBin.GET(Location.Code,Location."From-Production Bin Code");
        LibraryWarehouse.FindBin(ComponentsBin,Location.Code,'PICK',BinIndex);
      END;

      // Create AO
      OrderQty := LibraryRandom.RandDec(1000,2) + 1;
      CreateAssemblyOrderWithInventory(AssemblyHeader,Item,OrderQty,Location.Code,HeaderBin.Code,ComponentsBin.Code);

      // If Full WMS - process whse pick, else set bin on the lines to point where the inventory exists
      IF NOT Location."Directed Put-away and Pick" THEN
        SetLocAndBinCodeOnAsmLines(AssemblyHeader,ComponentsBin)
      ELSE
        ProcessWMSPick(AssemblyHeader);

      // Copy to temp & post AO
      IF FullPosting THEN BEGIN
        CopyAOToTemp(AssemblyHeader,TempAssemblyHeader,TempAssemblyLine);
        PostAssemblyOrderQty(AssemblyHeader,OrderQty);
      END ELSE BEGIN
        PostAssemblyOrderQty(AssemblyHeader,OrderQty / 2);
        CopyAOToTemp(AssemblyHeader,TempAssemblyHeader,TempAssemblyLine);
      END;

      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");

      // Exercise - undo
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,FALSE,'');

      // Verify
      CASE AssertOption OF
        AssertOption::WhseEntries:
          BEGIN
            LibraryAssembly.VerifyWarehouseEntries(TempAssemblyHeader,TempAssemblyLine,FALSE);
            LibraryAssembly.VerifyWarehouseEntries(TempAssemblyHeader,TempAssemblyLine,TRUE);
          END;
        AssertOption::BinContents:
          LibraryAssembly.VerifyBinContents(TempAssemblyHeader,TempAssemblyLine,0);
      END;
    END;

    [Test]
    [HandlerFunctions(ConfirmCreateMvmt,MessageActivityCreated)]
    PROCEDURE CannotUndoWhseEntryNotAvailSilverPick@83();
    BEGIN
      Initialize;
      TCCannotUndoWhseEntryNotAvail(LocationSilverWithPick.Code);
    END;

    LOCAL PROCEDURE TCCannotUndoWhseEntryNotAvail@82(LocationCode@1003 : Code[10]);
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1005 : Record 900;
      PostedAssemblyHeader@1002 : Record 910;
      InternalMovementHeader@1009 : Record 7346;
      HeaderBin@1008 : Record 7354;
      ComponentsBin@1010 : Record 7354;
      OtherBin@1011 : Record 7354;
      OrderQty@1006 : Decimal;
      DueDate@1007 : Date;
      BinIndex@1001 : Integer;
    BEGIN
      // Bin codes
      BinIndex := 1;
      LibraryWarehouse.FindBin(HeaderBin,LocationCode,'',BinIndex + 2);
      LibraryWarehouse.FindBin(ComponentsBin,LocationCode,'',BinIndex);
      LibraryWarehouse.FindBin(OtherBin,LocationCode,'',BinIndex + 3);

      // Create AO
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));
      OrderQty := LibraryRandom.RandDec(1000,2) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,HeaderBin.Code,'',DueDate,OrderQty);
      SetLocAndBinCodeOnAsmLines(AssemblyHeader,ComponentsBin);

      // Add enough inventory for comp and post
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationCode,ComponentsBin.Code);
      PostAssemblyOrderQty(AssemblyHeader,OrderQty);
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");

      // Create invt movm for the output
      CreateInternalMovementGetBin(InternalMovementHeader,Item."No.",LocationCode,OtherBin.Code,HeaderBin.Code);
      LibraryWarehouse.SetQtyToHandleInternalMovement(InternalMovementHeader,OrderQty);
      LibraryWarehouse.CreateInvtMvmtFromInternalMvmt(InternalMovementHeader);

      // Verify Undo - error - output "reserved"
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,MSG_INSUFFICIENT_QTY);
    END;

    [Test]
    [HandlerFunctions(ConfirmUndo)]
    PROCEDURE UndoWithQuestion@76();
    VAR
      Item@1000 : Record 27;
      PostedAssemblyHeader@1001 : Record 910;
      AssemblyHeader@1002 : Record 900;
      OrderQty@1005 : Decimal;
      DueDate@1006 : Date;
    BEGIN
      // run undo through codeunit 911 for codecoverage
      Initialize;

      // Create AO
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandDec(1000,2));
      OrderQty := LibraryRandom.RandDec(1000,2) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationBlue.Code,'','',DueDate,OrderQty);
      AddCommentsToOrder(AssemblyHeader);

      // Add enough inventory for comp and post
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WORKDATE,0,LocationBlue.Code,'');
      PostAssemblyOrderQty(AssemblyHeader,OrderQty);

      // Undo
      FindPostedAssemblyHeaderNotReversed(PostedAssemblyHeader,AssemblyHeader."No.");
      CODEUNIT.RUN(CODEUNIT::"Pstd. Assembly - Undo (Yes/No)",PostedAssemblyHeader); // First time the answer is "no" for conform dialog
      CODEUNIT.RUN(CODEUNIT::"Pstd. Assembly - Undo (Yes/No)",PostedAssemblyHeader);
    END;

    [Test]
    [HandlerFunctions(MessageActivityCreated)]
    PROCEDURE UndoPartiallyPostedAssemblyOrder@79();
    VAR
      Item@1001 : Record 27;
      AssemblyHeader@1000 : Record 900;
      PostedAssemblyHeader@1009 : Record 910;
      HeaderBin@1003 : Record 7354;
      ComponentsBin@1007 : Record 7354;
      OrderQty@1002 : ARRAY [3] OF Decimal;
    BEGIN
      // [FEATURE] [Assembly] [Undo Assembly] [Warehouse]
      // [SCENARIO 378211] It should be possible to Undo partially Posted Assembly Order if it has Quantity less then in previous posted Assembly Order
      Initialize;

      // [GIVEN] Released Assembly Order "A" with Quantity = "Q"
      OrderQty[3] := LibraryRandom.RandIntInRange(1,10);
      OrderQty[2] := LibraryRandom.RandIntInRange(11,100);
      OrderQty[1] := OrderQty[2] + OrderQty[3];

      HeaderBin.GET(LocationWhite.Code,LocationWhite."From-Assembly Bin Code");
      LibraryWarehouse.FindBin(ComponentsBin,LocationWhite.Code,LibraryWarehouse.SelectBinType(FALSE,FALSE,FALSE,TRUE),1);
      CreateAssemblyOrderWithInventory(AssemblyHeader,Item,OrderQty[1],LocationWhite.Code,HeaderBin.Code,ComponentsBin.Code);
      LibraryAssembly.ReleaseAO(AssemblyHeader);

      // [GIVEN] Post Assembly Order "A" with Quantity to Assemble = "Q1"
      AssemblyHeader.VALIDATE("Quantity to Assemble",OrderQty[2]);
      AssemblyHeader.MODIFY(TRUE);
      LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,TRUE,FALSE);
      RegisterPickWithQtyToHandle(AssemblyHeader,OrderQty[2]);
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // [GIVEN] Post Assembly Order "A" with Quantity to Assemble = "Q2", "Q2" < "Q1"
      AssemblyHeader.FIND;
      RegisterPickWithQtyToHandle(AssemblyHeader,OrderQty[3]);
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
      MockWhseEntry(Item,-OrderQty[2]);

      // [WHEN] Undo Assembly "A2"
      PostedAssemblyHeader.SETRANGE("Order No.",AssemblyHeader."No.");
      PostedAssemblyHeader.FINDLAST;
      LibraryAssembly.UndoPostedAssembly(PostedAssemblyHeader,TRUE,'');

      // [THEN] Assembly Order A2 is Undone
      PostedAssemblyHeader.FIND;
      PostedAssemblyHeader.TESTFIELD(Reversed,TRUE);
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [Undo] [SCM]
      Unsupported version tags:
      SE: Unable to Execute

      This CU is covering tests for the kitting undo functionality
    }
    END.
  }
}

