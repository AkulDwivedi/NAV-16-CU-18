OBJECT Codeunit 137102 SCM Kitting ATO in Whse
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      ItemJournalTemplate@1006 : Record 82;
      ItemJournalBatch@1001 : Record 233;
      Location@1008 : Record 14;
      LibraryUtility@1004 : Codeunit 131000;
      LibraryInventory@1003 : Codeunit 132201;
      LibrarySales@1020 : Codeunit 130509;
      LibraryManufacturing@1014 : Codeunit 132202;
      LibraryWarehouse@1013 : Codeunit 132204;
      LibraryAssembly@1005 : Codeunit 132207;
      LibraryPurchase@1032 : Codeunit 130512;
      Assert@1002 : Codeunit 130000;
      LibraryRandom@1012 : Codeunit 130440;
      GenProdPostingGr@1019 : Code[10];
      AsmInvtPostingGr@1018 : Code[10];
      CompInvtPostingGr@1017 : Code[10];
      isInitialized@1000 : Boolean;
      WorkDate2@1021 : Date;
      AdditionalBinCode1@1025 : Code[20];
      AdditionalBinCode2@1024 : Code[20];
      DefaultBinCode@1027 : Code[20];
      NotDefaultBinCode@1009 : Code[20];
      FromBinCode@1026 : Code[20];
      InvBinCode@1029 : Code[20];
      ToBinCode@1011 : Code[20];
      AsmShipBinCode@1015 : Code[20];
      ConfirmStatusChangeCount@1034 : Integer;
      ERR_BIN_CODE_CHANGE@1028 : TextConst 'ENU=Assemble to Order must be equal to ''No''  in Assembly Header:';
      CHANGE_LOC_CONFIRM@1010 : TextConst 'ENU=Do you want to update the Location Code on the lines?';
      ERR_QTY_BASE@1030 : TextConst 'ENU=" units are not available"';
      ERR_ATO_QTY_TO_ASM@1022 : TextConst 'ENU=Quantity to Assemble cannot be lower than %1 or higher than %2.';
      ERR_ATS_QTY_TO_ASM@1023 : TextConst 'ENU=Quantity to Assemble cannot be higher than the Remaining Quantity, which is %1.';
      TXT_EXPCTD_ACTUAL@1031 : TextConst 'ENU=Expected: %1, Actual: %2.';
      ERR_QTY_BASE_MUST_BE_0@1016 : TextConst 'ENU="Qty. to Asm. to Order (Base) must be equal to ''0''  in Sales Line: Document Type=Order, Document No.="';
      MSG_STATUS_WILL_BE_CHANGED@1033 : TextConst 'ENU="The status of the linked assembly order will be changed to "';
      ERR_UPDATE_INTERRUPTED@1035 : TextConst 'ENU=The update has been interrupted to respect the warning.';

    [Normal]
    LOCAL PROCEDURE Initialize@8();
    VAR
      LibraryERMCountryData@1001 : Codeunit 131305;
    BEGIN
      ConfirmStatusChangeCount := 0;

      IF isInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.UpdateSalesReceivablesSetup;

      GlobalSetup;

      isInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE GlobalSetup@1();
    BEGIN
      SetupAssembly;
      SetupItemJournal;
      SetupManufacturingSetup;
      SetupSalesAndReceivablesSetup;
      LibraryAssembly.SetupPostingToGL(GenProdPostingGr,AsmInvtPostingGr,CompInvtPostingGr,'');
      SetupLocation(Location);
    END;

    [Normal]
    LOCAL PROCEDURE SetupAssembly@127();
    VAR
      AssemblySetup@1002 : Record 905;
      PurchasesPayablesSetup@1006 : Record 312;
      SalesSetup@1005 : Record 311;
    BEGIN
      AssemblySetup.GET;
      AssemblySetup.VALIDATE("Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Posted Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Assembly Quote Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Blanket Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Default Location for Orders",'');
      AssemblySetup.MODIFY(TRUE);

      SalesSetup.GET;
      SalesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Return Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Blanket Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Quote Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Invoice Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Posted Invoice Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Posted Shipment Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.MODIFY(TRUE);

      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      PurchasesPayablesSetup.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE SetupItemJournal@138();
    BEGIN
      CLEAR(ItemJournalTemplate);
      ItemJournalTemplate.INIT;
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      ItemJournalTemplate.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      ItemJournalTemplate.MODIFY(TRUE);

      CLEAR(ItemJournalBatch);
      ItemJournalBatch.INIT;
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      ItemJournalBatch.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      ItemJournalBatch.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE SetupLocation@2(VAR Location@1000 : Record 14);
    VAR
      WarehouseEmployee@1004 : Record 7301;
      Bin@1003 : Record 7354;
    BEGIN
      CLEAR(Location);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,Location.Code,FALSE);

      AdditionalBinCode1 := 'A1Bin';
      AdditionalBinCode2 := 'A2Bin';
      DefaultBinCode := 'DefBin';
      NotDefaultBinCode := 'NotDefBin';
      FromBinCode := 'FromBin';
      InvBinCode := 'InvBin';
      ToBinCode := 'ToBin';
      AsmShipBinCode := 'AsmShip';
      LibraryWarehouse.CreateBin(Bin,Location.Code,AdditionalBinCode1,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,AdditionalBinCode2,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,DefaultBinCode,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,NotDefaultBinCode,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,FromBinCode,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,ToBinCode,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,InvBinCode,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,AsmShipBinCode,'','');
    END;

    LOCAL PROCEDURE UpdateLocation@232(VAR Location@1000 : Record 14;SetBinMandatory@1001 : Boolean;TestFromBinCode@1002 : Code[20];TestAsmShipBinCode@1003 : Code[20]);
    BEGIN
      IF SetBinMandatory <> Location."Bin Mandatory" THEN BEGIN
        // Skip validate trigger for bin mandatory to improve performance.
        Location."Bin Mandatory" := SetBinMandatory;
        Location.MODIFY(TRUE);
      END;

      IF TestFromBinCode <> Location."From-Assembly Bin Code" THEN BEGIN
        Location.VALIDATE("From-Assembly Bin Code",TestFromBinCode);
        Location.MODIFY(TRUE);
      END;

      IF TestAsmShipBinCode <> Location."Asm.-to-Order Shpt. Bin Code" THEN BEGIN
        Location.VALIDATE("Asm.-to-Order Shpt. Bin Code",TestAsmShipBinCode);
        Location.MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE ClearJournal@134(ItemJournalTemplate@1002 : Record 82;ItemJournalBatch@1001 : Record 233);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CLEAR(ItemJournalLine);
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalTemplate.Name);
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.DELETEALL;
    END;

    LOCAL PROCEDURE SetupManufacturingSetup@168();
    VAR
      ManufacturingSetup@1000 : Record 99000765;
    BEGIN
      CLEAR(ManufacturingSetup);
      ManufacturingSetup.GET;
      EVALUATE(ManufacturingSetup."Default Safety Lead Time",'<1D>');
      ManufacturingSetup.MODIFY(TRUE);

      WorkDate2 := CALCDATE(ManufacturingSetup."Default Safety Lead Time",WORKDATE); // to avoid Due Date Before Work Date message.
    END;

    LOCAL PROCEDURE SetupSalesAndReceivablesSetup@222();
    VAR
      SalesReceivablesSetup@1000 : Record 311;
    BEGIN
      SalesReceivablesSetup.GET;
      SalesReceivablesSetup.VALIDATE("Stockout Warning",FALSE);
      SalesReceivablesSetup.VALIDATE("Credit Warnings",SalesReceivablesSetup."Credit Warnings"::"No Warning");
      SalesReceivablesSetup.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CreateAssemblyList@20(ParentItem@1000 : Record 27;NoOfComponents@1001 : Integer;NoOfResources@1002 : Integer;NoOfTexts@1003 : Integer;QtyPer@1004 : Integer);
    VAR
      Item@1008 : Record 27;
      Resource@1009 : Record 156;
      BOMComponent@1006 : Record 90;
      CompCount@1007 : Integer;
    BEGIN
      // Add components - qty per is increasing same as no of components
      FOR CompCount := 1 TO NoOfComponents DO BEGIN
        CLEAR(Item);
        LibraryInventory.CreateItem(Item);
        AddComponentToAssemblyList(
          BOMComponent,BOMComponent.Type::Item,Item."No.",ParentItem."No.",'',
          BOMComponent."Resource Usage Type"::Direct,Item."Base Unit of Measure",QtyPer);
      END;

      // Add resources - qty per is increasing same as no of components
      FOR CompCount := 1 TO NoOfResources DO BEGIN
        LibraryAssembly.CreateResource(Resource,TRUE,GenProdPostingGr);
        AddComponentToAssemblyList(
          BOMComponent,BOMComponent.Type::Resource,Resource."No.",ParentItem."No.",'',
          BOMComponent."Resource Usage Type"::Direct,Resource."Base Unit of Measure",QtyPer);
      END;

      // Add simple text
      FOR CompCount := 1 TO NoOfTexts DO
        AddComponentToAssemblyList(BOMComponent,BOMComponent.Type::" ",'',ParentItem."No.",'',
          BOMComponent."Resource Usage Type"::Direct,'',QtyPer);
    END;

    LOCAL PROCEDURE CreateAssembledItem@10(VAR Item@1000 : Record 27;AssemblyPolicy@1001 : Option);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::Assembly);
      Item.VALIDATE("Assembly Policy",AssemblyPolicy);
      Item.MODIFY(TRUE);
      CreateAssemblyList(Item,LibraryRandom.RandInt(5),1,1,LibraryRandom.RandInt(1000));
    END;

    LOCAL PROCEDURE CreateSalesOrder@230(VAR SalesHeader@1000 : Record 36;ItemNo1@1001 : Code[20];ItemNo2@1004 : Code[20];LocationCode@1006 : Code[10];VAR SalesLine1@1002 : Record 37;VAR SalesLine2@1005 : Record 37;SalesQty@1008 : Integer);
    VAR
      ShipmentDate@1003 : Date;
    BEGIN
      ShipmentDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,'');
      SalesHeader.VALIDATE("Shipment Date",ShipmentDate);
      SalesHeader.VALIDATE("Location Code",LocationCode);
      SalesHeader.MODIFY(TRUE);
      LibrarySales.CreateSalesLineWithShipmentDate(SalesLine1,SalesHeader,SalesLine1.Type::Item,ItemNo1,ShipmentDate,SalesQty);
      IF ItemNo2 <> '' THEN
        LibrarySales.CreateSalesLineWithShipmentDate(SalesLine2,SalesHeader,SalesLine2.Type::Item,ItemNo2,ShipmentDate,SalesQty);
    END;

    [Normal]
    LOCAL PROCEDURE CreateItemJournalLine@35(Item@1000 : Record 27;Qty@1005 : Decimal);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",Item."No.",Qty);
      ItemJournalLine.VALIDATE("Posting Date",CALCDATE('<-1D>',WORKDATE));
      ItemJournalLine.VALIDATE("Document Date",CALCDATE('<-1D>',ItemJournalLine."Posting Date"));
      ItemJournalLine.VALIDATE("Unit of Measure Code",Item."Base Unit of Measure");
      ItemJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(50,2));
      ItemJournalLine.VALIDATE("Location Code",Location.Code);
      ItemJournalLine.VALIDATE("Bin Code",InvBinCode);
      ItemJournalLine.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CreateDefaultBinContent@4(Item@1001 : Record 27);
    VAR
      BinContent@1000 : Record 7302;
    BEGIN
      LibraryWarehouse.CreateBinContent(BinContent,Location.Code,'',DefaultBinCode,Item."No.",'',Item."Base Unit of Measure");
      BinContent.VALIDATE(Default,TRUE);
      BinContent.MODIFY(TRUE);
      LibraryWarehouse.CreateBinContent(BinContent,Location.Code,'',NotDefaultBinCode,Item."No.",'',Item."Base Unit of Measure");
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchOrderDropShipment@56(VAR PurchaseHeader@1000 : Record 38;SalesLine@1001 : Record 37);
    VAR
      PurchaseLine@1002 : Record 39;
    BEGIN
      CreatePurchaseHeader(PurchaseHeader,SalesLine."Sell-to Customer No.");
      CreatePurchLineFromSalesLine(PurchaseLine,SalesLine,PurchaseHeader."No.");
      LibraryInventory.UpdateSalesLine(SalesLine,SalesLine.FIELDNO("Unit Cost (LCY)"),PurchaseLine."Unit Cost (LCY)");
      LibraryInventory.UpdateSalesLine(SalesLine,SalesLine.FIELDNO("Purchase Order No."),PurchaseLine."Document No.");
      LibraryInventory.UpdateSalesLine(SalesLine,SalesLine.FIELDNO("Purch. Order Line No."),PurchaseLine."Line No.");
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchaseHeader@57(VAR PurchaseHeader@1000 : Record 38;SellToCustomerNo@1001 : Code[20]);
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      PurchaseHeader.VALIDATE("Sell-to Customer No.",SellToCustomerNo);
      PurchaseHeader.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchLineFromSalesLine@59(VAR PurchaseLine@1000 : Record 39;SalesLine@1001 : Record 37;DocumentNo@1002 : Code[20]);
    VAR
      CopyDocumentMgt@1003 : Codeunit 6620;
    BEGIN
      PurchaseLine.INIT;
      PurchaseLine.VALIDATE("Document Type",PurchaseLine."Document Type"::Order);
      PurchaseLine.VALIDATE("Document No.",DocumentNo);
      CopyDocumentMgt.TransfldsFromSalesToPurchLine(SalesLine,PurchaseLine);
      PurchaseLine.VALIDATE("Sales Order No.",SalesLine."Document No.");
      PurchaseLine.VALIDATE("Sales Order Line No.",SalesLine."Line No.");
      PurchaseLine.VALIDATE("Drop Shipment",TRUE);
      PurchaseLine.INSERT(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE AddComponentToAssemblyList@12(VAR BOMComponent@1008 : Record 90;ComponentType@1000 : Option;ComponentNo@1001 : Code[20];ParentItemNo@1005 : Code[20];VariantCode@1007 : Code[10];ResourceUsage@1006 : Option;UOM@1003 : Code[10];QuantityPer@1002 : Decimal);
    BEGIN
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentItemNo,ComponentType,ComponentNo,QuantityPer,UOM);
      IF ComponentType = BOMComponent.Type::Resource THEN
        BOMComponent.VALIDATE("Resource Usage Type",ResourceUsage);
      BOMComponent.VALIDATE("Variant Code",VariantCode);
      IF ComponentNo = '' THEN
        BOMComponent.VALIDATE(Description,
          LibraryUtility.GenerateRandomCode(BOMComponent.FIELDNO(Description),DATABASE::"BOM Component"));
      BOMComponent.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE AddComponentsToInventory@29(SalesLine@1000 : Record 37);
    VAR
      AssemblyHeader@1002 : Record 900;
      AssemblyLine@1004 : Record 901;
    BEGIN
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      IF AssemblyLine.FINDSET THEN
        REPEAT
          AssemblyLine.VALIDATE("Bin Code",'ToBin');
          AssemblyLine.MODIFY(TRUE);
        UNTIL AssemblyLine.NEXT = 0;

      LibraryAssembly.AddCompInventory(AssemblyHeader,WorkDate2,0);
    END;

    [Normal]
    LOCAL PROCEDURE AddInventoryNonDirectLocation@3(ItemNo@1000 : Code[20];LocationCode@1001 : Code[10];Qty@1002 : Integer;BinCode@1004 : Code[20]);
    VAR
      ItemJournalLine@1003 : Record 83;
    BEGIN
      ClearJournal(ItemJournalTemplate,ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Qty);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.VALIDATE("Bin Code",BinCode);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    [Normal]
    LOCAL PROCEDURE AddItemsInventory@126(Item1@1000 : Record 27;Item2@1001 : Record 27;Qty@1005 : Decimal);
    BEGIN
      ClearJournal(ItemJournalTemplate,ItemJournalBatch);

      CreateItemJournalLine(Item1,Qty);
      CreateItemJournalLine(Item2,Qty);

      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@15(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,CHANGE_LOC_CONFIRM) > 0,PADSTR('Actual:' + Question + '; Expected:' + CHANGE_LOC_CONFIRM,1024));
      Reply := TRUE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler2@68(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      ConfirmStatusChangeCount += 1;

      Assert.IsTrue(STRPOS(Question,MSG_STATUS_WILL_BE_CHANGED) > 0,PADSTR('Actual:' + Question + '; Expected:' + MSG_STATUS_WILL_BE_CHANGED,1024));
      IF ConfirmStatusChangeCount = 1 THEN
        Reply := FALSE
      ELSE
        Reply := TRUE;
    END;

    [ModalPageHandler]
    PROCEDURE AutoReserveAgainstILE@44(VAR ReservationPage@1000 : TestPage 498);
    VAR
      EntrySummary@1001 : Record 338;
      ItemLedgEntry@1002 : Record 32;
    BEGIN
      EntrySummary.INIT;
      ReservationPage.FIRST;
      IF ReservationPage."Summary Type".VALUE =
         COPYSTR(ItemLedgEntry.TABLECAPTION,1,MAXSTRLEN(EntrySummary."Summary Type"))
      THEN
        ReservationPage."Reserve from Current Line".INVOKE;
    END;

    [Normal]
    LOCAL PROCEDURE CheckCreatedBin@227(BinMandatory@1006 : Boolean;TestFromBinCode@1014 : Code[20];TestAsmShipBinCode@1002 : Code[20];ExpBinCode@1015 : Code[20];ExpBinCodeBC@1016 : Code[20];AddInventory@1005 : Boolean;Qty@1001 : Integer);
    VAR
      Item1@1000 : Record 27;
      ItemBC@1003 : Record 27;
      SalesHeader@1010 : Record 36;
      SalesLine1@1004 : Record 37;
      SalesLineBC@1012 : Record 37;
      AssemblyHeader1@1007 : Record 900;
      AssemblyHeaderBC@1011 : Record 900;
    BEGIN
      UpdateLocation(Location,BinMandatory,TestFromBinCode,TestAsmShipBinCode);

      CreateAssembledItem(Item1,Item1."Assembly Policy"::"Assemble-to-Order");
      CreateAssembledItem(ItemBC,ItemBC."Assembly Policy"::"Assemble-to-Order");
      CreateDefaultBinContent(ItemBC);

      IF AddInventory AND (Qty > 0) THEN
        AddItemsInventory(Item1,ItemBC,Qty);

      CreateSalesOrder(SalesHeader,Item1."No.",ItemBC."No.",Location.Code,SalesLine1,SalesLineBC,Qty);
      IF Qty > 0 THEN BEGIN
        Assert.IsTrue(SalesLine1.AsmToOrderExists(AssemblyHeader1),'There is no asm order');
        Assert.IsTrue(SalesLineBC.AsmToOrderExists(AssemblyHeaderBC),'There is no asm order');
        AssertBinCode(AssemblyHeader1."Bin Code",SalesLine1."Bin Code",ExpBinCode);
        AssertBinCode(AssemblyHeaderBC."Bin Code",SalesLineBC."Bin Code",ExpBinCodeBC)
      END ELSE BEGIN
        Assert.IsFalse(SalesLine1.AsmToOrderExists(AssemblyHeader1),'There is an asm order');
        Assert.IsFalse(SalesLineBC.AsmToOrderExists(AssemblyHeaderBC),'There is an asm order');

        Assert.AreEqual(ExpBinCode,SalesLine1."Bin Code",'Incorrect sales bin code' );
        Assert.AreEqual(ExpBinCodeBC,SalesLineBC."Bin Code",'Incorrect sales bin code' );
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CheckUpdatedBin@22(NewBinCode@1006 : Code[20];NewBinCodeBC@1014 : Code[20];ShipPartially@1015 : Boolean);
    VAR
      Item1@1000 : Record 27;
      ItemBC@1003 : Record 27;
      SalesHeader@1010 : Record 36;
      SalesLine1@1004 : Record 37;
      SalesLineBC@1012 : Record 37;
    BEGIN
      UpdateLocation(Location,TRUE,FromBinCode,'');

      CreateAssembledItem(Item1,Item1."Assembly Policy"::"Assemble-to-Order");
      CreateAssembledItem(ItemBC,ItemBC."Assembly Policy"::"Assemble-to-Order");
      CreateDefaultBinContent(ItemBC);

      CreateSalesOrder(SalesHeader,Item1."No.",ItemBC."No.",Location.Code,SalesLine1,SalesLineBC,LibraryRandom.RandInt(1000));
      IF ShipPartially THEN BEGIN
        AddComponentsToInventory(SalesLine1);
        AddComponentsToInventory(SalesLineBC);
        SalesLine1.VALIDATE("Qty. to Ship",SalesLine1."Qty. to Ship" / 2);
        SalesLine1.MODIFY(TRUE);
        SalesLineBC.VALIDATE("Qty. to Ship",SalesLineBC."Qty. to Ship" / 2);
        SalesLineBC.MODIFY(TRUE);
        LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      END;

      CheckUpdatedBinLine(SalesLine1,SalesLineBC,NewBinCode,NewBinCode,FromBinCode);
      CheckUpdatedBinLine(SalesLineBC,SalesLine1,NewBinCodeBC,NewBinCodeBC,NewBinCode);
    END;

    [Normal]
    LOCAL PROCEDURE CheckUpdatedLocationLine@46(SalesLineM@1000 : Record 37;SalesLineNM@1001 : Record 37;NewLocationCode@1006 : Code[10];BinCodeM@1004 : Code[20];BinCodeNM@1005 : Code[20]);
    VAR
      AssemblyHeaderM@1008 : Record 900;
      AssemblyHeaderNM@1007 : Record 900;
    BEGIN
      SalesLineM.VALIDATE("Location Code",NewLocationCode);
      SalesLineM.MODIFY(TRUE);
      SalesLineNM.GET(SalesLineNM."Document Type",SalesLineNM."Document No.",SalesLineNM."Line No.");

      Assert.IsTrue(SalesLineM.AsmToOrderExists(AssemblyHeaderM),'There is no asm order');
      Assert.IsTrue(SalesLineNM.AsmToOrderExists(AssemblyHeaderNM),'There is no asm order');
      AssertBinCode(AssemblyHeaderM."Bin Code",SalesLineM."Bin Code",BinCodeM);
      AssertBinCode(AssemblyHeaderNM."Bin Code",SalesLineNM."Bin Code",BinCodeNM);
    END;

    [Normal]
    LOCAL PROCEDURE CheckUpdatedBinLine@58(SalesLineM@1000 : Record 37;SalesLineNM@1001 : Record 37;NewBinCode@1006 : Code[20];BinCodeM@1004 : Code[20];BinCodeNM@1005 : Code[20]);
    VAR
      AssemblyHeaderM@1008 : Record 900;
      AssemblyHeaderNM@1007 : Record 900;
    BEGIN
      SalesLineM.GET(SalesLineM."Document Type",SalesLineM."Document No.",SalesLineM."Line No.");
      SalesLineM.VALIDATE("Bin Code",NewBinCode);
      SalesLineM.MODIFY(TRUE);
      SalesLineNM.GET(SalesLineNM."Document Type",SalesLineNM."Document No.",SalesLineNM."Line No.");

      Assert.IsTrue(SalesLineM.AsmToOrderExists(AssemblyHeaderM),'There is no asm order');
      Assert.IsTrue(SalesLineNM.AsmToOrderExists(AssemblyHeaderNM),'There is no asm order');
      AssertBinCode(AssemblyHeaderM."Bin Code",SalesLineM."Bin Code",BinCodeM);
      AssertBinCode(AssemblyHeaderNM."Bin Code",SalesLineNM."Bin Code",BinCodeNM);
    END;

    [Normal]
    LOCAL PROCEDURE AssertBinCode@229(AssemblyBinCode@1000 : Code[20];SalesBinCode@1001 : Code[20];ExpectedBinCode@1002 : Code[20]);
    BEGIN
      Assert.AreEqual(ExpectedBinCode,SalesBinCode,'Incorrect sales bin code' );
      Assert.AreEqual(ExpectedBinCode,AssemblyBinCode,'Incorrect assembly bin code');
    END;

    LOCAL PROCEDURE VerifyBinContent@101(LocationCode@1003 : Code[20];BinCode@1000 : Code[20];ItemNo@1002 : Code[20];Quantity@1001 : Decimal);
    VAR
      BinContent@1004 : Record 7302;
    BEGIN
      BinContent.RESET;
      BinContent.SETRANGE("Location Code",LocationCode);
      BinContent.SETRANGE("Bin Code",BinCode);
      BinContent.SETRANGE("Item No.",ItemNo);
      IF BinContent.FINDFIRST THEN BEGIN
        BinContent.CALCFIELDS(Quantity);
        BinContent.TESTFIELD(Quantity,Quantity);
      END ELSE
        Assert.AreEqual(0,Quantity,'Incorrect Qty of Item ' + ItemNo + ' in Bin ' + BinCode);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyBinContents@33(AssemblyHeader@1000 : Record 900;AssembledQty@1002 : Integer;CompQty@1003 : Integer;VerifyComponents@1004 : Boolean);
    VAR
      AssemblyLine@1001 : Record 901;
    BEGIN
      // Veryfy bin content for header assembly item
      VerifyBinContent(AssemblyHeader."Location Code",FromBinCode,AssemblyHeader."Item No.",AssembledQty);

      IF VerifyComponents THEN BEGIN
        // Verify bin contents for components
        AssemblyLine.RESET;
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
        AssemblyLine.FINDSET;

        REPEAT
          VerifyBinContent(
            AssemblyLine."Location Code",AssemblyLine."Bin Code",AssemblyLine."No.",CompQty * AssemblyLine."Quantity per");
        UNTIL AssemblyLine.NEXT = 0;
      END;
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinBM@16();
    BEGIN
      Initialize;

      CheckCreatedBin(TRUE,'','','',DefaultBinCode,FALSE,LibraryRandom.RandInt(1000));
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinBMLFA@231();
    BEGIN
      Initialize;

      CheckCreatedBin(TRUE,FromBinCode,'',FromBinCode,FromBinCode,FALSE,LibraryRandom.RandInt(1000));
    END;

    [Test]
    PROCEDURE ATOWhseCopyBin@21();
    BEGIN
      Initialize;

      CheckCreatedBin(FALSE,'','','','',FALSE,LibraryRandom.RandInt(1000));
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinBMAddInv@9();
    BEGIN
      Initialize;

      CheckCreatedBin(TRUE,'','',InvBinCode,DefaultBinCode,TRUE,LibraryRandom.RandInt(1000));
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinBMLFAAddInv@7();
    BEGIN
      Initialize;

      CheckCreatedBin(TRUE,FromBinCode,'',FromBinCode,FromBinCode,TRUE,LibraryRandom.RandInt(1000));
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinBMNoQty@26();
    BEGIN
      Initialize;

      CheckCreatedBin(TRUE,'','','',DefaultBinCode,FALSE,-1);
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinNoQty@23();
    BEGIN
      Initialize;

      CheckCreatedBin(FALSE,'','','','',FALSE,-1);
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinBMS@43();
    BEGIN
      Initialize;

      CheckCreatedBin(TRUE,'',AsmShipBinCode,AsmShipBinCode,AsmShipBinCode,FALSE,LibraryRandom.RandInt(1000));
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinBMLFAS@42();
    BEGIN
      Initialize;

      CheckCreatedBin(TRUE,FromBinCode,AsmShipBinCode,AsmShipBinCode,AsmShipBinCode,FALSE,LibraryRandom.RandInt(1000));
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinBMAddInvS@39();
    BEGIN
      Initialize;

      CheckCreatedBin(TRUE,'',AsmShipBinCode,AsmShipBinCode,AsmShipBinCode,TRUE,LibraryRandom.RandInt(1000));
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinBMLFAAddInvS@38();
    BEGIN
      Initialize;

      CheckCreatedBin(TRUE,FromBinCode,AsmShipBinCode,AsmShipBinCode,AsmShipBinCode,TRUE,LibraryRandom.RandInt(1000));
    END;

    [Test]
    PROCEDURE ATOWhseCopyBinBMNoQtyS@37();
    BEGIN
      Initialize;

      CheckCreatedBin(TRUE,'',AsmShipBinCode,AsmShipBinCode,AsmShipBinCode,FALSE,-1);
    END;

    [Test]
    PROCEDURE ATOWhseCopyMixedATS@52();
    VAR
      Item1@1000 : Record 27;
      ItemBC@1001 : Record 27;
      SalesHeader@1002 : Record 36;
      SalesLine1@1003 : Record 37;
      SalesLineBC@1004 : Record 37;
      AssemblyHeader1@1006 : Record 900;
      AssemblyHeaderBC@1007 : Record 900;
      Qty@1005 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,AsmShipBinCode);
      Qty := LibraryRandom.RandInt(1000);

      CreateAssembledItem(Item1,Item1."Assembly Policy"::"Assemble-to-Order");
      CreateAssembledItem(ItemBC,ItemBC."Assembly Policy"::"Assemble-to-Order");
      CreateDefaultBinContent(ItemBC);

      AddInventoryNonDirectLocation(Item1."No.",Location.Code,Qty,AdditionalBinCode1);
      AddInventoryNonDirectLocation(ItemBC."No.",Location.Code,Qty,AdditionalBinCode1);

      CreateSalesOrder(SalesHeader,Item1."No.",ItemBC."No.",Location.Code,SalesLine1,SalesLineBC,Qty);

      Assert.IsTrue(SalesLine1.AsmToOrderExists(AssemblyHeader1),'There is no asm order');
      Assert.IsTrue(SalesLineBC.AsmToOrderExists(AssemblyHeaderBC),'There is no asm order');
      AssertBinCode(AssemblyHeader1."Bin Code",SalesLine1."Bin Code",AsmShipBinCode);
      AssertBinCode(AssemblyHeaderBC."Bin Code",SalesLineBC."Bin Code",AsmShipBinCode);
    END;

    [Test]
    PROCEDURE ATOWhseCopyMixedATSZeroATO@6();
    VAR
      Item1@1000 : Record 27;
      SalesHeader@1002 : Record 36;
      SalesLine1@1003 : Record 37;
      AssemblyHeader1@1006 : Record 900;
      Qty@1005 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,AsmShipBinCode);
      Qty := LibraryRandom.RandInt(1000);

      CreateAssembledItem(Item1,Item1."Assembly Policy"::"Assemble-to-Order");
      AddInventoryNonDirectLocation(Item1."No.",Location.Code,Qty,AdditionalBinCode1);

      CreateSalesOrder(SalesHeader,Item1."No.",'',Location.Code,SalesLine1,SalesLine1,Qty);

      SalesLine1.VALIDATE("Qty. to Assemble to Order",0);

      Assert.IsFalse(SalesLine1.AsmToOrderExists(AssemblyHeader1),'There is no asm order');
      Assert.AreEqual(AsmShipBinCode,SalesLine1."Bin Code",'Incorrect sales bin code' );

      SalesLine1.VALIDATE("Bin Code",AdditionalBinCode1);
      SalesLine1.MODIFY(TRUE);
      SalesLine1.GET(SalesLine1."Document Type",SalesLine1."Document No.",SalesLine1."Line No.");

      Assert.AreEqual(AdditionalBinCode1,SalesLine1."Bin Code",'Incorrect sales bin code' );
    END;

    [Test]
    PROCEDURE ATSWhseCopyMixedATO@17();
    VAR
      Item1@1000 : Record 27;
      SalesHeader@1002 : Record 36;
      SalesLine1@1003 : Record 37;
      AssemblyHeader1@1006 : Record 900;
      Qty@1005 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,AsmShipBinCode);
      Qty := LibraryRandom.RandInt(1000);

      CreateAssembledItem(Item1,Item1."Assembly Policy"::"Assemble-to-Stock");
      AddInventoryNonDirectLocation(Item1."No.",Location.Code,Qty,AdditionalBinCode1);

      CreateSalesOrder(SalesHeader,Item1."No.",'',Location.Code,SalesLine1,SalesLine1,Qty);

      Assert.IsFalse(SalesLine1.AsmToOrderExists(AssemblyHeader1),'There is an asm order');
      Assert.AreEqual(AdditionalBinCode1,SalesLine1."Bin Code",'Incorrect sales bin code' );

      SalesLine1.VALIDATE("Qty. to Assemble to Order",Qty);

      Assert.IsTrue(SalesLine1.AsmToOrderExists(AssemblyHeader1),'There is no asm order');
      AssertBinCode(AssemblyHeader1."Bin Code",SalesLine1."Bin Code",AsmShipBinCode);
    END;

    [Test]
    PROCEDURE ATOWhseUpdBinBM@13();
    BEGIN
      Initialize;

      CheckUpdatedBin(AdditionalBinCode1,AdditionalBinCode2,FALSE);
    END;

    [Test]
    PROCEDURE ATOWhseUpdBinBMPartShipped@28();
    BEGIN
      Initialize;

      CheckUpdatedBin(AdditionalBinCode1,AdditionalBinCode2,TRUE);
    END;

    [Test]
    PROCEDURE ATOWhseDelBinBM@25();
    BEGIN
      Initialize;

      CheckUpdatedBin('','',FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE ATOWhseUpdLocBMLFA@11();
    VAR
      Item1@1000 : Record 27;
      ItemBC@1003 : Record 27;
      SalesHeader@1010 : Record 36;
      SalesLine1@1004 : Record 37;
      SalesLineBC@1012 : Record 37;
      NewLocation@1006 : Record 14;
    BEGIN
      Initialize;
      UpdateLocation(Location,TRUE,FromBinCode,'');
      SetupLocation(NewLocation);
      UpdateLocation(NewLocation,TRUE,AdditionalBinCode2,'');

      CreateAssembledItem(Item1,Item1."Assembly Policy"::"Assemble-to-Order");
      CreateAssembledItem(ItemBC,ItemBC."Assembly Policy"::"Assemble-to-Order");
      CreateDefaultBinContent(ItemBC);

      CreateSalesOrder(SalesHeader,Item1."No.",ItemBC."No.",Location.Code,SalesLine1,SalesLineBC,LibraryRandom.RandInt(1000));

      CheckUpdatedLocationLine(SalesLine1,SalesLineBC,NewLocation.Code,AdditionalBinCode2,FromBinCode);
      CheckUpdatedLocationLine(SalesLineBC,SalesLine1,NewLocation.Code,AdditionalBinCode2,AdditionalBinCode2);
    END;

    [Test]
    PROCEDURE ATOWhseUpdLocToSameBMLFA@40();
    VAR
      Item1@1000 : Record 27;
      ItemBC@1003 : Record 27;
      SalesHeader@1010 : Record 36;
      SalesLine1@1004 : Record 37;
      SalesLineBC@1012 : Record 37;
    BEGIN
      Initialize;
      UpdateLocation(Location,TRUE,FromBinCode,'');

      CreateAssembledItem(Item1,Item1."Assembly Policy"::"Assemble-to-Order");
      CreateAssembledItem(ItemBC,ItemBC."Assembly Policy"::"Assemble-to-Order");
      CreateDefaultBinContent(ItemBC);

      CreateSalesOrder(SalesHeader,Item1."No.",ItemBC."No.",Location.Code,SalesLine1,SalesLineBC,LibraryRandom.RandInt(1000));

      CheckUpdatedLocationLine(SalesLine1,SalesLineBC,Location.Code,FromBinCode,FromBinCode);
      CheckUpdatedLocationLine(SalesLineBC,SalesLine1,Location.Code,FromBinCode,FromBinCode);
    END;

    [Test]
    PROCEDURE ATOWhseEditAsmHeaderBinBMLFA@14();
    VAR
      Item1@1000 : Record 27;
      SalesHeader@1010 : Record 36;
      SalesLine1@1004 : Record 37;
      AssemblyHeader1@1007 : Record 900;
    BEGIN
      Initialize;
      UpdateLocation(Location,TRUE,FromBinCode,'');

      CreateAssembledItem(Item1,Item1."Assembly Policy"::"Assemble-to-Order");

      CreateSalesOrder(SalesHeader,Item1."No.",'',Location.Code,SalesLine1,SalesLine1,LibraryRandom.RandInt(1000));
      Assert.IsTrue(SalesLine1.AsmToOrderExists(AssemblyHeader1),'There is no asm order');

      ASSERTERROR AssemblyHeader1.VALIDATE("Bin Code",AdditionalBinCode1);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ERR_BIN_CODE_CHANGE) > 0,PADSTR('Actual:' + GETLASTERRORTEXT + ';Expected:' + ERR_BIN_CODE_CHANGE,1024));
    END;

    [Test]
    PROCEDURE ATOWhseEditAsmHeaderLocBMLFA@61();
    VAR
      Item1@1000 : Record 27;
      SalesHeader@1010 : Record 36;
      SalesLine1@1004 : Record 37;
      AssemblyHeader1@1007 : Record 900;
      NewLocation@1001 : Record 14;
    BEGIN
      Initialize;
      UpdateLocation(Location,TRUE,FromBinCode,'');
      SetupLocation(NewLocation);
      UpdateLocation(NewLocation,TRUE,AdditionalBinCode2,'');

      CreateAssembledItem(Item1,Item1."Assembly Policy"::"Assemble-to-Order");

      CreateSalesOrder(SalesHeader,Item1."No.",'',Location.Code,SalesLine1,SalesLine1,LibraryRandom.RandInt(1000));
      Assert.IsTrue(SalesLine1.AsmToOrderExists(AssemblyHeader1),'There is no asm order');

      ASSERTERROR AssemblyHeader1.VALIDATE("Location Code",NewLocation.Code);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ERR_BIN_CODE_CHANGE) > 0,PADSTR('Actual:' + GETLASTERRORTEXT + ';Expected:' + ERR_BIN_CODE_CHANGE,1024));
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipChangeSOQtyToShip@5();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Qty@1000 : Integer;
      NewQtyToShip@1001 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);
      NewQtyToShip := 10;

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      AddInventoryNonDirectLocation(Item."No.",Location.Code,Qty,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      // Change Sales Order "Qty. to ship".
      SalesLine.VALIDATE("Qty. to Ship",NewQtyToShip);
      SalesLine.MODIFY(TRUE);

      // Verify Assembly order "Quantity to Assemble"
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      Assert.AreEqual(NewQtyToShip,AssemblyHeader."Quantity to Assemble",'Qty to Assemble is updated incorrecly');
      Assert.AreEqual(Qty,AssemblyHeader.Quantity,'Quantity is updated');

      // Verify posting
      AddComponentsToInventory(SalesLine);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      VerifyBinContents(AssemblyHeader,Qty,Qty - NewQtyToShip,TRUE);
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipZeroSOQtyToAssemble@18();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Qty@1000 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      // Change Sales Order "Qty. to Assemble to Order" to zero
      SalesLine.VALIDATE("Qty. to Assemble to Order",0);
      SalesLine.MODIFY(TRUE);

      // Verify Assembly order "Quantity to Assemble"
      Assert.IsFalse(SalesLine.AsmToOrderExists(AssemblyHeader),'There is an asm order');
      Assert.AreEqual(Qty,SalesLine."Qty. to Ship",'Quantity is updated');

      // Verify posting
      AddInventoryNonDirectLocation(Item."No.",Location.Code,Qty,FromBinCode);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipZeroAOQtyToAssemble@27();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      AsmOrder@1003 : TestPage 900;
      Qty@1000 : Integer;
      ActualError@1001 : Text[1024];
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      AddInventoryNonDirectLocation(Item."No.",Location.Code,Qty,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);

      // Change Assembly Order "Quantity to Assemble" to zero
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      AsmOrder.TRAP;
      PAGE.RUN(PAGE::"Assembly Order",AssemblyHeader);

      ASSERTERROR AsmOrder."Quantity to Assemble".SETVALUE(0);
      ActualError := AsmOrder."Quantity to Assemble".GETVALIDATIONERROR(1);
      Assert.IsTrue(
        STRPOS(ActualError,STRSUBSTNO(ERR_ATO_QTY_TO_ASM,Qty,Qty)) > 0,
        PADSTR(STRSUBSTNO(TXT_EXPCTD_ACTUAL,STRSUBSTNO(ERR_ATO_QTY_TO_ASM,Qty,Qty),ActualError),1024));
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipChangeSOQtyToShipQtyToAssemble@24();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Qty@1000 : Integer;
      NewQtyToShip@1001 : Integer;
      QtyFromStock@1003 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');

      Qty := LibraryRandom.RandIntInRange(100,1000);
      NewQtyToShip := ROUND(Qty / 2);
      QtyFromStock := 10;

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      AddInventoryNonDirectLocation(Item."No.",Location.Code,QtyFromStock,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      // Change Sales Order "Qty. to Ship" and then Sales Order "Qty. to Assemble to Order"
      SalesLine.VALIDATE("Qty. to Ship",NewQtyToShip);
      SalesLine.VALIDATE("Qty. to Assemble to Order",NewQtyToShip - QtyFromStock);
      SalesLine.MODIFY(TRUE);

      // Verify Assembly Order
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      Assert.AreEqual(NewQtyToShip - QtyFromStock,AssemblyHeader."Quantity to Assemble",'Qty to Assemble is updated incorrecly');
      Assert.AreEqual(NewQtyToShip - QtyFromStock,AssemblyHeader.Quantity,'Quantity is updated incorrectly');

      // Verify posting
      AddComponentsToInventory(SalesLine);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      VerifyBinContents(AssemblyHeader,0,0,TRUE);

      // Verify Sales Order and Assembly Order after posting
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      SalesLine.GET(SalesLine."Document Type",SalesLine."Document No.",SalesLine."Line No.");
      Assert.AreEqual(
        NewQtyToShip - QtyFromStock,SalesLine."Qty. to Assemble to Order",'Qty. to Assemble to Order is updated incorrecly');
      Assert.AreEqual(Qty - NewQtyToShip,SalesLine."Qty. to Ship",'Qty to Assemble is updated incorrecly');
      Assert.AreEqual(NewQtyToShip - QtyFromStock,AssemblyHeader.Quantity,'Quantity is updated');
      Assert.AreEqual(0,AssemblyHeader."Quantity to Assemble",'Qty to Assemble is updated incorrecly after posting');
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipSOMaxQtyToShip@31();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      AsmOrder@1008 : TestPage 900;
      Qty@1000 : Integer;
      NewQtyToShip@1001 : Integer;
      ActualError@1009 : Text[1024];
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);
      NewQtyToShip := 10;

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);

      SalesLine.VALIDATE("Qty. to Ship",NewQtyToShip);
      SalesLine.MODIFY(TRUE);

      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      AsmOrder.TRAP;
      PAGE.RUN(PAGE::"Assembly Order",AssemblyHeader);

      ASSERTERROR AsmOrder."Quantity to Assemble".SETVALUE(NewQtyToShip + 1);
      ActualError := AsmOrder."Quantity to Assemble".GETVALIDATIONERROR(1);
      Assert.IsTrue(
        STRPOS(ActualError,STRSUBSTNO(ERR_ATO_QTY_TO_ASM,NewQtyToShip,NewQtyToShip)) > 0,
        PADSTR(STRSUBSTNO(TXT_EXPCTD_ACTUAL,STRSUBSTNO(ERR_ATO_QTY_TO_ASM,NewQtyToShip,NewQtyToShip),ActualError),1024));
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipSOMaxRemQty@36();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      AsmOrder@1008 : TestPage 900;
      Qty@1000 : Integer;
      ActualError@1009 : Text[1024];
    BEGIN
      // Maximum value of "Quantity to Assemble" = Minimum {SalesLine."Qty. to Ship", AsmHeader."Remaining Quantity"}
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      AddInventoryNonDirectLocation(Item."No.",Location.Code,Qty,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);

      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');
      SalesLine.VALIDATE("Qty. to Assemble to Order",90);
      SalesLine.MODIFY(TRUE);

      AddComponentsToInventory(SalesLine);

      AsmOrder.TRAP;
      PAGE.RUN(PAGE::"Assembly Order",AssemblyHeader);

      ASSERTERROR AsmOrder."Quantity to Assemble".SETVALUE(SalesLine."Qty. to Assemble to Order" + 1);
      ActualError := AsmOrder."Quantity to Assemble".GETVALIDATIONERROR(1);
      Assert.IsTrue(
        STRPOS(ActualError,STRSUBSTNO(ERR_ATS_QTY_TO_ASM,SalesLine."Qty. to Assemble to Order")) > 0,
        PADSTR(STRSUBSTNO(TXT_EXPCTD_ACTUAL,STRSUBSTNO(ERR_ATS_QTY_TO_ASM,SalesLine."Qty. to Assemble to Order"),ActualError),1024));
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipSOMin@41();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      AsmOrder@1008 : TestPage 900;
      Qty@1000 : Integer;
      NewQtyToShip@1001 : Integer;
      QtyOnStock@1006 : Integer;
      ActualError@1009 : Text[1024];
    BEGIN
      // Minimum value of "Quantity to Assemble" = Maximum {0, SalesLine."Quantity to Ship" - UnshippedNonATOQty}
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      QtyOnStock := 50;
      AddInventoryNonDirectLocation(Item."No.",Location.Code,QtyOnStock,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);

      NewQtyToShip := QtyOnStock + 10;
      SalesLine.VALIDATE("Qty. to Ship",NewQtyToShip);
      SalesLine.MODIFY(TRUE);

      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      AsmOrder.TRAP;
      PAGE.RUN(PAGE::"Assembly Order",AssemblyHeader);

      ASSERTERROR AsmOrder."Quantity to Assemble".SETVALUE(NewQtyToShip - QtyOnStock - 1);
      ActualError := AsmOrder."Quantity to Assemble".GETVALIDATIONERROR(1);
      Assert.IsTrue(
        STRPOS(ActualError,STRSUBSTNO(ERR_ATO_QTY_TO_ASM,NewQtyToShip,NewQtyToShip)) > 0,
        PADSTR(STRSUBSTNO(TXT_EXPCTD_ACTUAL,STRSUBSTNO(ERR_ATO_QTY_TO_ASM,NewQtyToShip,NewQtyToShip),ActualError),1024));
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipChangeSOQtyToAssemble@19();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Qty@1000 : Integer;
      NewQtyToAsmSO@1001 : Integer;
      QtyFromStock@1003 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);
      QtyFromStock := 10;
      NewQtyToAsmSO := Qty - QtyFromStock;

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      AddInventoryNonDirectLocation(Item."No.",Location.Code,QtyFromStock,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      // Change Sales Order "Qty. to Assemble to Order"
      SalesLine.VALIDATE("Qty. to Assemble to Order",NewQtyToAsmSO);
      SalesLine.MODIFY(TRUE);

      // Verify Assembly Order
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      Assert.AreEqual(NewQtyToAsmSO,AssemblyHeader."Quantity to Assemble",'Qty to Assemble is updated incorrecly');
      Assert.AreEqual(NewQtyToAsmSO,AssemblyHeader.Quantity,'Quantity is updated incorrectly');

      // Verify posting
      AddComponentsToInventory(SalesLine);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipChangeSOQtyToAssembleQtyToShipM@32();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Qty@1000 : Integer;
      NewQtyToAsmSO@1001 : Integer;
      QtyFromStock@1003 : Integer;
      NewQtyToShip@1006 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);
      QtyFromStock := 10;
      NewQtyToAsmSO := Qty - QtyFromStock;
      NewQtyToShip := NewQtyToAsmSO - 30;

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      AddInventoryNonDirectLocation(Item."No.",Location.Code,QtyFromStock,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      // Change Sales Order "Qty. to Assemble to Order" and then Sales order "Qty. to ship"
      SalesLine.VALIDATE("Qty. to Assemble to Order",NewQtyToAsmSO);
      SalesLine.VALIDATE("Qty. to Ship",NewQtyToShip);
      SalesLine.MODIFY(TRUE);

      // Verify Assembly order
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      Assert.AreEqual(NewQtyToShip,AssemblyHeader."Quantity to Assemble",'Quantity to Assemble is updated incorrecly');
      Assert.AreEqual(NewQtyToAsmSO,AssemblyHeader.Quantity,'Quantity is updated incorrectly');

      // Verify posting
      AddComponentsToInventory(SalesLine);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      VerifyBinContents(AssemblyHeader,QtyFromStock,NewQtyToAsmSO - NewQtyToShip,TRUE);

      // Verify Sales and Assembly order after posting
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      SalesLine.GET(SalesLine."Document Type",SalesLine."Document No.",SalesLine."Line No.");
      Assert.AreEqual(
        NewQtyToAsmSO,SalesLine."Qty. to Assemble to Order",'Qty. to Assemble to Order is updated incorrecly after posting');
      Assert.AreEqual(Qty - NewQtyToShip,SalesLine."Qty. to Ship",'Qty to Ship is updated incorrecly after posting');
      Assert.AreEqual(NewQtyToAsmSO,AssemblyHeader.Quantity,'Quantity is updated');
      Assert.AreEqual(
        NewQtyToAsmSO - NewQtyToShip,AssemblyHeader."Quantity to Assemble",'Quantity to Assemble is updated incorrecly after posting');
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipChangeSOQtyToAssembleQtyToShipP@71();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Qty@1000 : Integer;
      NewQtyToAsmSO@1001 : Integer;
      QtyFromStock@1003 : Integer;
      NewQtyToShip@1006 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);
      QtyFromStock := 10;
      NewQtyToAsmSO := Qty - QtyFromStock;
      NewQtyToShip := NewQtyToAsmSO + 3;

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      AddInventoryNonDirectLocation(Item."No.",Location.Code,QtyFromStock,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      // Change Sales Order "Qty. to Assemble to Order" and then Sales order "Qty. to ship"
      SalesLine.VALIDATE("Qty. to Assemble to Order",NewQtyToAsmSO);
      SalesLine.VALIDATE("Qty. to Ship",NewQtyToShip);
      SalesLine.MODIFY(TRUE);

      // Verify Assembly order
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      Assert.AreEqual(NewQtyToAsmSO,AssemblyHeader."Quantity to Assemble",'Quantity to Assemble is updated incorrecly');
      Assert.AreEqual(NewQtyToAsmSO,AssemblyHeader.Quantity,'Quantity is updated incorrectly');

      // Verify posting
      AddComponentsToInventory(SalesLine);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      VerifyBinContents(AssemblyHeader,Qty - NewQtyToShip,0,TRUE);

      // Verify Sales and Assembly order after posting
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      SalesLine.GET(SalesLine."Document Type",SalesLine."Document No.",SalesLine."Line No.");
      Assert.AreEqual(
        NewQtyToAsmSO,SalesLine."Qty. to Assemble to Order",'Qty. to Assemble to Order is updated incorrecly after posting');
      Assert.AreEqual(Qty - NewQtyToShip,SalesLine."Qty. to Ship",'Qty to Ship is updated incorrecly after posting');
      Assert.AreEqual(NewQtyToAsmSO,AssemblyHeader.Quantity,'Quantity is updated');
      Assert.AreEqual(0,AssemblyHeader."Quantity to Assemble",'Quantity to Assemble is updated incorrecly after posting');
    END;

    [Test]
    [HandlerFunctions(AutoReserveAgainstILE)]
    PROCEDURE QtyToAsmQtyToShipChangeSOQtyToAssembleQtyToShipZero@45();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Qty@1000 : Integer;
      NewQtyToAsmSO@1001 : Integer;
      QtyFromStock@1003 : Integer;
      NewQtyToShip@1006 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);
      QtyFromStock := 10;
      NewQtyToAsmSO := Qty - QtyFromStock;
      NewQtyToShip := QtyFromStock;

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      AddInventoryNonDirectLocation(Item."No.",Location.Code,QtyFromStock,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);

      // Change Sales Order "Qty. to Assemble to Order" and then Sales order "Qty. to ship"
      SalesLine.VALIDATE("Qty. to Assemble to Order",NewQtyToAsmSO);
      SalesLine.VALIDATE("Qty. to Ship",NewQtyToShip);
      SalesLine.MODIFY(TRUE);

      // Verify Assembly order
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');
      AssemblyHeader.VALIDATE("Quantity to Assemble",0);
      AssemblyHeader.MODIFY(TRUE);

      SalesLine.ShowReservation; // reserve the rest of qty on sales against ILE: Bug 273866
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify posting
      VerifyBinContents(AssemblyHeader,0,0,TRUE);

      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      SalesLine.GET(SalesLine."Document Type",SalesLine."Document No.",SalesLine."Line No.");
      Assert.AreEqual(NewQtyToAsmSO,SalesLine."Qty. to Assemble to Order",'Qty. to Assemble to Order is updated incorrecly');
      Assert.AreEqual(Qty - NewQtyToShip,SalesLine."Qty. to Ship",'Qty to Ship is updated incorrecly');
      Assert.AreEqual(NewQtyToAsmSO,AssemblyHeader.Quantity,'Quantity is updated');
      Assert.AreEqual(NewQtyToAsmSO,AssemblyHeader."Quantity to Assemble",'Qty to Assemble is updated incorrecly after posting');

      // Post rest of the order
      AddComponentsToInventory(SalesLine);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      VerifyBinContents(AssemblyHeader,0,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AutoReserveAgainstILE)]
    PROCEDURE QtyToAsmQtyToShipChangeSOQtyToAssembleQtyToShipAO@49();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Qty@1000 : Integer;
      NewQtyToAsmSO@1001 : Integer;
      NewQtyToAssembleAO@1008 : Integer;
      QtyFromStock@1003 : Integer;
      NewQtyToShip@1006 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);
      QtyFromStock := 10;
      NewQtyToAsmSO := Qty - QtyFromStock;
      NewQtyToShip := QtyFromStock + 1;

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      AddInventoryNonDirectLocation(Item."No.",Location.Code,QtyFromStock,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);

      SalesLine.VALIDATE("Qty. to Assemble to Order",NewQtyToAsmSO);
      SalesLine.VALIDATE("Qty. to Ship",NewQtyToShip);
      SalesLine.MODIFY(TRUE);

      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');
      NewQtyToAssembleAO := 1;
      AssemblyHeader.VALIDATE("Quantity to Assemble",NewQtyToAssembleAO);
      AssemblyHeader.MODIFY(TRUE);

      SalesLine.ShowReservation; // reserve the rest of qty on sales against ILE: Bug 273866

      AddComponentsToInventory(SalesLine);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      VerifyBinContents(AssemblyHeader,0,NewQtyToAsmSO - NewQtyToAssembleAO,TRUE);

      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      SalesLine.GET(SalesLine."Document Type",SalesLine."Document No.",SalesLine."Line No.");
      Assert.AreEqual(NewQtyToAsmSO,SalesLine."Qty. to Assemble to Order",'Qty. to Assemble to Order is updated incorrecly');
      Assert.AreEqual(Qty - NewQtyToShip,SalesLine."Qty. to Ship",'Qty to Ship is updated incorrecly');
      Assert.AreEqual(NewQtyToAsmSO,AssemblyHeader.Quantity,'Quantity is updated');
      Assert.AreEqual(
        NewQtyToAsmSO - NewQtyToAssembleAO,AssemblyHeader."Quantity to Assemble",
        'Qty to Assemble is updated incorrecly after posting');

      // Post rest of the order
      AddComponentsToInventory(SalesLine);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      VerifyBinContents(AssemblyHeader,0,0,FALSE);
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipNegativeInv@51();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Qty@1000 : Integer;
      NewQtyToAsmSO@1001 : Integer;
      QtyFromStock@1003 : Integer;
      NewQtyToShip@1006 : Integer;
      ErrMsg@1008 : Text[1024];
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      QtyFromStock := 10;
      NewQtyToAsmSO := 22;
      NewQtyToShip := NewQtyToAsmSO + QtyFromStock + 37;

      AddInventoryNonDirectLocation(Item."No.",Location.Code,QtyFromStock,FromBinCode);

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      SalesLine.VALIDATE("Qty. to Assemble to Order",NewQtyToAsmSO);
      SalesLine.VALIDATE("Qty. to Ship",NewQtyToShip);
      SalesLine.MODIFY(TRUE);

      AddComponentsToInventory(SalesLine);
      ErrMsg := FORMAT(NewQtyToShip - QtyFromStock - NewQtyToAsmSO) + ERR_QTY_BASE;
      ASSERTERROR LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ErrMsg) > 0,PADSTR('Actual:' + GETLASTERRORTEXT + ';Expected:' + ErrMsg,1024));
    END;

    [Test]
    PROCEDURE QtyToAsmQtyToShipFull@53();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      Qty@1000 : Integer;
      NewQtyToAsmSO@1001 : Integer;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');
      Qty := LibraryRandom.RandIntInRange(100,1000);
      NewQtyToAsmSO := Qty - 10;

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,Qty);
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');

      SalesLine.VALIDATE("Qty. to Assemble to Order",NewQtyToAsmSO);
      SalesLine.MODIFY(TRUE);

      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      ASSERTERROR AssemblyHeader.VALIDATE("Quantity to Assemble",NewQtyToAsmSO - 1);
      Assert.IsTrue(
        STRPOS(GETLASTERRORTEXT,STRSUBSTNO(ERR_ATO_QTY_TO_ASM,NewQtyToAsmSO,NewQtyToAsmSO)) > 0,
        PADSTR(STRSUBSTNO(TXT_EXPCTD_ACTUAL,STRSUBSTNO(ERR_ATO_QTY_TO_ASM,NewQtyToAsmSO,NewQtyToAsmSO),GETLASTERRORTEXT),1024));
    END;

    [Test]
    PROCEDURE ATODropShipment1@34();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,LibraryRandom.RandIntInRange(100,1000));
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');
      AddInventoryNonDirectLocation(Item."No.",Location.Code,SalesLine.Quantity,FromBinCode);

      ASSERTERROR BEGIN
        COMMIT;
        SalesLine.VALIDATE("Drop Shipment",TRUE);
      END;
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ERR_QTY_BASE_MUST_BE_0) > 0,PADSTR('Actual: ' + GETLASTERRORTEXT + ';Expected: ' + ERR_QTY_BASE_MUST_BE_0,1024));

      SalesLine.VALIDATE("Qty. to Assemble to Order",0);
      SalesLine.MODIFY(TRUE);

      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
    END;

    [Test]
    PROCEDURE ATODropShipment2@54();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
      PurchaseHeader@1009 : Record 38;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");

      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,LibraryRandom.RandIntInRange(100,1000));
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');
      AddInventoryNonDirectLocation(Item."No.",Location.Code,SalesLine.Quantity,FromBinCode);

      SalesLine.VALIDATE("Qty. to Assemble to Order",0);
      SalesLine.MODIFY(TRUE);

      SalesLine.VALIDATE("Drop Shipment",TRUE);
      SalesLine.MODIFY(TRUE);

      CreatePurchOrderDropShipment(PurchaseHeader,SalesLine);

      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);
      SalesHeader.GET(SalesHeader."Document Type"::Order,SalesLine."Document No.");
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler2)]
    PROCEDURE ATOReopenQuestion@63();
    VAR
      Item@1007 : Record 27;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1002 : Record 900;
    BEGIN
      Initialize;

      UpdateLocation(Location,TRUE,FromBinCode,'');

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order");
      CreateSalesOrder(SalesHeader,Item."No.",'',Location.Code,SalesLine,SalesLine,LibraryRandom.RandIntInRange(100,1000));
      Assert.IsTrue(SalesLine.AsmToOrderExists(AssemblyHeader),'There is no asm order');
      AddInventoryNonDirectLocation(Item."No.",Location.Code,SalesLine.Quantity,FromBinCode);

      LibrarySales.ReleaseSalesDocument(SalesHeader);

      ASSERTERROR BEGIN
        COMMIT;
        SalesLine.FIND; // To retrieve the latest record.
        SalesLine.VALIDATE("Qty. to Assemble to Order",10);
      END;
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ERR_UPDATE_INTERRUPTED) > 0,PADSTR('Actual: ' + GETLASTERRORTEXT + ';Expected: ' + ERR_UPDATE_INTERRUPTED,1024));

      SalesLine.VALIDATE("Qty. to Assemble to Order",10); // second time in confirm dialog reply is yes
      SalesLine.MODIFY(TRUE);

      AddComponentsToInventory(SalesLine);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [Warehouse] [SCM]
    }
    END.
  }
}

