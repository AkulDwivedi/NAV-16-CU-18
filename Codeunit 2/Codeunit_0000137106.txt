OBJECT Codeunit 137106 SCM Kitting ATS in Whse/IT WMS
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            IsInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LocationWMS@1016 : Record 14;
      CompItem@1035 : Record 27;
      KitItem@1036 : Record 27;
      Assert@1009 : Codeunit 130000;
      LibraryWarehouse@1002 : Codeunit 132204;
      LibraryUtility@1003 : Codeunit 131000;
      LibraryAssembly@1010 : Codeunit 132207;
      LibraryInventory@1014 : Codeunit 132201;
      LibraryPurchase@1043 : Codeunit 130512;
      LibraryKitting@1024 : Codeunit 132205;
      LibraryRandom@1017 : Codeunit 130440;
      LibrarySales@1007 : Codeunit 130509;
      LibraryManufacturing@1008 : Codeunit 132202;
      IsInitialized@1000 : Boolean;
      MSG_PICK_ACT_CREATED@1018 : TextConst 'ENU=Pick activity no.';
      MSG_NOTHING_TO_HANDLE@1055 : TextConst 'ENU=Nothing to handle.';
      MSG_STATUS_MUST_BE_RELEASED@1056 : TextConst 'ENU=Status must be equal to ''Released''';
      MSG_QTY_OUTST@1057 : TextConst 'ENU=You cannot handle more than the outstanding';
      MSG_SER_NO_MUST@1026 : TextConst 'ENU=Serial No. must have a value';
      MSG_LOT_NO_MUST@1006 : TextConst 'ENU=Lot No. must have a value';
      LocationTakeBinCode@1032 : Code[20];
      LocationAdditionalBinCode@1013 : Code[20];
      LocationToBinCode@1004 : Code[20];
      LocationFromBinCode@1058 : Code[20];
      LocationAdditionalPickBinCode@1044 : Code[20];
      MsgCount@1042 : Integer;
      WhseActivityType@1041 : 'None,WhsePick,InvtMvmt';
      Tracking@1049 : 'Untracked,Lot,Serial,LotSerial';
      GLB_ITPageHandler@1040 : 'AssignITSpec,SelectITSpec,AssignITSpecPartial,PutManuallyITSpec';
      PAR_ITPage_AssignSerial@1039 : Boolean;
      PAR_ITPage_AssignLot@1020 : Boolean;
      PAR_ITPage_AssignPartial@1011 : Boolean;
      PAR_ITPage_AssignQty@1005 : Decimal;
      PAR_ITPage_ITNo@1012 : Code[20];
      PAR_ITPage_FINDDIR@1028 : Code[20];
      WorkDate2@1019 : Date;
      MSG_CANNOT_POST_CONS@1033 : TextConst 'ENU=You cannot post consumption for order no.';

    LOCAL PROCEDURE Initialize@25();
    VAR
      WarehouseSetup@1001 : Record 5769;
      SalesReceivablesSetup@1002 : Record 311;
      PurchasesPayablesSetup@1006 : Record 312;
      AssemblySetup@1000 : Record 905;
      MfgSetup@1004 : Record 99000765;
      LibraryERMCountryData@1008 : Codeunit 131305;
    BEGIN
      MsgCount := 0;

      IF IsInitialized THEN
        EXIT;

      // Setup Demonstration data.
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;

      CLEARLASTERROR;
      MfgSetup.GET;
      WorkDate2 := CALCDATE(MfgSetup."Default Safety Lead Time",WORKDATE); // to avoid Due Date Before Work Date message.
      LibraryAssembly.UpdateAssemblySetup(AssemblySetup,'',AssemblySetup."Copy Component Dimensions from"::"Item/Resource Card",
        LibraryUtility.GetGlobalNoSeriesCode);

      LibraryWarehouse.NoSeriesSetup(WarehouseSetup);

      SalesReceivablesSetup.GET;
      SalesReceivablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesReceivablesSetup.MODIFY(TRUE);

      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      PurchasesPayablesSetup.MODIFY(TRUE);

      LocationSetupWMS(LocationWMS);

      IsInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE SetGenWarehouseEntriesFilter@99(VAR WarehouseEntry@1001 : Record 7312;AssemblyHeader@1000 : Record 900);
    VAR
      SourceCodeSetup@1002 : Record 242;
    BEGIN
      WarehouseEntry.RESET;
      SourceCodeSetup.GET;
      WarehouseEntry.SETRANGE("Source Code",SourceCodeSetup.Assembly);
      WarehouseEntry.SETRANGE("Source No.",AssemblyHeader."No.");
      WarehouseEntry.SETRANGE("Registering Date",AssemblyHeader."Posting Date");
      WarehouseEntry.SETRANGE("User ID",USERID);
    END;

    LOCAL PROCEDURE SetLocWarehouseEntriesFilter@147(VAR WarehouseEntry@1001 : Record 7312;VariantCode@1000 : Code[20];UOMCode@1002 : Code[20];Quantity@1003 : Decimal;WarehouseEntryType@1004 : Integer;LocationCode@1005 : Code[20];BinCode@1006 : Code[20];ItemNo@1007 : Code[20];SourceLineNo@1008 : Integer);
    BEGIN
      WarehouseEntry.SETRANGE("Variant Code",VariantCode);
      WarehouseEntry.SETRANGE("Unit of Measure Code",UOMCode);
      WarehouseEntry.SETRANGE(Quantity,Quantity);
      WarehouseEntry.SETRANGE("Entry Type",WarehouseEntryType);
      WarehouseEntry.SETRANGE("Location Code",LocationCode);
      WarehouseEntry.SETRANGE("Bin Code",BinCode);
      WarehouseEntry.SETRANGE("Item No.",ItemNo);
      // Description is not set because of bug
      // WarehouseEntry.SETRANGE(Description,TempAssemblyLine.Description);
      // WarehouseEntry.SETRANGE("Source Document",WarehouseEntry."Source Document"::"Assembly Order");
      WarehouseEntry.SETRANGE("Source Line No.",SourceLineNo);
    END;

    LOCAL PROCEDURE VerifyWarehouseEntries@125(AssemblyHeader@1001 : Record 900;VAR TempAssemblyLine@1002 : TEMPORARY Record 901;AssembledQty@1003 : Decimal;ShouldBeCreated@1004 : Boolean;ExpectedNoOfWhseEntries@1005 : Integer);
    VAR
      WarehouseEntry@1000 : Record 7312;
    BEGIN
      // Verify whole amount of warehouse entries
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);

      SetGenWarehouseEntriesFilter(WarehouseEntry,AssemblyHeader);
      IF ShouldBeCreated THEN
        Assert.AreEqual(ExpectedNoOfWhseEntries,WarehouseEntry.COUNT,
          'Incorect number of warehouse entries for assembly ' + AssemblyHeader."No.")
      ELSE
        Assert.AreEqual(0,WarehouseEntry.COUNT,
          'Incorect number of warehouse entries for assembly ' + AssemblyHeader."No.");

      // Verify warehouse entries for header assembly item
      SetGenWarehouseEntriesFilter(WarehouseEntry,AssemblyHeader);
      SetLocWarehouseEntriesFilter(WarehouseEntry,
        AssemblyHeader."Variant Code",
        AssemblyHeader."Unit of Measure Code",
        AssembledQty,
        WarehouseEntry."Entry Type"::"Positive Adjmt.",
        AssemblyHeader."Location Code",
        AssemblyHeader."Bin Code",
        AssemblyHeader."Item No.",
        0);
      IF ShouldBeCreated THEN
        Assert.AreEqual(1,WarehouseEntry.COUNT,
          'Incorrect number of warehouse entries for assembly item ' + AssemblyHeader."Item No.")
      ELSE
        Assert.AreEqual(0,WarehouseEntry.COUNT,
          'Incorrect number of warehouse entries for assembly item ' + AssemblyHeader."Item No.");

      // Verify warehouse entries for components
      TempAssemblyLine.FINDSET;
      REPEAT
        SetGenWarehouseEntriesFilter(WarehouseEntry,AssemblyHeader);
        SetLocWarehouseEntriesFilter(WarehouseEntry,
          TempAssemblyLine."Variant Code",
          TempAssemblyLine."Unit of Measure Code",
          -TempAssemblyLine."Quantity to Consume",
          WarehouseEntry."Entry Type"::"Negative Adjmt.",
          TempAssemblyLine."Location Code",
          TempAssemblyLine."Bin Code",
          TempAssemblyLine."No.",
          TempAssemblyLine."Line No.");
        IF ShouldBeCreated THEN
          Assert.AreEqual(1,WarehouseEntry.COUNT,
            'Incorrect number of warehouse entries for assembly line ' + TempAssemblyLine."No.")
        ELSE
          Assert.AreEqual(0,WarehouseEntry.COUNT,
            'Incorrect number of warehouse entries for assembly line ' + TempAssemblyLine."No.");
      UNTIL TempAssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyBinContent@101(LocationCode@1003 : Code[20];BinCode@1000 : Code[20];ItemNo@1002 : Code[20];Quantity@1001 : Decimal);
    VAR
      BinContent@1004 : Record 7302;
    BEGIN
      BinContent.RESET;
      BinContent.SETRANGE("Location Code",LocationCode);
      BinContent.SETRANGE("Bin Code",BinCode);
      BinContent.SETRANGE("Item No.",ItemNo);
      IF BinContent.FINDFIRST THEN BEGIN
        BinContent.CALCFIELDS(Quantity);
        BinContent.TESTFIELD(Quantity,Quantity);
      END ELSE
        Assert.AreEqual(Quantity,0,'Incorrect Qty of Item ' + ItemNo + ' in Bin ' + BinCode);
    END;

    LOCAL PROCEDURE VerifyBinContentsMvmt@30(AssemblyHeader@1000 : Record 900;VAR TempAssemblyLine@1001 : TEMPORARY Record 901;QtySupplement@1002 : Decimal;AssembledQty@1003 : Decimal);
    VAR
      Location@1004 : Record 14;
    BEGIN
      // Verify bin content for header assembly item
      VerifyBinContent(AssemblyHeader."Location Code",AssemblyHeader."Bin Code",AssemblyHeader."Item No.",AssembledQty);

      // Verify bin contents for components
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;

      REPEAT
        Location.GET(TempAssemblyLine."Location Code");
        IF Location."Require Shipment" THEN BEGIN
          VerifyBinContent(TempAssemblyLine."Location Code",TempAssemblyLine."Bin Code",
            TempAssemblyLine."No.",
            TempAssemblyLine.Quantity - TempAssemblyLine."Quantity to Consume" - TempAssemblyLine."Consumed Quantity");
          VerifyBinContent(TempAssemblyLine."Location Code",LocationTakeBinCode,
            TempAssemblyLine."No.",
            QtySupplement);
        END ELSE BEGIN
          VerifyBinContent(TempAssemblyLine."Location Code",TempAssemblyLine."Bin Code",
            TempAssemblyLine."No.",0);
          VerifyBinContent(TempAssemblyLine."Location Code",LocationTakeBinCode,
            TempAssemblyLine."No.",
            QtySupplement + TempAssemblyLine.Quantity - TempAssemblyLine."Quantity to Consume" - TempAssemblyLine."Consumed Quantity")
        END;
      UNTIL TempAssemblyLine.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE VerifyRegWhsePickHeader@159(AssemblyHeader@1001 : Record 900;ExpectedNoOfRegWhsePick@1006 : Integer;WhsePickNo@1000 : Code[20]);
    VAR
      RegdWhseActivityHdr@1002 : Record 5772;
    BEGIN
      RegdWhseActivityHdr.RESET;

      RegdWhseActivityHdr.SETRANGE("Location Code",AssemblyHeader."Location Code");
      RegdWhseActivityHdr.SETRANGE("Whse. Activity No.",WhsePickNo);
      Assert.AreEqual(ExpectedNoOfRegWhsePick,RegdWhseActivityHdr.COUNT,COPYSTR(
          'There should be 1 registered WhsePickHeader within the filter: ' +
          RegdWhseActivityHdr.GETFILTERS,1,1024));
    END;

    [Normal]
    LOCAL PROCEDURE VerifyRegWhsePick@158(AssemblyHeader@1001 : Record 900;VAR TempAssemblyLine@1004 : TEMPORARY Record 901;WarehouseActivityHeaderNo@1005 : Code[20];ExpectedNoOfRegWhsePick@1006 : Integer;NotEnoughItemNo@1008 : Code[20];NotEnoughQty@1007 : Decimal;AdditionalBinQty@1009 : Decimal);
    VAR
      RegdWhseActivityLine@1000 : Record 5773;
      RegdWhseActivityHdr@1002 : Record 5772;
      ExpectedNoOfLines@1010 : Integer;
    BEGIN
      VerifyRegWhsePickHeader(AssemblyHeader,ExpectedNoOfRegWhsePick,WarehouseActivityHeaderNo);

      RegdWhseActivityHdr.SETRANGE("Whse. Activity No.",WarehouseActivityHeaderNo);
      RegdWhseActivityHdr.FINDFIRST;

      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);

      RegdWhseActivityLine.RESET;
      RegdWhseActivityLine.SETRANGE("No.",RegdWhseActivityHdr."No.");

      ExpectedNoOfLines := 2 * TempAssemblyLine.COUNT;
      IF AdditionalBinQty > 0 THEN
        ExpectedNoOfLines += 2;
      Assert.AreEqual(
        ExpectedNoOfLines,RegdWhseActivityLine.COUNT,COPYSTR('There are not ' + FORMAT(ExpectedNoOfLines) +
          ' reg Invt mvmt lines within the filter: ' + RegdWhseActivityHdr.GETFILTERS,1,1024));

      VerifyRegWhsePickLines(RegdWhseActivityHdr,TempAssemblyLine,
        RegdWhseActivityLine."Action Type"::Take,LocationTakeBinCode,NotEnoughItemNo,NotEnoughQty,AdditionalBinQty);
      VerifyRegWhsePickLines(RegdWhseActivityHdr,TempAssemblyLine,
        RegdWhseActivityLine."Action Type"::Place,LocationToBinCode,NotEnoughItemNo,NotEnoughQty,AdditionalBinQty);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyWhseActivity@6(AssemblyHeader@1001 : Record 900;VAR TempAssemblyLine@1004 : TEMPORARY Record 901;VAR WhseActivityHdr@1005 : Record 5766;NotEnoughItemNo@1006 : Code[20];NotEnoughQty@1002 : Decimal;AdditionalBinQty@1007 : Decimal);
    VAR
      WhseActivityLine@1000 : Record 5767;
      ExpectedNoOfItems@1008 : Integer;
    BEGIN
      VerifyWhseActivityHeader(AssemblyHeader,WhseActivityHdr);

      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);

      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHdr."No.");

      ExpectedNoOfItems := 2 * TempAssemblyLine.COUNT;
      IF AdditionalBinQty > 0 THEN
        ExpectedNoOfItems += 2;

      Assert.AreEqual(
        ExpectedNoOfItems,WhseActivityLine.COUNT,COPYSTR('There are not ' + FORMAT(ExpectedNoOfItems) +
          ' whse activity lines within the filter: ' + WhseActivityHdr.GETFILTERS,1,1024));

      VerifyWhseActivityLines(WhseActivityHdr,TempAssemblyLine,
        WhseActivityLine."Action Type"::Take,LocationTakeBinCode,NotEnoughItemNo,NotEnoughQty,AdditionalBinQty);
      VerifyWhseActivityLines(WhseActivityHdr,TempAssemblyLine,
        WhseActivityLine."Action Type"::Place,LocationToBinCode,NotEnoughItemNo,NotEnoughQty,AdditionalBinQty);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyWhseActivityHeader@15(AssemblyHeader@1001 : Record 900;VAR WarehouseActivityHeader@1005 : Record 5766);
    BEGIN
      WarehouseActivityHeader.RESET;
      WarehouseActivityHeader.SETRANGE("Location Code",AssemblyHeader."Location Code");

      IF WarehouseActivityHeader.Type = WarehouseActivityHeader.Type::Pick THEN
        // WarehouseActivityHeader.SETRANGE("Source No.",AssemblyHeader."No.");
        // WarehouseActivityHeader.SETRANGE("Source Document",WarehouseRequest."Source Document"::"Assembly Consumption");
        // WarehouseActivityHeader.SETRANGE("Source Type",DATABASE::"Assembly Line");
        // WarehouseActivityHeader.SETRANGE("Source Subtype",AssemblyHeader."Document Type");
        // WarehouseActivityHeader.SETRANGE("Destination Type",WarehouseActivityHeader."Destination Type"::Item);
        // WarehouseActivityHeader.SETRANGE("Destination No.",AssemblyHeader."Item No.");
        // WarehouseActivityHeader.SETRANGE("Destination Type",WarehouseActivityHeader."Destination Type"::Item);
        // WarehouseActivityHeader.SETRANGE("Destination No.",AssemblyHeader."Item No.");
        ;

      Assert.AreEqual(1,WarehouseActivityHeader.COUNT,COPYSTR('There should be 1 whse activity header within the filter: ' +
          WarehouseActivityHeader.GETFILTERS,1,1024));

      WarehouseActivityHeader.FINDFIRST;
    END;

    [Normal]
    LOCAL PROCEDURE VerifyRegWhsePickLine@161(RegdWhseActivityHdr@1003 : Record 5772;VAR TempAssemblyLine@1000 : TEMPORARY Record 901;ActionType@1002 : Option;BinCode@1004 : Code[20];Qty@1008 : Decimal);
    VAR
      RegdWhseActivityLine@1001 : Record 5773;
    BEGIN
      RegdWhseActivityLine.RESET;
      RegdWhseActivityLine.SETRANGE("No.",RegdWhseActivityHdr."No.");
      RegdWhseActivityLine.SETRANGE("Action Type",ActionType);
      RegdWhseActivityLine.SETRANGE("Bin Code",BinCode);
      RegdWhseActivityLine.SETRANGE("Location Code",TempAssemblyLine."Location Code");
      RegdWhseActivityLine.SETRANGE("Item No.",TempAssemblyLine."No.");
      RegdWhseActivityLine.SETRANGE(Description,TempAssemblyLine.Description);
      RegdWhseActivityLine.SETRANGE("Unit of Measure Code",TempAssemblyLine."Unit of Measure Code");
      RegdWhseActivityLine.SETRANGE("Qty. per Unit of Measure",1);
      RegdWhseActivityLine.SETRANGE("Due Date",TempAssemblyLine."Due Date");

      RegdWhseActivityLine.SETRANGE(Quantity,Qty);
      RegdWhseActivityLine.SETRANGE("Qty. (Base)",Qty);

      Assert.AreEqual(1,RegdWhseActivityLine.COUNT,COPYSTR('There are not 1 registered whse pick lines within the filter: ' +
          RegdWhseActivityLine.GETFILTERS,1,1024));
    END;

    [Normal]
    LOCAL PROCEDURE VerifyRegWhsePickLines@160(RegdWhseActivityHdr@1003 : Record 5772;VAR TempAssemblyLine@1000 : TEMPORARY Record 901;ActionType@1002 : Option;BinCode@1004 : Code[20];NotEnoughItemNo@1005 : Code[20];NotEnoughQty@1006 : Decimal;AdditionalBinQty@1007 : Decimal);
    VAR
      RegdWhseActivityLine@1001 : Record 5773;
      Location@1008 : Record 14;
      Item@1009 : Record 27;
      QtyOnRegPick@1010 : Decimal;
    BEGIN
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;

      REPEAT
        IF TempAssemblyLine."No." = NotEnoughItemNo THEN BEGIN
          VerifyRegWhsePickLine(RegdWhseActivityHdr,TempAssemblyLine,ActionType,BinCode,
            NotEnoughQty);
        END ELSE BEGIN
          Location.GET(TempAssemblyLine."Location Code");
          IF Location."Require Shipment" THEN BEGIN
            Item.GET(TempAssemblyLine."No.");
            Item."Location Filter" := Location.Code;
            Item.CALCFIELDS(Inventory);
            IF Item.Inventory < TempAssemblyLine."Remaining Quantity" THEN
              QtyOnRegPick := Item.Inventory
            ELSE
              QtyOnRegPick := TempAssemblyLine."Remaining Quantity";
            VerifyRegWhsePickLine(RegdWhseActivityHdr,TempAssemblyLine,ActionType,BinCode,QtyOnRegPick);
          END ELSE
            VerifyRegWhsePickLine(RegdWhseActivityHdr,TempAssemblyLine,ActionType,BinCode,
              TempAssemblyLine."Quantity to Consume");
        END;
      UNTIL TempAssemblyLine.NEXT = 0;

      IF AdditionalBinQty > 0 THEN BEGIN
        TempAssemblyLine.RESET;
        TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
        TempAssemblyLine.SETRANGE("No.",NotEnoughItemNo);
        TempAssemblyLine.FINDFIRST;

        IF ActionType = RegdWhseActivityLine."Action Type"::Take THEN
          VerifyRegWhsePickLine(RegdWhseActivityHdr,TempAssemblyLine,ActionType,LocationAdditionalBinCode,
            AdditionalBinQty)
        ELSE
          VerifyRegWhsePickLine(RegdWhseActivityHdr,TempAssemblyLine,ActionType,BinCode,
            AdditionalBinQty);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE VerifyWhseActivityLines@21(WhseActivityHdr@1003 : Record 5766;VAR TempAssemblyLine@1000 : TEMPORARY Record 901;ActionType@1002 : Option;BinCode@1004 : Code[20];NotEnoughItemNo@1005 : Code[20];NotEnoughQty@1006 : Decimal;AdditionalBinQty@1007 : Decimal);
    VAR
      WhseActivityLine@1001 : Record 5767;
      Location@1008 : Record 14;
      Item@1009 : Record 27;
      QtyOnPick@1010 : Decimal;
    BEGIN
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;

      REPEAT
        IF TempAssemblyLine."No." = NotEnoughItemNo THEN
          VerifyWhseActivityLine(WhseActivityHdr,TempAssemblyLine,ActionType,BinCode,NotEnoughQty,NotEnoughQty)
        ELSE BEGIN
          Location.GET(TempAssemblyLine."Location Code");
          IF Location."Require Shipment" THEN BEGIN
            Item.GET(TempAssemblyLine."No.");
            Item."Location Filter" := Location.Code;
            Item.CALCFIELDS(Inventory);
            IF Item.Inventory < TempAssemblyLine."Remaining Quantity" THEN
              QtyOnPick := Item.Inventory
            ELSE
              QtyOnPick := TempAssemblyLine."Remaining Quantity";
            VerifyWhseActivityLine(WhseActivityHdr,TempAssemblyLine,ActionType,BinCode,QtyOnPick,QtyOnPick);
          END ELSE
            VerifyWhseActivityLine(WhseActivityHdr,TempAssemblyLine,ActionType,BinCode,TempAssemblyLine."Quantity to Consume",
              TempAssemblyLine."Quantity to Consume");
        END;
      UNTIL TempAssemblyLine.NEXT = 0;

      IF AdditionalBinQty > 0 THEN BEGIN
        TempAssemblyLine.RESET;
        TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
        TempAssemblyLine.SETRANGE("No.",NotEnoughItemNo);
        TempAssemblyLine.FINDFIRST;

        IF ActionType = WhseActivityLine."Action Type"::Take THEN
          VerifyWhseActivityLine(
            WhseActivityHdr,TempAssemblyLine,ActionType,LocationAdditionalBinCode,AdditionalBinQty,AdditionalBinQty)
        ELSE
          VerifyWhseActivityLine(WhseActivityHdr,TempAssemblyLine,ActionType,BinCode,AdditionalBinQty,AdditionalBinQty);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE VerifyWhseActivityLine@32(WhseActivityHdr@1003 : Record 5766;VAR TempAssemblyLine@1000 : TEMPORARY Record 901;ActionType@1002 : Option;BinCode@1004 : Code[20];Qty@1006 : Decimal;QtyToHandle@1007 : Decimal);
    VAR
      WhseActivityLine@1001 : Record 5767;
    BEGIN
      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHdr."No.");
      WhseActivityLine.SETRANGE("Action Type",ActionType);
      WhseActivityLine.SETRANGE("Location Code",TempAssemblyLine."Location Code");
      WhseActivityLine.SETRANGE("Item No.",TempAssemblyLine."No.");
      WhseActivityLine.SETRANGE("Bin Code",BinCode);
      WhseActivityLine.SETRANGE(Quantity,Qty);

      Assert.AreEqual(1,WhseActivityLine.COUNT,COPYSTR('There is no whse activity line within the filter: ' +
          WhseActivityLine.GETFILTERS,1,1024));
      WhseActivityLine.FINDFIRST;

      Assert.AreEqual(TempAssemblyLine.Description,WhseActivityLine.Description,'Incorrect descriprion');
      Assert.AreEqual(TempAssemblyLine."Unit of Measure Code",WhseActivityLine."Unit of Measure Code",'Incorrect UOM');
      Assert.AreEqual(TempAssemblyLine."Due Date",WhseActivityLine."Due Date",'Incorrect due date');
      Assert.AreEqual(1,WhseActivityLine."Qty. per Unit of Measure",'Incorrect qty per UOM');
      Assert.AreEqual(Qty,WhseActivityLine."Qty. (Base)",'Incorrect qty base');

      Assert.AreEqual(QtyToHandle,WhseActivityLine."Qty. to Handle",'incorrect qty to handle');
      IF QtyToHandle > 0 THEN
        Assert.AreEqual(Qty - QtyToHandle,WhseActivityLine."Qty. Handled",'incorrect qty. handled')
      ELSE
        Assert.AreEqual(0,WhseActivityLine."Qty. Handled",'incorrect qty. handled');
    END;

    LOCAL PROCEDURE AddCompInventoryNotEnough@11(AssemblyHeader@1001 : Record 900;NotEnoughNo@1003 : Integer;VAR NotEnoughItemNo@1006 : Code[20];CompQtyFactor@1007 : Integer;VAR ResultQtys@1004 : ARRAY [10] OF Decimal;AddAdditionalQty@1009 : Boolean;BinToPutCode@1000 : Code[20]);
    VAR
      Item@1002 : Record 27;
      AssemblyLine@1010 : Record 901;
      i@1005 : Integer;
      ItemsCount@1008 : Integer;
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.FINDSET;

      // Calculate result quantities
      i := 1;
      REPEAT
        ResultQtys[i] := AssemblyLine.Quantity * CompQtyFactor / 100;
        IF i = NotEnoughNo THEN BEGIN
          Item.GET(AssemblyLine."No.");
          NotEnoughItemNo := Item."No.";
          ResultQtys[i] := ROUND(ResultQtys[i],0.00001,'>');
          ResultQtys[i] -= 0.00002;
          ItemsCount := AssemblyLine.COUNT + 1;
          ResultQtys[ItemsCount] := 0.00002;
        END ELSE
          ResultQtys[i] := ROUND(ResultQtys[i],0.00001,'>');

        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add inventory
      i := 1;
      AssemblyLine.FINDSET;
      REPEAT
        LibraryAssembly.AddItemInventory(AssemblyLine,WorkDate2,AssemblyLine."Location Code",BinToPutCode,ResultQtys[i]);
        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add rest inventory to additional bin
      IF AddAdditionalQty THEN BEGIN
        AssemblyLine.RESET;
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
        AssemblyLine.SETRANGE("No.",NotEnoughItemNo);
        AssemblyLine.FINDFIRST;

        LibraryAssembly.AddItemInventory(
          AssemblyLine,WorkDate2,AssemblyLine."Location Code",LocationAdditionalBinCode,ResultQtys[ItemsCount]);
      END;
    END;

    LOCAL PROCEDURE LocationSetupWMS@23(VAR Location@1000 : Record 14);
    VAR
      WarehouseEmployee@1001 : Record 7301;
      Bin@1002 : Record 7354;
    BEGIN
      LibraryWarehouse.CreateFullWMSLocation(Location,LibraryRandom.RandIntInRange(8,12));
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,Location.Code,FALSE);

      LibraryWarehouse.FindBin(Bin,Location.Code,'QC',1);
      LocationToBinCode := Bin.Code;
      LibraryWarehouse.FindBin(Bin,Location.Code,'QC',2);
      LocationFromBinCode := Bin.Code;

      Location.VALIDATE("From-Assembly Bin Code",LocationFromBinCode);
      Location.VALIDATE("To-Assembly Bin Code",LocationToBinCode);
      Location.MODIFY(TRUE);

      AssignBinCodesWMS;
    END;

    [Normal]
    LOCAL PROCEDURE AssignBinCodesWMS@56();
    VAR
      Bin@1000 : Record 7354;
    BEGIN
      LocationToBinCode := LocationWMS."To-Assembly Bin Code";
      LocationFromBinCode := LocationWMS."From-Assembly Bin Code";

      LibraryWarehouse.FindBin(Bin,LocationWMS.Code,'PICK',3);
      LocationAdditionalBinCode := Bin.Code;

      LibraryWarehouse.FindBin(Bin,LocationWMS.Code,'PICK',1);
      LocationTakeBinCode := Bin.Code;

      LibraryWarehouse.FindBin(Bin,LocationWMS.Code,'PICK',2);
      LocationAdditionalPickBinCode := Bin.Code;
    END;

    [Normal]
    LOCAL PROCEDURE PostAssemblyHeader@172(AssemblyHeaderNo@1000 : Code[20];ExpectedError@1002 : Text[1024]);
    VAR
      AssemblyHeader@1003 : Record 900;
    BEGIN
      AssemblyHeader.INIT;
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,ExpectedError);
    END;

    [Normal]
    LOCAL PROCEDURE CreateWhsePickAndVerify@39(AssemblyHeaderNo@1000 : Code[20];VAR TempAssemblyLine@1001 : TEMPORARY Record 901;ExpectedNoOfRegInvtMmnt@1004 : Integer;NotEnoughItemNo@1003 : Code[20];NotEnoughQty@1002 : Decimal;AdditionalBinQty@1005 : Decimal);
    VAR
      WhseActivityHeader@1006 : Record 5766;
      AssemblyHeader@1008 : Record 900;
    BEGIN
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      IF AssemblyHeader."Assembled Quantity" >
         0
      THEN BEGIN // assuming that previous posting has created picks for the full remaining qty.
        COMMIT; // to save state before expected error
        ASSERTERROR LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
        Assert.IsTrue(STRPOS(GETLASTERRORTEXT,MSG_NOTHING_TO_HANDLE) > 0,'');
      END ELSE BEGIN
        LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
        VerifyWhseActivity(AssemblyHeader,TempAssemblyLine,WhseActivityHeader,NotEnoughItemNo,NotEnoughQty,AdditionalBinQty);

        LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);

        VerifyRegWhsePick(AssemblyHeader,TempAssemblyLine,WhseActivityHeader."No.",ExpectedNoOfRegInvtMmnt,NotEnoughItemNo,
          NotEnoughQty,AdditionalBinQty);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE UpdateWhseActivityLine@54(NoToChange@1000 : Integer;VAR ChangedItemNo@1004 : Code[20];VAR ChangedItemQty@1005 : Decimal;VAR TempAssemblyLine@1001 : TEMPORARY Record 901;WhseActivityHeader@1007 : Record 5766;QtyToAdd@1002 : Decimal);
    VAR
      WhseActivityLine@1003 : Record 5767;
      i@1006 : Integer;
    BEGIN
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;

      i := 1;
      REPEAT
        IF i = NoToChange THEN
          ChangedItemNo := TempAssemblyLine."No.";
        i += 1;
      UNTIL TempAssemblyLine.NEXT = 0;

      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");
      WhseActivityLine.SETRANGE("Item No.",ChangedItemNo);
      Assert.AreEqual(2,WhseActivityLine.COUNT,COPYSTR('There are not 2 registered whse activity lines within the filter: ' +
          WhseActivityLine.GETFILTERS,1,1024));

      WhseActivityLine.FINDSET;
      ChangedItemQty := ROUND(WhseActivityLine.Quantity,0.00001,'<');
      ChangedItemQty += QtyToAdd;

      REPEAT
        WhseActivityLine.VALIDATE("Qty. to Handle",ChangedItemQty);
        WhseActivityLine.MODIFY(TRUE);
      UNTIL WhseActivityLine.NEXT = 0;
    END;

    LOCAL PROCEDURE NormalPostingWMS@14(HeaderQtyFactor@1012 : Decimal;PartialPostFactor@1011 : Decimal;QtySupplement@1018 : Decimal) : Code[20];
    VAR
      TempAssemblyLine@1007 : TEMPORARY Record 901;
      AssemblyHeader@1019 : Record 900;
      AssembledQty@1013 : Decimal;
    BEGIN
      AssignBinCodesWMS;
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationWMS.Code,LibraryRandom.RandIntInRange(1,3));

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,QtySupplement,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);
      AssembledQty := AssemblyHeader."Quantity to Assemble";
      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      CreateWhsePickAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,'',0,0);

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify.
      VerifyBinContentsMvmt(AssemblyHeader,TempAssemblyLine,QtySupplement,AssembledQty);

      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      VerifyWarehouseEntries(AssemblyHeader,TempAssemblyLine,AssembledQty,TRUE,TempAssemblyLine.COUNT + 1);
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssembledQty);
      LibraryAssembly.VerifyItemRegister(AssemblyHeader);

      EXIT(AssemblyHeader."No.");
    END;

    LOCAL PROCEDURE NotEnoughItemPostingWMS@55(HeaderQtyFactor@1012 : Decimal;PartialPostFactor@1011 : Decimal;AddAdditionalQty@1000 : Boolean;ExpectedErrorMessage@1004 : Text[1024]);
    VAR
      TempAssemblyLine@1007 : TEMPORARY Record 901;
      AssemblyHeader@1022 : Record 900;
      NotEnoughItemNo@1015 : Code[20];
      NotEnoughNo@1018 : Integer;
      NoOfItems@1019 : Integer;
      Qtys@1017 : ARRAY [10] OF Decimal;
    BEGIN
      AssignBinCodesWMS;
      NoOfItems := LibraryRandom.RandIntInRange(2,3);

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationWMS.Code,NoOfItems);

      NotEnoughNo := LibraryRandom.RandIntInRange(1,NoOfItems);
      AddCompInventoryNotEnough(AssemblyHeader,NotEnoughNo,NotEnoughItemNo,PartialPostFactor,Qtys,AddAdditionalQty,
        LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      IF AddAdditionalQty THEN
        CreateWhsePickAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,NotEnoughItemNo,Qtys[NotEnoughNo],Qtys[NoOfItems + 1])
      ELSE
        CreateWhsePickAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,NotEnoughItemNo,Qtys[NotEnoughNo],0);

      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessage);
    END;

    LOCAL PROCEDURE MoveNotEnoughItemWMS@57(HeaderQtyFactor@1016 : Integer;PartialPostFactor@1017 : Integer);
    VAR
      TempAssemblyLine@1011 : TEMPORARY Record 901;
      AssemblyHeader@1009 : Record 900;
      WhseActivityHeader@1013 : Record 5766;
      WhseActivityLine@1014 : Record 5767;
      NotEnoughItemNo@1008 : Code[20];
      NotEnoughNo@1005 : Integer;
      NoOfItems@1004 : Integer;
      NotEnoughQty@1015 : Decimal;
    BEGIN
      AssignBinCodesWMS;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationWMS.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      // Create Warehouse Pick and Verify
      LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
      VerifyWhseActivity(AssemblyHeader,TempAssemblyLine,WhseActivityHeader,'',0,0);

      // Reduce Quantity to Handled of one of the items
      NotEnoughNo := LibraryRandom.RandIntInRange(1,NoOfItems);
      UpdateWhseActivityLine(NotEnoughNo,NotEnoughItemNo,NotEnoughQty,TempAssemblyLine,WhseActivityHeader,-0.00001);

      // Register warehouse activity and verify
      LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);
      VerifyRegWhsePick(AssemblyHeader,TempAssemblyLine,WhseActivityHeader."No.",1,NotEnoughItemNo,NotEnoughQty,0);

      // Post assembly order
      PostAssemblyHeader(AssemblyHeader."No.",''); // pick for the whole quantity has already been made as partial posting happens

      // Verify warehouse activity with rest of the item
      VerifyWhseActivityHeader(AssemblyHeader,WhseActivityHeader);

      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");

      Assert.AreEqual(
        2,WhseActivityLine.COUNT,COPYSTR('There are not 2 whse activity lines within the filter: ' +
          WhseActivityHeader.GETFILTERS,1,1024));

      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.SETRANGE("No.",NotEnoughItemNo);
      TempAssemblyLine.FINDFIRST;

      VerifyWhseActivityLine(WhseActivityHeader,TempAssemblyLine,WhseActivityLine."Action Type"::Take,LocationTakeBinCode,
        TempAssemblyLine.Quantity,TempAssemblyLine.Quantity - NotEnoughQty);
      VerifyWhseActivityLine(WhseActivityHeader,TempAssemblyLine,WhseActivityLine."Action Type"::Place,LocationToBinCode,
        TempAssemblyLine.Quantity,TempAssemblyLine.Quantity - NotEnoughQty);

      // Register warehouse activity
      LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);
      VerifyRegWhsePickHeader(AssemblyHeader,2,WhseActivityHeader."No.");

      // Post assembly order
      PostAssemblyHeader(AssemblyHeader."No.",'');
    END;

    [MessageHandler]
    PROCEDURE PickMessageHandler@61(Message@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(STRPOS(Message,MSG_PICK_ACT_CREATED) > 0,PADSTR('Unexpected message: ' + Message,1024));
    END;

    LOCAL PROCEDURE PostingPartialIT@124(Location@1001 : Record 14;WhseActivity@1002 : Option;ExpectedErrorMessage@1000 : Text[1024];AssignITBeforeWhseAct@1005 : Boolean;AssignITOnWhseAct@1008 : Boolean);
    VAR
      AssemblyHeader@1019 : Record 900;
    BEGIN
      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,100);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,TRUE,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,TRUE,FALSE,'-');
      END;

      CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,TRUE,ExpectedErrorMessage);
    END;

    LOCAL PROCEDURE Post2Steps@122(Location@1000 : Record 14;WhseActivity@1002 : Option;AssignITBeforeWhseAct@1005 : Boolean;AssignITOnWhseAct@1006 : Boolean);
    VAR
      AssemblyHeader@1003 : Record 900;
      AssemblyLine@1007 : Record 901;
      TempAssemblyLine2@1008 : TEMPORARY Record 901;
      WhseActivityLine@1009 : Record 5767;
      WhseActivityHeader@1011 : Record 5766;
      ReleaseAssemblyDoc@1004 : Codeunit 903;
      AssemblyHeaderNo@1010 : Code[20];
      HeaderQtyFactor@1001 : Decimal;
    BEGIN
      HeaderQtyFactor := LibraryRandom.RandIntInRange(50,60);

      AssemblyHeaderNo := NormalPostingIT(Location,HeaderQtyFactor,0,WhseActivity,'',AssignITBeforeWhseAct,AssignITOnWhseAct,FALSE);

      // Post rest of the asembly order
      AssemblyHeader.RESET;
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationTakeBinCode);

      ReleaseAssemblyDoc.Reopen(AssemblyHeader);

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");

      AssemblyLine.FINDSET;
      REPEAT
        IF AssemblyLine."Quantity to Consume" > 0 THEN BEGIN
          AssemblyLine.VALIDATE("Quantity to Consume",1);
          AssemblyLine.MODIFY(TRUE);
          TempAssemblyLine2 := AssemblyLine;
          TempAssemblyLine2.INSERT
        END;
      UNTIL (AssemblyLine.NEXT = 0);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      IF AssignITBeforeWhseAct THEN BEGIN
        WhseActivityLine.SETRANGE("Source Type",DATABASE::"Assembly Line");
        WhseActivityLine.SETRANGE("Source Subtype",AssemblyHeader."Document Type");
        WhseActivityLine.SETRANGE("Source No.",AssemblyHeader."No.");
        IF WhseActivityLine.FINDSET THEN
          REPEAT
            IF WhseActivityHeader.GET(WhseActivityLine."Activity Type",WhseActivityLine."No.") THEN
              WhseActivityHeader.DELETE(TRUE);
          UNTIL WhseActivityLine.NEXT = 0;

        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,FALSE,TRUE,'+')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,FALSE,FALSE,'+');

        IF NOT AssemblyHeader.CompletelyPicked THEN
          CreateAndRegisterWhseActivity(AssemblyHeaderNo,WhseActivity,AssignITOnWhseAct,FALSE,'');
      END ELSE BEGIN
        WhseActivityLine.SETRANGE("Source Type",DATABASE::"Assembly Line");
        WhseActivityLine.SETRANGE("Source Subtype",AssemblyHeader."Document Type");
        WhseActivityLine.SETRANGE("Source No.",AssemblyHeader."No.");
        IF WhseActivityLine.FINDFIRST THEN BEGIN
          WhseActivityHeader.GET(WhseActivityLine."Activity Type",WhseActivityLine."No.");

          IF AssignITOnWhseAct THEN
            AssignITWhseActivity(AssemblyHeader,WhseActivityHeader,FALSE);

          LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);
        END;
      END;

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
    END;

    LOCAL PROCEDURE PurchaseComponentsToBin@120(AssemblyHeader@1000 : Record 900;QtySupplement@1001 : Decimal;Location@1007 : Record 14;BinCode@1006 : Code[20]);
    VAR
      AssemblyLine@1003 : Record 901;
      PurchaseHeader@1002 : Record 38;
    BEGIN
      CreatePurchaseHeader(Location.Code,PurchaseHeader);

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      IF AssemblyLine.FINDSET THEN
        REPEAT
          CreatePurchaseLine(PurchaseHeader,AssemblyLine."No.",Location,BinCode,
            ROUND(AssemblyLine.Quantity + QtySupplement,1,'>'));
        UNTIL AssemblyLine.NEXT = 0;

      PostPurchaseHeader(PurchaseHeader,Location,'');
    END;

    LOCAL PROCEDURE PurchaseComponentsNotEnough@118(Location@1012 : Record 14;AssemblyHeader@1001 : Record 900;NotEnoughNo@1003 : Integer;VAR NotEnoughItemNo@1006 : Code[20];CompQtyFactor@1007 : Integer;VAR ResultQtys@1004 : ARRAY [10] OF Decimal;AddAdditionalQty@1009 : Boolean;BinToPutCode@1000 : Code[20]);
    VAR
      Item@1002 : Record 27;
      AssemblyLine@1010 : Record 901;
      PurchaseHeader@1011 : Record 38;
      i@1005 : Integer;
      ItemsCount@1008 : Integer;
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.FINDSET;

      // Calculate result quantities
      i := 1;
      REPEAT
        ResultQtys[i] := AssemblyLine.Quantity * CompQtyFactor / 100;
        IF i = NotEnoughNo THEN BEGIN
          Item.GET(AssemblyLine."No.");
          NotEnoughItemNo := Item."No.";
          ResultQtys[i] := ROUND(ResultQtys[i],1,'>');
          ResultQtys[i] -= 2;
          ItemsCount := AssemblyLine.COUNT + 1;
          ResultQtys[ItemsCount] := 2;
        END ELSE
          ResultQtys[i] := ROUND(ResultQtys[i],1,'>');

        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add inventory
      CreatePurchaseHeader(Location.Code,PurchaseHeader);

      i := 1;
      AssemblyLine.FINDSET;
      REPEAT
        CreatePurchaseLine(PurchaseHeader,AssemblyLine."No.",Location,BinToPutCode,ResultQtys[i]);
        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add rest inventory to additional bin
      IF AddAdditionalQty THEN BEGIN
        AssemblyLine.RESET;
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
        AssemblyLine.SETRANGE("No.",NotEnoughItemNo);
        AssemblyLine.FINDFIRST;

        CreatePurchaseLine(PurchaseHeader,AssemblyLine."No.",
          Location,LocationAdditionalBinCode,ResultQtys[ItemsCount]);
        PostPurchaseHeader(PurchaseHeader,Location,NotEnoughItemNo);
      END ELSE
        PostPurchaseHeader(PurchaseHeader,Location,'');
    END;

    [Normal]
    LOCAL PROCEDURE CreateAssemblyOrder@110(Location@1000 : Record 14;Qty@1002 : Integer;VAR AssemblyHeader@1001 : Record 900);
    BEGIN
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WorkDate2,KitItem."No.",Location.Code,Qty,'');

      CreateAssemblyLine(AssemblyHeader,CompItem."No.",LibraryRandom.RandIntInRange(2,4),FALSE,FALSE);
    END;

    LOCAL PROCEDURE CreateAssemblyLine@108(VAR AssemblyHeader@1000 : Record 900;ItemNo@1002 : Code[20];Quantity@1003 : Integer;AssignBinCode@1004 : Boolean;AssignIT@1005 : Boolean);
    VAR
      AssemblyLine@1001 : Record 901;
      AssemblyOrderPage@1006 : TestPage 900;
    BEGIN
      LibraryKitting.AddLine(AssemblyHeader,AssemblyLine.Type::Item,ItemNo,
        LibraryAssembly.GetUnitOfMeasureCode(AssemblyLine.Type::Item,ItemNo,TRUE),
        Quantity,1,'');

      IF AssignBinCode THEN BEGIN
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE("No.",ItemNo);
        AssemblyLine.FINDLAST;

        AssemblyLine.VALIDATE("Bin Code",LocationAdditionalBinCode);
        AssemblyLine.VALIDATE("Quantity to Consume",Quantity);
        AssemblyLine.MODIFY;
      END;

      IF AssignIT THEN BEGIN
        AssemblyOrderPage.OPENEDIT;
        AssemblyOrderPage.FILTER.SETFILTER("No.",AssemblyHeader."No.");

        AssemblyOrderPage.Lines.LAST;

        PrepareHandleSelectEntries(FALSE);
        AssemblyOrderPage.Lines."Item Tracking Lines".INVOKE;
        AssemblyOrderPage.OK.INVOKE;
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CreateItems@107(ItemTracking@1000 : Option);
    BEGIN
      CreateTrackedItem(CompItem,ItemTracking);
      CreateTrackedItem(KitItem,Tracking::Untracked);
    END;

    LOCAL PROCEDURE CreateTrackedItem@106(VAR Item@1000 : Record 27;TrackingType@1001 : Option);
    VAR
      Serial@1003 : Boolean;
      Lot@1002 : Boolean;
    BEGIN
      LibraryInventory.CreateItem(Item);
      IF TrackingType <> Tracking::Untracked THEN BEGIN
        Lot := (TrackingType = Tracking::Lot) OR (TrackingType = Tracking::LotSerial);
        Serial := (TrackingType = Tracking::Serial) OR (TrackingType = Tracking::LotSerial);
        AssignItemTrackingCode(Item,Lot,Serial);
      END;
    END;

    LOCAL PROCEDURE CreateItemTrackingCode@105(VAR ItemTrackingCode@1000 : Record 6502;Lot@1001 : Boolean;Serial@1002 : Boolean);
    VAR
      LibraryUtility@1003 : Codeunit 131000;
    BEGIN
      IF NOT ItemTrackingCode.GET(Serial) THEN BEGIN
        ItemTrackingCode.INIT;
        ItemTrackingCode.VALIDATE(Code,
          LibraryUtility.GenerateRandomCode(ItemTrackingCode.FIELDNO(Code),DATABASE::"Item Tracking Code"));
        ItemTrackingCode.INSERT(TRUE);
        ItemTrackingCode.VALIDATE("SN Specific Tracking",Serial);
        ItemTrackingCode.VALIDATE("Lot Specific Tracking",Lot);
        ItemTrackingCode.VALIDATE("SN Warehouse Tracking",Serial);
        ItemTrackingCode.VALIDATE("Lot Warehouse Tracking",Lot);
        ItemTrackingCode.MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreatePickFromSalesOrder@10(SalesHeader@1002 : Record 36);
    VAR
      WarehouseShipmentLine@1000 : Record 7321;
      WarehouseShipmentHeader@1001 : Record 7320;
    BEGIN
      WarehouseShipmentLine.SETRANGE("Source Type",DATABASE::"Sales Line");
      WarehouseShipmentLine.SETRANGE("Source Subtype",SalesHeader."Document Type");
      WarehouseShipmentLine.SETRANGE("Source No.",SalesHeader."No.");
      WarehouseShipmentLine.FINDFIRST;
      WarehouseShipmentHeader.GET(WarehouseShipmentLine."No.");
      LibraryWarehouse.CreatePick(WarehouseShipmentHeader);
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchaseHeader@104(LocationCode@1001 : Code[10];VAR PurchaseHeader@1000 : Record 38);
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      PurchaseHeader.VALIDATE("Location Code",LocationCode);
      PurchaseHeader.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchaseLine@103(PurchaseHeader@1000 : Record 38;ItemNo@1002 : Code[20];Location@1003 : Record 14;BinCode@1004 : Code[20];Qty@1005 : Decimal);
    VAR
      PurchaseLine@1001 : Record 39;
    BEGIN
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Qty);
      PurchaseLine.VALIDATE("Location Code",Location.Code);
      IF NOT Location."Require Receive" THEN
        PurchaseLine.VALIDATE("Bin Code",BinCode);
      PurchaseLine.MODIFY(TRUE);

      AssignITToPurchLine(PurchaseHeader,PurchaseLine);
    END;

    [Normal]
    LOCAL PROCEDURE CreateAndRegisterWhseActivity@102(AssemblyHeaderNo@1000 : Code[20];WhseActivity@1007 : Option;AssignITOnWhseAct@1001 : Boolean;ITPartial@1002 : Boolean;ExpectedError@1004 : Text[1024]);
    VAR
      WhseActivityHeader@1006 : Record 5766;
      AssemblyHeader@1008 : Record 900;
    BEGIN
      IF WhseActivity = WhseActivityType::None THEN
        EXIT;

      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      CASE WhseActivity OF
        WhseActivityType::WhsePick:
          LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
        WhseActivityType::InvtMvmt:
          LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      END;

      AutoFillQtyWhseActivity(AssemblyHeader,WhseActivityHeader);

      IF AssignITOnWhseAct THEN
        AssignITWhseActivity(AssemblyHeader,WhseActivityHeader,ITPartial);

      IF ExpectedError = '' THEN BEGIN
        EmptyQtyToHandleForLinesWithoutIT(WhseActivityHeader);
        LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);
      END ELSE BEGIN
        COMMIT; // to save state before expected error
        ASSERTERROR LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);
        Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ExpectedError) > 0,
          'Expected:' + ExpectedError + '. Actual:' + GETLASTERRORTEXT);
        CLEARLASTERROR;
      END;
    END;

    LOCAL PROCEDURE EmptyQtyToHandleForLinesWithoutIT@17(WhseActivityHeader@1000 : Record 5766);
    VAR
      WhseActivityLine@1001 : Record 5767;
      Item@1003 : Record 27;
    BEGIN
      WITH WhseActivityLine DO BEGIN
        SETRANGE("Activity Type",WhseActivityHeader.Type);
        SETRANGE("No.",WhseActivityHeader."No.");
        SETRANGE("Serial No.",'');
        SETRANGE("Lot No.",'');
        SETFILTER("Qty. to Handle",'<>%1',0);
        IF FINDSET THEN
          REPEAT
            Item.GET("Item No.");
            IF Item."Item Tracking Code" <> '' THEN BEGIN
              VALIDATE("Qty. to Handle",0);
              MODIFY(TRUE);
            END;
          UNTIL NEXT = 0;
      END;
    END;

    [Normal]
    LOCAL PROCEDURE PrepareOrderPosting@100(VAR AssemblyHeader@1000 : Record 900;HeaderQtyFactor@1001 : Integer);
    VAR
      AssemblyLine@1002 : Record 901;
      ITType@1005 : Option;
    BEGIN
      AssemblyHeader.VALIDATE("Quantity to Assemble",AssemblyHeader."Quantity to Assemble" * HeaderQtyFactor / 100);
      AssemblyHeader.MODIFY(TRUE);

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);

      IF AssemblyLine.FINDSET THEN
        REPEAT
          GetItemIT(AssemblyLine."No.",ITType);
          IF (ITType = Tracking::Serial) OR (ITType = Tracking::LotSerial) THEN BEGIN
            AssemblyLine.VALIDATE("Quantity to Consume",ROUND(AssemblyLine."Quantity to Consume",1,'<'));
            AssemblyLine.MODIFY(TRUE)
          END;
        UNTIL (AssemblyLine.NEXT = 0);

      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);
    END;

    [Normal]
    LOCAL PROCEDURE PostPurchaseHeader@96(PurchaseHeader@1000 : Record 38;Location@1014 : Record 14;NotEnoughItemNo@1002 : Code[20]);
    VAR
      WarehouseReceiptHeader@1011 : Record 7316;
      WarehouseActivityHeader@1004 : Record 5766;
      WarehouseActivityLine@1003 : Record 5767;
      WhseReceiptLine@1001 : Record 7317;
      Bin@1005 : Record 7354;
      PurchaseHeaderNo@1012 : Code[20];
    BEGIN
      PurchaseHeaderNo := PurchaseHeader."No.";

      LibraryPurchase.ReleasePurchaseDocument(PurchaseHeader);
      IF Location."Require Receive" THEN BEGIN
        LibraryWarehouse.CreateWhseReceiptFromPO(PurchaseHeader);

        WhseReceiptLine.SETRANGE("Source Document",WhseReceiptLine."Source Document"::"Purchase Order");
        WhseReceiptLine.SETRANGE("Source No.",PurchaseHeader."No.");
        WhseReceiptLine.FINDFIRST;
        WarehouseReceiptHeader.GET(WhseReceiptLine."No.");
        LibraryWarehouse.PostWhseReceipt(WarehouseReceiptHeader);
      END;

      PurchaseHeader.RESET;
      PurchaseHeader.SETRANGE("No.",PurchaseHeaderNo);
      PurchaseHeader.FINDFIRST;
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      IF Location."Require Put-away" THEN BEGIN
        WarehouseActivityHeader.SETRANGE("Location Code",Location.Code);
        WarehouseActivityHeader.FINDFIRST;
        WarehouseActivityLine.SETRANGE("No.",WarehouseActivityHeader."No.");
        WarehouseActivityLine.FINDFIRST;

        WarehouseActivityLine.AutofillQtyToHandle(WarehouseActivityLine);

        LibraryWarehouse.FindBin(Bin,Location.Code,'PICK',4);
        WarehouseActivityLine.RESET;
        WarehouseActivityLine.SETRANGE("No.",WarehouseActivityHeader."No.");
        WarehouseActivityLine.SETRANGE("Action Type",WarehouseActivityLine."Action Type"::Place);
        IF WarehouseActivityLine.FINDSET THEN
          REPEAT
            WarehouseActivityLine.VALIDATE("Zone Code",'PICK');
            WarehouseActivityLine.VALIDATE("Bin Code",Bin.Code);
            WarehouseActivityLine.MODIFY(TRUE)
          UNTIL (WarehouseActivityLine.NEXT = 0);

        IF (LocationAdditionalPickBinCode <> '') AND (NotEnoughItemNo <> '') THEN BEGIN
          WarehouseActivityLine.RESET;
          WarehouseActivityLine.SETRANGE("No.",WarehouseActivityHeader."No.");
          WarehouseActivityLine.SETRANGE("Item No.",NotEnoughItemNo);
          WarehouseActivityLine.SETRANGE("Action Type",WarehouseActivityLine."Action Type"::Place);
          WarehouseActivityLine.FINDSET;

          WarehouseActivityLine.VALIDATE("Bin Code",LocationAdditionalPickBinCode);
          WarehouseActivityLine.MODIFY(TRUE);
          WarehouseActivityLine.NEXT;
          WarehouseActivityLine.VALIDATE("Bin Code",LocationAdditionalPickBinCode);
          WarehouseActivityLine.MODIFY(TRUE);
        END;

        LibraryWarehouse.RegisterWhseActivity(WarehouseActivityHeader);
      END;
    END;

    LOCAL PROCEDURE CreateWhseJournalLine@53(WarehouseJournalBatch@1000 : Record 7310;Bin@1002 : Record 7354;ItemNo@1003 : Code[20];Qty@1004 : Decimal;UomCode@1007 : Code[10]);
    VAR
      WarehouseJournalLine@1001 : Record 7311;
    BEGIN
      LibraryWarehouse.CreateWhseJournalLine(
        WarehouseJournalLine,WarehouseJournalBatch."Journal Template Name",WarehouseJournalBatch.Name,Bin."Location Code",
        Bin."Zone Code",Bin.Code,WarehouseJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Qty);
      WarehouseJournalLine.VALIDATE("Unit of Measure Code",UomCode);
      WarehouseJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE MoveNotEnoughItem@92(Location@1002 : Record 14;HeaderQtyFactor@1016 : Integer;WhseActivity@1000 : Option;ExpectedErrorMessage@1001 : Text[1024];AssignITBeforeWhseAct@1003 : Boolean;AssignITOnWhseAct@1006 : Boolean;QtyToAdd@1012 : Integer);
    VAR
      AssemblyHeader@1009 : Record 900;
      WhseActivityHeader@1013 : Record 5766;
    BEGIN
      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,FALSE,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,FALSE,FALSE,'-');
      END;

      // Create Whse Activity
      CASE WhseActivity OF
        WhseActivityType::WhsePick:
          LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
        WhseActivityType::InvtMvmt:
          LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      END;

      AutoFillQtyWhseActivity(AssemblyHeader,WhseActivityHeader);

      // Update Quantity to Handled of one of the items
      UpdateWhseActivityLineIT(WhseActivityHeader,CompItem."No.",QtyToAdd);

      IF AssignITOnWhseAct THEN
        AssignITWhseActivity(AssemblyHeader,WhseActivityHeader,FALSE);

      // Register whse activity
      EmptyQtyToHandleForLinesWithoutIT(WhseActivityHeader);
      LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);

      // Post assembly order
      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessage);
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      PrepareOrderPosting(AssemblyHeader,100);

      IF AssignITOnWhseAct THEN
        AssignITWhseActivity(AssemblyHeader,WhseActivityHeader,FALSE);

      // Register rest of the whse activity
      EmptyQtyToHandleForLinesWithoutIT(WhseActivityHeader);
      LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);

      // Post assembly order
      PostAssemblyHeader(AssemblyHeader."No.",'');
    END;

    [Normal]
    LOCAL PROCEDURE AutoFillQtyWhseActivity@89(AssemblyHeader@1000 : Record 900;VAR WhseActivityHeader@1003 : Record 5766);
    VAR
      WhseActivityLine@1002 : Record 5767;
    BEGIN
      WhseActivityHeader.RESET;
      WhseActivityHeader.SETRANGE("Location Code",AssemblyHeader."Location Code");
      WhseActivityHeader.FINDLAST;

      // Check that quantity is not autofilled
      IF WhseActivityHeader.Type <> WhseActivityHeader.Type::Pick THEN BEGIN
        WhseActivityLine.RESET;
        WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");

        REPEAT
          Assert.AreEqual(0,WhseActivityLine."Qty. to Handle",'Incorrect value');
        UNTIL WhseActivityLine.NEXT = 0;

        LibraryWarehouse.AutoFillQtyInventoryActivity(WhseActivityHeader);
      END;
    END;

    LOCAL PROCEDURE RecreateWhseActivity@87(Location@1000 : Record 14;WhseActivity@1002 : Option;AssignITBeforeWhseAct@1009 : Boolean;AssignITOnWhseAct@1007 : Boolean);
    VAR
      AssemblyHeader@1003 : Record 900;
      WhseActivityHdr@1008 : Record 5766;
      HeaderQtyFactor@1001 : Decimal;
    BEGIN
      HeaderQtyFactor := LibraryRandom.RandIntInRange(50,60);

      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,FALSE,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,FALSE,FALSE,'-');
      END;

      CASE WhseActivity OF
        WhseActivityType::WhsePick:
          LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
        WhseActivityType::InvtMvmt:
          LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      END;

      AutoFillQtyWhseActivity(AssemblyHeader,WhseActivityHdr);

      IF AssignITOnWhseAct THEN
        AssignITWhseActivity(AssemblyHeader,WhseActivityHdr,FALSE);

      WhseActivityHdr.DELETE(TRUE);

      CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,FALSE,'');

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
    END;

    LOCAL PROCEDURE AssignItemTrackingCode@86(VAR Item@1000 : Record 27;LotTracked@1001 : Boolean;SerialTracked@1002 : Boolean);
    VAR
      ItemTrackingCode@1003 : Record 6502;
      LibraryUtility@1004 : Codeunit 131000;
    BEGIN
      CreateItemTrackingCode(ItemTrackingCode,LotTracked,SerialTracked);

      Item.VALIDATE("Item Tracking Code",ItemTrackingCode.Code);

      Item.VALIDATE("Item Tracking Code",ItemTrackingCode.Code);
      Item.VALIDATE("Serial Nos.",LibraryUtility.GetGlobalNoSeriesCode);

      Item.VALIDATE("Lot Nos.",LibraryUtility.GetGlobalNoSeriesCode);

      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE NormalPostingIT@127(Location@1003 : Record 14;HeaderQtyFactor@1012 : Decimal;QtySupplement@1018 : Decimal;WhseActivity@1002 : Option;ExpectedErrorMessage@1000 : Text[1024];AssignITBeforeWhseAct@1005 : Boolean;AssignITOnWhseAct@1008 : Boolean;ITPartial@1001 : Boolean) : Code[20];
    VAR
      AssemblyHeader@1019 : Record 900;
    BEGIN
      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,QtySupplement,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,QtySupplement,Location,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,FALSE,'-');
      END;

      CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,ITPartial,'');

      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessage);

      EXIT(AssemblyHeader."No.");
    END;

    [Normal]
    LOCAL PROCEDURE GetItemIT@84(ItemNo@1000 : Code[20];VAR ITType@1003 : Option);
    VAR
      Item@1001 : Record 27;
      ItemTrackingCode@1002 : Record 6502;
    BEGIN
      Item.GET(ItemNo);

      IF Item."Item Tracking Code" = '' THEN
        EXIT;

      ItemTrackingCode.GET(Item."Item Tracking Code");

      ITType := Tracking::Untracked;

      IF ItemTrackingCode."Lot Specific Tracking" AND ItemTrackingCode."SN Specific Tracking" THEN
        ITType := Tracking::LotSerial
      ELSE
        IF (NOT ItemTrackingCode."Lot Specific Tracking") AND ItemTrackingCode."SN Specific Tracking" THEN
          ITType := Tracking::Serial
        ELSE
          IF ItemTrackingCode."Lot Specific Tracking" AND (NOT ItemTrackingCode."SN Specific Tracking") THEN
            ITType := Tracking::Lot;
    END;

    [Normal]
    LOCAL PROCEDURE PrepareHandleSelectEntries@83(ITPartial@1000 : Boolean);
    BEGIN
      GLB_ITPageHandler := GLB_ITPageHandler::SelectITSpec;
      PAR_ITPage_AssignPartial := ITPartial;
    END;

    [Normal]
    LOCAL PROCEDURE PrepareHandlePutManually@82(ItemNo@1001 : Code[20];ITType@1002 : Option;ITPartial@1000 : Boolean;Quantity@1003 : Decimal;FindDir@1004 : Code[10]);
    BEGIN
      GLB_ITPageHandler := GLB_ITPageHandler::PutManuallyITSpec;
      PAR_ITPage_AssignLot := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Lot);
      PAR_ITPage_AssignSerial := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Serial);
      PAR_ITPage_AssignPartial := ITPartial;
      PAR_ITPage_AssignQty := Quantity;
      PAR_ITPage_ITNo := ItemNo;
      PAR_ITPage_FINDDIR := FindDir;
    END;

    LOCAL PROCEDURE PrepareHandleAssignPartial@109(ITType@1001 : Option;Quantity@1000 : Decimal);
    BEGIN
      GLB_ITPageHandler := GLB_ITPageHandler::AssignITSpec;
      PAR_ITPage_AssignLot := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Lot);
      PAR_ITPage_AssignSerial := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Serial);
      PAR_ITPage_AssignPartial := TRUE;
      PAR_ITPage_AssignQty := Quantity;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage@80(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      CASE GLB_ITPageHandler OF
        GLB_ITPageHandler::AssignITSpec,GLB_ITPageHandler::AssignITSpecPartial:
          BEGIN
            IF PAR_ITPage_AssignSerial THEN
              HNDL_ITPage_AssignSerial(ItemTrackingLinesPage)
            ELSE
              IF PAR_ITPage_AssignLot THEN
                HNDL_ITPage_AssignLot(ItemTrackingLinesPage);
          END;
        GLB_ITPageHandler::SelectITSpec:
          HNDL_ITPage_SelectEntries(ItemTrackingLinesPage);
        GLB_ITPageHandler::PutManuallyITSpec:
          HNDL_ITPage_PutITManually(ItemTrackingLinesPage);
      END
    END;

    [ModalPageHandler]
    [HandlerFunctions(HNDL_EnterQty)]
    PROCEDURE HNDL_ITPage_AssignSerial@79(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      ItemTrackingLinesPage."Assign Serial No.".INVOKE;
      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage_AssignLot@77(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      ItemTrackingLinesPage."Assign Lot No.".INVOKE; // Assign Lot No.
      IF PAR_ITPage_AssignPartial THEN
        ItemTrackingLinesPage."Quantity (Base)".SETVALUE(PAR_ITPage_AssignQty);
      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage_SelectEntries@76(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      ItemTrackingLinesPage."Select Entries".INVOKE; // Select Entries
      IF PAR_ITPage_AssignPartial THEN BEGIN
        ItemTrackingLinesPage.LAST;
        ItemTrackingLinesPage."Quantity (Base)".SETVALUE(ItemTrackingLinesPage."Quantity (Base)".ASINTEGER - 1);
      END;

      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage_PutITManually@73(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    VAR
      ItemLedgerEntry@1001 : Record 32;
      TrackedQty@1003 : Integer;
    BEGIN
      ItemLedgerEntry.RESET;
      ItemLedgerEntry.SETRANGE("Item No.",PAR_ITPage_ITNo);
      ItemLedgerEntry.FIND(PAR_ITPage_FINDDIR);

      TrackedQty := ItemLedgerEntry.COUNT;

      IF (ItemLedgerEntry."Serial No." <> '') AND (PAR_ITPage_AssignQty < ItemLedgerEntry.COUNT) THEN
        TrackedQty := PAR_ITPage_AssignQty;

      IF PAR_ITPage_AssignPartial THEN
        TrackedQty -= 1;

      IF ItemTrackingLinesPage.LAST THEN
        ItemTrackingLinesPage.NEXT;

      WHILE TrackedQty > 0 DO BEGIN
        TrackedQty -= 1;

        IF STRLEN(ItemLedgerEntry."Serial No.") > 0 THEN
          ItemTrackingLinesPage."Serial No.".SETVALUE(ItemLedgerEntry."Serial No.");
        IF STRLEN(ItemLedgerEntry."Lot No.") > 0 THEN
          ItemTrackingLinesPage."Lot No.".SETVALUE(ItemLedgerEntry."Lot No.");

        IF PAR_ITPage_AssignQty < ItemLedgerEntry.Quantity THEN
          ItemTrackingLinesPage."Quantity (Base)".SETVALUE(PAR_ITPage_AssignQty)
        ELSE
          ItemTrackingLinesPage."Quantity (Base)".SETVALUE(ItemLedgerEntry.Quantity);
        IF ItemLedgerEntry.NEXT <> 0 THEN
          ItemTrackingLinesPage.NEXT;
      END;

      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_EnterQty@71(VAR EnterQuantityPage@1000 : TestPage 6513);
    BEGIN
      IF PAR_ITPage_AssignLot THEN
        EnterQuantityPage.CreateNewLotNo.VALUE := 'yes';
      IF PAR_ITPage_AssignPartial THEN
        EnterQuantityPage.QtyToCreate.SETVALUE(PAR_ITPage_AssignQty);
      EnterQuantityPage.OK.INVOKE;
    END;

    [MessageHandler]
    PROCEDURE PickMessageHandler1@361(Message@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(
        STRPOS(Message,MSG_PICK_ACT_CREATED) > 0,
        COPYSTR('Unexpected message ' + FORMAT(MsgCount) + ': ' + Message + '; Expected: ' + MSG_PICK_ACT_CREATED,1,1024));
    END;

    [MessageHandler]
    PROCEDURE PickMessageHandler2@58(Message@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(
        STRPOS(Message,MSG_PICK_ACT_CREATED) > 0,
        PADSTR('Unexpected message ' + FORMAT(MsgCount) + ': ' + Message + '; Expected: ' + MSG_PICK_ACT_CREATED,1024));
    END;

    LOCAL PROCEDURE AssignITToPurchLine@41(PurchaseHeader@1001 : Record 38;PurchaseLine@1000 : Record 39);
    VAR
      PurchaseOrderPage@1004 : TestPage 50;
      ITType@1002 : Option;
    BEGIN
      GetItemIT(PurchaseLine."No.",ITType);

      IF ITType = Tracking::Untracked THEN
        EXIT;

      PurchaseOrderPage.OPENEDIT;
      PurchaseOrderPage.FILTER.SETFILTER("No.",PurchaseHeader."No.");

      PurchaseOrderPage.PurchLines.LAST;

      PrepareHandleAssignPartial(ITType,PurchaseLine.Quantity);
      PurchaseOrderPage.PurchLines."Item Tracking Lines".INVOKE;

      PurchaseOrderPage.OK.INVOKE;
    END;

    LOCAL PROCEDURE AssignITToAssemblyLines@66(VAR AssemblyHeader@1000 : Record 900;ITPartial@1002 : Boolean;SelectEntries@1004 : Boolean;FindDir@1005 : Code[10]);
    VAR
      AssemblyLine@1001 : Record 901;
      AssemblyOrderPage@1003 : TestPage 900;
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.FINDSET;

      AssemblyOrderPage.OPENEDIT;
      AssemblyOrderPage.FILTER.SETFILTER("No.",AssemblyHeader."No.");

      REPEAT
        AssignITToAsmLine(AssemblyLine."No.",AssemblyLine."Quantity to Consume",ITPartial,SelectEntries,AssemblyOrderPage,FindDir);
      UNTIL AssemblyLine.NEXT = 0;

      AssemblyOrderPage.OK.INVOKE;
    END;

    LOCAL PROCEDURE AssignITToAsmLine@40(ItemNo@1002 : Code[20];Quantity@1006 : Decimal;ITPartial@1004 : Boolean;SelectEntries@1003 : Boolean;AssemblyOrderPage@1001 : TestPage 900;FindDir@1000 : Code[10]);
    VAR
      ITType@1005 : Option;
    BEGIN
      GetItemIT(ItemNo,ITType);

      IF ITType = Tracking::Untracked THEN
        EXIT;

      AssemblyOrderPage.Lines.FILTER.SETFILTER("No.",ItemNo);

      IF SelectEntries THEN
        PrepareHandleSelectEntries(ITPartial)
      ELSE
        PrepareHandlePutManually(ItemNo,ITType,ITPartial,Quantity,FindDir);

      AssemblyOrderPage.Lines."Item Tracking Lines".INVOKE;
    END;

    [Normal]
    LOCAL PROCEDURE AssignITWhseActivity@35(AssemblyHeader@1000 : Record 900;WhseActivityHeader@1001 : Record 5766;ITPartial@1002 : Boolean);
    VAR
      AssemblyLine@1003 : Record 901;
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);

      IF AssemblyLine.FINDSET THEN
        REPEAT
          AssingITWhseActivityLine(AssemblyLine."No.",WhseActivityHeader,ITPartial);
        UNTIL (AssemblyLine.NEXT = 0);
    END;

    LOCAL PROCEDURE AssingITWhseActivityLine@20(ItemNo@1001 : Code[20];WhseActivityHeader@1000 : Record 5766;ITPartial@1005 : Boolean);
    VAR
      WhseActivityLineTake@1002 : Record 5767;
      WhseActivityLinePlace@1003 : Record 5767;
      RegdWhseActivityHdr@1004 : Record 5772;
      RegdWhseActivityLine@1007 : Record 5773;
      TrackedQty@1006 : Integer;
    BEGIN
      RegdWhseActivityHdr.RESET;
      RegdWhseActivityHdr.SETRANGE("Location Code",WhseActivityHeader."Location Code");
      RegdWhseActivityHdr.SETRANGE(Type,RegdWhseActivityHdr.Type::"Put-away");
      RegdWhseActivityHdr.FINDLAST;

      RegdWhseActivityLine.RESET;
      RegdWhseActivityLine.SETRANGE("No.",RegdWhseActivityHdr."No.");
      RegdWhseActivityLine.SETRANGE("Action Type",RegdWhseActivityLine."Action Type"::Place);
      RegdWhseActivityLine.FINDSET;

      WhseActivityLineTake.RESET;
      WhseActivityLineTake.SETRANGE("No.",WhseActivityHeader."No.");
      WhseActivityLineTake.SETRANGE("Item No.",ItemNo);
      WhseActivityLineTake.SETRANGE("Serial No.",'');
      WhseActivityLineTake.SETRANGE("Lot No.",'');
      WhseActivityLineTake.SETRANGE("Action Type",WhseActivityLineTake."Action Type"::Take);

      TrackedQty := WhseActivityLineTake.COUNT;
      IF ITPartial THEN
        TrackedQty := WhseActivityLineTake.COUNT - 1;
      REPEAT
        IF TrackedQty = 0 THEN
          EXIT;

        TrackedQty -= 1;
        WhseActivityLineTake.RESET;
        WhseActivityLineTake.SETRANGE("No.",WhseActivityHeader."No.");
        WhseActivityLineTake.SETRANGE("Item No.",ItemNo);
        WhseActivityLineTake.SETRANGE("Serial No.",'');
        WhseActivityLineTake.SETRANGE("Lot No.",'');
        WhseActivityLineTake.SETRANGE("Action Type",WhseActivityLineTake."Action Type"::Take);
        WhseActivityLineTake.SETRANGE("Bin Code",RegdWhseActivityLine."Bin Code");
        IF NOT WhseActivityLineTake.FINDFIRST THEN
          EXIT; // in case of partial posting whse activity has less lines then in item ledger entries

        WhseActivityLinePlace.RESET;
        WhseActivityLinePlace.SETRANGE("No.",WhseActivityHeader."No.");
        WhseActivityLinePlace.SETRANGE("Item No.",ItemNo);
        WhseActivityLinePlace.SETRANGE("Serial No.",'');
        WhseActivityLinePlace.SETRANGE("Lot No.",'');
        WhseActivityLinePlace.SETRANGE("Action Type",WhseActivityLinePlace."Action Type"::Place);
        WhseActivityLinePlace.SETFILTER("Line No.",'>=' + FORMAT(WhseActivityLineTake."Line No."));
        WhseActivityLinePlace.FINDFIRST;

        WhseActivityLineTake.VALIDATE("Serial No.",RegdWhseActivityLine."Serial No.");
        WhseActivityLinePlace.VALIDATE("Serial No.",RegdWhseActivityLine."Serial No.");

        WhseActivityLineTake.VALIDATE("Lot No.",RegdWhseActivityLine."Lot No.");
        WhseActivityLinePlace.VALIDATE("Lot No.",RegdWhseActivityLine."Lot No.");

        WhseActivityLineTake.MODIFY(TRUE);
        WhseActivityLinePlace.MODIFY(TRUE);

      UNTIL RegdWhseActivityLine.NEXT = 0;
    END;

    LOCAL PROCEDURE FindPutAwayPickZone@28(VAR Zone@1000 : Record 7300;LocationCode@1001 : Code[10]);
    BEGIN
      Zone.SETRANGE("Location Code",LocationCode);
      Zone.SETRANGE("Bin Type Code",LibraryWarehouse.SelectBinType(FALSE,FALSE,TRUE,TRUE));
      Zone.SETRANGE("Cross-Dock Bin Zone",FALSE);
      Zone.FINDFIRST;
    END;

    [Normal]
    LOCAL PROCEDURE UpdateWhseActivityLineIT@128(WhseActivityHeader@1007 : Record 5766;ItemNoToUpdate@1000 : Code[20];QtyToAdd@1002 : Decimal);
    VAR
      WhseActivityLine@1003 : Record 5767;
      ChangedItemQty@1004 : Integer;
    BEGIN
      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");
      WhseActivityLine.SETRANGE("Item No.",ItemNoToUpdate);
      WhseActivityLine.SETRANGE("Action Type",WhseActivityLine."Action Type"::Place);
      WhseActivityLine.FINDFIRST;

      ChangedItemQty := ROUND(WhseActivityLine.Quantity,1,'<');
      ChangedItemQty += QtyToAdd;

      WhseActivityLine.VALIDATE("Qty. to Handle",ChangedItemQty);
      WhseActivityLine.MODIFY(TRUE);

      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");
      WhseActivityLine.SETRANGE("Item No.",ItemNoToUpdate);
      WhseActivityLine.SETRANGE("Action Type",WhseActivityLine."Action Type"::Take);
      WhseActivityLine.FINDFIRST;

      ChangedItemQty := ROUND(WhseActivityLine.Quantity,1,'<');
      ChangedItemQty += QtyToAdd;

      WhseActivityLine.VALIDATE("Qty. to Handle",ChangedItemQty);
      WhseActivityLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE NotEnoughItemPostingIT@65(Location@1003 : Record 14;HeaderQtyFactor@1012 : Decimal;PartialPostFactor@1011 : Decimal;AddAdditionalQty@1000 : Boolean;WhseActivity@1002 : Option;ExpectedErrorMessagePost@1004 : Text[1024];ExpectedErrorMessageReg@1007 : Text[1024];AssignITBeforeWhseAct@1006 : Boolean;AssignITOnWhseAct@1005 : Boolean;ITPartial@1001 : Boolean);
    VAR
      AssemblyHeader@1022 : Record 900;
      NotEnoughItemNo@1015 : Code[20];
      NotEnoughNo@1018 : Integer;
      Qtys@1017 : ARRAY [10] OF Decimal;
    BEGIN
      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      NotEnoughNo := 1;

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsNotEnough(
          Location,AssemblyHeader,NotEnoughNo,NotEnoughItemNo,PartialPostFactor,Qtys,AddAdditionalQty,LocationToBinCode)
      ELSE
        PurchaseComponentsNotEnough(
          Location,AssemblyHeader,NotEnoughNo,NotEnoughItemNo,PartialPostFactor,Qtys,AddAdditionalQty,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,FALSE,'-');
      END;

      CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,ITPartial,ExpectedErrorMessageReg);

      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessagePost);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSFullPost@97();
    BEGIN
      // TC-WMS
      Initialize;
      NormalPostingWMS(100,100,0);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSFullPartCompPost@88();
    BEGIN
      // TC-WMS
      Initialize;
      NormalPostingWMS(100,LibraryRandom.RandIntInRange(1,99),0);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSPartPost@944();
    BEGIN
      // TC-WMS
      Initialize;
      NormalPostingWMS(
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        0);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSFullPostQtySupplem@947();
    BEGIN
      // TC-WMS
      Initialize;
      NormalPostingWMS(100,100,LibraryRandom.RandIntInRange(1,10));
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSPartPostQtySupplem@946();
    BEGIN
      // TC-WMS
      Initialize;
      NormalPostingWMS(
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,10));
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSFullPost2Steps@949();
    VAR
      AssemblyHeader@1003 : Record 900;
      AssemblyLine@1007 : Record 901;
      TempAssemblyLine2@1008 : TEMPORARY Record 901;
      AssemblyHeaderNo@1010 : Code[20];
      HeaderQtyFactor@1001 : Decimal;
      PartialPostFactor@1000 : Decimal;
      AssembledQty@1009 : Decimal;
      FullAssembledQty@1011 : Decimal;
    BEGIN
      // TC-WMS
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesWMS;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,90);
      PartialPostFactor := HeaderQtyFactor;

      AssemblyHeaderNo := NormalPostingWMS(HeaderQtyFactor,PartialPostFactor,0);

      // Post rest of the asembly order
      AssemblyHeader.INIT;
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");

      AssemblyLine.FINDSET;
      REPEAT
        IF AssemblyLine."Quantity to Consume" > 0 THEN BEGIN
          TempAssemblyLine2 := AssemblyLine;
          TempAssemblyLine2.INSERT
        END;
      UNTIL (AssemblyLine.NEXT = 0);

      CreateWhsePickAndVerify(AssemblyHeaderNo,TempAssemblyLine2,1,'',0,0);

      AssembledQty := AssemblyHeader."Quantity to Assemble";
      FullAssembledQty := AssemblyHeader.Quantity;
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify.
      VerifyBinContentsMvmt(AssemblyHeader,TempAssemblyLine2,0,FullAssembledQty);

      TempAssemblyLine2.RESET;
      TempAssemblyLine2.SETRANGE(Type,TempAssemblyLine2.Type::Item);
      VerifyWarehouseEntries(AssemblyHeader,TempAssemblyLine2,AssembledQty,TRUE,2 * (TempAssemblyLine2.COUNT + 1));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE WMSPostNotRelease@924();
    VAR
      AssemblyHeader@1003 : Record 900;
      TempAssemblyLine@1004 : TEMPORARY Record 901;
      HeaderQtyFactor@1001 : Decimal;
      PartialPostFactor@1000 : Decimal;
    BEGIN
      // TC-WMS
      Initialize;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,100);
      PartialPostFactor := LibraryRandom.RandIntInRange(1,100);

      AssignBinCodesWMS;

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationWMS.Code,LibraryRandom.RandIntInRange(1,3));

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      ASSERTERROR LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,MSG_STATUS_MUST_BE_RELEASED) > 0,
        'Actual:' + GETLASTERRORTEXT + 'Expected:' + MSG_STATUS_MUST_BE_RELEASED);
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSCreateSame@929();
    VAR
      AssemblyHeader@1003 : Record 900;
      TempAssemblyLine@1004 : TEMPORARY Record 901;
      HeaderQtyFactor@1001 : Decimal;
      PartialPostFactor@1000 : Decimal;
    BEGIN
      // TC-WMS
      Initialize;
      AssignBinCodesWMS;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,100);
      PartialPostFactor := LibraryRandom.RandIntInRange(1,100);

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationWMS.Code,LibraryRandom.RandIntInRange(1,3));
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);
      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      CreateWhsePickAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,'',0,0);

      ASSERTERROR LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,MSG_NOTHING_TO_HANDLE) > 0,
        'Actual:' + GETLASTERRORTEXT + ',Expected:' + MSG_NOTHING_TO_HANDLE);
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSRecreate@910();
    VAR
      AssemblyHeader@1003 : Record 900;
      WhseActivityHdr@1008 : Record 5766;
      TempAssemblyLine@1004 : TEMPORARY Record 901;
      HeaderQtyFactor@1001 : Decimal;
      PartialPostFactor@1000 : Decimal;
      AssembledQty@1007 : Decimal;
    BEGIN
      // TC-WMS
      // Test creates whse pick, deletes it, creates a new one and verifies it
      Initialize;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,100);
      PartialPostFactor := LibraryRandom.RandIntInRange(1,100);

      AssignBinCodesWMS;

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationWMS.Code,LibraryRandom.RandIntInRange(1,3));

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);
      AssembledQty := AssemblyHeader."Quantity to Assemble";

      LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
      VerifyWhseActivity(AssemblyHeader,TempAssemblyLine,WhseActivityHdr,'',0,0);

      WhseActivityHdr.DELETE(TRUE);

      CreateWhsePickAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,'',0,0);

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify.
      VerifyBinContentsMvmt(AssemblyHeader,TempAssemblyLine,0,AssembledQty);
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      VerifyWarehouseEntries(AssemblyHeader,TempAssemblyLine,AssembledQty,TRUE,TempAssemblyLine.COUNT + 1);
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssembledQty);
      LibraryAssembly.VerifyItemRegister(AssemblyHeader);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSFullNotEnoughItemInBin@951();
    BEGIN
      // TC-WMS
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;

      NotEnoughItemPostingWMS(100,100,FALSE,MSG_CANNOT_POST_CONS);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSPartNotEnoughItemInBin@950();
    BEGIN
      // TC-WMS
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks that no error appears during partial posting
      Initialize;

      NotEnoughItemPostingWMS(
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        FALSE,MSG_CANNOT_POST_CONS);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSFullNotEnoughItemInInv@943();
    BEGIN
      // TC-WMS
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks no error appears during full posting
      Initialize;

      NotEnoughItemPostingWMS(100,100,TRUE,'');
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSPartNotEnoughItemInInv@95();
    BEGIN
      // TC-WMS
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during partial posting
      Initialize;

      NotEnoughItemPostingWMS(LibraryRandom.RandIntInRange(1,99),LibraryRandom.RandIntInRange(1,99),TRUE,'');
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSPartPostMoveNotEnItem@968();
    BEGIN
      // TC-WMS
      // There is enough item in inventory
      // Test creates inventory movement for partial posting, reduces one of the quantity, registeres whse pick and posts.
      // Then test checks whse pick for the rest of the qty, registeres whse pick and posts.
      Initialize;

      MoveNotEnoughItemWMS(LibraryRandom.RandIntInRange(1,100),
        LibraryRandom.RandIntInRange(1,100));
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSFullPostMoveNotEnItem@942();
    BEGIN
      // TC-WMS
      // There is enough item in inventory
      // Test creates whse pick for full posting, reduces one of the quantity, registeres whse pick and posts.
      // Then test checks whse pick for the rest of the qty, registeres whse pick and fully posts.
      Initialize;

      MoveNotEnoughItemWMS(LibraryRandom.RandIntInRange(1,100),
        LibraryRandom.RandIntInRange(1,100));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE WMSPostNoWhsePick@993();
    VAR
      AssemblyHeader@1004 : Record 900;
      TempAssemblyLine@1005 : TEMPORARY Record 901;
      HeaderQtyFactor@1003 : Decimal;
      PartialPostFactor@1002 : Decimal;
      NoOfItems@1001 : Integer;
    BEGIN
      // TC-WMS
      Initialize;
      AssignBinCodesWMS;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,100);
      PartialPostFactor := LibraryRandom.RandIntInRange(1,100);

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationWMS.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,LibraryRandom.RandIntInRange(1,9),
        AssemblyHeader."Location Code",LocationToBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      PostAssemblyHeader(AssemblyHeader."No.",MSG_CANNOT_POST_CONS);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSReuseFromAnotherOrder@974();
    VAR
      TempAssemblyLine@1013 : TEMPORARY Record 901;
      TempAssemblyLine2@1018 : TEMPORARY Record 901;
      AssemblyHeader2@1019 : Record 900;
      AssemblyHeader@1011 : Record 900;
      ReleaseAssemblyDoc@1004 : Codeunit 903;
      NoOfItems@1006 : Integer;
      HeaderQtyFactor@1015 : Decimal;
      PartialPostFactor@1014 : Decimal;
      AssemblyItemNo@1016 : Code[20];
    BEGIN
      // TC-WMS
      // Test checks that whse pick created for one assembly order can be reused for another
      Initialize;
      AssignBinCodesWMS;

      HeaderQtyFactor := 100;
      PartialPostFactor := 100;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationWMS.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,LibraryRandom.RandIntInRange(1,5),
        AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      CreateWhsePickAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,'',0,0);

      ReleaseAssemblyDoc.Reopen(AssemblyHeader);

      HeaderQtyFactor := 10;
      PartialPostFactor := 10;
      AssemblyHeader.VALIDATE("Quantity to Assemble",AssemblyHeader."Quantity to Assemble" * HeaderQtyFactor / 100);
      AssemblyItemNo := AssemblyHeader."Item No.";

      // Post asssembly order
      PostAssemblyHeader(AssemblyHeader."No.",'');

      // Create another assembly order
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader2,WorkDate2,AssemblyItemNo,LocationWMS.Code,ROUND(AssemblyHeader.Quantity * (100 - HeaderQtyFactor) / 100,1,'<'),
        '');
      LibraryAssembly.PrepareOrderPosting(AssemblyHeader2,TempAssemblyLine2,100,100,TRUE,WorkDate2);

      // Post assembly order
      PostAssemblyHeader(AssemblyHeader2."No.",MSG_CANNOT_POST_CONS);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE WMSCreateMoreThenQtyOutst@985();
    VAR
      TempAssemblyLine@1013 : TEMPORARY Record 901;
      AssemblyHeader@1011 : Record 900;
      WhseActivityHeader@1002 : Record 5766;
      WhseActivityLine@1001 : Record 5767;
      NoOfItems@1006 : Integer;
      QtySupplement@1003 : Integer;
      HeaderQtyFactor@1015 : Decimal;
      PartialPostFactor@1014 : Decimal;
    BEGIN
      // TC-WMS
      Initialize;
      AssignBinCodesWMS;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,100);
      PartialPostFactor := LibraryRandom.RandIntInRange(1,100);
      QtySupplement := LibraryRandom.RandIntInRange(5000,10000);

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationWMS.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,QtySupplement,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      // Create whse pick and Verify
      LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
      VerifyWhseActivity(AssemblyHeader,TempAssemblyLine,WhseActivityHeader,'',0,0);

      // Increase Quantity to Handled of one of the items
      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");

      WhseActivityLine.FINDFIRST;
      ASSERTERROR WhseActivityLine.VALIDATE("Qty. to Handle",QtySupplement);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,MSG_QTY_OUTST) > 0,
        'Actual:' + GETLASTERRORTEXT + ',Expected:' + MSG_QTY_OUTST);
      CLEARLASTERROR;
    END;

    [ModalPageHandler]
    PROCEDURE AvailabilityWindowHandler@9(VAR AsmAvailability@1000 : Page 908;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::Yes; // always confirm
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSFullPost@143();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationWMS,100,0,WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSPartPost@142();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),0,WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSFullPostQtySupplem@141();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationWMS,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSPartPostQtySupplem@140();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSFullPost2Steps@139();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      Post2Steps(LocationWMS,WhseActivityType::WhsePick,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler2)]
    PROCEDURE ITWMSRecreate@137();
    BEGIN
      // Test creates whse pick, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      RecreateWhseActivity(LocationWMS,WhseActivityType::WhsePick,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSFullNotEnoughItemInBin@136();
    BEGIN
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NotEnoughItemPostingIT(LocationWMS,100,100,TRUE,WhseActivityType::WhsePick,'','',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSFullNotEnoughItemInInv@134();
    BEGIN
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NotEnoughItemPostingIT(LocationWMS,100,100,FALSE,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSPartPostMoveNotEnL@133();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for partial posting, reduces one of the quantity, registeres whse pick and posts.
      // Then test checks whse pick for the rest of the qty, registeres whse pick and posts.
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      MoveNotEnoughItem(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        WhseActivityType::WhsePick,'',FALSE,TRUE,-1); // no error as more than required quantity has been registered on pick
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullPostMoveNotEnL@132();
    BEGIN
      // There is enough item in inventory
      // Test creates whse pick for full posting, reduces one of the quantity, registeres whse pick and posts.
      // Then test checks whse pick for the rest of the qty, registeres whse pick and fully posts.
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      MoveNotEnoughItem(LocationWMS,100,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,FALSE,TRUE,-1);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSPartPostMoveNotEnLS@131();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for partial posting, reduces one of the quantity, registeres whse pick and posts.
      // Then test checks whse pick for the rest of the qty, registeres whse pick and posts.
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      MoveNotEnoughItem(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        WhseActivityType::WhsePick,'',FALSE,TRUE,-1); // no error as more than required quantity has been registered on pick
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostMoveNotEnLS@130();
    BEGIN
      // There is enough item in inventory
      // Test creates whse pick for full posting, reduces one of the quantity, registeres whse pick and posts.
      // Then test checks whse pick for the rest of the qty, registeres whse pick and fully posts.
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      MoveNotEnoughItem(LocationWMS,100,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,FALSE,TRUE,-1);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSFullPostAO@129();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationWMS,100,0,WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSPartPostAO@126();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),0,WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSFullPostQtySupplemAO@123();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationWMS,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSPartPostQtySupplemAO@116();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSFullPost2StepsAO@115();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      Post2Steps(LocationWMS,WhseActivityType::WhsePick,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler2)]
    PROCEDURE ITWMSRecreateAO@114();
    BEGIN
      // Test creates whse pick, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      RecreateWhseActivity(LocationWMS,WhseActivityType::WhsePick,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSFullNotEnoughItemInBinAO@113();
    BEGIN
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NotEnoughItemPostingIT(LocationWMS,100,100,TRUE,WhseActivityType::WhsePick,'','',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1)]
    PROCEDURE ITWMSFullNotEnoughItemInInvAO@112();
    BEGIN
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Untracked);

      NotEnoughItemPostingIT(LocationWMS,100,100,FALSE,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSPartPostMoveNotEnAOL@111();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for partial posting, reduces one of the quantity, registeres whse pick and posts.
      // Then test checks whse pick for the rest of the qty, registeres whse pick and posts.
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      MoveNotEnoughItem(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        WhseActivityType::WhsePick,'',FALSE,TRUE,-1); // no error as more than required quantity has been registered on pick
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullPostMoveNotEnAOL@98();
    BEGIN
      // There is enough item in inventory
      // Test creates whse pick for full posting, reduces one of the quantity, registeres whse pick and posts.
      // Then test checks whse pick for the rest of the qty, registeres whse pick and fully posts.
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      MoveNotEnoughItem(LocationWMS,100,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,TRUE,FALSE,-1);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSPartPostMoveNotEnAOLS@90();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for partial posting, reduces one of the quantity, registeres whse pick and posts.
      // Then test checks whse pick for the rest of the qty, registeres whse pick and posts.
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      MoveNotEnoughItem(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,TRUE,FALSE,-1);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostMoveNotEnAOLS@91();
    BEGIN
      // There is enough item in inventory
      // Test creates whse pick for full posting, reduces one of the quantity, registeres whse pick and posts.
      // Then test checks whse pick for the rest of the qty, registeres whse pick and fully posts.
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      MoveNotEnoughItem(LocationWMS,100,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,TRUE,FALSE,-1);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostS@229();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationWMS,100,0,WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSPartPostS@228();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),0,WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostQtySupplemS@227();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationWMS,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSPartPostQtySupplemS@226();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPost2StepsS@225();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      Post2Steps(LocationWMS,WhseActivityType::WhsePick,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler2,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSRecreateS@224();
    BEGIN
      // Test creates whse pick, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      RecreateWhseActivity(LocationWMS,WhseActivityType::WhsePick,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullNotEnoughItemInBinS@223();
    BEGIN
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks no error appears during full posting
      Initialize;

      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NotEnoughItemPostingIT(LocationWMS,100,100,TRUE,WhseActivityType::WhsePick,'','',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullNotEnoughItemInInvS@222();
    BEGIN
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NotEnoughItemPostingIT(LocationWMS,100,100,FALSE,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostPartITS@217();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      PostingPartialIT(LocationWMS,WhseActivityType::WhsePick,MSG_SER_NO_MUST,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostAOS@216();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationWMS,100,0,WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSPartPostAOS@215();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),0,WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostQtySupplemAOS@214();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationWMS,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSPartPostQtySupplemAOS@213();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPost2StepsAOS@212();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      Post2Steps(LocationWMS,WhseActivityType::WhsePick,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler2,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSRecreateAOS@211();
    BEGIN
      // Test creates whse pick, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      RecreateWhseActivity(LocationWMS,WhseActivityType::WhsePick,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullNotEnoughItemInBinAOS@210();
    BEGIN
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NotEnoughItemPostingIT(LocationWMS,100,100,TRUE,WhseActivityType::WhsePick,'','',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullNotEnoughItemInInvAOS@209();
    BEGIN
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      NotEnoughItemPostingIT(LocationWMS,100,100,FALSE,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostPartITAOS@204();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Serial);

      PostingPartialIT(LocationWMS,WhseActivityType::WhsePick,MSG_SER_NO_MUST,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullPostL@247();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationWMS,100,0,WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSPartPostL@246();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),0,WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullPostQtySupplemL@245();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationWMS,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSPartPostQtySupplemL@244();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullPost2StepsL@243();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      Post2Steps(LocationWMS,WhseActivityType::WhsePick,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler2,HNDL_ITPage)]
    PROCEDURE ITWMSRecreateL@242();
    BEGIN
      // Test creates whse pick, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      RecreateWhseActivity(LocationWMS,WhseActivityType::WhsePick,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullNotEnoughItemInInvL@240();
    BEGIN
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NotEnoughItemPostingIT(LocationWMS,100,100,FALSE,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullPostPartITL@239();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      PostingPartialIT(LocationWMS,WhseActivityType::WhsePick,MSG_LOT_NO_MUST,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullPostAOL@238();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationWMS,100,0,WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSPartPostAOL@237();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),0,WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullPostQtySupplemAOL@236();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationWMS,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSPartPostQtySupplemAOL@235();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullPost2StepsAOL@234();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      Post2Steps(LocationWMS,WhseActivityType::WhsePick,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler2,HNDL_ITPage)]
    PROCEDURE ITWMSRecreateAOL@233();
    BEGIN
      // Test creates whse pick, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      RecreateWhseActivity(LocationWMS,WhseActivityType::WhsePick,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullNotEnoughItemInBinAOL@232();
    BEGIN
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NotEnoughItemPostingIT(LocationWMS,100,100,TRUE,WhseActivityType::WhsePick,'','',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullNotEnoughItemInInvAOL@231();
    BEGIN
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      NotEnoughItemPostingIT(LocationWMS,100,100,FALSE,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage)]
    PROCEDURE ITWMSFullPostPartITAOL@230();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::Lot);

      PostingPartialIT(LocationWMS,WhseActivityType::WhsePick,MSG_LOT_NO_MUST,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostLS@265();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationWMS,100,0,WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSPartPostLS@264();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),0,WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostQtySupplemLS@263();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationWMS,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSPartPostQtySupplemLS@262();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPost2StepsLS@261();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      Post2Steps(LocationWMS,WhseActivityType::WhsePick,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler2,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSRecreateLS@260();
    BEGIN
      // Test creates whse pick, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      RecreateWhseActivity(LocationWMS,WhseActivityType::WhsePick,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullNotEnoughItemInBinLS@259();
    BEGIN
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks no error appears during full posting
      Initialize;

      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NotEnoughItemPostingIT(LocationWMS,100,100,TRUE,WhseActivityType::WhsePick,'','',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullNotEnoughItemInInvLS@258();
    BEGIN
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NotEnoughItemPostingIT(LocationWMS,100,100,FALSE,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostPartITLS@257();
    BEGIN
      Initialize;

      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      PostingPartialIT(LocationWMS,WhseActivityType::WhsePick,MSG_SER_NO_MUST,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostAOLS@256();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationWMS,100,0,WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSPartPostAOLS@255();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),0,WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostQtySupplemAOLS@254();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationWMS,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSPartPostQtySupplemAOLS@253();
    BEGIN
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationWMS,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::WhsePick,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPost2StepsAOLS@252();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      Post2Steps(LocationWMS,WhseActivityType::WhsePick,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler2,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSRecreateAOLS@251();
    BEGIN
      // Test creates whse pick, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      RecreateWhseActivity(LocationWMS,WhseActivityType::WhsePick,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullNotEnoughItemInBinAOLS@250();
    BEGIN
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NotEnoughItemPostingIT(LocationWMS,100,100,TRUE,WhseActivityType::WhsePick,'','',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullNotEnoughItemInInvAOLS@249();
    BEGIN
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      NotEnoughItemPostingIT(LocationWMS,100,100,FALSE,WhseActivityType::WhsePick,MSG_CANNOT_POST_CONS,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(PickMessageHandler1,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITWMSFullPostPartITAOLS@248();
    BEGIN
      Initialize;

      AssignBinCodesWMS;
      CreateItems(Tracking::LotSerial);

      PostingPartialIT(LocationWMS,WhseActivityType::WhsePick,MSG_SER_NO_MUST,TRUE,FALSE);
    END;

    [Test]
    PROCEDURE NoZeroPickLinesWithAvailableBinContentAssigned@1();
    VAR
      ItemUnitOfMeasure@1001 : Record 5404;
      WarehouseJournalTemplate@1004 : Record 7309;
      WarehouseJournalBatch@1005 : Record 7310;
      Bin@1007 : Record 7354;
      Zone@1008 : Record 7300;
      SalesHeader@1012 : Record 36;
      SalesLine@1013 : Record 37;
      BOMComponent@1017 : Record 90;
      WarehouseActivityLine@1002 : Record 5767;
      QtyPerUoM@1003 : Integer;
      QtyToConsume@1000 : Integer;
      QtyToSell@1009 : Integer;
    BEGIN
      // [FEATURE] [Pick]
      // [SCENARIO 207772] Pick line with Quantity = 0 is not created when first available bin content is assigned to the same warehouse pick

      Initialize;

      // [GIVEN] Item "C" is an assembly component for item "P", qty. required to assembly one item "I" is 200
      // [GIVEN] Component item "C" has an additional unit of measure "BOX", base UoM is "PCS", qty. per unit of measure is 200
      CreateItems(Tracking::Untracked);
      QtyPerUoM := LibraryRandom.RandIntInRange(100,200);
      QtyToConsume := LibraryRandom.RandInt(5);
      QtyToSell := LibraryRandom.RandIntInRange(6,10);
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,CompItem."No.",QtyPerUoM);
      LibraryManufacturing.CreateBOMComponent(
        BOMComponent,KitItem."No.",BOMComponent.Type::Item,CompItem."No.",QtyPerUoM,CompItem."Base Unit of Measure");

      // [GIVEN] Purchase and put-away 1 box of component item "C" into a bin "B2"
      FindPutAwayPickZone(Zone,LocationWMS.Code);
      LibraryAssembly.SetupWarehouseJournal(WarehouseJournalTemplate,WarehouseJournalBatch,LocationWMS.Code);
      LibraryWarehouse.FindBin(Bin,LocationWMS.Code,Zone.Code,2);
      CreateWhseJournalLine(WarehouseJournalBatch,Bin,CompItem."No.",QtyToConsume,ItemUnitOfMeasure.Code);
      // [GIVEN] Purchase and put-away 3 boxes of component item "C" into a bin "B1"
      LibraryWarehouse.FindBin(Bin,LocationWMS.Code,Zone.Code,1);
      CreateWhseJournalLine(WarehouseJournalBatch,Bin,CompItem."No.",QtyToSell,ItemUnitOfMeasure.Code);

      LibraryWarehouse.RegisterWhseJournalLine(
        WarehouseJournalBatch."Journal Template Name",WarehouseJournalBatch.Name,LocationWMS.Code,TRUE);
      LibraryWarehouse.PostWhseAdjustment(CompItem);

      // [GIVEN] Create a sales order with 2 lines
      // [GIVEN] 1st line - 1 item "P" which requires 1 box of components to assemble
      // [GIVEN] 2nd line - 2 boxes of item "C"
      LibrarySales.CreateSalesDocumentWithItem(
        SalesHeader,SalesLine,SalesHeader."Document Type"::Order,LibrarySales.CreateCustomerNo,KitItem."No.",QtyToConsume,
        LocationWMS.Code,WorkDate2);
      SalesLine.VALIDATE("Qty. to Assemble to Order",SalesLine.Quantity);
      SalesLine.MODIFY(TRUE);

      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,CompItem."No.",QtyToSell);
      SalesLine.VALIDATE("Unit of Measure Code",ItemUnitOfMeasure.Code);
      SalesLine.MODIFY(TRUE);

      LibrarySales.ReleaseSalesDocument(SalesHeader);
      LibraryWarehouse.CreateWhseShipmentFromSO(SalesHeader);

      // [WHEN] Create warehouse shipment and pick from the sales order
      CreatePickFromSalesOrder(SalesHeader);

      // [THEN] Total quantity to pick for item "C" is 4 boxes
      // [THEN] There are no pick lines with Quantity = 0
      WarehouseActivityLine.SETRANGE("Item No.",CompItem."No.");
      WarehouseActivityLine.SETRANGE("Action Type",WarehouseActivityLine."Action Type"::Take);
      WarehouseActivityLine.SETRANGE("Unit of Measure Code",ItemUnitOfMeasure.Code);
      WarehouseActivityLine.SETRANGE(Quantity,0);
      Assert.RecordIsEmpty(WarehouseActivityLine);

      WarehouseActivityLine.SETRANGE(Quantity);
      WarehouseActivityLine.CALCSUMS(Quantity);
      WarehouseActivityLine.TESTFIELD(Quantity,QtyToConsume + QtyToSell);
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [Assemble-to-Stock] [Warehouse] [Item Tracking] [SCM]
      This CU is for deliverables "Kitting D07A - Assemble-to-Stock in Warehousing, as per the following" and " Kitting - Warehouse Item Tracking"
       BINPOST,IMVMT,WMS story codes.
    }
    END.
  }
}

