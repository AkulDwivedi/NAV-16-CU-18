OBJECT Codeunit 137296 SCM Inventory Misc. IV
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      Assert@1006 : Codeunit 130000;
      LibraryCosting@1007 : Codeunit 132200;
      LibraryERM@1004 : Codeunit 131300;
      LibraryInventory@1003 : Codeunit 132201;
      LibraryManufacturing@1015 : Codeunit 132202;
      LibraryPurchase@1005 : Codeunit 130512;
      LibraryPlanning@1002 : Codeunit 132203;
      LibrarySales@1018 : Codeunit 130509;
      LibraryService@1036 : Codeunit 131902;
      LibraryJob@1016 : Codeunit 131920;
      LibraryWarehouse@1013 : Codeunit 132204;
      LibraryVariableStorage@1010 : Codeunit 131004;
      LibraryRandom@1001 : Codeunit 130440;
      LibraryUtility@1011 : Codeunit 131000;
      isInitialized@1000 : Boolean;
      AmountError@1012 : TextConst 'ENU=Amount must be equal.';
      ItemVariantExistError@1033 : TextConst 'ENU="The Item Variant does not exist. Identification fields and values: Item No.=''%1'',Code=''%2''"';
      ItemVariantError@1034 : TextConst 'ENU=You cannot delete item variant %1 because there is at least one %2 that includes this Variant Code.';
      UpdateAutomaticCostMessage@1035 : TextConst 'ENU=The field Automatic Cost Posting should not be set to Yes if field Use Legacy G/L Entry Locking in General Ledger Setup table is set to No because of possibility of deadlocks.';
      UpdateExpCostConfMessage@1039 : TextConst 'ENU=If you change the Expected Cost Posting to G/L, the program must update table Post Value Entry to G/L.This can take several hours.';
      UpdateExpCostMessage@1037 : TextConst 'ENU=Expected Cost Posting to G/L has been changed to Yes. You should now run Post Inventory Cost to G/L.';
      UpdateAutomaticCostPeriodMessage@1038 : TextConst 'ENU=Some unadjusted value entries will not be covered with the new setting.';
      WrongNextCountingStartDateErr@1008 : TextConst 'ENU=Wrong next phys. inventory counting period start date.';
      WrongNextCountingEndDateErr@1009 : TextConst 'ENU=Wrong next phys. inventory counting period end date.';
      CalculateNeedVARParameterOutputValueErr@1014 : TextConst '@@@=%1 - VAR Parameter Name;ENU=%1 output value is wrong';

    [Test]
    PROCEDURE DeleteItemVariantError@96();
    VAR
      ItemVariant@1001 : Record 5401;
      ItemNo@1000 : Code[20];
      VariantCode@1002 : Code[10];
    BEGIN
      // Verify existence of deleted Item Variant.

      // Setup: Create Item, create Item Variant.
      Initialize;
      ItemNo := CreateItem;
      VariantCode := LibraryInventory.CreateItemVariant(ItemVariant,ItemNo);
      ItemVariant.DELETE(TRUE);

      // Exercise.
      ASSERTERROR ItemVariant.GET(ItemNo,VariantCode);

      // Verify: Verify existence of deleted Item Variant.
      Assert.ExpectedError(STRSUBSTNO(ItemVariantExistError,ItemNo,VariantCode));
    END;

    [Test]
    PROCEDURE DeleteItemVariantUsedInPurchOrderError@132();
    VAR
      PurchaseHeader@1000 : Record 38;
    BEGIN
      // Verify Error while Delete Item Variant which is used in Purchase Order Line.
      DeleteItemVariantUsedInPurchLineError(PurchaseHeader."Document Type"::Order);
    END;

    [Test]
    PROCEDURE DeleteItemVariantUsedInPurchRetOrderError@133();
    VAR
      PurchaseHeader@1000 : Record 38;
    BEGIN
      // Verify Error while Delete Item Variant which is used in Purchase Return Order Line.
      DeleteItemVariantUsedInPurchLineError(PurchaseHeader."Document Type"::"Return Order");
    END;

    LOCAL PROCEDURE DeleteItemVariantUsedInPurchLineError@112(DocumentType@1005 : Option);
    VAR
      ItemVariant@1001 : Record 5401;
      PurchaseLine@1004 : Record 39;
      ItemNo@1000 : Code[20];
    BEGIN
      // Setup: Create Item, Create Purchase Document with Variant Code.
      Initialize;
      ItemNo := CreateItem;
      CreatePurchaseDocument(
        PurchaseLine,DocumentType,ItemNo,LibraryInventory.CreateItemVariant(ItemVariant,ItemNo),CreateVendor,
        LibraryRandom.RandInt(10),WORKDATE); // Used Random for Quantity.

      // Exercise.
      ASSERTERROR ItemVariant.DELETE(TRUE);

      // Verify: Verify Error while Delete Item Variant.
      Assert.ExpectedError(STRSUBSTNO(ItemVariantError,PurchaseLine."Variant Code",PurchaseLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE DeleteItemVariantUsedInSalesOrderError@150();
    VAR
      SalesHeader@1000 : Record 36;
    BEGIN
      // Verify Error while Delete Item Variant which is used in Sales Order Line.
      DeleteItemVariantUsedInSalesLineError(SalesHeader."Document Type"::Order);
    END;

    [Test]
    PROCEDURE DeleteItemVariantUsedInSalesRetOrderError@149();
    VAR
      SalesHeader@1000 : Record 36;
    BEGIN
      // Verify Error while Delete Item Variant which is used in Sales Return Order Line.
      DeleteItemVariantUsedInSalesLineError(SalesHeader."Document Type"::"Return Order");
    END;

    LOCAL PROCEDURE DeleteItemVariantUsedInSalesLineError@144(DocumentType@1005 : Option);
    VAR
      ItemVariant@1001 : Record 5401;
      SalesLine@1004 : Record 37;
      ItemNo@1000 : Code[20];
    BEGIN
      // Setup: Create Item, Create Sales Document with Variant Code.
      Initialize;
      ItemNo := CreateItem;
      CreateSalesDocument(
        SalesLine,DocumentType,ItemNo,LibraryInventory.CreateItemVariant(ItemVariant,ItemNo),LibraryRandom.RandDec(10,2));  // Used Random for Quantity.

      // Exercise.
      ASSERTERROR ItemVariant.DELETE(TRUE);

      // Verify: Verify Error while Delete Item Variant.
      Assert.ExpectedError(STRSUBSTNO(ItemVariantError,SalesLine."Variant Code",SalesLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE DeleteItemVariantUsedInServiceOrderError@172();
    VAR
      ItemVariant@1001 : Record 5401;
      ServiceHeader@1004 : Record 5900;
      ServiceLine@1006 : Record 5902;
    BEGIN
      // Verify Error while Delete Item Variant which is used in Service Order Line.

      // Setup: Create Service Order with Variant Code.
      Initialize;
      LibraryService.CreateServiceHeader(ServiceHeader,ServiceHeader."Document Type"::Order,CreateCustomer);
      LibraryService.CreateServiceLine(ServiceLine,ServiceHeader,ServiceLine.Type::Item,CreateItem);
      ServiceLine.VALIDATE("Variant Code",LibraryInventory.CreateItemVariant(ItemVariant,ServiceLine."No."));
      ServiceLine.MODIFY(TRUE);

      // Exercise.
      ASSERTERROR ItemVariant.DELETE(TRUE);

      // Verify: Verify Error while Delete Item Variant.
      Assert.ExpectedError(STRSUBSTNO(ItemVariantError,ServiceLine."Variant Code",ServiceLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE DeleteItemVariantUsedInItemJournalError@134();
    VAR
      ItemVariant@1001 : Record 5401;
      ItemJournalLine@1004 : Record 83;
      ItemNo@1000 : Code[20];
    BEGIN
      // Verify Error while Delete Item Variant which is used in Item Journal Line.

      // Setup: Create Item Journal with Variant Code..
      Initialize;
      ItemNo := CreateItem;
      CreateItemJournalLine(ItemJournalLine,ItemNo,LibraryInventory.CreateItemVariant(ItemVariant,ItemNo),'','');

      // Exercise.
      ASSERTERROR ItemVariant.DELETE(TRUE);

      // Verify: Verify Error while Delete Item Variant.
      Assert.ExpectedError(STRSUBSTNO(ItemVariantError,ItemJournalLine."Variant Code",ItemJournalLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE DeleteItemVariantUsedInItemLedEntryError@118();
    VAR
      ItemVariant@1001 : Record 5401;
      ItemJournalLine@1004 : Record 83;
      ItemLedgerEntry@1002 : Record 32;
      ItemNo@1000 : Code[20];
    BEGIN
      // Verify Error while Delete Item Variant which is exist in Item Ledger Entry.

      // Setup: Create Item Journal with Variant Code and Post.
      Initialize;
      ItemNo := CreateItem;
      CreateItemJournalLine(ItemJournalLine,ItemNo,LibraryInventory.CreateItemVariant(ItemVariant,ItemNo),'','');
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Exercise.
      ASSERTERROR ItemVariant.DELETE(TRUE);

      // Verify: Verify Error while Delete Item Variant.
      Assert.ExpectedError(STRSUBSTNO(ItemVariantError,ItemJournalLine."Variant Code",ItemLedgerEntry.TABLECAPTION));
    END;

    [Test]
    PROCEDURE DeleteItemVariantUsedInProdBOMLineError@102();
    VAR
      ItemVariant@1001 : Record 5401;
      ProductionBOMHeader@1000 : Record 99000771;
      ProductionBOMLine@1002 : Record 99000772;
      ItemNo@1004 : Code[20];
    BEGIN
      // Verify Error while Delete Item Variant which is exist in Production BOM Line.

      // Setup: Create Item, create Productin BOM with Variant Code.
      Initialize;
      ItemNo := CreateItem;
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,'');
      LibraryManufacturing.CreateProductionBOMLine(ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ItemNo,1);  // Required 1 for Quantity Per.
      ProductionBOMLine.VALIDATE("Variant Code",LibraryInventory.CreateItemVariant(ItemVariant,ProductionBOMLine."No."));
      ProductionBOMLine.MODIFY(TRUE);

      // Exercise.
      ASSERTERROR ItemVariant.DELETE(TRUE);

      // Verify: Verify Error while Delete Item Variant.
      Assert.ExpectedError(STRSUBSTNO(ItemVariantError,ProductionBOMLine."Variant Code",ProductionBOMLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE DeleteItemVariantUsedInProdOrdComponentError@123();
    VAR
      Item@1003 : Record 27;
      Item2@1004 : Record 27;
      ItemVariant@1001 : Record 5401;
      ProductionOrder@1005 : Record 5405;
      ProdOrderComponent@1002 : Record 5407;
    BEGIN
      // Verify Error while Delete Item Variant which is exist in Production Order Component Line.

      // Setup: Create Item, create component Item, create Certified Production BOM.
      Initialize;
      Item.GET(CreateItem);
      Item2.GET(CreateItem);

      // Update Production Bom on Item.
      UpdateItemWithCertifiedBOMAndRouting(Item,Item2."No.");

      // Create Released Production Order and update Prod. Order Component with Variant.
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,Item."No.",
        LibraryRandom.RandInt(10));  // Used Random Int for Quantity.
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,FALSE,TRUE,FALSE);
      FindAndUpdateProdCompLine(ProductionOrder,LibraryInventory.CreateItemVariant(ItemVariant,Item2."No."));

      // Exercise.
      ASSERTERROR ItemVariant.DELETE(TRUE);

      // Verify: Verify Error while Delete Item Variant.
      Assert.ExpectedError(STRSUBSTNO(ItemVariantError,ItemVariant.Code,ProdOrderComponent.TABLECAPTION));
    END;

    [Test]
    PROCEDURE PhysInvCountingPeriodOnItem@1();
    VAR
      Item@1000 : Record 27;
      NextCountingStartDate@1001 : Date;
      NextCountingEndDate@1002 : Date;
    BEGIN
      // Verify 'Next Counting Period' after update 'Phys. Invt. Counting Period' on Item.

      // Setup: Create Item.
      Initialize;

      // Exercise: Update 'Phys. Invt. Counting Period' on Item.
      UpdatePhysInvCountingPeriodOnItem(Item,LibraryRandom.RandInt(100));
      NextCountingStartDate := Item."Next Counting Start Date";
      NextCountingEndDate := Item."Next Counting End Date";

      // Verify: Verify 'Next Counting Period' after update 'Phys. Invt. Counting Period' on Item.
      GetNextCountingPeriod(Item,NextCountingStartDate,NextCountingEndDate);
      Item.TESTFIELD("Next Counting Start Date",NextCountingStartDate);
      Item.TESTFIELD("Next Counting End Date",NextCountingEndDate);
    END;

    [Test]
    PROCEDURE UpdatePhysInvCountingPeriodOnPhysInventoryWithinThePeriod@13();
    VAR
      Item@1000 : Record 27;
      PhysInvtCountManagement@1001 : Codeunit 7380;
      NextCountingStartDate@1002 : Date;
      NextCountingEndDate@1003 : Date;
      PhysInventoryDate@1004 : Date;
      CountFrequency@1005 : Integer;
    BEGIN
      // [FEATURE] [Phys. Inventory] [UT]
      // [SCENARIO 379410] Next Counting Start and End Dates are updated when Phys. Inventory Counting Period is shorter than a month and Phys. Inventory is posted within this period.
      Initialize;

      // [GIVEN] Item with a weekly Phys. Inventory Counting Period.
      CountFrequency := 52; // 52 weeks in a year
      UpdatePhysInvCountingPeriodOnItem(Item,CountFrequency);
      NextCountingStartDate := Item."Next Counting Start Date";
      NextCountingEndDate := Item."Next Counting End Date";
      PhysInventoryDate := NextCountingStartDate + LibraryRandom.RandInt(NextCountingEndDate - NextCountingStartDate); // within the next counting period

      // [WHEN] Next Counting Start and End Dates are calculated by CalcPeriod function which is called on Phys. Inventory Journal Line posting.
      PhysInvtCountManagement.CalcPeriod(
        PhysInventoryDate,Item."Next Counting Start Date",Item."Next Counting End Date",CountFrequency);

      // [THEN] New "Next Counting Start Date" = Old "Next Counting End Date" + 1 day
      // [THEN] New "Next Counting End Date" = New "Next Counting Start Date" + 1 week
      Item.TESTFIELD("Next Counting Start Date",CALCDATE('<1D>',NextCountingEndDate));
      Item.TESTFIELD("Next Counting End Date",CALCDATE('<1W>',Item."Next Counting Start Date"));
    END;

    [Test]
    PROCEDURE DoNotUpdatePhysInvCountingPeriodOnPhysInventoryOutsideThePeriod@29();
    VAR
      Item@1002 : Record 27;
      PhysInvtCountManagement@1003 : Codeunit 7380;
      NextCountingStartDate@1001 : Date;
      NextCountingEndDate@1000 : Date;
      CountFrequency@1004 : Integer;
    BEGIN
      // [FEATURE] [Phys. Inventory] [UT]
      // [SCENARIO 379410] Next Counting Start and End Dates are not updated when Phys. Inventory is posted one day before the starting date of the Counting Period.
      Initialize;

      // [GIVEN] Item with a Phys. Inventory Counting Period.
      CountFrequency := LibraryRandom.RandInt(100);
      UpdatePhysInvCountingPeriodOnItem(Item,CountFrequency);
      NextCountingStartDate := Item."Next Counting Start Date";
      NextCountingEndDate := Item."Next Counting End Date";

      // [WHEN] Call "Phys. Invt. Count Management".CalcPeriod function with a Phys. Inventory posting date parameter a day before the period start.
      PhysInvtCountManagement.CalcPeriod(
        NextCountingStartDate - 1,Item."Next Counting Start Date",Item."Next Counting End Date",CountFrequency);

      // [THEN] Next Counting Start and End Dates are not updated.
      Item.TESTFIELD("Next Counting Start Date",NextCountingStartDate);
      Item.TESTFIELD("Next Counting End Date",NextCountingEndDate);
    END;

    [Test]
    PROCEDURE NextPhysInvtCountingPeriodIsAfterLastInventoryDateDoneOutsidePeriod@192();
    VAR
      PhysInvtCountManagement@1005 : Codeunit 7380;
      NextCountingStartDate@1003 : Date;
      NextCountingEndDate@1002 : Date;
      PhysInvtDate@1006 : Date;
      CountFrequency@1000 : Integer;
      CountPeriodBounds@1001 : ARRAY [5,2] OF Integer;
      i@1004 : Integer;
    BEGIN
      // [FEATURE] [Phys. Inventory] [UT]
      // [SCENARIO 212591] The next phys. inventory counting period should be shifted to the nearest period in a sequence after the phys. inventory date, if the inventory is posted later than the end date of the current period.
      Initialize;

      // [GIVEN] Weekly (52 times a year) phys. inventory counting period.
      CountFrequency := 52;

      // [GIVEN] The current counting period is 0..7 days from WORKDATE.
      NextCountingStartDate := WORKDATE;
      NextCountingEndDate := WORKDATE + 7;

      // [GIVEN] The next counting periods will be as follows: 8..15, 16..23, 24..31, ...
      FOR i := 1 TO ARRAYLEN(CountPeriodBounds,1) DO BEGIN
        CountPeriodBounds[i][1] := 7 * i + i;
        CountPeriodBounds[i][2] := 7 * (i + 1) + i;
      END;

      // [GIVEN] Last phys. inventory is carried out within the period of 8..15 days.
      i := LibraryRandom.RandInt(ARRAYLEN(CountPeriodBounds,1) - 1);
      PhysInvtDate := LibraryRandom.RandDateFromInRange(WORKDATE,CountPeriodBounds[i][1],CountPeriodBounds[i][2]);

      // [WHEN] Calculate the next counting period.
      PhysInvtCountManagement.CalcPeriod(
        PhysInvtDate,NextCountingStartDate,NextCountingEndDate,CountFrequency);

      // [THEN] The next counting period is the period that follows 8..15, which is 16..23 days.
      Assert.AreEqual(WORKDATE + CountPeriodBounds[i + 1][1],NextCountingStartDate,WrongNextCountingStartDateErr);
      Assert.AreEqual(WORKDATE + CountPeriodBounds[i + 1][2],NextCountingEndDate,WrongNextCountingEndDateErr);
    END;

    [Test]
    PROCEDURE BiweeklyPhysInvCountingPeriodWithNoLastDate@36();
    VAR
      PhysInvtCountManagement@1004 : Codeunit 7380;
      NextCountingStartDate@1003 : Date;
      NextCountingEndDate@1002 : Date;
      StartDateOfMonth@1001 : Date;
      MiddleDateOfMonth@1007 : Date;
      EndDateOfMonth@1006 : Date;
      HalfMonthStartDate@1009 : Date;
      HalfMonthEndDate@1010 : Date;
      DaysInMonth@1008 : Integer;
      MiddleDayOfMonth@1012 : Integer;
      LastDayOfMonth@1013 : Integer;
      CountFrequency@1000 : Integer;
    BEGIN
      // [FEATURE] [Phys. Inventory] [UT]
      // [SCENARIO 201098] CalcPeriod function in Phys. Invt. Count.-Management codeunit run with (CountFrequency = 24, LastDate = empty) parameters should set half a month long counting period into which WORKDATE would fall into.
      Initialize;

      // [GIVEN] Phys. inventory counting frequency = 24 times a year (twice in a month).
      CountFrequency := 24;

      // [GIVEN] Last counting date = empty, so the calculation of the next counting period will be based on WORKDATE.
      // [GIVEN] WORKDATE = 25/01/YY.
      StartDateOfMonth := CALCDATE('<-CM>',WORKDATE); // month begin date = 01/01/YY
      EndDateOfMonth := CALCDATE('<CM>',WORKDATE); // month end date = 31/01/YY
      DaysInMonth := DATE2DMY(EndDateOfMonth,1); // days in month = 31
      MiddleDateOfMonth := StartDateOfMonth + DaysInMonth DIV 2; // first day of second half of month = 16/01/YY

      MiddleDayOfMonth := DATE2DMY(MiddleDateOfMonth,1);
      LastDayOfMonth := DATE2DMY(EndDateOfMonth,1);

      // [GIVEN] First and last day of the half a month into which WORKDATE falls into is defined.
      HalfMonthStartDate :=
        StartDateOfMonth + (DATE2DMY(WORKDATE,1) DIV MiddleDayOfMonth) * (MiddleDayOfMonth - 1); // 16/01/YY
      HalfMonthEndDate :=
        EndDateOfMonth - ((LastDayOfMonth - DATE2DMY(WORKDATE,1)) DIV MiddleDayOfMonth) * MiddleDayOfMonth; // 31/01/YY

      // [WHEN] Run CalcPeriod function in Phys. Invt. Count.-Management to get next counting start and end dates.
      PhysInvtCountManagement.CalcPeriod(0D,NextCountingStartDate,NextCountingEndDate,CountFrequency);

      // [THEN] Next counting start date = 16/01/YY.
      // [THEN] Next counting end date = 31/01/YY.
      Assert.AreEqual(HalfMonthStartDate,NextCountingStartDate,WrongNextCountingStartDateErr);
      Assert.AreEqual(HalfMonthEndDate,NextCountingEndDate,WrongNextCountingEndDateErr);
    END;

    [Test]
    PROCEDURE BiweeklyPhysInvCountingPeriodWithLastDateOnFirstHalfMonth@37();
    VAR
      PhysInvtCountManagement@1003 : Codeunit 7380;
      NextCountingStartDate@1002 : Date;
      NextCountingEndDate@1001 : Date;
      LastCountingDate@1004 : Date;
      CountFrequency@1000 : Integer;
    BEGIN
      // [FEATURE] [Phys. Inventory] [UT]
      // [SCENARIO 201098] CalcPeriod function in Phys. Invt. Count.-Management codeunit run with (CountFrequency = 24, LastDate in first half of month) parameters should set half a month long counting period, following the one with LastDate.
      Initialize;

      // [GIVEN] Phys. inventory counting frequency = 24 times a year (twice in a month).
      // [GIVEN] Last counting date = 05/01/YY (in first half of month).
      CountFrequency := 24;
      LastCountingDate := 050120D;

      // [WHEN] Run CalcPeriod function in Phys. Invt. Count.-Management to get next counting start and end dates.
      PhysInvtCountManagement.CalcPeriod(LastCountingDate,NextCountingStartDate,NextCountingEndDate,CountFrequency);

      // [THEN] Next counting start date = 16/01/YY.
      // [THEN] Next counting end date = 31/01/YY.
      Assert.AreEqual(160120D,NextCountingStartDate,WrongNextCountingStartDateErr);
      Assert.AreEqual(310120D,NextCountingEndDate,WrongNextCountingEndDateErr);
    END;

    [Test]
    PROCEDURE BiweeklyPhysInvCountingPeriodWithLastDateOnSecondHalfMonth@38();
    VAR
      PhysInvtCountManagement@1004 : Codeunit 7380;
      NextCountingStartDate@1003 : Date;
      NextCountingEndDate@1002 : Date;
      LastCountingDate@1001 : Date;
      CountFrequency@1000 : Integer;
    BEGIN
      // [FEATURE] [Phys. Inventory] [UT]
      // [SCENARIO 201098] CalcPeriod function in Phys. Invt. Count.-Management codeunit run with (CountFrequency = 24, LastDate in second half of month) parameters should set half a month long counting period, following the one with LastDate.
      Initialize;

      // [GIVEN] Phys. inventory counting frequency = 24 times a year (twice in a month).
      // [GIVEN] Last counting date = 25/01/YY (in second half of month).
      CountFrequency := 24;
      LastCountingDate := 250120D;

      // [WHEN] Run CalcPeriod function in Phys. Invt. Count.-Management to get next counting start and end dates.
      PhysInvtCountManagement.CalcPeriod(LastCountingDate,NextCountingStartDate,NextCountingEndDate,CountFrequency);

      // [THEN] Next counting start date = 01/02/YY.
      // [THEN] Next counting end date = 14/02/YY.
      Assert.AreEqual(010220D,NextCountingStartDate,WrongNextCountingStartDateErr);
      Assert.AreEqual(140220D,NextCountingEndDate,WrongNextCountingEndDateErr);
    END;

    [Test]
    PROCEDURE DirectUnitCostOnPurchLineFromPurchPrice@9();
    VAR
      PurchasePrice@1000 : Record 7012;
      PurchaseLine@1002 : Record 39;
    BEGIN
      // Verify Direct Unit Cost on Purchase Line when Order Date is same as Starting Date of Purchase Price.

      // Setup:
      Initialize;
      CreatePurchasePrice(PurchasePrice,'',CreateVendor,WORKDATE);

      // Exercise: Create Purchase Order.
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchasePrice."Item No.",'',PurchasePrice."Vendor No.",
        PurchasePrice."Minimum Quantity",WORKDATE);

      // Verify: Verify Direct Unit Cost on Purchase Line.
      PurchaseLine.TESTFIELD("Direct Unit Cost",PurchasePrice."Direct Unit Cost");
    END;

    [Test]
    PROCEDURE DirectUnitCostOnPurchLineFromItem@24();
    VAR
      PurchasePrice@1000 : Record 7012;
      PurchaseLine@1002 : Record 39;
      Item@1003 : Record 27;
    BEGIN
      // Verify Direct Unit Cost on Purchase Line when Order Date is before Starting Date of Purchase Price.

      // Setup:
      Initialize;
      CreatePurchasePrice(PurchasePrice,'',CreateVendor,WORKDATE);
      Item.GET(PurchasePrice."Item No.");

      // Exercise: Create Purchase Order.
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchasePrice."Item No.",'',PurchasePrice."Vendor No.",
        PurchasePrice."Minimum Quantity",CALCDATE('<-' + FORMAT(LibraryRandom.RandInt(5)) + 'M>',WORKDATE));

      // Verify: Verify Direct Unit Cost on Purchase Line.
      PurchaseLine.TESTFIELD("Direct Unit Cost",Item."Last Direct Cost");
    END;

    [Test]
    PROCEDURE DirectUnitCostOnPurchLineWithCurrency@33();
    VAR
      PurchasePrice@1000 : Record 7012;
      PurchaseLine@1002 : Record 39;
      Currency@1001 : Record 4;
    BEGIN
      // Verify Direct Unit Cost on Purchase Line when Purchase Price is defined with Currency.

      // Setup:
      Initialize;
      Currency.GET(CreateCurrency);
      CreatePurchasePrice(PurchasePrice,Currency.Code,CreateAndModifyVendor(Currency.Code),WORKDATE);

      // Exercise: Create Purchase Order.
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchasePrice."Item No.",'',PurchasePrice."Vendor No.",
        PurchasePrice."Minimum Quantity",WORKDATE);

      // Verify: Verify Direct Unit Cost on Purchase Line.
      PurchaseLine.TESTFIELD("Direct Unit Cost",PurchasePrice."Direct Unit Cost");
    END;

    [Test]
    PROCEDURE PurchasePriceForVendorWithPartialQty@39();
    VAR
      PurchasePrice@1000 : Record 7012;
      PurchaseLine@1002 : Record 39;
      DocumentNo@1004 : Code[20];
    BEGIN
      // Verify Direct Unit Cost on Posted Purchase Invoice Line after posting Partial Quantity on Purchase Order and updating Unit Cost on Purchase Price.

      // Setup:
      Initialize;
      CreatePurchasePrice(PurchasePrice,'',CreateVendor,WORKDATE);
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchasePrice."Item No.",'',PurchasePrice."Vendor No.",
        PurchasePrice."Minimum Quantity",WORKDATE);
      UpdateUnitCostOnPurchasePrice(PurchasePrice);
      UpdatePurchLineQtyForPartialPost(PurchaseLine);

      // Exercise: Post Purchase Order.
      DocumentNo := PostPurchaseDocument(PurchaseLine,TRUE);

      // Verify: Verify Direct Unit Cost on Posted Purchase Invoice after posting Partial Quantity.
      VerifyPstdPurchaseInvoice(DocumentNo,PurchasePrice."Direct Unit Cost",0);  // 0 for Line Discount Pct.
    END;

    [Test]
    PROCEDURE PostPurchaseInvUsingCopyDocument@6();
    VAR
      PurchasePrice@1000 : Record 7012;
      PurchaseLine@1002 : Record 39;
      PurchaseHeader@1003 : Record 38;
      DocumentNo@1004 : Code[20];
      DocType@1005 : 'Quote,Blanket Order,Order,Invoice,Return Order,Credit Memo,Posted Receipt,Posted Invoice,Posted Return Shipment,Posted Credit Memo';
      DirectUnitCost@1006 : Decimal;
    BEGIN
      // Verify Direct Unit Cost on Posted Purchase Invoice after posting Purchase Invoice using Copy Document and updating Unit Cost on Purchase Price.

      // Setup: Create Purchase Price, create and Receive Purchase order.
      Initialize;
      CreatePurchasePrice(PurchasePrice,'',CreateVendor,WORKDATE);
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchasePrice."Item No.",'',PurchasePrice."Vendor No.",
        PurchasePrice."Minimum Quantity",WORKDATE);
      DocumentNo := PostPurchaseDocument(PurchaseLine,FALSE);

      // Update Unit Cost on Purchase Price, create Purchase Invoice using Copy Document.
      DirectUnitCost := UpdateUnitCostOnPurchasePrice(PurchasePrice);
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Invoice,PurchasePrice."Vendor No.");
      LibraryPurchase.CopyPurchaseDocument(PurchaseHeader,DocType::"Posted Receipt",DocumentNo,FALSE,TRUE);

      // Exercise: Post Purchase Invoice.
      DocumentNo := LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // Verify: Verify Direct Unit Cost on Posted Purchase Invoice after posting Purchase Invoice using Copy Document.
      VerifyPstdPurchaseInvoice(DocumentNo,DirectUnitCost,0);
    END;

    [Test]
    PROCEDURE UnitCostOnPurchLineWithCarryOutActionMsg@5();
    VAR
      PurchasePrice@1000 : Record 7012;
      SalesLine@1001 : Record 37;
      PurchaseLine@1003 : Record 39;
    BEGIN
      // Verify Direct Unit Cost on Purchase Line after Calculate Regenerative Plan and carry Out Action Message.

      // Setup: Create Item, create Purchase Price, create Sales order.
      Initialize;
      CreatePurchasePrice(PurchasePrice,'',CreateVendor,CALCDATE('<-1D>',WORKDATE));
      CreateSalesDocument(SalesLine,SalesLine."Document Type"::Order,PurchasePrice."Item No.",'',PurchasePrice."Minimum Quantity");

      // Exercise: Calculate Regenerative Plan and carry Out Action Message.
      CalculateRegPlanAndCarryOutActionMsg(PurchasePrice."Item No.");

      // Verify: Verify Direct Cost on Purchase Line.
      PurchaseLine.SETRANGE("No.",PurchasePrice."Item No.");
      PurchaseLine.FINDFIRST;
      PurchaseLine.TESTFIELD("Direct Unit Cost",PurchasePrice."Direct Unit Cost");
    END;

    [Test]
    PROCEDURE LineDiscOnPurchLineFromPurchLineDisc@3();
    VAR
      PurchaseLineDiscount@1000 : Record 7014;
      PurchaseLine@1001 : Record 39;
    BEGIN
      // Verify Line Discount on Purchase Line when Order Date is same as Starting Date of Purchase Price.

      // Setup: Create Purchase Line Discount.
      Initialize;
      CreatePurchaseLineDiscount(PurchaseLineDiscount);

      // Exercise: Create Purchase Order.
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLineDiscount."Item No.",'',PurchaseLineDiscount."Vendor No.",
        PurchaseLineDiscount."Minimum Quantity",WORKDATE);

      // Verify: Verify Line Discount on Purchase Line.
      PurchaseLine.TESTFIELD("Line Discount %",PurchaseLineDiscount."Line Discount %");
    END;

    [Test]
    PROCEDURE LineDiscOnPurchLineFromItem@8();
    VAR
      PurchaseLineDiscount@1000 : Record 7014;
      PurchaseLine@1001 : Record 39;
    BEGIN
      // Verify Line Discount on Purchase Line when Order Date is before Starting Date of Purchase Price.

      // Setup: Create Purchase Line Discount.
      Initialize;
      CreatePurchaseLineDiscount(PurchaseLineDiscount);

      // Exercise: Create Purchase Order.
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLineDiscount."Item No.",'',PurchaseLineDiscount."Vendor No.",
        PurchaseLineDiscount."Minimum Quantity",CALCDATE('<-' + FORMAT(LibraryRandom.RandInt(5)) + 'M>',WORKDATE))
      ;

      // Verify: Verify Line Discount on Purchase Line.
      PurchaseLine.TESTFIELD("Line Discount %",0);
    END;

    [Test]
    PROCEDURE PurchLineDiscForVendorWithPartialQty@7();
    VAR
      PurchaseLineDiscount@1000 : Record 7014;
      PurchaseLine@1001 : Record 39;
      Item@1003 : Record 27;
      DocumentNo@1002 : Code[20];
    BEGIN
      // Verify Line Discount Pct on Posted Purchase Invoice Line after posting Partial Quantity on Purchase Order and updating Line Discount Pct on Purchase Line Discount.

      // Setup: Create Purchase Line Discount, create Purchase Order, Update Line Discount.
      Initialize;
      CreatePurchaseLineDiscount(PurchaseLineDiscount);
      Item.GET(PurchaseLineDiscount."Item No.");
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLineDiscount."Item No.",'',PurchaseLineDiscount."Vendor No.",
        PurchaseLineDiscount."Minimum Quantity",WORKDATE);
      UpdateLineDiscOnPurchLineDisc(PurchaseLineDiscount);
      UpdatePurchLineQtyForPartialPost(PurchaseLine);

      // Exercise: Post Purchase Order.
      DocumentNo := PostPurchaseDocument(PurchaseLine,TRUE);

      // Verify: Verify Line Discount Pct on Posted Purchase Invoice Line after posting Partial Quantity on Purchase Order.
      VerifyPstdPurchaseInvoice(DocumentNo,Item."Last Direct Cost",PurchaseLineDiscount."Line Discount %");
    END;

    [Test]
    PROCEDURE LineDiscOnPstdPurchInvUsingCopyDoc@2();
    VAR
      Item@1001 : Record 27;
      PurchaseLineDiscount@1000 : Record 7014;
      PurchaseLine@1002 : Record 39;
      PurchaseHeader@1003 : Record 38;
      DocumentNo@1004 : Code[20];
      DocType@1005 : 'Quote,Blanket Order,Order,Invoice,Return Order,Credit Memo,Posted Receipt,Posted Invoice,Posted Return Shipment,Posted Credit Memo';
      LineDiscountPct@1006 : Decimal;
    BEGIN
      // Verify Line Discount on Posted Purchase Invoice after posting Purchase Invoice using Copy Document and updating Line Discount Pct on Purchase Price.

      // Setup: Create Purchase Price, create and Receive Purchase order.
      Initialize;
      CreatePurchaseLineDiscount(PurchaseLineDiscount);
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLineDiscount."Item No.",'',PurchaseLineDiscount."Vendor No.",
        PurchaseLineDiscount."Minimum Quantity",WORKDATE);
      DocumentNo := PostPurchaseDocument(PurchaseLine,FALSE);
      Item.GET(PurchaseLine."No.");

      // Update Line Discount Pct on Purchase Price, create Purchase Invoice using Copy Document.
      LineDiscountPct := UpdateLineDiscOnPurchLineDisc(PurchaseLineDiscount);
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Invoice,PurchaseLineDiscount."Vendor No.");
      LibraryPurchase.CopyPurchaseDocument(PurchaseHeader,DocType::"Posted Receipt",DocumentNo,FALSE,TRUE);

      // Exercise: Post Purchase Invoice.
      DocumentNo := LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // Verify: Verify Line Discount on Posted Purchase Invoice after posting Purchase Invoice using Copy Document.
      VerifyPstdPurchaseInvoice(DocumentNo,Item."Last Direct Cost",LineDiscountPct);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE PostOutputJournalFromRelProdOrder@30();
    VAR
      InventorySetup@1005 : Record 313;
      Item@1000 : Record 27;
      ProductionOrder@1001 : Record 5405;
      ValueEntry@1007 : Record 5802;
      ItemNo@1008 : Code[20];
    BEGIN
      // Verify Value Entry after post Output Journal which is created from Production Order.

      // Setup.
      Initialize;
      InventorySetupEnqueues;  // Enqueue Message Handler.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,TRUE,InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");

      // Create Item.
      ItemNo := CreateAndModifyItem('',Item."Flushing Method"::Backward,Item."Replenishment System"::Purchase); // Component Item.

      // Excercise.
      SetupForPostOutputJournal(ProductionOrder,ItemNo);

      // Verify: Verify Value Entry after post Output Journal.
      VerifyValueEntry(ValueEntry."Item Ledger Entry Type"::Consumption,ProductionOrder."No.",ItemNo);
      VerifyValueEntry(ValueEntry."Item Ledger Entry Type"::Output,ProductionOrder."No.",ProductionOrder."Source No.");

      // Tear Down.
      LibraryVariableStorage.Enqueue(UpdateExpCostConfMessage);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE PostOutputJournalWithAppliesToEntry@14();
    VAR
      InventorySetup@1005 : Record 313;
      Item@1000 : Record 27;
      ProductionOrder@1001 : Record 5405;
      ItemJournalLine@1006 : Record 83;
      ItemLedgerEntry@1003 : Record 32;
      ValueEntry@1002 : Record 5802;
      ItemNo@1011 : Code[20];
    BEGIN
      // Verify Value Entry and Application Worksheet after post Output Journal with 'Apply to Entry' which is created from Production Order.

      // Setup.
      Initialize;
      InventorySetupEnqueues;  // Enqueue Message Handler.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,TRUE,InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");

      // Create Item, Post Purchase Order, create Released Production Order.
      ItemNo := CreateAndModifyItem('',Item."Flushing Method"::Backward,Item."Replenishment System"::Purchase); // Component Item.
      SetupForPostOutputJournal(ProductionOrder,ItemNo);

      // Create Output Journal with Applies to Entry and Post.
      FindItemLedgerEntry(ItemLedgerEntry,ItemLedgerEntry."Entry Type"::Output,ProductionOrder."No.");
      CreateOutputJournal(
        ItemJournalLine,ProductionOrder."Source No.",ProductionOrder."No.",GetOperationNo(ProductionOrder."No."),
        -ProductionOrder.Quantity,ItemLedgerEntry."Entry No.");

      // Excercise.
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Verify: Verify Item Ledger Entry (Application Worksheet) and Value Entry after post Output Journal.
      FindItemLedgerEntry(ItemLedgerEntry,ItemLedgerEntry."Entry Type"::Consumption,ProductionOrder."No.");
      ItemLedgerEntry.TESTFIELD("Item No.",ItemNo);
      VerifyValueEntry(ValueEntry."Item Ledger Entry Type"::Consumption,ProductionOrder."No.",ItemNo);

      // Tear Down.
      LibraryVariableStorage.Enqueue(UpdateExpCostConfMessage);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE ExpCostAmountInValueEntry@147();
    VAR
      InventorySetup@1005 : Record 313;
      Item@1000 : Record 27;
      ValueEntry@1002 : Record 5802;
      PurchaseLine@1001 : Record 39;
      PostedReceiptNo@1004 : Code[20];
    BEGIN
      // Verify Value Entry after receive Purchase Order.

      // Setup: Update Inventory Setup, create Purchase Order,
      Initialize;
      InventorySetupEnqueues; // Enqueue Message Handler.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,TRUE,InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,
        CreateAndModifyItem('',Item."Flushing Method"::Backward,Item."Replenishment System"::Purchase),'',CreateVendor,
        LibraryRandom.RandInt(10),WORKDATE);

      // Exercise
      PostedReceiptNo := PostPurchaseDocument(PurchaseLine,FALSE);

      // Verify: Verify Value Entry after post Purchase Order.
      VerifyValueEntry(ValueEntry."Item Ledger Entry Type"::Purchase,PostedReceiptNo,PurchaseLine."No.");

      // Tear Down.
      LibraryVariableStorage.Enqueue(UpdateExpCostConfMessage);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE GLEntryAfterPostSalesOrder@196();
    VAR
      InventorySetup@1005 : Record 313;
      Item@1000 : Record 27;
      PurchaseLine@1001 : Record 39;
      SalesLine@1003 : Record 37;
      SalesHeader@1006 : Record 36;
      GLEntry@1007 : Record 17;
      PostedInvoiceNo@1004 : Code[20];
    BEGIN
      // Verify GL Entry after post Salse Order.

      // Setup: Update Inventory Setup, create and post Purchase Order, create Sales Order.
      Initialize;
      InventorySetupEnqueues; // Enqueue Message Handler.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,TRUE,InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
      CreateAndPostPurchaseOrder(
        PurchaseLine,CreateAndModifyItem('',Item."Flushing Method"::Backward,Item."Replenishment System"::Purchase),FALSE);
      CreateSalesDocument(SalesLine,SalesLine."Document Type"::Order,PurchaseLine."No.",'',LibraryRandom.RandInt(10));
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");

      // Exercise.
      PostedInvoiceNo := LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify: Verify GL Entry after post Salse Order.
      VerifyGLEntry(GLEntry."Document Type"::Invoice,PostedInvoiceNo,-SalesLine."Line Amount",GLEntry."Gen. Posting Type"::Sale);
      VerifyGLEntry(
        GLEntry."Document Type"::Invoice,PostedInvoiceNo,SalesLine."Amount Including VAT",GLEntry."Gen. Posting Type"::" ");

      // Tear Down.
      LibraryVariableStorage.Enqueue(UpdateExpCostConfMessage);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler,PostedSalesDocumentLinesHandler)]
    PROCEDURE GLEntryAfterPostCreditMemo@31();
    VAR
      InventorySetup@1005 : Record 313;
      Item@1000 : Record 27;
      PurchaseLine@1001 : Record 39;
      PurchaseHeader@1009 : Record 38;
      ReasonCode@1032 : Record 231;
      SalesLine@1003 : Record 37;
      SalesHeader@1006 : Record 36;
      SalesHeader2@1008 : Record 36;
      GLEntry@1007 : Record 17;
      PostedCreditMemoNo@1004 : Code[20];
    BEGIN
      // Verify GL Entry after post Credit Memo.

      // Setup: Update Inventory Setup, create and receive Purchase Order.
      Initialize;
      LibraryERM.CreateReasonCode(ReasonCode);  // Added for G1 Country Fix.
      InventorySetupEnqueues; // Enqueue Message Handler.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,TRUE,InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
      CreateAndPostPurchaseOrder(
        PurchaseLine,CreateAndModifyItem('',Item."Flushing Method"::Backward,Item."Replenishment System"::Purchase),FALSE);   // Used Random for 'Direct Unit Cost'.

      // Reopen Purchase Order and update Direct Unit Cost on Purchase Line.
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);
      PurchaseLine.GET(PurchaseLine."Document Type",PurchaseLine."Document No.",PurchaseLine."Line No.");
      PurchaseLine.VALIDATE("Direct Unit Cost",(PurchaseLine."Direct Unit Cost" + LibraryRandom.RandInt(10)));  // Used Random, required more than existing 'Direct Unit Cost'.
      PurchaseLine.MODIFY(TRUE);

      // Create Sales Order and post.
      CreateSalesDocument(SalesLine,SalesLine."Document Type"::Order,PurchaseLine."No.",'',PurchaseLine.Quantity);
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Create Sales Credit Memo, Get Posted Invoice to Reverse and Post.
      LibrarySales.CreateSalesHeader(SalesHeader2,SalesHeader2."Document Type"::"Credit Memo",SalesHeader."Sell-to Customer No.");
      GetPostedDocumentLines(SalesHeader2."No.");
      SalesHeader2.VALIDATE("Reason Code",ReasonCode.Code);
      SalesHeader2.MODIFY(TRUE);
      FindSalesLine(SalesLine,SalesHeader2."Document Type"::"Credit Memo",SalesHeader2."No.");
      PostedCreditMemoNo := LibrarySales.PostSalesDocument(SalesHeader2,TRUE,TRUE);

      // Exercise: Post Purhcase received Purchase Order with updated 'Direct Unit Cost'.
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // Verify: Verify GL Entry after post Salse Credit Memo.
      VerifyGLEntry(
        GLEntry."Document Type"::"Credit Memo",PostedCreditMemoNo,SalesLine."Line Amount",GLEntry."Gen. Posting Type"::Sale);
      VerifyGLEntry(
        GLEntry."Document Type"::"Credit Memo",PostedCreditMemoNo,-SalesLine."Amount Including VAT",GLEntry."Gen. Posting Type"::" ");

      // Tear Down.
      LibraryVariableStorage.Enqueue(UpdateExpCostConfMessage);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    PROCEDURE RequisitionWorksheetDescriptionFromItemCrossReference@43();
    VAR
      Item@1002 : Record 27;
      ItemCrossReference@1004 : Record 5717;
      SalesLine@1001 : Record 37;
      RequisitionWkshName@1006 : Record 245;
      RequisitionLine@1007 : Record 246;
      ReqWkshTemplateName@1000 : Code[10];
    BEGIN
      // [FEATURE] [Requisition Worksheet] [Item Cross Reference]
      // [SCENARIO 202830] Description should be copied into a requisition worksheet line from the item cross reference when calculating requisition plan

      Initialize;

      // [GIVEN] Item "I". Vendor "V" is setup as the default vendor for the item.
      CreateItemWithVendor(Item);

      // [GIVEN] Item cross reference "CR" for item "I" with vendor "V". Description in the cross reference is "D".
      CreateItemCrossReference(ItemCrossReference,Item."No.",Item."Vendor No.");
      // [GIVEN] Create a sales order for item "I"
      CreateSalesDocument(SalesLine,SalesLine."Document Type"::Order,Item."No.",'',LibraryRandom.RandInt(100));

      // [WHEN] Calculate requisition plan for item "I"
      ReqWkshTemplateName := LibraryPlanning.SelectRequisitionTemplateName;
      LibraryPlanning.CreateRequisitionWkshName(RequisitionWkshName,ReqWkshTemplateName);
      LibraryPlanning.CreateRequisitionLine(RequisitionLine,ReqWkshTemplateName,RequisitionWkshName.Name);
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item,WORKDATE,WORKDATE);

      // [THEN] New requisition line is created with "Description" = "D"
      VerifyDescriptionsOnRequisitionLine(Item."No.",ItemCrossReference.Description,'');
    END;

    [Test]
    PROCEDURE ReqWorksheetDescriptionFromItemCrossRefForDropShipment@64();
    VAR
      Item@1000 : Record 27;
      ItemCrossReference@1001 : Record 5717;
      SalesLine@1002 : Record 37;
    BEGIN
      // [FEATURE] [Requisition Worksheet] [Item Cross Reference] [Drop Shipment]
      // [SCENARIO 214007] Description should be copied into a requisition worksheet line from the item cross reference when running Get Sales Orders function for Drop Shipment.
      Initialize;

      // [GIVEN] Item "I". Vendor "V" is setup as the default vendor for the item.
      // [GIVEN] Item cross reference "CR" for item "I" with vendor "V". Description in the cross reference is "Desc-CR".
      CreateItemWithVendor(Item);
      CreateItemCrossReference(ItemCrossReference,Item."No.",Item."Vendor No.");

      // [GIVEN] Drop shipment sales order line for item "I". Descriptions on the sales line = "Desc-S1" and "Desc-S2".
      CreateSalesDocument(SalesLine,SalesLine."Document Type"::Order,Item."No.",'',LibraryRandom.RandInt(100));
      SalesLine.VALIDATE("Drop Shipment",TRUE);
      SalesLine.VALIDATE(Description,LibraryUtility.GenerateRandomText(20));
      SalesLine.VALIDATE("Description 2",LibraryUtility.GenerateRandomText(20));
      SalesLine.MODIFY(TRUE);

      // [WHEN] Run Get Sales Orders function in requisition worksheet.
      GetSalesOrdersInRequisitionWorksheet(SalesLine);

      // [THEN] New requisition line is created with Description = "Desc-CR" and "Description 2" = blank.
      VerifyDescriptionsOnRequisitionLine(Item."No.",ItemCrossReference.Description,'');
    END;

    [Test]
    PROCEDURE ReqWorksheetDescriptionFromSalesOrderLineForDropShipment@66();
    VAR
      Item@1002 : Record 27;
      SalesLine@1000 : Record 37;
    BEGIN
      // [FEATURE] [Requisition Worksheet] [Item Cross Reference] [Drop Shipment]
      // [SCENARIO 214007] Descriptions should be copied into a requisition worksheet line from sales line when running Get Sales Order function for Drop Shipment.
      Initialize;

      // [GIVEN] Item "I". Vendor "V" is setup as the default vendor for the item.
      CreateItemWithVendor(Item);

      // [GIVEN] Drop shipment sales order line for item "I". Descriptions on the sales line = "D1" and "D2".
      CreateSalesDocument(SalesLine,SalesLine."Document Type"::Order,Item."No.",'',LibraryRandom.RandInt(100));
      SalesLine.VALIDATE("Drop Shipment",TRUE);
      SalesLine.VALIDATE(Description,LibraryUtility.GenerateRandomText(20));
      SalesLine.VALIDATE("Description 2",LibraryUtility.GenerateRandomText(20));
      SalesLine.MODIFY(TRUE);

      // [WHEN] Run Get Sales Orders function in requisition worksheet.
      GetSalesOrdersInRequisitionWorksheet(SalesLine);

      // [THEN] New requisition line is created with Description = "D1" and "Description 2" = "D2".
      VerifyDescriptionsOnRequisitionLine(Item."No.",SalesLine.Description,SalesLine."Description 2");
    END;

    [Test]
    PROCEDURE ItemCrossReferenceGetItemDescriptionCrossRefExists@44();
    VAR
      Item@1001 : Record 27;
      Vendor@1002 : Record 23;
      ItemCrossReference@1000 : Record 5717;
      Description@1003 : Text;
    BEGIN
      // [FEATURE] [Requisition Worksheet] [Item Cross Reference] [UT]
      // [SCENARIO 202830] Function GetItemDescription in table 5717 "Item Cross Reference" should return description text when a cross reference exists for the given combination of item and vendor

      LibraryInventory.CreateItem(Item);
      LibraryPurchase.CreateVendor(Vendor);
      CreateItemCrossReference(ItemCrossReference,Item."No.",Vendor."No.");

      Description := Item.Description;
      Assert.IsTrue(
        ItemCrossReference.GetItemDescription(
          Description,Item."No.",'',Item."Base Unit of Measure",
          ItemCrossReference."Cross-Reference Type"::Vendor,Vendor."No."),'');

      Assert.AreEqual(ItemCrossReference.Description,Description,'');
    END;

    [Test]
    PROCEDURE ItemCrossReferenceGetItemDescriptionCrossRefDoesNotExist@45();
    VAR
      Item@1000 : Record 27;
      ItemCrossReference@1002 : Record 5717;
      Description@1001 : Text;
    BEGIN
      // [FEATURE] [Requisition Worksheet] [Item Cross Reference] [UT]
      // [SCENARIO 202830] Function GetItemDescription in table 5717 "Item Cross Reference" should not change description text when no cross references exist for the given combination of item and vendor

      LibraryInventory.CreateItem(Item);

      Description := Item.Description;
      Assert.IsFalse(
        ItemCrossReference.GetItemDescription(
          Description,Item."No.",'',Item."Base Unit of Measure",
          ItemCrossReference."Cross-Reference Type"::Vendor,''),'');

      Assert.AreEqual(Item.Description,Description,'');
    END;

    [Test]
    PROCEDURE ItemAvailabilityFormsMgtCalculateNeedAlwaysCALCFIELDSShipLFBlank@48();
    VAR
      Item@1000 : Record 27;
      TransferHeader@1006 : Record 5740;
      TransferLine@1005 : Record 5741;
      TransferQuantity@1004 : Decimal;
      InventoryQuantity@1007 : Decimal;
      ToShipQuantity@1008 : Decimal;
      ToReceiveQuantity@1009 : Decimal;
      GrossRequirement@1010 : Decimal;
      PlannedOrderReceipt@1003 : Decimal;
      ScheduledReceipt@1002 : Decimal;
      PlannedOrderReleases@1001 : Decimal;
    BEGIN
      // [FEATURE] [Transfer] [Item Availability]
      // [SCENARIO 209093] PROCEDURE "Item Availability Forms Mgt".CalculateNeed always calculates FlowFields depended from "Transfer Line", partly shipped transfer, "Location Filter" is blank
      Initialize;

      // [GIVEN] PROCEDURE CalculateNeed "CN" of Codeunit 353 calculates flowfields of Item "I", Gross Requirement "GR", Planned Order Receipt "PORcp", Scheduled Receipt "SR", Planned Order Releases "PORls";
      SetupTransferQuantities(InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [GIVEN] Item "I" has inventory = "IQ" at Location "L1" and no inventory at Location "L2";
      // [GIVEN] Partly shipped Transfer Line from "L1" to "L2" with "Quantity" = "TQ" and "Quantity Shipped" = "SQ";
      CreateItemInPartlyShippedTransferOrder(Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity);

      // [WHEN] Execute "CN" when "I"."Location Filter" is blank
      ItemAvailabilityFormsMgtCalculateNeed(
        Item,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases,'');

      // [THEN] "I" has: "Inventory" = "IQ", "Qty. in Transit" = "SQ", "Trans. Ord. Shipment (Qty.)" = "TQ" - "SQ", "Trans. Ord. Receipt (Qty.)" = "TQ" - "SQ";
      VerifyItemPlanningFields(
        Item,InventoryQuantity,ToShipQuantity,TransferQuantity - ToShipQuantity,TransferQuantity - ToShipQuantity);

      // [THEN] "GR" = 0, "PORcp" = 0, "SR" = 0, "PORls" = 0.
      VerifyCalculatedNeed(
        0,0,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases);
    END;

    [Test]
    PROCEDURE ItemAvailabilityFormsMgtCalculateNeedAlwaysCALCFIELDSShipLFFrom@78();
    VAR
      Item@1000 : Record 27;
      TransferHeader@1006 : Record 5740;
      TransferLine@1005 : Record 5741;
      TransferQuantity@1004 : Decimal;
      InventoryQuantity@1007 : Decimal;
      ToShipQuantity@1008 : Decimal;
      ToReceiveQuantity@1009 : Decimal;
      GrossRequirement@1010 : Decimal;
      PlannedOrderReceipt@1003 : Decimal;
      ScheduledReceipt@1002 : Decimal;
      PlannedOrderReleases@1001 : Decimal;
    BEGIN
      // [FEATURE] [Transfer] [Item Availability]
      // [SCENARIO 209093] PROCEDURE "Item Availability Forms Mgt".CalculateNeed always calculates FlowFields depended from "Transfer Line", partly shipped transfer, "Location Filter" = "Transfer From Code"
      Initialize;

      // [GIVEN] PROCEDURE CalculateNeed "CN" of Codeunit 353 calculates flowfields of Item "I", Gross Requirement "GR", Planned Order Receipt "PORcp", Scheduled Receipt "SR", Planned Order Releases "PORls";
      SetupTransferQuantities(InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [GIVEN] Item "I" has inventory = "IQ" at Location "L1" and no inventory at Location "L2"
      // [GIVEN] Partly shipped Transfer Line from "L1" to "L2" with "Quantity" = "TQ" and "Quantity Shipped" = "SQ"
      CreateItemInPartlyShippedTransferOrder(Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity);

      // [WHEN] Execute "CN" when "I"."Location Filter" is "L1"
      ItemAvailabilityFormsMgtCalculateNeed(
        Item,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases,TransferLine."Transfer-from Code");

      // [THEN] "I" has: "Inventory" = "IQ" - "SQ", "Qty. in Transit" = 0, "Trans. Ord. Shipment (Qty.)" = "TQ" - "SQ", "Trans. Ord. Receipt (Qty.)" = 0;
      VerifyItemPlanningFields(
        Item,InventoryQuantity - ToShipQuantity,0,TransferQuantity - ToShipQuantity,0);

      // [THEN] "GR" = "TQ" - "SQ", "PORcp" = 0, "SR" = 0, "PORls" = 0.
      VerifyCalculatedNeed(
        TransferQuantity - ToShipQuantity,0,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases);
    END;

    [Test]
    PROCEDURE ItemAvailabilityFormsMgtCalculateNeedAlwaysCALCFIELDSShipLFTo@79();
    VAR
      Item@1000 : Record 27;
      TransferHeader@1006 : Record 5740;
      TransferLine@1005 : Record 5741;
      TransferQuantity@1004 : Decimal;
      InventoryQuantity@1007 : Decimal;
      ToShipQuantity@1008 : Decimal;
      ToReceiveQuantity@1009 : Decimal;
      GrossRequirement@1010 : Decimal;
      PlannedOrderReceipt@1003 : Decimal;
      ScheduledReceipt@1002 : Decimal;
      PlannedOrderReleases@1001 : Decimal;
    BEGIN
      // [FEATURE] [Transfer] [Item Availability]
      // [SCENARIO 209093] PROCEDURE "Item Availability Forms Mgt".CalculateNeed always calculates FlowFields depended from "Transfer Line", partly shipped transfer, "Location Filter" = "Transfer To Code"
      Initialize;

      // [GIVEN] PROCEDURE CalculateNeed "CN" of Codeunit 353 calculates flowfields of Item "I", Gross Requirement "GR", Planned Order Receipt "PORcp", Scheduled Receipt "SR", Planned Order Releases "PORls";
      SetupTransferQuantities(InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [GIVEN] Item "I" has inventory = "IQ" at Location "L1" and no inventory at Location "L2"
      // [GIVEN] Partly shipped Transfer Line from "L1" to "L2" with "Quantity" = "TQ" and "Quantity Shipped" = "SQ"
      CreateItemInPartlyShippedTransferOrder(Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity);

      // [WHEN] Execute "CN" when "I"."Location Filter" is "L2"
      ItemAvailabilityFormsMgtCalculateNeed(
        Item,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases,TransferLine."Transfer-to Code");

      // [THEN] "I" has: "Inventory" = 0, "Qty. in Transit" = "SQ", "Trans. Ord. Shipment (Qty.)" = 0, "Trans. Ord. Receipt (Qty.)" = "TQ" - "SQ";
      VerifyItemPlanningFields(
        Item,0,ToShipQuantity,0,TransferQuantity - ToShipQuantity);

      // [THEN] "GR" = 0, "PORcp" = 0, "SR" = "TQ", "PORls" = 0.
      VerifyCalculatedNeed(
        0,TransferQuantity,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases);
    END;

    [Test]
    PROCEDURE ItemAvailabilityFormsMgtCalculateNeedAlwaysCALCFIELDSReceiveLFBlank@80();
    VAR
      Item@1000 : Record 27;
      TransferHeader@1006 : Record 5740;
      TransferLine@1005 : Record 5741;
      TransferQuantity@1004 : Decimal;
      InventoryQuantity@1007 : Decimal;
      ToShipQuantity@1008 : Decimal;
      ToReceiveQuantity@1009 : Decimal;
      GrossRequirement@1010 : Decimal;
      PlannedOrderReceipt@1003 : Decimal;
      ScheduledReceipt@1002 : Decimal;
      PlannedOrderReleases@1001 : Decimal;
    BEGIN
      // [FEATURE] [Transfer] [Item Availability]
      // [SCENARIO 209093] PROCEDURE "Item Availability Forms Mgt".CalculateNeed always calculates FlowFields depended from "Transfer Line", partly received transfer, "Location Filter" is blank
      Initialize;

      // [GIVEN] PROCEDURE CalculateNeed "CN" of Codeunit 353 calculates flowfields of Item "I", Gross Requirement "GR", Planned Order Receipt "PORcp", Scheduled Receipt "SR", Planned Order Releases "PORls";
      SetupTransferQuantities(InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [GIVEN] Item "I" has inventory = "IQ" at Location "L1" and no inventory at Location "L2"
      // [GIVEN] Partly received Transfer Line from "L1" to "L2" with "Quantity" = "TQ", "Quantity Shipped" = "SQ" and "Quantity Received" = "RQ"
      CreateItemInPartlyReceivedTransferOrder(
        Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [WHEN] Execute "CN" when "I"."Location Filter" is blank
      ItemAvailabilityFormsMgtCalculateNeed(
        Item,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases,'');

      // [THEN] "I" has: "Inventory" = "IQ", "Qty. in Transit" = "SQ" - "RQ", "Trans. Ord. Shipment (Qty.)" = "TQ" - "SQ", "Trans. Ord. Receipt (Qty.)" = "TQ" - "SQ";
      VerifyItemPlanningFields(
        Item,InventoryQuantity,ToShipQuantity - ToReceiveQuantity,TransferQuantity - ToShipQuantity,TransferQuantity - ToShipQuantity);

      // [THEN] "GR" = 0, "PORcp" = 0, "SR" = 0, "PORls" = 0.
      VerifyCalculatedNeed(
        0,0,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases);
    END;

    [Test]
    PROCEDURE ItemAvailabilityFormsMgtCalculateNeedAlwaysCALCFIELDSReceiveLFFrom@81();
    VAR
      Item@1000 : Record 27;
      TransferHeader@1006 : Record 5740;
      TransferLine@1005 : Record 5741;
      TransferQuantity@1004 : Decimal;
      InventoryQuantity@1007 : Decimal;
      ToShipQuantity@1008 : Decimal;
      ToReceiveQuantity@1009 : Decimal;
      GrossRequirement@1010 : Decimal;
      PlannedOrderReceipt@1003 : Decimal;
      ScheduledReceipt@1002 : Decimal;
      PlannedOrderReleases@1001 : Decimal;
    BEGIN
      // [FEATURE] [Transfer] [Item Availability]
      // [SCENARIO 209093] PROCEDURE "Item Availability Forms Mgt".CalculateNeed always calculates FlowFields depended from "Transfer Line", partly received transfer, "Location Filter" = "Transfer From Code"
      Initialize;

      // [GIVEN] PROCEDURE CalculateNeed "CN" of Codeunit 353 calculates flowfields of Item "I", Gross Requirement "GR", Planned Order Receipt "PORcp", Scheduled Receipt "SR", Planned Order Releases "PORls";
      SetupTransferQuantities(InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [GIVEN] Item "I" has inventory = "IQ" at Location "L1" and no inventory at Location "L2"
      // [GIVEN] Partly received Transfer Line from "L1" to "L2" with "Quantity" = "TQ", "Quantity Shipped" = "SQ" and "Quantity Received" = "RQ"
      CreateItemInPartlyReceivedTransferOrder(
        Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [WHEN] Execute "CN" when "I"."Location Filter" is "L1"
      ItemAvailabilityFormsMgtCalculateNeed(
        Item,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases,TransferLine."Transfer-from Code");

      // [THEN] "I" has: "Inventory" = "IQ" - "SQ", "Qty. in Transit" = 0, "Trans. Ord. Shipment (Qty.)" = "TQ" - "SQ", "Trans. Ord. Receipt (Qty.)" = 0;
      VerifyItemPlanningFields(
        Item,InventoryQuantity - ToShipQuantity,0,TransferQuantity - ToShipQuantity,0);

      // [THEN] "GR" = "TQ" - "SQ", "PORcp" = 0, "SR" = 0, "PORls" = 0.
      VerifyCalculatedNeed(
        TransferQuantity - ToShipQuantity,0,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases);
    END;

    [Test]
    PROCEDURE ItemAvailabilityFormsMgtCalculateNeedAlwaysCALCFIELDSReceiveLFTo@82();
    VAR
      Item@1000 : Record 27;
      TransferHeader@1006 : Record 5740;
      TransferLine@1005 : Record 5741;
      TransferQuantity@1004 : Decimal;
      InventoryQuantity@1007 : Decimal;
      ToShipQuantity@1008 : Decimal;
      ToReceiveQuantity@1009 : Decimal;
      GrossRequirement@1010 : Decimal;
      PlannedOrderReceipt@1003 : Decimal;
      ScheduledReceipt@1002 : Decimal;
      PlannedOrderReleases@1001 : Decimal;
    BEGIN
      // [FEATURE] [Transfer] [Item Availability]
      // [SCENARIO 209093]  PROCEDURE "Item Availability Forms Mgt".CalculateNeed always calculates FlowFields depended from "Transfer Line", partly received transfer, "Location Filter" = "Transfer To Code"
      Initialize;

      // [GIVEN] PROCEDURE CalculateNeed "CN" of Codeunit 353 calculates flowfields of Item "I", Gross Requirement "GR", Planned Order Receipt "PORcp", Scheduled Receipt "SR", Planned Order Releases "PORls";
      SetupTransferQuantities(InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [GIVEN] Item "I" has inventory = "IQ" at Location "L1" and no inventory at Location "L2"
      // [GIVEN] Partly received Transfer Line from "L1" to "L2" with "Quantity" = "TQ", "Quantity Shipped" = "SQ" and "Quantity Received" = "RQ"
      CreateItemInPartlyReceivedTransferOrder(
        Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [WHEN] Execute "CN" when "I"."Location Filter" is "L2"
      ItemAvailabilityFormsMgtCalculateNeed(
        Item,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases,TransferLine."Transfer-to Code");

      // [THEN] "I" has: "Inventory" = "RQ", "Qty. in Transit" = "SQ" - "RQ", "Trans. Ord. Shipment (Qty.)" = 0, "Trans. Ord. Receipt (Qty.)" = "TQ" - "SQ";
      VerifyItemPlanningFields(
        Item,ToReceiveQuantity,ToShipQuantity - ToReceiveQuantity,0,TransferQuantity - ToShipQuantity);

      // [THEN] "GR" = 0, "PORcp" = 0, "SR" = "TQ" - "RQ", "PORls" = 0.
      VerifyCalculatedNeed(
        0,TransferQuantity - ToReceiveQuantity,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases);
    END;

    [Test]
    [HandlerFunctions(ItemAvailabilityLineListHandler)]
    PROCEDURE ItemAvailabilityFormsMgtShowItemAvailLineListLFBlank@61();
    VAR
      Item@1000 : Record 27;
      TransferHeader@1006 : Record 5740;
      TransferLine@1005 : Record 5741;
      TransferQuantity@1004 : Decimal;
      InventoryQuantity@1007 : Decimal;
      ToShipQuantity@1008 : Decimal;
      ToReceiveQuantity@1009 : Decimal;
    BEGIN
      // [FEATURE] [Transfer] [Item Availability]
      // [SCENARIO 209093] The PROCEDURE "Item Availability Forms Mgt".ShowItemAvailLineList doesn't calculate Item FlowFields, case "Location Filter" is blank
      Initialize;

      // [GIVEN] PROCEDURE ShowItemAvailLineList "SIALL" of Codeunit 353 "Item Availability Forms Mgt" has VAR output parameter Item "I";
      SetupTransferQuantities(InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [GIVEN] Item "I" has inventory = "IQ" at Location "L1" and no inventory at Location "L2";
      // [GIVEN] Partly received Transfer Line from "L1" to "L2" with "Quantity" = "TQ", "Quantity Shipped" = "SQ" and "Quantity Received" = "RQ";
      CreateItemInPartlyReceivedTransferOrder(
        Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [WHEN] Execute "SIALL" when "I"."Location Filter" is blank
      ItemAvailabilityFormsMgtShowItemAvailLineList(Item,'');

      // [THEN] "I" has: "Inventory" = 0, "Qty. in Transit" = 0, "Trans. Ord. Shipment (Qty.)" = 0, "Trans. Ord. Receipt (Qty.)" = 0.
      Item.TESTFIELD(Inventory,0);
      Item.TESTFIELD("Qty. in Transit",0);
      Item.TESTFIELD("Trans. Ord. Shipment (Qty.)",0);
      Item.TESTFIELD("Trans. Ord. Receipt (Qty.)",0);
    END;

    [Test]
    [HandlerFunctions(ItemAvailabilityLineListHandler)]
    PROCEDURE ItemAvailabilityFormsMgtShowItemAvailLineListLFFrom@71();
    VAR
      Item@1000 : Record 27;
      TransferHeader@1006 : Record 5740;
      TransferLine@1005 : Record 5741;
      TransferQuantity@1004 : Decimal;
      InventoryQuantity@1007 : Decimal;
      ToShipQuantity@1008 : Decimal;
      ToReceiveQuantity@1009 : Decimal;
    BEGIN
      // [FEATURE] [Transfer] [Item Availability]
      // [SCENARIO 209093] The PROCEDURE "Item Availability Forms Mgt".ShowItemAvailLineList doesn't calculate Item FlowFields, case "Location Filter" is "Transfer From Code"
      Initialize;

      // [GIVEN] PROCEDURE ShowItemAvailLineList "SIALL" of Codeunit 353 "Item Availability Forms Mgt" has VAR output parameter Item "I";
      SetupTransferQuantities(InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [GIVEN] Item "I" has inventory = "IQ" at Location "L1" and no inventory at Location "L2";
      // [GIVEN] Partly received Transfer Line from "L1" to "L2" with "Quantity" = "TQ", "Quantity Shipped" = "SQ" and "Quantity Received" = "RQ";
      CreateItemInPartlyReceivedTransferOrder(
        Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [WHEN] Execute "SIALL" when "I"."Location Filter" is "L1"
      ItemAvailabilityFormsMgtShowItemAvailLineList(Item,TransferLine."Transfer-from Code");

      // [THEN] "I" has: "Inventory" = 0, "Qty. in Transit" = 0, "Trans. Ord. Shipment (Qty.)" = 0, "Trans. Ord. Receipt (Qty.)" = 0.
      Item.TESTFIELD(Inventory,0);
      Item.TESTFIELD("Qty. in Transit",0);
      Item.TESTFIELD("Trans. Ord. Shipment (Qty.)",0);
      Item.TESTFIELD("Trans. Ord. Receipt (Qty.)",0);
    END;

    [Test]
    [HandlerFunctions(ItemAvailabilityLineListHandler)]
    PROCEDURE ItemAvailabilityFormsMgtShowItemAvailLineListLFTo@70();
    VAR
      Item@1000 : Record 27;
      TransferHeader@1006 : Record 5740;
      TransferLine@1005 : Record 5741;
      TransferQuantity@1004 : Decimal;
      InventoryQuantity@1007 : Decimal;
      ToShipQuantity@1008 : Decimal;
      ToReceiveQuantity@1009 : Decimal;
    BEGIN
      // [FEATURE] [Transfer] [Item Availability]
      // [SCENARIO 209093] The PROCEDURE "Item Availability Forms Mgt".ShowItemAvailLineList doesn't calculate Item FlowFields, case "Location Filter" is "Transfer To Code"
      Initialize;

      // [GIVEN] PROCEDURE ShowItemAvailLineList "SIALL" of Codeunit 353 "Item Availability Forms Mgt" has VAR output parameter Item "I";
      SetupTransferQuantities(InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [GIVEN] Item "I" has inventory = "IQ" at Location "L1" and no inventory at Location "L2";
      // [GIVEN] Partly received Transfer Line from "L1" to "L2" with "Quantity" = "TQ", "Quantity Shipped" = "SQ" and "Quantity Received" = "RQ";
      CreateItemInPartlyReceivedTransferOrder(
        Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity,ToReceiveQuantity);

      // [WHEN] Execute "SIALL" when "I"."Location Filter" is "L2"
      ItemAvailabilityFormsMgtShowItemAvailLineList(Item,TransferLine."Transfer-to Code");

      // [THEN] "I" has: "Inventory" = 0, "Qty. in Transit" = 0, "Trans. Ord. Shipment (Qty.)" = 0, "Trans. Ord. Receipt (Qty.)" = 0.
      Item.TESTFIELD(Inventory,0);
      Item.TESTFIELD("Qty. in Transit",0);
      Item.TESTFIELD("Trans. Ord. Shipment (Qty.)",0);
      Item.TESTFIELD("Trans. Ord. Receipt (Qty.)",0);
    END;

    [Test]
    PROCEDURE PurchaseVariantZeroLineDiscount@57();
    VAR
      ItemVariant@1003 : Record 5401;
      PurchaseLine@1001 : Record 39;
      VendorNo@1002 : Code[20];
    BEGIN
      // [FEATURE] [Purchase] [Variant] [Discount]
      // [SCENARIO 208048] Zero discounts must be transferred to purchase document from "Purchase Line Discount"
      Initialize;

      // [GIVEN] Variant "IV" of Item "I"
      LibraryInventory.CreateItemVariant(ItemVariant,LibraryInventory.CreateItemNo);

      // [GIVEN] Vendor "V"
      VendorNo := LibraryPurchase.CreateVendorNo;

      // [GIVEN] Purchase Line Discount "IPLD" for "V" and "I", "IPLD"."Minimum Quantity" = 0, "IPLD"."Variant Code" is blank, "IPLD"."Line Discount %" > 0;
      // [GIVEN] Purchase Line Discount "VPLD" for "V", "I" and "IV", "VPLD"."Minimum Quantity" = 0, "VPLD"."Variant Code" = "IV", "VPLD"."Line Discount %" = 0;
      // [GIVEN] Purchase Line "L" with "No." = "I"."No." and Quantity > 0 has "Line Discount %" = "IPLD"."Line Discount %"
      CreateZeroForVariantPurchaseLineDiscount(ItemVariant,VendorNo);

      // [WHEN] Set "Variant Code" = "IV" in "L"
      CreatePurchaseOrderLineWithItemVariant(PurchaseLine,ItemVariant,VendorNo);

      // [THEN] "L"."Line Discount %" = 0
      PurchaseLine.TESTFIELD("Line Discount %",0);
    END;

    [Test]
    PROCEDURE SalesVariantZeroLineDiscount@76();
    VAR
      ItemVariant@1003 : Record 5401;
      SalesLine@1001 : Record 37;
      CustomerNo@1005 : Code[20];
    BEGIN
      // [FEATURE] [Sales] [Variant] [Discount]
      // [SCENARIO 208048] Zero discounts must be transferred to sales document from "Sales Line Discount"
      Initialize;

      // [GIVEN] Variant "IV" of Item "I"
      LibraryInventory.CreateItemVariant(ItemVariant,LibraryInventory.CreateItemNo);

      // [GIVEN] Customer "C"
      CustomerNo := LibrarySales.CreateCustomerNo;

      // [GIVEN] Sales Line Discount "ISLD" for "C" and "I", "ISLD"."Minimum Quantity" = 0, "ISLD"."Variant Code" is blank, "ISLD"."Line Discount %" > 0;
      // [GIVEN] Sales Line Discount "VSLD" for "C", "I" and "IV", "VSLD"."Minimum Quantity" = 0, "VSLD"."Variant Code" = "IV", "VSLD"."Line Discount %" = 0;
      // [GIVEN] Sales Line "L" with "No." = "I"."No." and Quantity > 0 has "Line Discount %" = "IPLD"."Line Discount %"
      CreateZeroForVariantSalesLineDiscount(ItemVariant,CustomerNo);

      // [WHEN] Set "Variant Code" = "IV" in "L"
      CreateSalesOrderLineWithItemVariant(SalesLine,ItemVariant,CustomerNo);

      // [THEN] "L"."Line Discount %" = 0
      SalesLine.TESTFIELD("Line Discount %",0);
    END;

    [Test]
    PROCEDURE JobPlanningLineVariantZeroLineDiscount@90();
    VAR
      ItemVariant@1003 : Record 5401;
      JobTask@1001 : Record 1001;
      JobPlanningLine@1007 : Record 1003;
      CustomerNo@1005 : Code[20];
    BEGIN
      // [FEATURE] [Job Planning] [Variant] [Discount]
      // [SCENARIO 208048] Zero discounts must be transferred to "Job Planning Line" from "Sales Line Discount"
      Initialize;

      // [GIVEN] Variant "IV" of Item "I"
      LibraryInventory.CreateItemVariant(ItemVariant,LibraryInventory.CreateItemNo);

      // [GIVEN] Customer "C"
      CustomerNo := CreateJobTask(JobTask);

      // [GIVEN] Sales Line Discount "ISLD" for "C" and "I", "ISLD"."Minimum Quantity" = 0, "ISLD"."Variant Code" is blank, "ISLD"."Line Discount %" > 0;
      // [GIVEN] Sales Line Discount "VSLD" for "C", "I" and "IV", "VSLD"."Minimum Quantity" = 0, "VSLD"."Variant Code" = "IV", "VSLD"."Line Discount %" = 0;
      // [GIVEN] "Job Planning Line" "L" with "No." = "I"."No." and Quantity > 0 has "Line Discount %" = "IPLD"."Line Discount %"
      CreateZeroForVariantSalesLineDiscount(ItemVariant,CustomerNo);

      // [WHEN] Set "Variant Code" = "IV" in "L"
      CreateJobPlanningLineWithItemVariant(JobPlanningLine,JobTask,ItemVariant);

      // [THEN] "L"."Line Discount %" = 0
      JobPlanningLine.TESTFIELD("Line Discount %",0);
    END;

    [Test]
    PROCEDURE JobJournalLineVariantZeroLineDiscount@103();
    VAR
      ItemVariant@1003 : Record 5401;
      JobTask@1001 : Record 1001;
      JobJournalLine@1007 : Record 210;
      CustomerNo@1005 : Code[20];
    BEGIN
      // [FEATURE] [Job Journal] [Variant] [Discount]
      // [SCENARIO 208048] Zero discounts must be transferred to "Job Journal Line" from "Sales Line Discount"
      Initialize;

      // [GIVEN] Variant "IV" of Item "I"
      LibraryInventory.CreateItemVariant(ItemVariant,LibraryInventory.CreateItemNo);

      // [GIVEN] Customer "C"
      CustomerNo := CreateJobTask(JobTask);

      // [GIVEN] Sales Line Discount "ISLD" for "C" and "I", "ISLD"."Minimum Quantity" = 0, "ISLD"."Variant Code" is blank, "ISLD"."Line Discount %" > 0;
      // [GIVEN] Sales Line Discount "VSLD" for "C", "I" and "IV", "VSLD"."Minimum Quantity" = 0, "VSLD"."Variant Code" = "IV", "VSLD"."Line Discount %" = 0;
      // [GIVEN] "Job Journal Line" "L" with "No." = "I"."No." and Quantity > 0 has "Line Discount %" = "IPLD"."Line Discount %"
      CreateZeroForVariantSalesLineDiscount(ItemVariant,CustomerNo);

      // [WHEN] Set "Variant Code" = "IV" in "L"
      CreateJobJournalLineWithItemVariant(JobJournalLine,JobTask,ItemVariant);

      // [THEN] "L"."Line Discount %" = 0
      JobJournalLine.TESTFIELD("Line Discount %",0);
    END;

    LOCAL PROCEDURE Initialize@4();
    VAR
      LibraryERMCountryData@1002 : Codeunit 131305;
    BEGIN
      LibraryVariableStorage.Clear;

      // Lazy Setup.
      IF isInitialized THEN
        EXIT;
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdatePurchasesPayablesSetup;
      LibraryERMCountryData.UpdateGeneralLedgerSetup;
      LibraryERMCountryData.UpdateGeneralPostingSetup;

      isInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE CreatePurchaseOrderLineWithItemVariant@108(VAR PurchaseLine@1000 : Record 39;ItemVariant@1002 : Record 5401;VendorNo@1003 : Code[20]);
    VAR
      PurchaseHeader@1001 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchaseDocumentWithItem(
        PurchaseHeader,PurchaseLine,PurchaseHeader."Document Type"::Order,VendorNo,
        ItemVariant."Item No.",LibraryRandom.RandIntInRange(10,20),'',WORKDATE);
      PurchaseLine.VALIDATE("Variant Code",ItemVariant.Code);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesOrderLineWithItemVariant@127(VAR SalesLine@1000 : Record 37;ItemVariant@1002 : Record 5401;CustomerNo@1003 : Code[20]);
    VAR
      SalesHeader@1001 : Record 36;
    BEGIN
      LibrarySales.CreateSalesDocumentWithItem(
        SalesHeader,SalesLine,SalesHeader."Document Type"::Order,CustomerNo,
        ItemVariant."Item No.",LibraryRandom.RandIntInRange(10,20),'',WORKDATE);
      SalesLine.VALIDATE("Variant Code",ItemVariant.Code);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateJobTask@130(VAR JobTask@1000 : Record 1001) : Code[20];
    VAR
      Job@1002 : Record 167;
    BEGIN
      LibraryJob.CreateJob(Job);
      LibraryJob.CreateJobTask(Job,JobTask);
      EXIT(Job."Bill-to Customer No.");
    END;

    LOCAL PROCEDURE CreateJobPlanningLineWithItemVariant@136(VAR JobPlanningLine@1000 : Record 1003;JobTask@1002 : Record 1001;ItemVariant@1003 : Record 5401);
    BEGIN
      LibraryJob.CreateJobPlanningLine(
        JobPlanningLine."Line Type"::"Both Schedule and Contract",JobPlanningLine.Type::Item,JobTask,JobPlanningLine);
      JobPlanningLine.VALIDATE("No.",ItemVariant."Item No.");
      JobPlanningLine.VALIDATE("Variant Code",ItemVariant.Code);
      JobPlanningLine.VALIDATE(Quantity,LibraryRandom.RandIntInRange(10,20));
      JobPlanningLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateJobJournalLineWithItemVariant@141(VAR JobJournalLine@1001 : Record 210;JobTask@1002 : Record 1001;ItemVariant@1003 : Record 5401);
    BEGIN
      LibraryJob.CreateJobJournalLine(JobJournalLine."Line Type"::"Both Schedule and Contract",JobTask,JobJournalLine);
      JobJournalLine.VALIDATE(Type,JobJournalLine.Type::Item);
      JobJournalLine.VALIDATE("No.",ItemVariant."Item No.");
      JobJournalLine.VALIDATE("Variant Code",ItemVariant.Code);
      JobJournalLine.VALIDATE(Quantity,LibraryRandom.RandIntInRange(10,20));
      JobJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateZeroForVariantPurchaseLineDiscount@115(ItemVariant@1001 : Record 5401;VendorNo@1000 : Code[20]);
    VAR
      ItemBlankVariantPurchaseLineDiscount@1004 : Record 7014;
      ItemWithVariantPurchaseLineDiscount@1002 : Record 7014;
    BEGIN
      LibraryERM.CreateLineDiscForVendor(
        ItemBlankVariantPurchaseLineDiscount,ItemVariant."Item No.",VendorNo,WORKDATE,'','','',0);
      ItemBlankVariantPurchaseLineDiscount.VALIDATE("Line Discount %",LibraryRandom.RandIntInRange(10,20));
      ItemBlankVariantPurchaseLineDiscount.MODIFY(TRUE);
      LibraryERM.CreateLineDiscForVendor(
        ItemWithVariantPurchaseLineDiscount,ItemVariant."Item No.",VendorNo,WORKDATE,'',ItemVariant.Code,'',0);
    END;

    LOCAL PROCEDURE CreateZeroForVariantSalesLineDiscount@121(ItemVariant@1001 : Record 5401;CustomerNo@1003 : Code[20]);
    VAR
      ItemBlankVariantSalesLineDiscount@1007 : Record 7004;
      ItemWithVariantSalesLineDiscount@1006 : Record 7004;
    BEGIN
      LibraryERM.CreateLineDiscForCustomer(
        ItemBlankVariantSalesLineDiscount,ItemBlankVariantSalesLineDiscount.Type::Item,ItemVariant."Item No.",
        ItemBlankVariantSalesLineDiscount."Sales Type"::Customer,CustomerNo,WORKDATE,'','','',0);
      ItemBlankVariantSalesLineDiscount.VALIDATE("Line Discount %",LibraryRandom.RandIntInRange(10,20));
      ItemBlankVariantSalesLineDiscount.MODIFY(TRUE);

      LibraryERM.CreateLineDiscForCustomer(
        ItemWithVariantSalesLineDiscount,ItemWithVariantSalesLineDiscount.Type::Item,ItemVariant."Item No.",
        ItemWithVariantSalesLineDiscount."Sales Type"::Customer,CustomerNo,WORKDATE,'',ItemVariant.Code,'',0);
    END;

    LOCAL PROCEDURE SetupTransferQuantities@68(VAR TransferQuantity@1003 : Decimal;VAR InventoryQuantity@1002 : Decimal;VAR ToShipQuantity@1001 : Decimal;VAR ToReceiveQuantity@1000 : Decimal);
    BEGIN
      ToReceiveQuantity := LibraryRandom.RandIntInRange(10,100);
      ToShipQuantity := ToReceiveQuantity + LibraryRandom.RandIntInRange(10,100);
      TransferQuantity := ToShipQuantity + LibraryRandom.RandIntInRange(10,100);
      InventoryQuantity := TransferQuantity + LibraryRandom.RandIntInRange(10,100);
    END;

    LOCAL PROCEDURE AcceptAndCarryOutActionMessage@41(ItemNo@1000 : Code[20]);
    VAR
      RequisitionLine@1001 : Record 246;
    BEGIN
      RequisitionLine.SETRANGE("No.",ItemNo);
      RequisitionLine.FINDFIRST;
      RequisitionLine.VALIDATE("Accept Action Message",TRUE);
      RequisitionLine.MODIFY(TRUE);
      LibraryPlanning.CarryOutActionMsgPlanWksh(RequisitionLine);
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrder@46(VAR PurchaseLine@1000 : Record 39;ItemNo@1002 : Code[20];Invoice@1004 : Boolean) : Code[20];
    BEGIN
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,ItemNo,'',CreateVendor,LibraryRandom.RandInt(10),WORKDATE);
      EXIT(PostPurchaseDocument(PurchaseLine,Invoice));
    END;

    LOCAL PROCEDURE CalculateRegPlanAndCarryOutActionMsg@88(ItemNo@1000 : Code[20]);
    VAR
      RequisitionLine@1003 : Record 246;
      RequisitionWkshName@1002 : Record 245;
      ReqWkshTemplate@1001 : Record 244;
      Item@1004 : Record 27;
    BEGIN
      Item.GET(ItemNo);
      ReqWkshTemplate.SETRANGE(Type,ReqWkshTemplate.Type::Planning);
      ReqWkshTemplate.FINDFIRST;
      LibraryPlanning.CreateRequisitionWkshName(RequisitionWkshName,ReqWkshTemplate.Name);
      LibraryPlanning.CreateRequisitionLine(RequisitionLine,ReqWkshTemplate.Name,RequisitionWkshName.Name);
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item,WORKDATE,WORKDATE);
      AcceptAndCarryOutActionMessage(ItemNo);
    END;

    LOCAL PROCEDURE CreateAndModifyItem@26(VendorNo@1001 : Code[20];FlushingMethod@1003 : Option;ReplenishmentSystem@1002 : Option) : Code[20];
    VAR
      Item@1000 : Record 27;
    BEGIN
      Item.GET(CreateItem);
      Item.VALIDATE("Reordering Policy",Item."Reordering Policy"::"Lot-for-Lot");
      Item.VALIDATE("Vendor No.",VendorNo);
      Item.VALIDATE("Replenishment System",ReplenishmentSystem);
      Item.VALIDATE("Flushing Method",FlushingMethod);
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateAndModifyVendor@12(CurrencyCode@1001 : Code[10]) : Code[20];
    VAR
      Vendor@1000 : Record 23;
    BEGIN
      Vendor.GET(CreateVendor);
      Vendor.VALIDATE("Currency Code",CurrencyCode);
      Vendor.MODIFY(TRUE);
      EXIT(Vendor."No.");
    END;

    LOCAL PROCEDURE CreateAndCertifyProductionBOM@77(VAR ProductionBOMHeader@1000 : Record 99000771;BaseUnitOfMeasure@1003 : Code[10];No@1004 : Code[20];RoutingLinkCode@1001 : Code[10]);
    VAR
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,BaseUnitOfMeasure);
      LibraryManufacturing.CreateProductionBOMLine(ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,No,1);  // Use blank value for Version Code and 1 for Quantity per.
      ProductionBOMLine.VALIDATE("Routing Link Code",RoutingLinkCode);
      ProductionBOMLine.MODIFY(TRUE);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateCurrency@99() : Code[10];
    VAR
      Currency@1000 : Record 4;
    BEGIN
      LibraryERM.CreateCurrency(Currency);
      LibraryERM.CreateRandomExchangeRate(Currency.Code);
      EXIT(Currency.Code);
    END;

    LOCAL PROCEDURE CreateCustomer@19() : Code[20];
    VAR
      Customer@1000 : Record 18;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      EXIT(Customer."No.");
    END;

    LOCAL PROCEDURE CreateLocationsChain@49(VAR FromLocation@1007 : Record 14;VAR ToLocation@1005 : Record 14;VAR TransitLocation@1000 : Record 14);
    VAR
      TransferRoute@1002 : Record 5742;
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(FromLocation);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(ToLocation);
      LibraryWarehouse.CreateInTransitLocation(TransitLocation);
      LibraryWarehouse.CreateAndUpdateTransferRoute(TransferRoute,FromLocation.Code,ToLocation.Code,TransitLocation.Code,'','');
    END;

    LOCAL PROCEDURE CreateItem@22() : Code[20];
    VAR
      Item@1000 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Last Direct Cost",LibraryRandom.RandInt(10));
      Item.VALIDATE("Unit Cost",LibraryRandom.RandInt(10));
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateItemWithInventory@97(VAR Item@1001 : Record 27;LocationCode@1000 : Code[10];InventoryQuantity@1002 : Decimal);
    BEGIN
      LibraryInventory.CreateItem(Item);
      UpdateInventory(Item."No.",LocationCode,InventoryQuantity);
    END;

    LOCAL PROCEDURE CreateItemInTransferOrder@50(VAR Item@1001 : Record 27;VAR TransferHeader@1000 : Record 5740;VAR TransferLine@1003 : Record 5741;InventoryQuantity@1002 : Decimal;TransferQuantity@1007 : Decimal;ToShipQuantity@1008 : Decimal);
    VAR
      FromLocation@1006 : Record 14;
      ToLocation@1005 : Record 14;
      TransitLocation@1004 : Record 14;
    BEGIN
      CreateLocationsChain(FromLocation,ToLocation,TransitLocation);
      CreateItemWithInventory(Item,FromLocation.Code,InventoryQuantity);
      CreateTransferOrder(
        TransferHeader,TransferLine,Item."No.",FromLocation.Code,ToLocation.Code,TransitLocation.Code,TransferQuantity);
      UpdateTransferLineQtyToShip(TransferLine,ToShipQuantity);
    END;

    LOCAL PROCEDURE CreateItemInPartlyShippedTransferOrder@72(VAR Item@1001 : Record 27;VAR TransferHeader@1000 : Record 5740;VAR TransferLine@1003 : Record 5741;InventoryQuantity@1002 : Decimal;TransferQuantity@1007 : Decimal;ToShipQuantity@1008 : Decimal);
    BEGIN
      CreateItemInTransferOrder(Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity);
      LibraryWarehouse.PostTransferOrder(TransferHeader,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateItemInPartlyReceivedTransferOrder@75(VAR Item@1001 : Record 27;VAR TransferHeader@1000 : Record 5740;VAR TransferLine@1003 : Record 5741;InventoryQuantity@1002 : Decimal;TransferQuantity@1007 : Decimal;ToShipQuantity@1008 : Decimal;ToReceiveQuantity@1009 : Decimal);
    BEGIN
      CreateItemInPartlyShippedTransferOrder(Item,TransferHeader,TransferLine,InventoryQuantity,TransferQuantity,ToShipQuantity);
      UpdateTransferLineQtyToReceive(TransferLine,ToReceiveQuantity);
      LibraryWarehouse.PostTransferOrder(TransferHeader,FALSE,TRUE);
    END;

    LOCAL PROCEDURE CreateItemCrossReference@54(VAR ItemCrossReference@1000 : Record 5717;ItemNo@1001 : Code[20];VendorNo@1002 : Code[20]);
    VAR
      StrLen@1003 : Integer;
    BEGIN
      StrLen := MAXSTRLEN(ItemCrossReference.Description);
      LibraryInventory.CreateItemCrossReference(ItemCrossReference,ItemNo,ItemCrossReference."Cross-Reference Type"::Vendor,VendorNo);
      ItemCrossReference.Description := COPYSTR(LibraryUtility.GenerateRandomText(StrLen),1,StrLen);
      ItemCrossReference.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemJournalLine@23(VAR ItemJournalLine@1000 : Record 83;ItemNo@1003 : Code[20];VariantCode@1002 : Code[10];LocationCode@1004 : Code[10];BinCode@1005 : Code[20]);
    VAR
      ItemJournalBatch@1001 : Record 233;
    BEGIN
      SelectAndClearItemJournalBatch(ItemJournalBatch,ItemJournalBatch."Template Type"::Item);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,10 + LibraryRandom.RandInt(10)); // Use random Quantity.
      ItemJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(10,2)); // Using Random value for Unit Cost.
      ItemJournalLine.VALIDATE("Variant Code",VariantCode);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.VALIDATE("Bin Code",BinCode);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreatePositiveAdjmtItemJournalLine@55(VAR ItemJournalLine@1000 : Record 83;ItemNo@1003 : Code[20];LocationCode@1004 : Code[10];Quantity@1002 : Decimal);
    VAR
      ItemJournalBatch@1001 : Record 233;
    BEGIN
      SelectAndClearItemJournalBatch(ItemJournalBatch,ItemJournalBatch."Template Type"::Item);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Quantity);
      ItemJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(10,2));
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemWithVendor@56(VAR Item@1000 : Record 27);
    VAR
      Vendor@1001 : Record 23;
    BEGIN
      LibraryPurchase.CreateVendor(Vendor);
      Item.GET(CreateAndModifyItem(Vendor."No.",Item."Flushing Method"::Backward,Item."Replenishment System"::Purchase));
      Item.VALIDATE("Vendor No.",Vendor."No.");
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateOutputJournal@86(VAR ItemJournalLine@1000 : Record 83;ItemNo@1002 : Code[20];ProductionOrderNo@1001 : Code[20];OperationNo@1005 : Code[10];OutputQuantity@1006 : Decimal;AppliesToEntry@1007 : Integer);
    VAR
      ItemJournalTemplate@1003 : Record 82;
      ItemJournalBatch@1004 : Record 233;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Output);
      SelectAndClearItemJournalBatch(ItemJournalBatch,ItemJournalBatch."Template Type"::Output);
      LibraryManufacturing.CreateOutputJournal(ItemJournalLine,ItemJournalTemplate,ItemJournalBatch,ItemNo,ProductionOrderNo);
      ItemJournalLine.VALIDATE("Operation No.",OperationNo);
      ItemJournalLine.VALIDATE("Output Quantity",OutputQuantity);
      ItemJournalLine.VALIDATE("Applies-to Entry",AppliesToEntry);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreatePhysInvtCountingPeriod@17(CountFrequency@1000 : Integer) : Code[10];
    VAR
      PhysInvtCountingPeriod@1001 : Record 7381;
    BEGIN
      LibraryInventory.CreatePhysicalInventoryCountingPeriod(PhysInvtCountingPeriod);
      PhysInvtCountingPeriod.VALIDATE("Count Frequency per Year",CountFrequency);
      PhysInvtCountingPeriod.MODIFY(TRUE);
      EXIT(PhysInvtCountingPeriod.Code);
    END;

    LOCAL PROCEDURE CreatePurchaseDocument@65(VAR PurchaseLine@1000 : Record 39;DocumentType@1004 : Option;ItemNo@1003 : Code[20];VariantCode@1001 : Code[10];VendorNo@1006 : Code[20];Quantity@1007 : Decimal;OrderDate@1008 : Date);
    VAR
      PurchaseHeader@1002 : Record 38;
      GLAccount@1011 : Record 15;
      GeneralPostingSetup@1012 : Record 252;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,DocumentType,VendorNo);
      PurchaseHeader.VALIDATE("Order Date",OrderDate);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity);
      PurchaseLine.VALIDATE("Variant Code",VariantCode);
      PurchaseLine.MODIFY(TRUE);

      // Update 'Invt. Accrual Acc. (Interim)' in General Posting Setup.
      LibraryERM.FindGLAccount(GLAccount);
      GeneralPostingSetup.GET(PurchaseLine."Gen. Bus. Posting Group",PurchaseLine."Gen. Prod. Posting Group");
      GeneralPostingSetup.VALIDATE("Invt. Accrual Acc. (Interim)",GLAccount."No.");
      GeneralPostingSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreatePurchaseLineDiscount@27(VAR PurchaseLineDiscount@1000 : Record 7014);
    BEGIN
      LibraryERM.CreateLineDiscForVendor(
        PurchaseLineDiscount,CreateItem,CreateVendor,WORKDATE,'','','',LibraryRandom.RandDec(10,2));  // Take random for Quantity.
      PurchaseLineDiscount.VALIDATE("Line Discount %",LibraryRandom.RandDec(10,2));  // Take random for Line Discount Pct.
      PurchaseLineDiscount.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreatePurchasePrice@15(VAR PurchasePrice@1000 : Record 7012;CurrencyCode@1001 : Code[10];VendorNo@1003 : Code[20];StartingDate@1005 : Date);
    VAR
      Item@1002 : Record 27;
      ItemNo@1004 : Code[20];
    BEGIN
      ItemNo := CreateAndModifyItem(VendorNo,Item."Flushing Method"::Manual,Item."Replenishment System"::Purchase);
      LibraryCosting.CreatePurchasePrice(
        PurchasePrice,VendorNo,ItemNo,StartingDate,CurrencyCode,'','',LibraryRandom.RandDec(10,2));  // Take random for Quantity.
      PurchasePrice.VALIDATE("Direct Unit Cost",LibraryRandom.RandDec(10,2));  // take random for Direct Unit Cost.
      PurchasePrice.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRoutingSetup@166(WorkCenterNo@1001 : Code[20];RoutingLinkCode@1000 : Code[10]) : Code[20];
    VAR
      RoutingHeader@1002 : Record 99000763;
      RoutingLine@1004 : Record 99000764;
    BEGIN
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);
      CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenterNo);
      RoutingLine.VALIDATE("Routing Link Code",RoutingLinkCode);
      RoutingLine.MODIFY(TRUE);
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
      EXIT(RoutingHeader."No.");
    END;

    LOCAL PROCEDURE CreateRoutingLine@165(VAR RoutingLine@1003 : Record 99000764;RoutingHeader@1000 : Record 99000763;CenterNo@1002 : Code[20]);
    VAR
      OperationNo@1001 : Code[10];
    BEGIN
      // Random value used so that the Next Operation No is greater than the previous Operation No.
      OperationNo := FindLastOperationNo(RoutingHeader."No.") + FORMAT(LibraryRandom.RandInt(5));
      LibraryManufacturing.CreateRoutingLineSetup(
        RoutingLine,RoutingHeader,CenterNo,OperationNo,LibraryRandom.RandInt(5),LibraryRandom.RandInt(5));
    END;

    LOCAL PROCEDURE CreateSalesDocument@87(VAR SalesLine@1003 : Record 37;DocumentType@1007 : Option;ItemNo@1004 : Code[20];VariantCode@1002 : Code[10];Quantity@1001 : Decimal);
    VAR
      SalesHeader@1000 : Record 36;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,DocumentType,CreateCustomer);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
      SalesLine.VALIDATE("Unit Price",LibraryRandom.RandInt(10));  // Take random for Unit Price.
      SalesLine.VALIDATE("Variant Code",VariantCode);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateVendor@11() : Code[20];
    VAR
      Vendor@1000 : Record 23;
    BEGIN
      LibraryPurchase.CreateVendor(Vendor);
      EXIT(Vendor."No.");
    END;

    LOCAL PROCEDURE CreateTransferOrder@51(VAR TransferHeader@1003 : Record 5740;VAR TransferLine@1004 : Record 5741;ItemNo@1002 : Code[20];FromLocationCode@1007 : Code[10];ToLocationCode@1000 : Code[10];TransitLocationCode@1005 : Code[10];Quantity@1001 : Decimal);
    BEGIN
      LibraryWarehouse.CreateTransferHeader(TransferHeader,FromLocationCode,ToLocationCode,TransitLocationCode);
      LibraryWarehouse.CreateTransferLine(TransferHeader,TransferLine,ItemNo,Quantity);
      TransferLine.VALIDATE("Receipt Date",WORKDATE);
      TransferLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ItemAvailabilityFormsMgtCalculateNeed@83(VAR Item@1001 : Record 27;VAR GrossRequirement@1005 : Decimal;VAR PlannedOrderReceipt@1004 : Decimal;VAR ScheduledReceipt@1003 : Decimal;VAR PlannedOrderReleases@1002 : Decimal;LocationFilter@1006 : Text);
    VAR
      ItemAvailabilityFormsMgt@1000 : Codeunit 353;
    BEGIN
      Item.INIT;
      Item.SETFILTER("Location Filter",LocationFilter);
      ItemAvailabilityFormsMgt.CalculateNeed(Item,GrossRequirement,PlannedOrderReceipt,ScheduledReceipt,PlannedOrderReleases);
    END;

    LOCAL PROCEDURE ItemAvailabilityFormsMgtShowItemAvailLineList@53(VAR Item@1001 : Record 27;LocationFilter@1006 : Text);
    VAR
      ItemAvailabilityFormsMgt@1000 : Codeunit 353;
    BEGIN
      Item.INIT;
      Item.SETRANGE("Date Filter",WORKDATE);
      Item.SETFILTER("Location Filter",LocationFilter);
      ItemAvailabilityFormsMgt.ShowItemAvailLineList(Item,4);
    END;

    LOCAL PROCEDURE FindAndUpdateProdCompLine@208(ProductionOrder@1000 : Record 5405;VariantCode@1002 : Code[10]);
    VAR
      ProdOrderComponent@1001 : Record 5407;
    BEGIN
      ProdOrderComponent.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderComponent.FINDFIRST;
      ProdOrderComponent.VALIDATE("Variant Code",VariantCode);
      ProdOrderComponent.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE FindCapacityLedgerEntry@59(VAR CapacityLedgerEntry@1000 : Record 5832;OrderNo@1001 : Code[20]);
    BEGIN
      CapacityLedgerEntry.SETRANGE("Order Type",CapacityLedgerEntry."Order Type"::Production);
      CapacityLedgerEntry.SETRANGE("Order No.",OrderNo);
      CapacityLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindItemLedgerEntry@35(VAR ItemLedgerEntry@1000 : Record 32;EntryType@1001 : Option;OrderNo@1002 : Code[20]);
    BEGIN
      ItemLedgerEntry.SETRANGE("Entry Type",EntryType);
      ItemLedgerEntry.SETRANGE("Order Type",ItemLedgerEntry."Order Type"::Production);
      ItemLedgerEntry.SETRANGE("Order No.",OrderNo);
      ItemLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindSalesLine@34(VAR SalesLine@1002 : Record 37;DocumentType@1000 : Option;DocumentNo@1001 : Code[20]);
    BEGIN
      SalesLine.SETRANGE("Document Type",DocumentType);
      SalesLine.SETRANGE("Document No.",DocumentNo);
      SalesLine.SETRANGE(Type,SalesLine.Type::Item);
      SalesLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindValueEntry@52(VAR ValueEntry@1000 : Record 5802;ItemLedgerEntryType@1002 : Option;DocumentNo@1001 : Code[20]);
    BEGIN
      ValueEntry.SETRANGE("Item Ledger Entry Type",ItemLedgerEntryType);
      ValueEntry.SETRANGE("Document No.",DocumentNo);
      ValueEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE GetNextCountingPeriod@20(Item@1000 : Record 27;VAR NextCountingStartDate@1003 : Date;VAR NextCountingEndDate@1004 : Date);
    VAR
      PhysInvtCountingPeriod@1001 : Record 7381;
      PhysInvtCountManagement@1002 : Codeunit 7380;
    BEGIN
      PhysInvtCountingPeriod.GET(Item."Phys Invt Counting Period Code");
      PhysInvtCountManagement.CalcPeriod(
        Item."Last Counting Period Update",NextCountingStartDate,NextCountingEndDate,
        PhysInvtCountingPeriod."Count Frequency per Year");
    END;

    LOCAL PROCEDURE GetOperationNo@62(OrderNo@1001 : Code[20]) : Code[10];
    VAR
      CapacityLedgerEntry@1000 : Record 5832;
    BEGIN
      FindCapacityLedgerEntry(CapacityLedgerEntry,OrderNo);
      EXIT(CapacityLedgerEntry."Operation No.");
    END;

    LOCAL PROCEDURE FindLastOperationNo@170(RoutingNo@1000 : Code[20]) : Code[10];
    VAR
      RoutingLine@1001 : Record 99000764;
    BEGIN
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      IF RoutingLine.FINDLAST THEN
        EXIT(RoutingLine."Operation No.");
      EXIT('');
    END;

    LOCAL PROCEDURE GetPostedDocumentLines@40(No@1000 : Code[20]);
    VAR
      SalesCreditMemo@1001 : TestPage 44;
    BEGIN
      SalesCreditMemo.OPENEDIT;
      SalesCreditMemo.FILTER.SETFILTER("No.",No);
      SalesCreditMemo.GetPostedDocumentLinesToReverse.INVOKE;
    END;

    LOCAL PROCEDURE GetSalesOrdersInRequisitionWorksheet@116(SalesLine@1000 : Record 37);
    VAR
      RequisitionWkshName@1002 : Record 245;
      RequisitionLine@1001 : Record 246;
    BEGIN
      LibraryPlanning.CreateRequisitionWkshName(RequisitionWkshName,LibraryPlanning.SelectRequisitionTemplateName);
      LibraryPlanning.CreateRequisitionLine(RequisitionLine,RequisitionWkshName."Worksheet Template Name",RequisitionWkshName.Name);
      LibraryPlanning.GetSalesOrders(SalesLine,RequisitionLine,0);
    END;

    LOCAL PROCEDURE InventorySetupEnqueues@140();
    BEGIN
      LibraryVariableStorage.Enqueue(UpdateAutomaticCostMessage);
      LibraryVariableStorage.Enqueue(UpdateExpCostConfMessage);
      LibraryVariableStorage.Enqueue(UpdateExpCostMessage);
      LibraryVariableStorage.Enqueue(UpdateAutomaticCostPeriodMessage);
    END;

    LOCAL PROCEDURE PostPurchaseDocument@63(PurchaseLine@1000 : Record 39;Invoice@1002 : Boolean) : Code[20];
    VAR
      PurchaseHeader@1001 : Record 38;
    BEGIN
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      EXIT(LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,Invoice));
    END;

    LOCAL PROCEDURE SelectAndClearItemJournalBatch@95(VAR ItemJournalBatch@1000 : Record 233;TemplateType@1002 : Option);
    VAR
      ItemJournalTemplate@1001 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,TemplateType);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
    END;

    LOCAL PROCEDURE SetupForPostOutputJournal@69(VAR ProductionOrder@1000 : Record 5405;ItemNo@1002 : Code[20]);
    VAR
      Item@1001 : Record 27;
      ItemJournalLine@1003 : Record 83;
      PurchaseLine@1004 : Record 39;
      PurchaseLine2@1005 : Record 39;
    BEGIN
      // Create Finished Item.
      Item.GET(CreateAndModifyItem('',Item."Flushing Method"::Backward,Item."Replenishment System"::"Prod. Order")); // Finished Item.

      // Update BOM and Routing on Item, create and post two Purchase Order with different 'Unit Cost'.
      UpdateItemWithCertifiedBOMAndRouting(Item,ItemNo);
      CreateAndPostPurchaseOrder(PurchaseLine,ItemNo,TRUE);

      CreatePurchaseDocument(
        PurchaseLine2,PurchaseLine2."Document Type"::Order,PurchaseLine."No.",'',CreateVendor,LibraryRandom.RandInt(10),
        WORKDATE);  // Used Rnadom for Quantity.
      PurchaseLine2.VALIDATE("Direct Unit Cost",(PurchaseLine2."Direct Unit Cost" + LibraryRandom.RandInt(10)));  // 'Direct Unit Cost' required more than previous Purchase Order.
      PurchaseLine2.MODIFY(TRUE);
      PostPurchaseDocument(PurchaseLine2,TRUE);

      // Create Released Production Order and create Output Journal, Explode Routing and Post.
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,Item."No.",
        LibraryRandom.RandInt(10));   // Used Random Int for Quantity.
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      CreateOutputJournal(ItemJournalLine,Item."No.",ProductionOrder."No.",'',0,0);  // 0s are used for 'Output Quantity' and 'Apply to Entry'.
      CODEUNIT.RUN(CODEUNIT::"Output Jnl.-Expl. Route",ItemJournalLine);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE UpdateItemWithCertifiedBOMAndRouting@32(VAR Item@1000 : Record 27;ItemNo@1002 : Code[20]);
    VAR
      ProductionBOMHeader@1001 : Record 99000771;
      RoutingLink@1005 : Record 99000777;
      WorkCenter@1007 : Record 99000754;
    BEGIN
      RoutingLink.FINDFIRST;
      WorkCenter.FINDFIRST;

      // Create Production BOM with Raouting Link Code.
      CreateAndCertifyProductionBOM(ProductionBOMHeader,Item."Base Unit of Measure",ItemNo,RoutingLink.Code);

      // Update Item with Prodouction BOM No. and Routing No.
      Item.VALIDATE("Production BOM No.",ProductionBOMHeader."No.");
      Item.VALIDATE("Routing No.",CreateRoutingSetup(WorkCenter."No.",RoutingLink.Code));
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateLineDiscOnPurchLineDisc@10(PurchaseLineDiscount@1000 : Record 7014) : Decimal;
    BEGIN
      PurchaseLineDiscount.VALIDATE("Line Discount %",PurchaseLineDiscount."Line Discount %" + LibraryRandom.RandDec(10,2));  // Take random to update Line Discount Pct.
      PurchaseLineDiscount.MODIFY(TRUE);
      EXIT(PurchaseLineDiscount."Line Discount %");
    END;

    LOCAL PROCEDURE UpdatePhysInvCountingPeriodOnItem@18(VAR Item@1000 : Record 27;CountFrequency@1001 : Integer);
    BEGIN
      WITH Item DO BEGIN
        GET(CreateItem);
        VALIDATE("Phys Invt Counting Period Code",CreatePhysInvtCountingPeriod(CountFrequency));
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE UpdatePurchLineQtyForPartialPost@47(VAR PurchaseLine@1000 : Record 39);
    BEGIN
      PurchaseLine.VALIDATE("Qty. to Receive",PurchaseLine."Qty. to Receive" / 2);
      PurchaseLine.VALIDATE("Qty. to Invoice",PurchaseLine."Qty. to Invoice" / 2);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateUnitCostOnPurchasePrice@42(PurchasePrice@1000 : Record 7012) : Decimal;
    BEGIN
      PurchasePrice.VALIDATE("Direct Unit Cost",PurchasePrice."Direct Unit Cost" + LibraryRandom.RandDec(10,2));  // Take random value to update Direct Unit Cost.
      PurchasePrice.MODIFY(TRUE);
      EXIT(PurchasePrice."Direct Unit Cost");
    END;

    LOCAL PROCEDURE UpdateInventory@60(ItemNo@1000 : Code[20];LocationCode@1001 : Code[10];Quantuty@1002 : Decimal);
    VAR
      ItemJournalLine@1003 : Record 83;
    BEGIN
      CreatePositiveAdjmtItemJournalLine(ItemJournalLine,ItemNo,LocationCode,Quantuty);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE UpdateTransferLineQtyToShip@91(VAR TransferLine@1000 : Record 5741;ToShipQuantity@1002 : Decimal);
    BEGIN
      TransferLine.VALIDATE("Qty. to Ship",ToShipQuantity);
      TransferLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateTransferLineQtyToReceive@89(VAR TransferLine@1000 : Record 5741;ToReceiveQuantity@1002 : Decimal);
    BEGIN
      TransferLine.FIND;
      TransferLine.VALIDATE("Qty. to Receive",ToReceiveQuantity);
      TransferLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE VerifyDescriptionsOnRequisitionLine@107(ItemNo@1000 : Code[20];Desc@1001 : Text;Desc2@1002 : Text);
    VAR
      RequisitionLine@1003 : Record 246;
    BEGIN
      WITH RequisitionLine DO BEGIN
        SETRANGE(Type,Type::Item);
        SETRANGE("No.",ItemNo);
        FINDFIRST;
        TESTFIELD(Description,Desc);
        TESTFIELD("Description 2",Desc2);
      END;
    END;

    LOCAL PROCEDURE VerifyGLEntry@207(DocumentType@1004 : Option;DocumentNo@1001 : Code[20];Amount@1002 : Decimal;GenPostingType@1003 : Option);
    VAR
      GLEntry@1000 : Record 17;
      ActualAmount@1005 : Decimal;
    BEGIN
      GLEntry.SETRANGE("Document Type",DocumentType);
      GLEntry.SETRANGE("Document No.",DocumentNo);
      GLEntry.SETRANGE("Gen. Posting Type",GenPostingType);
      GLEntry.FINDSET;
      REPEAT
        ActualAmount := GLEntry.Amount;
      UNTIL GLEntry.NEXT = 0;
      Assert.AreNearlyEqual(Amount,ActualAmount,LibraryERM.GetAmountRoundingPrecision,AmountError);
    END;

    LOCAL PROCEDURE VerifyPstdPurchaseInvoice@58(DocumentNo@1000 : Code[20];DirectUnitCost@1001 : Decimal;LineDiscountPct@1003 : Decimal);
    VAR
      PurchInvLine@1002 : Record 123;
    BEGIN
      PurchInvLine.SETRANGE("Document No.",DocumentNo);
      PurchInvLine.SETRANGE(Type,PurchInvLine.Type::Item);
      PurchInvLine.FINDFIRST;
      PurchInvLine.TESTFIELD("Direct Unit Cost",DirectUnitCost);
      PurchInvLine.TESTFIELD("Line Discount %",LineDiscountPct);
    END;

    LOCAL PROCEDURE VerifyValueEntry@28(ItemLedgerEntryType@1001 : Option;DocumentNo@1002 : Code[20];ItemNo@1003 : Code[20]);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      FindValueEntry(ValueEntry,ItemLedgerEntryType,DocumentNo);
      ValueEntry.TESTFIELD("Item No.",ItemNo);
    END;

    LOCAL PROCEDURE VerifyItemPlanningFields@125(VAR Item@1001 : Record 27;InventoryExpected@1000 : Decimal;QtyInTransitExpected@1002 : Decimal;TransOrdShipmentQtyExpected@1003 : Decimal;TransOrdReceiptQtyExpected@1004 : Decimal);
    BEGIN
      Item.TESTFIELD(Inventory,InventoryExpected);
      Item.TESTFIELD("Qty. in Transit",QtyInTransitExpected);
      Item.TESTFIELD("Trans. Ord. Shipment (Qty.)",TransOrdShipmentQtyExpected);
      Item.TESTFIELD("Trans. Ord. Receipt (Qty.)",TransOrdReceiptQtyExpected);
    END;

    LOCAL PROCEDURE VerifyCalculatedNeed@142(ExpectedGrossRequirement@1004 : Decimal;ExpectedScheduledReceipt@1006 : Decimal;ActualGrossRequirement@1003 : Decimal;ActualPlannedOrderReceipt@1002 : Decimal;ActualScheduledReceipt@1001 : Decimal;ActualPlannedOrderReleases@1000 : Decimal);
    BEGIN
      Assert.AreEqual(
        ExpectedGrossRequirement,ActualGrossRequirement,STRSUBSTNO(CalculateNeedVARParameterOutputValueErr,'GrossRequirement'));
      Assert.AreEqual(0,ActualPlannedOrderReceipt,STRSUBSTNO(CalculateNeedVARParameterOutputValueErr,'PlannedOrderReceipt'));
      Assert.AreEqual(
        ExpectedScheduledReceipt,ActualScheduledReceipt,STRSUBSTNO(CalculateNeedVARParameterOutputValueErr,'ScheduledReceipt'));
      Assert.AreEqual(0,ActualPlannedOrderReleases,STRSUBSTNO(CalculateNeedVARParameterOutputValueErr,'PlannedOrderReleases'));
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@25(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@21(Message@1000 : Text[1024]);
    BEGIN
    END;

    [ModalPageHandler]
    PROCEDURE PostedSalesDocumentLinesHandler@16(VAR PostedSalesDocumentLines@1000 : TestPage 5850);
    BEGIN
      PostedSalesDocumentLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemAvailabilityLineListHandler@74(VAR ItemAvailabilityLineList@1000 : TestPage 99000902);
    BEGIN
    END;

    BEGIN
    {
      // [FEATURE] [SCM]
       1. Verify existence of deleted Item Variant.
       2. Verify Error while Delete Item Variant which is used in Purchase Order Line.
       3. Verify Error while Delete Item Variant which is used in Purchase Return Order Line.
       4. Verify Error while Delete Item Variant which is used in Sales Order Line.
       5. Verify Error while Delete Item Variant which is used in Sales Return Order Line.
       6. Verify Error while Delete Item Variant which is used in Service Order Line.
       7. Verify Error while Delete Item Variant which is used in Item Journal Line.
       8. Verify Error while Delete Item Variant which is exist in Item Ledger Entry.
       9. Verify Error while Delete Item Variant which is exist in Production BOM Line.
      10. Verify Error while Delete Item Variant which is exist in Production Order Component Line.
      11. Verify 'Next Counting Period' after update 'Phys. Invt. Counting Period' on Item.
      12. Verify Direct Unit Cost on Purchase Line when Order Date is same as Starting Date of Purchase Price.
      13. Verify Direct Unit Cost on Purchase Line when Order Date is before Starting Date of Purchase Price.
      14. Verify Direct Unit Cost on Purchase Line when Purchase Price is defined with Currency.
      15. Verify Direct Unit Cost on Posted Purchase Invoice Line after posting Partial Quantity on Purchase Order and updating Unit Cost on Purchase Price.
      16. Verify Direct Unit Cost on Posted Purchase Invoice after posting Purchase Invoice using Copy Document and updating Unit Cost on Purchase Price.
      17. Verify Direct Unit Cost on Purchase Line after Calculate Regenerative Plan and carry Out Action Message.
      18. Verify Line Discount on Purchase Line when Order Date is same as Starting Date of Purchase Price.
      19. Verify Line Discount on Purchase Line when Order Date is before Starting Date of Purchase Price.
      20. Verify Line Discount Pct on Posted Purchase Invoice Line after posting Partial Quantity on Purchase Order and updating Line Discount Pct on Purchase Line Discount.
      21. Verify Line Discount on Posted Purchase Invoice after posting Purchase Invoice using Copy Document and updating Line Discount Pct on Purchase Price.
      22. Verify Value Entry after post Output Journal which is created from Production Order.
      23. Verify Value Entry and Application Worksheet after post Output Journal with 'Apply to Entry' which is created from Production Order.
      24. Verify Value Entry after receive Purchase Order.
      25. Verify GL Entry after post Salse Order.
      26. Verify GL Entry after post Salse Credit Memo.
      27. Verify Picking Request is being available on Pick Worksheet for new Component linewhen  Prod. Order Components has been consumed, the Remaining Qty for all Lines will be Zero.
      28. Verify Value Entries for an Item which have zero quantity after run the Adjust Cost Item Entries.
      29. Verify Unit Cost(LCY) on Purchase Line when Subcontracting Purchase Order is created with Foreign Currency.
      30. Verify Capacity Ledger Entries when Subcontracting Purchase Order is created and posted with Foreign Currency.
      Covers Test cases: for WI - 315618
      ------------------------------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                                 TFS ID
      ------------------------------------------------------------------------------------------------------------------------------------------
      DeleteItemVariantError, DeleteItemVariantUsedInPurchOrderError, DeleteItemVariantUsedInPurchRetOrderError,
      DeleteItemVariantUsedInSalesOrderError, DeleteItemVariantUsedInSalesRetOrderError, DeleteItemVariantUsedInServiceOrderError,
      DeleteItemVariantUsedInItemJournalError, DeleteItemVariantUsedInItemLedEntryError,DeleteItemVariantUsedInProdBOMLineError,
      DeleteItemVariantUsedInProdOrdComponentError                                                                                       264323

      Covers Test cases: for WI - 315978
      ------------------------------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                                 TFS ID
      ------------------------------------------------------------------------------------------------------------------------------------------
      PhysInvCountingPeriodOnItem                                                                                                        264574

      Covers Test cases: for WI - 316012
      ------------------------------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                                 TFS ID
      ------------------------------------------------------------------------------------------------------------------------------------------
      DirectUnitCostOnPurchLineFromPurchPrice, DirectUnitCostOnPurchLineFromItem
      DirectUnitCostOnPurchLineWithCurrency, PurchasePriceForVendorWithPartialQty                                                        128220
      PostPurchaseInvUsingCopyDocument, UnitCostOnPurchLineWithCarryOutActionMsg
      LineDiscOnPurchLineFromPurchLineDisc, LineDiscOnPurchLineFromItem                                                                  128221
      PurchLineDiscForVendorWithPartialQty, LineDiscOnPstdPurchInvUsingCopyDoc

      Covers Test cases: for WI - 315128
      ------------------------------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                                 TFS ID
      ------------------------------------------------------------------------------------------------------------------------------------------
      PostOutputJournalFromRelProdOrder, PostOutputJournalWithAppliesToEntry, ExpCostAmountInValueEntry,
      GLEntryAfterPostSalesOrder, GLEntryAfterPostCreditMemo                                                                             257808
    }
    END.
  }
}

