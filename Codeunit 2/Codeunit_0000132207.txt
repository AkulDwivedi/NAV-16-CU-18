OBJECT Codeunit 132207 Library - Assembly
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Normal;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      LibraryUtility@1004 : Codeunit 131000;
      LibraryCosting@1012 : Codeunit 132200;
      LibraryPurchase@1006 : Codeunit 130512;
      LibraryInventory@1003 : Codeunit 132201;
      LibraryERM@1019 : Codeunit 131300;
      LibraryDimension@1008 : Codeunit 131001;
      LibraryManufacturing@1010 : Codeunit 132202;
      LibraryResource@1005 : Codeunit 130511;
      LibraryWarehouse@1013 : Codeunit 132204;
      Assert@1002 : Codeunit 130000;
      LibraryRandom@1007 : Codeunit 130440;
      ChangeType@1011 : ' ,Add,Replace,Delete,Edit,Delete all,Edit cards';
      ErrorZeroQty@1009 : TextConst 'ENU="Quantity must have a value in Assembly Header: Document Type=Order, No.=%1. It cannot be zero or empty."';
      ErrorStdCost@1021 : TextConst 'ENU=Changing Unit Cost or Cost Amount is not allowed when Costing Method is Standard.';
      BlockType@1025 : 'Dimension,Dimension Value,Dimension Combination,None';
      ClearType@1024 : 'Posting Group,Location Posting Setup,Posting Group Setup';
      AdjSource@1023 : 'Purchase,Revaluation,Item Card,Order Lines,Resource,None';
      ErrorDimCombination@1027 : TextConst '@@@="%1=OrderNo, %2=LineNo, %3=DimensionCode[1], %4=DimensionCode[2]";ENU=The combination of dimensions used in Order %1%2 is blocked. Dimensions %3 and %4 can''t be used concurrently.';
      ErrorPostingSetup@1026 : TextConst 'ENU="The General Posting Setup does not exist. "';
      ErrorInvtPostingSetup@1029 : TextConst 'ENU=The Inventory Posting Setup does not exist.';

    [Normal]
    PROCEDURE AddCompInventory@52(AssemblyHeader@1000 : Record 900;PostingDate@1002 : Date;QtySupplement@1001 : Decimal);
    VAR
      AssemblyLine@1003 : Record 901;
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      IF AssemblyLine.FINDSET THEN
        REPEAT
          AddItemInventory(
            AssemblyLine,PostingDate,AssemblyLine."Location Code",AssemblyLine."Bin Code",AssemblyLine.Quantity + QtySupplement);
        UNTIL AssemblyLine.NEXT = 0;
    END;

    [Normal]
    PROCEDURE AddCompInventoryToBin@27(AssemblyHeader@1000 : Record 900;PostingDate@1005 : Date;QtySupplement@1001 : Decimal;LocationCode@1004 : Code[10];BinCode@1002 : Code[20]);
    VAR
      AssemblyLine@1003 : Record 901;
      Bin@1007 : Record 7354;
      Location@1008 : Record 14;
      ItemJournalTemplate@1009 : Record 82;
      ItemJournalBatch@1010 : Record 233;
      ItemJournalLine@1015 : Record 83;
      WarehouseJournalTemplate@1011 : Record 7309;
      WarehouseJournalBatch@1012 : Record 7310;
      WarehouseJournalLine@1013 : Record 7311;
      Item@1014 : Record 27;
      isDirected@1006 : Boolean;
    BEGIN
      isDirected := FALSE;

      IF BinCode <> '' THEN BEGIN
        Bin.SETRANGE(Code,BinCode);
        Bin.SETRANGE("Location Code",LocationCode);
        Bin.FINDFIRST;

        Location.GET(LocationCode);
        IF Location."Directed Put-away and Pick" THEN
          isDirected := TRUE;
      END;

      SetupItemJournal(ItemJournalTemplate,ItemJournalBatch);
      IF isDirected THEN BEGIN
        SetupWarehouseJournal(WarehouseJournalTemplate,WarehouseJournalBatch,LocationCode);

        AssemblyLine.RESET;
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
        IF AssemblyLine.FINDSET THEN
          REPEAT
            LibraryWarehouse.CreateWhseJournalLine(WarehouseJournalLine,WarehouseJournalTemplate.Name,WarehouseJournalBatch.Name,
              LocationCode,Bin."Zone Code",BinCode,
              WarehouseJournalLine."Entry Type"::"Positive Adjmt.",AssemblyLine."No.",AssemblyLine.Quantity + QtySupplement);
          UNTIL AssemblyLine.NEXT = 0;

        LibraryWarehouse.RegisterWhseJournalLine(WarehouseJournalTemplate.Name,WarehouseJournalBatch.Name,LocationCode,
          TRUE);

        // Add to inventory
        Item.SETRANGE("Location Filter",LocationCode);
        LibraryWarehouse.CalculateWhseAdjustment(Item,ItemJournalBatch);
      END ELSE BEGIN
        AssemblyLine.RESET;
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
        IF AssemblyLine.FINDSET THEN
          REPEAT
            LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,
              ItemJournalLine."Entry Type"::"Positive Adjmt.",AssemblyLine."No.",AssemblyLine.Quantity + QtySupplement);
            ItemJournalLine.VALIDATE("Posting Date",CALCDATE('<-1D>',PostingDate));
            ItemJournalLine.VALIDATE("Document Date",CALCDATE('<-1D>',ItemJournalLine."Posting Date"));
            ItemJournalLine.VALIDATE("Unit of Measure Code",AssemblyLine."Unit of Measure Code");
            ItemJournalLine.VALIDATE("Variant Code",AssemblyLine."Variant Code");
            ItemJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(50,2));
            ItemJournalLine.VALIDATE("Location Code",LocationCode);
            ItemJournalLine.VALIDATE("Bin Code",BinCode);
            ItemJournalLine.MODIFY(TRUE);

          UNTIL AssemblyLine.NEXT = 0;
      END;

      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    [Normal]
    PROCEDURE AddItemInventory@126(AssemblyLine@1000 : Record 901;PostingDate@1013 : Date;LocationCode@1014 : Code[10];BinCode@1001 : Code[20];Qty@1005 : Decimal);
    VAR
      ItemJournalLine@1002 : Record 83;
      ItemJournalTemplate@1004 : Record 82;
      ItemJournalBatch@1003 : Record 233;
      Location@1007 : Record 14;
      Bin@1012 : Record 7354;
      WarehouseJournalLine@1008 : Record 7311;
      WarehouseJournalTemplate@1009 : Record 7309;
      WarehouseJournalBatch@1010 : Record 7310;
      Item@1011 : Record 27;
      isDirected@1006 : Boolean;
    BEGIN
      isDirected := FALSE;

      IF BinCode <> '' THEN BEGIN
        Bin.SETRANGE(Code,BinCode);
        Bin.SETRANGE("Location Code",LocationCode);
        Bin.FINDFIRST;

        Location.GET(LocationCode);
        IF Location."Directed Put-away and Pick" THEN
          isDirected := TRUE;
      END;

      SetupItemJournal(ItemJournalTemplate,ItemJournalBatch);
      IF isDirected THEN BEGIN
        SetupWarehouseJournal(WarehouseJournalTemplate,WarehouseJournalBatch,LocationCode);

        LibraryWarehouse.CreateWhseJournalLine(WarehouseJournalLine,WarehouseJournalTemplate.Name,WarehouseJournalBatch.Name,
          LocationCode,Bin."Zone Code",BinCode,
          WarehouseJournalLine."Entry Type"::"Positive Adjmt.",AssemblyLine."No.",Qty);
        LibraryWarehouse.RegisterWhseJournalLine(WarehouseJournalTemplate.Name,WarehouseJournalBatch.Name,LocationCode,
          TRUE);

        // Add to inventory
        Item.SETRANGE("No.",AssemblyLine."No.");
        Item.SETRANGE("Location Filter",LocationCode);
        LibraryWarehouse.CalculateWhseAdjustment(Item,ItemJournalBatch);
      END ELSE BEGIN
        LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,
          ItemJournalLine."Entry Type"::"Positive Adjmt.",AssemblyLine."No.",Qty);
        ItemJournalLine.VALIDATE("Posting Date",CALCDATE('<-1D>',PostingDate));
        ItemJournalLine.VALIDATE("Document Date",CALCDATE('<-1D>',ItemJournalLine."Posting Date"));
        ItemJournalLine.VALIDATE("Unit of Measure Code",AssemblyLine."Unit of Measure Code");
        ItemJournalLine.VALIDATE("Variant Code",AssemblyLine."Variant Code");
        ItemJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(50,2));
        ItemJournalLine.VALIDATE("Location Code",LocationCode);
        ItemJournalLine.VALIDATE("Bin Code",BinCode);
        ItemJournalLine.MODIFY(TRUE);
      END;

      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    [Normal]
    PROCEDURE AddAssemblyHeaderComment@160(AssemblyHeader@1000 : Record 900;AssemblyLineNo@1001 : Integer);
    VAR
      AssemblyCommentLine@1002 : Record 906;
    BEGIN
      CLEAR(AssemblyCommentLine);
      AssemblyCommentLine.INIT;
      AssemblyCommentLine.VALIDATE("Document Type",AssemblyHeader."Document Type");
      AssemblyCommentLine.VALIDATE("Document No.",AssemblyHeader."No.");
      AssemblyCommentLine.VALIDATE("Document Line No.",AssemblyLineNo);
      AssemblyCommentLine.VALIDATE(Comment,'Order:' + AssemblyHeader."No." + ', Line:' + FORMAT(AssemblyLineNo));
      AssemblyCommentLine.INSERT(TRUE);
    END;

    PROCEDURE AddAssemblyLineComment@93(VAR AssemblyCommentLine@1000 : Record 906;DocType@1001 : Option;DocumentNo@1002 : Code[20];DocumentLineNo@1003 : Integer;Date@1004 : Date;Comment@1005 : Text[80]);
    VAR
      RecRef@1006 : RecordRef;
    BEGIN
      CLEAR(AssemblyCommentLine);
      AssemblyCommentLine.VALIDATE("Document Type",DocType);
      AssemblyCommentLine.VALIDATE("Document No.",DocumentNo);
      AssemblyCommentLine.VALIDATE("Document Line No.",DocumentLineNo);
      RecRef.GETTABLE(AssemblyCommentLine);
      AssemblyCommentLine.VALIDATE("Line No.",LibraryUtility.GetNewLineNo(RecRef,AssemblyCommentLine.FIELDNO("Line No.")));
      AssemblyCommentLine.INSERT(TRUE);
      AssemblyCommentLine.VALIDATE(Date,Date);
      AssemblyCommentLine.VALIDATE(Comment,Comment);
      AssemblyCommentLine.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE AddEntityDimensions@155(Type@1004 : Option;No@1000 : Code[20]);
    VAR
      TempDimension@1001 : TEMPORARY Record 348;
      TempDimensionValue@1002 : TEMPORARY Record 349;
      DefaultDimension@1005 : Record 352;
      AssemblyLine@1003 : Record 901;
    BEGIN
      CreateDimensionSetup(TempDimension,TempDimensionValue);
      TempDimension.FINDSET;
      TempDimensionValue.FINDSET;
      REPEAT
        CASE Type OF
          AssemblyLine.Type::Item:
            LibraryDimension.CreateDefaultDimensionItem(DefaultDimension,No,TempDimension.Code,TempDimensionValue.Code);
          AssemblyLine.Type::Resource:
            LibraryDimension.CreateDefaultDimensionResource(DefaultDimension,No,TempDimension.Code,TempDimensionValue.Code);
        END;
        TempDimensionValue.NEXT;
      UNTIL TempDimension.NEXT = 0;
    END;

    [Normal]
    PROCEDURE BatchPostAssemblyHeaders@38(VAR AssemblyHeader@1000 : Record 900;PostingDate@1003 : Date;ReplacePostingDate@1004 : Boolean;ExpectedError@1001 : Text[1024]);
    VAR
      BatchPostAssemblyOrders@1002 : Report 900;
    BEGIN
      BatchPostAssemblyOrders.USEREQUESTPAGE(FALSE);
      BatchPostAssemblyOrders.InitializeRequest(PostingDate,ReplacePostingDate);
      BatchPostAssemblyOrders.SETTABLEVIEW(AssemblyHeader);
      IF ExpectedError = '' THEN
        BatchPostAssemblyOrders.RUNMODAL
      ELSE BEGIN
        ASSERTERROR BatchPostAssemblyOrders.RUNMODAL;
        Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ExpectedError) > 0,'Actual:' + GETLASTERRORTEXT);
        CLEARLASTERROR;
      END;
    END;

    [Normal]
    PROCEDURE BlockDimensions@168(TableID@1003 : Integer;DimBlockType@1000 : Option;EntityNo@1001 : Code[20];OrderNo@1008 : Code[20];LineNo@1009 : Text[30]) : Text[1024];
    VAR
      Dimension@1005 : Record 348;
      DimensionValue@1006 : Record 349;
      DimensionCombination@1007 : Record 350;
      DefaultDimension@1004 : Record 352;
      DimensionCode@1002 : ARRAY [5] OF Code[20];
      Count@1011 : Integer;
      ExpectedError@1012 : Text[1024];
    BEGIN
      LibraryDimension.FindDefaultDimension(DefaultDimension,TableID,EntityNo);
      DefaultDimension.FINDSET;
      FOR Count := 1 TO DefaultDimension.COUNT DO BEGIN
        DimensionCode[Count] := DefaultDimension."Dimension Code";
        DefaultDimension.NEXT;
      END;

      ExpectedError := '';
      CASE DimBlockType OF
        BlockType::Dimension:
          BEGIN
            Dimension.GET(DefaultDimension."Dimension Code");
            Dimension.VALIDATE(Blocked,TRUE);
            Dimension.MODIFY(TRUE);
            ExpectedError := 'Dimension ' + Dimension.Code + ' is blocked.';
          END;
        BlockType::"Dimension Value":
          BEGIN
            DimensionValue.GET(DefaultDimension."Dimension Code",DefaultDimension."Dimension Value Code");
            DimensionValue.VALIDATE(Blocked,TRUE);
            DimensionValue.MODIFY(TRUE);
            ExpectedError := 'Dimension Value ' + DimensionValue."Dimension Code" + ' - ' + DimensionValue.Code + ' is blocked.';
          END;
        BlockType::"Dimension Combination":
          BEGIN
            DimensionCombination.GET(DimensionCode[1],DimensionCode[2]);
            DimensionCombination.VALIDATE("Combination Restriction",DimensionCombination."Combination Restriction"::Blocked);
            DimensionCombination.MODIFY(TRUE);
            ExpectedError := STRSUBSTNO(ErrorDimCombination,OrderNo,LineNo,DimensionCode[1],DimensionCode[2]);
          END;
      END;

      EXIT(ExpectedError);
    END;

    [Normal]
    PROCEDURE BlockOrderDimensions@131(AssemblyHeader@1000 : Record 900;HeaderBlockType@1001 : Option;CompBlockType@1008 : Option) : Text[1024];
    VAR
      AssemblyLine@1005 : Record 901;
      TableID@1007 : Integer;
      HeaderError@1009 : Text[1024];
      CompError@1010 : Text[1024];
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      IF AssemblyLine.FINDFIRST THEN BEGIN
        CASE AssemblyLine.Type OF
          AssemblyLine.Type::Item:
            TableID := 27;
          AssemblyLine.Type::Resource:
            TableID := 156;
          AssemblyLine.Type::" ":
            BEGIN
              TableID := 0;
              AssemblyLine.TESTFIELD("Dimension Set ID",0);
            END;
        END;
        CompError := BlockDimensions(TableID,CompBlockType,AssemblyLine."No.",
            AssemblyLine."Document No.",', line no. ' + FORMAT(AssemblyLine."Line No."));
      END;

      HeaderError := BlockDimensions(27,HeaderBlockType,AssemblyHeader."Item No.",AssemblyHeader."No.",'');

      IF HeaderError <> '' THEN
        EXIT(HeaderError);
      IF CompError <> '' THEN
        EXIT(CompError);
      EXIT('');
    END;

    PROCEDURE CalcExpectedStandardCost@6(VAR MaterialCost@1011 : Decimal;VAR CapacityCost@1010 : Decimal;VAR CapOverhead@1009 : Decimal;ParentItemNo@1000 : Code[20]) : Decimal;
    VAR
      BOMComponent@1001 : Record 90;
      Item@1002 : Record 27;
      Item1@1008 : Record 27;
      Resource@1003 : Record 156;
      ItemUnitOfMeasure@1004 : Record 5404;
      ResourceUnitOfMeasure@1005 : Record 205;
      ExpectedCost@1006 : Decimal;
      LotSize@1007 : Decimal;
      LineCost@1012 : Decimal;
    BEGIN
      ExpectedCost := 0;
      MaterialCost := 0;
      CapacityCost := 0;
      CapOverhead := 0;
      BOMComponent.SETRANGE("Parent Item No.",ParentItemNo);
      Item.GET(ParentItemNo);

      IF BOMComponent.FINDSET THEN
        REPEAT
          CASE BOMComponent.Type OF
            BOMComponent.Type::Item:
              BEGIN
                Item1.GET(BOMComponent."No.");
                ItemUnitOfMeasure.GET(Item1."No.",BOMComponent."Unit of Measure Code");
                LineCost := Item1."Unit Cost" * BOMComponent."Quantity per" * ItemUnitOfMeasure."Qty. per Unit of Measure";
                ExpectedCost += LineCost;
                MaterialCost += LineCost;
              END;
            BOMComponent.Type::Resource:
              BEGIN
                Resource.GET(BOMComponent."No.");
                ResourceUnitOfMeasure.GET(Resource."No.",BOMComponent."Unit of Measure Code");
                IF (BOMComponent."Resource Usage Type" = BOMComponent."Resource Usage Type"::Direct) OR (Item."Lot Size" = 0) THEN
                  LotSize := 1
                ELSE
                  LotSize := Item."Lot Size";

                LineCost := (Resource."Unit Cost" * BOMComponent."Quantity per" * ResourceUnitOfMeasure."Qty. per Unit of Measure"
                             ) / LotSize;
                CapOverhead += LineCost - Resource."Direct Unit Cost" *
                  BOMComponent."Quantity per" * ResourceUnitOfMeasure."Qty. per Unit of Measure" / LotSize;
                CapacityCost += LineCost;
                ExpectedCost += LineCost;
              END
          END;
        UNTIL BOMComponent.NEXT = 0;

      IF ExpectedCost = 0 THEN
        EXIT(Item."Standard Cost");
      ExpectedCost := ExpectedCost * (1 + Item."Indirect Cost %" / 100) + Item."Overhead Rate";

      MaterialCost := ROUND(MaterialCost,LibraryERM.GetUnitAmountRoundingPrecision);
      CapacityCost := ROUND(CapacityCost,LibraryERM.GetUnitAmountRoundingPrecision);
      CapOverhead := ROUND(CapOverhead,LibraryERM.GetUnitAmountRoundingPrecision);
      EXIT(ROUND(ExpectedCost,LibraryERM.GetUnitAmountRoundingPrecision));
    END;

    PROCEDURE CalcExpectedPrice@7(ParentItemNo@1000 : Code[20]) : Decimal;
    VAR
      Item@1002 : Record 27;
      BOMComponent@1008 : Record 90;
      ItemUnitOfMeasure@1005 : Record 5404;
      Resource@1003 : Record 156;
      ResUnitOfMeasure@1004 : Record 205;
      ExpectedPrice@1001 : Decimal;
    BEGIN
      ExpectedPrice := 0;
      BOMComponent.SETRANGE("Parent Item No.",ParentItemNo);
      BOMComponent.SETRANGE(Type,BOMComponent.Type::Item);
      IF BOMComponent.FINDSET THEN
        REPEAT
          Item.GET(BOMComponent."No.");
          ItemUnitOfMeasure.GET(Item."No.",BOMComponent."Unit of Measure Code");
          ExpectedPrice += Item."Unit Price" * BOMComponent."Quantity per" * ItemUnitOfMeasure."Qty. per Unit of Measure";
        UNTIL BOMComponent.NEXT = 0;

      Item.GET(ParentItemNo);
      BOMComponent.SETRANGE(Type,BOMComponent.Type::Resource);
      IF BOMComponent.FINDSET THEN
        REPEAT
          Resource.GET(BOMComponent."No.");
          ResUnitOfMeasure.GET(Resource."No.",BOMComponent."Unit of Measure Code");
          ExpectedPrice += Resource."Unit Price" * BOMComponent."Quantity per" * ResUnitOfMeasure."Qty. per Unit of Measure"
        UNTIL BOMComponent.NEXT = 0;

      IF ExpectedPrice = 0 THEN
        EXIT(Item."Unit Price");
      EXIT(ROUND(ExpectedPrice,LibraryERM.GetUnitAmountRoundingPrecision));
    END;

    [Normal]
    PROCEDURE CalcOrderCostAmount@16(VAR MaterialCost@1009 : Decimal;VAR ResourceCost@1011 : Decimal;VAR ResourceOvhd@1012 : Decimal;VAR AssemblyOvhd@1006 : Decimal;AssemblyHeaderNo@1000 : Code[20]) : Decimal;
    VAR
      Item@1002 : Record 27;
      AssemblyLine@1003 : Record 901;
      AssemblyHeader@1004 : Record 900;
      ExpectedCost@1001 : Decimal;
      Overhead@1005 : Decimal;
      IndirectCost@1007 : Decimal;
      UnitCost@1008 : Decimal;
      LineCost@1010 : Decimal;
      LineOverhead@1013 : Decimal;
    BEGIN
      ExpectedCost := 0;
      MaterialCost := 0;
      ResourceCost := 0;
      ResourceOvhd := 0;

      AssemblyLine.SETCURRENTKEY("Document Type","Document No.",Type);
      AssemblyLine.SETRANGE("Document Type",AssemblyLine."Document Type"::Order);
      AssemblyLine.SETRANGE("Document No.",AssemblyHeaderNo);
      AssemblyLine.SETFILTER(Type,'<>%1',AssemblyLine.Type::" ");
      IF AssemblyLine.FINDSET THEN
        REPEAT
          GetCostInformation(UnitCost,Overhead,IndirectCost,AssemblyLine.Type,AssemblyLine."No.",'','');
          LineOverhead := Overhead * AssemblyLine.Quantity * AssemblyLine."Qty. per Unit of Measure";
          LineCost := AssemblyLine."Unit Cost" * AssemblyLine.Quantity ;
          IF AssemblyLine.Type = AssemblyLine.Type::Item THEN
            MaterialCost += LineCost
          ELSE BEGIN
            ResourceCost += LineCost;
            ResourceOvhd += LineOverhead;
          END
        UNTIL AssemblyLine.NEXT = 0;

      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,AssemblyHeaderNo);
      Item.GET(AssemblyHeader."Item No.");
      AssemblyOvhd := Item."Indirect Cost %" / 100 * (MaterialCost + ResourceCost + ResourceOvhd) +
        Item."Overhead Rate" * AssemblyHeader.Quantity * AssemblyHeader."Qty. per Unit of Measure";

      IF Item."Costing Method" = Item."Costing Method"::Standard THEN
        EXIT((Item."Standard Cost" * (100 + Item."Indirect Cost %") / 100 + Item."Overhead Rate") *
          AssemblyHeader.Quantity * AssemblyHeader."Qty. per Unit of Measure");

      MaterialCost := ROUND(MaterialCost,LibraryERM.GetAmountRoundingPrecision);
      ResourceCost := ROUND(ResourceCost,LibraryERM.GetAmountRoundingPrecision);
      ResourceOvhd := ROUND(ResourceOvhd,LibraryERM.GetAmountRoundingPrecision);
      AssemblyOvhd := ROUND(AssemblyOvhd,LibraryERM.GetAmountRoundingPrecision);
      ExpectedCost := MaterialCost + ResourceCost + ResourceOvhd + AssemblyOvhd;
      EXIT(ROUND(ExpectedCost,LibraryERM.GetAmountRoundingPrecision));
    END;

    [Normal]
    PROCEDURE ChangeResourceUsage@64(AssemblyHeaderNo@1005 : Code[20]);
    VAR
      AssemblyLine@1004 : Record 901;
    BEGIN
      AssemblyLine.SETCURRENTKEY("Document Type","Document No.",Type);
      AssemblyLine.SETRANGE("Document Type",AssemblyLine."Document Type"::Order);
      AssemblyLine.SETRANGE("Document No.",AssemblyHeaderNo);
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Resource);
      AssemblyLine.NEXT(RANDOM(AssemblyLine.COUNT));

      IF AssemblyLine."Resource Usage Type" = AssemblyLine."Resource Usage Type"::Fixed THEN
        AssemblyLine.VALIDATE("Resource Usage Type",AssemblyLine."Resource Usage Type"::Direct)
      ELSE
        AssemblyLine.VALIDATE("Resource Usage Type",AssemblyLine."Resource Usage Type"::Fixed)
    END;

    [Normal]
    PROCEDURE ClearOrderPostingSetup@154(OrderClearType@1000 : Option;InvtPostingGroup@1001 : Code[10];GenProdPostingGroup@1002 : Code[10];LocationCode@1003 : Code[10]) : Text[1024];
    VAR
      InventoryPostingSetup@1004 : Record 5813;
      GeneralPostingSetup@1005 : Record 252;
      ExpectedError@1006 : Text[1024];
    BEGIN
      ExpectedError := '';
      CASE OrderClearType OF
        ClearType::"Posting Group Setup":
          BEGIN
            InventoryPostingSetup.SETRANGE("Invt. Posting Group Code",InvtPostingGroup);
            IF InventoryPostingSetup.FINDFIRST THEN
              InventoryPostingSetup.DELETEALL;
            GeneralPostingSetup.SETRANGE("Gen. Prod. Posting Group",GenProdPostingGroup);
            IF GeneralPostingSetup.FINDFIRST THEN
              GeneralPostingSetup.DELETEALL;
            ExpectedError := ErrorPostingSetup;
          END;
        ClearType::"Location Posting Setup":
          BEGIN
            InventoryPostingSetup.SETRANGE("Location Code",LocationCode);
            InventoryPostingSetup.SETRANGE("Invt. Posting Group Code",InvtPostingGroup);
            IF InventoryPostingSetup.FINDFIRST THEN
              InventoryPostingSetup.DELETEALL;
            ExpectedError := ErrorInvtPostingSetup;
          END;
      END;
      EXIT(ExpectedError);
    END;

    [Normal]
    LOCAL PROCEDURE CreateAssemblyHeaderLocal@17(VAR AssemblyHeader@1001 : Record 900;DueDate@1005 : Date;ParentItemNo@1000 : Code[20];LocationCode@1002 : Code[10];Quantity@1003 : Decimal;DocumentType@1004 : Option;VariantCode@1006 : Code[10]) : Code[20];
    BEGIN
      CLEAR(AssemblyHeader);
      AssemblyHeader."Document Type" := DocumentType;
      AssemblyHeader.INSERT(TRUE);
      AssemblyHeader.VALIDATE("Item No.",ParentItemNo);
      AssemblyHeader.VALIDATE("Location Code",LocationCode);
      AssemblyHeader.VALIDATE("Due Date",DueDate);
      AssemblyHeader.VALIDATE(Quantity,Quantity);
      IF VariantCode <> '' THEN
        AssemblyHeader.VALIDATE("Variant Code",VariantCode);
      AssemblyHeader.MODIFY(TRUE);

      EXIT(AssemblyHeader."No.");
    END;

    [Normal]
    PROCEDURE CreateAssemblyHeader@53(VAR AssemblyHeader@1001 : Record 900;DueDate@1004 : Date;ParentItemNo@1000 : Code[20];LocationCode@1002 : Code[10];Quantity@1003 : Decimal;VariantCode@1005 : Code[10]) : Code[20];
    BEGIN
      EXIT(
        CreateAssemblyHeaderLocal(
          AssemblyHeader,DueDate,ParentItemNo,LocationCode,Quantity,AssemblyHeader."Document Type"::Order,VariantCode));
    END;

    [Normal]
    PROCEDURE CreateAssemblyQuote@51(VAR AssemblyHeader@1001 : Record 900;DueDate@1004 : Date;ParentItemNo@1000 : Code[20];LocationCode@1002 : Code[10];Quantity@1003 : Decimal;VariantCode@1005 : Code[10]) : Code[20];
    BEGIN
      EXIT(
        CreateAssemblyHeaderLocal(
          AssemblyHeader,DueDate,ParentItemNo,LocationCode,Quantity,AssemblyHeader."Document Type"::Quote,VariantCode));
    END;

    PROCEDURE CreateAssemblyLine@43(AssemblyHeader@1000 : Record 900;VAR AssemblyLine@1008 : Record 901;Type@1001 : Option;No@1002 : Code[20];UOMCode@1003 : Code[10];Quantity@1004 : Decimal;QtyPer@1005 : Decimal;Desc@1006 : Text[50]);
    VAR
      RecRef@1007 : RecordRef;
    BEGIN
      CLEAR(AssemblyLine);
      AssemblyLine."Document Type" := AssemblyHeader."Document Type";
      AssemblyLine."Document No." := AssemblyHeader."No.";
      RecRef.GETTABLE(AssemblyLine);
      AssemblyLine.VALIDATE("Line No.",LibraryUtility.GetNewLineNo(RecRef,AssemblyLine.FIELDNO("Line No.")));
      AssemblyLine.INSERT(TRUE);
      AssemblyLine.VALIDATE(Type,Type);
      AssemblyLine.VALIDATE("No.",No);
      IF AssemblyHeader.Quantity <> 0 THEN
        AssemblyLine."Quantity per" := AssemblyLine.CalcQuantityPer(Quantity);
      AssemblyLine.VALIDATE(Quantity,Quantity);
      AssemblyLine.VALIDATE("Unit of Measure Code",UOMCode);
      IF QtyPer <> 0 THEN
        AssemblyLine.VALIDATE("Quantity per",QtyPer);
      AssemblyLine.VALIDATE(Description,Desc);
      AssemblyLine.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE CreateAssemblyLines@48(CostingMethod@1009 : Option;AssemblyHeaderNo@1000 : Code[20];NoOfItems@1001 : Integer;NoOfResources@1002 : Integer);
    VAR
      AssemblyHeader@1003 : Record 900;
      TempItem@1011 : TEMPORARY Record 27;
      TempResource@1010 : TEMPORARY Record 156;
      AssemblyLine@1004 : Record 901;
    BEGIN
      SetupComponents(TempItem,TempResource,CostingMethod,NoOfItems,NoOfResources,'','');
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,AssemblyHeaderNo);

      IF TempItem.FINDSET THEN
        REPEAT
          CreateAssemblyLine(AssemblyHeader,AssemblyLine,AssemblyLine.Type::Item,TempItem."No.",
            GetUnitOfMeasureCode(AssemblyLine.Type::Item,TempItem."No.",TRUE),LibraryRandom.RandDec(20,2),0,'');
        UNTIL TempItem.NEXT = 0;

      IF TempResource.FINDSET THEN
        REPEAT
          CreateAssemblyLine(AssemblyHeader,AssemblyLine,AssemblyLine.Type::Resource,TempResource."No.",
            GetUnitOfMeasureCode(AssemblyLine.Type::Resource,TempResource."No.",TRUE),LibraryRandom.RandDec(20,2),0,'');
        UNTIL TempResource.NEXT = 0;
    END;

    [Normal]
    PROCEDURE CreateAssemblyList@21(CostingMethod@1009 : Option;ParentItemNo@1000 : Code[20];UseBaseUnitOfMeasure@1005 : Boolean;NoOfItems@1001 : Integer;NoOfResources@1002 : Integer;NoOfTexts@1003 : Integer;QtyPerFactor@1004 : Integer;GenProdPostingGroup@1007 : Code[10];InventoryPostingGroup@1012 : Code[10]);
    VAR
      BOMComponent@1006 : Record 90;
      TempItem@1011 : TEMPORARY Record 27;
      TempResource@1010 : TEMPORARY Record 156;
      CompCount@1008 : Integer;
    BEGIN
      SetupComponents(TempItem,TempResource,CostingMethod,NoOfItems,NoOfResources,GenProdPostingGroup,InventoryPostingGroup);

      IF TempItem.FINDSET THEN
        REPEAT
          CreateAssemblyListComponent(BOMComponent.Type::Item,TempItem."No.",ParentItemNo,'',
            BOMComponent."Resource Usage Type"::Direct,QtyPerFactor * LibraryRandom.RandDec(20,5),UseBaseUnitOfMeasure);
        UNTIL TempItem.NEXT = 0;

      CompCount := 1;
      IF TempResource.FINDSET THEN
        REPEAT
          IF CompCount MOD 2 = 0 THEN
            CreateAssemblyListComponent(BOMComponent.Type::Resource,TempResource."No.",ParentItemNo,'',
              BOMComponent."Resource Usage Type"::Direct,QtyPerFactor * LibraryRandom.RandDec(20,5),UseBaseUnitOfMeasure)
          ELSE
            CreateAssemblyListComponent(BOMComponent.Type::Resource,TempResource."No.",ParentItemNo,'',
              BOMComponent."Resource Usage Type"::Fixed,QtyPerFactor * LibraryRandom.RandDec(20,5),UseBaseUnitOfMeasure);
          CompCount += 1;
        UNTIL TempResource.NEXT = 0;

      FOR CompCount := 1 TO NoOfTexts DO
        CreateAssemblyListComponent(BOMComponent.Type::" ",'',ParentItemNo,'',
          BOMComponent."Resource Usage Type"::Direct,0,UseBaseUnitOfMeasure);

      COMMIT;
    END;

    PROCEDURE CreateAssemblyListComponent@12(ComponentType@1000 : Option;ComponentNo@1001 : Code[20];ParentItemNo@1005 : Code[20];VariantCode@1007 : Code[10];ResourceUsage@1006 : Option;Qty@1002 : Decimal;UseBaseUnitOfMeasure@1003 : Boolean);
    VAR
      BOMComponent@1004 : Record 90;
    BEGIN
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentItemNo,ComponentType,ComponentNo,Qty,
        GetUnitOfMeasureCode(ComponentType,ComponentNo,UseBaseUnitOfMeasure));
      IF ComponentType = BOMComponent.Type::Resource THEN
        BOMComponent.VALIDATE("Resource Usage Type",ResourceUsage);
      BOMComponent.VALIDATE("Variant Code",VariantCode);
      BOMComponent.VALIDATE(
        Description,LibraryUtility.GenerateRandomCode(BOMComponent.FIELDNO(Description),DATABASE::"BOM Component"));
      BOMComponent.MODIFY(TRUE);
      COMMIT;
    END;

    [Normal]
    PROCEDURE CreateAssemblySetup@127(VAR AssemblySetup@1002 : Record 905;LocationCode@1000 : Code[10];DimensionsFrom@1003 : Option;PostedOrdersNo@1004 : Code[10]);
    BEGIN
      IF AssemblySetup."Assembly Order Nos." = '' THEN
        AssemblySetup.VALIDATE("Assembly Order Nos.",
          LibraryUtility.GetGlobalNoSeriesCode);
      IF AssemblySetup."Posted Assembly Order Nos." = '' THEN
        AssemblySetup.VALIDATE("Posted Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      IF AssemblySetup."Assembly Quote Nos." = '' THEN
        AssemblySetup.VALIDATE("Assembly Quote Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      IF AssemblySetup."Blanket Assembly Order Nos." = '' THEN
        AssemblySetup.VALIDATE("Blanket Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Default Location for Orders",LocationCode);
      AssemblySetup.VALIDATE("Copy Component Dimensions from",DimensionsFrom);
      AssemblySetup.VALIDATE("Posted Assembly Order Nos.",PostedOrdersNo);
      AssemblySetup.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE CreateBOM@115(VAR Item@1000 : Record 27;NoOfComps@1001 : Integer);
    VAR
      Item1@1008 : Record 27;
      ProductionBOMHeader@1007 : Record 99000771;
      ProductionBOMLine@1006 : Record 99000772;
      count@1002 : Integer;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,Item."Base Unit of Measure");

      FOR count := 1 TO NoOfComps DO BEGIN
        CreateItem(Item1,Item."Costing Method"::Standard,Item."Replenishment System"::Purchase,'','');
        LibraryManufacturing.CreateProductionBOMLine(
          ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,Item1."No.",1);
      END;

      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
      Item.VALIDATE("Production BOM No.",ProductionBOMHeader."No.");
      Item.MODIFY(TRUE);
    END;

    PROCEDURE CreateRouting@189(VAR Item@1000 : Record 27;NoOfLines@1005 : Integer);
    VAR
      MachineCenter@1007 : Record 99000758;
      WorkCenter@1003 : Record 99000754;
      RoutingHeader@1001 : Record 99000763;
      RoutingLine@1002 : Record 99000764;
      count@1006 : Integer;
    BEGIN
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);
      LibraryManufacturing.CreateWorkCenter(WorkCenter);

      FOR count := 1 TO NoOfLines DO
        IF count MOD 2 = 0 THEN BEGIN
          RoutingLine.VALIDATE(Type,RoutingLine.Type::"Work Center");
          LibraryManufacturing.CreateRoutingLineSetup(RoutingLine,RoutingHeader,WorkCenter."No.",
            COPYSTR(
              LibraryUtility.GenerateRandomCode(RoutingLine.FIELDNO("Operation No."),DATABASE::"Routing Line"),1,
              LibraryUtility.GetFieldLength(DATABASE::"Routing Line",RoutingLine.FIELDNO("Operation No."))),
            LibraryRandom.RandDec(10,2),LibraryRandom.RandDec(10,2));
        END ELSE BEGIN
          LibraryManufacturing.CreateMachineCenter(MachineCenter,WorkCenter."No.",LibraryRandom.RandInt(5));
          RoutingLine.VALIDATE(Type,RoutingLine.Type::"Machine Center");
          LibraryManufacturing.CreateRoutingLineSetup(RoutingLine,RoutingHeader,MachineCenter."No.",
            COPYSTR(
              LibraryUtility.GenerateRandomCode(RoutingLine.FIELDNO("Operation No."),DATABASE::"Routing Line"),1,
              LibraryUtility.GetFieldLength(DATABASE::"Routing Line",RoutingLine.FIELDNO("Operation No."))),
            LibraryRandom.RandDec(10,2),LibraryRandom.RandDec(10,2));
        END;

      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
      Item.VALIDATE("Routing No.",RoutingHeader."No.");
      Item.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE CreateDimensionSetup@165(VAR TempDimension@1000 : TEMPORARY Record 348;VAR TempDimensionValue@1005 : TEMPORARY Record 349);
    VAR
      DimensionValue@1002 : Record 349;
      DimensionCombination@1004 : Record 350;
      Dimension@1001 : Record 348;
      Count@1003 : Integer;
      DimensionCode@1006 : ARRAY [5] OF Code[20];
    BEGIN
      FOR Count := 1 TO 2 DO BEGIN
        LibraryDimension.CreateDimension(Dimension);
        DimensionCode[Count] := Dimension.Code;
        TempDimension := Dimension;
        TempDimension.INSERT;
        LibraryDimension.CreateDimensionValue(DimensionValue,Dimension.Code);
        TempDimensionValue := DimensionValue;
        TempDimensionValue.INSERT;
      END;
      LibraryDimension.CreateDimensionCombination(DimensionCombination,DimensionCode[1],DimensionCode[2]);
    END;

    [Normal]
    PROCEDURE CreateGLAccount@176(VAR GLAccount@1002 : Record 15;IncomeBalance@1001 : Option;Name@1000 : Text[30]);
    BEGIN
      LibraryERM.CreateGLAccount(GLAccount);
      GLAccount.VALIDATE("Income/Balance",IncomeBalance);
      GLAccount.VALIDATE("Debit/Credit",GLAccount."Debit/Credit"::Both);
      GLAccount.VALIDATE("Account Type",GLAccount."Account Type"::Posting);
      GLAccount.VALIDATE(Name,Name);
      GLAccount.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE CreateItem@22(VAR Item@1000 : Record 27;CostingMethod@1002 : Option;ReplenishmentMethod@1004 : Option;GenProdPostingGroup@1006 : Code[10];InventoryPostingGroup@1007 : Code[10]) : Code[20];
    VAR
      GeneralPostingSetup@1008 : Record 252;
      ItemUnitOfMeasure@1001 : Record 5404;
      UnitOfMeasure@1005 : Record 204;
      VATPostingSetup@1003 : Record 325;
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Replenishment System",ReplenishmentMethod);
      Item.VALIDATE("Costing Method",CostingMethod);

      IF ReplenishmentMethod <> Item."Replenishment System"::Assembly THEN BEGIN
        IF CostingMethod = Item."Costing Method"::Standard THEN
          Item.VALIDATE("Standard Cost",LibraryRandom.RandDec(25,2))
        ELSE
          Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(25,2));
        Item.VALIDATE("Unit Price",Item."Unit Cost" + LibraryRandom.RandDec(25,2));
      END ELSE BEGIN
        Item.VALIDATE("Standard Cost",0);
        Item.VALIDATE("Unit Cost",0);
        Item.VALIDATE("Unit Price",0);
      END;

      Item.VALIDATE("Last Direct Cost",Item."Unit Cost");
      IF InventoryPostingGroup <> '' THEN
        Item.VALIDATE("Inventory Posting Group",InventoryPostingGroup);
      IF GenProdPostingGroup = '' THEN BEGIN
        LibraryERM.FindGeneralPostingSetupInvtToGL(GeneralPostingSetup);
        GenProdPostingGroup := GeneralPostingSetup."Gen. Prod. Posting Group";
      END;
      Item.VALIDATE("Gen. Prod. Posting Group",GenProdPostingGroup);
      CLEAR(VATPostingSetup);
      LibraryERM.FindVATPostingSetup(VATPostingSetup,VATPostingSetup."VAT Calculation Type"::"Normal VAT");
      Item.VALIDATE("VAT Prod. Posting Group",VATPostingSetup."VAT Prod. Posting Group");
      Item.MODIFY(TRUE);

      UnitOfMeasure.SETFILTER(Code,'<>%1',Item."Base Unit of Measure");
      UnitOfMeasure.FINDFIRST;
      LibraryInventory.CreateItemUnitOfMeasure(
        ItemUnitOfMeasure,Item."No.",UnitOfMeasure.Code,LibraryRandom.RandInt(10));
      EXIT(Item."No.");
    END;

    [Normal]
    PROCEDURE CreateInvtPostingSetup@142(VAR InventoryPostingSetup@1000 : Record 5813;LocationCode@1001 : Code[10];InvtPostingGroupCode@1002 : Code[10];InvtAccount@1003 : Code[20];MatVarAccount@1004 : Code[20];CapVarAcc@1005 : Code[20];CapOvhdVarAcc@1006 : Code[20];MfgOvhdVarAcc@1007 : Code[20];InvtAccInterim@1250 : Code[20]);
    VAR
      GLAccount@1008 : Record 15;
    BEGIN
      CLEAR(InventoryPostingSetup);
      InventoryPostingSetup.INIT;
      InventoryPostingSetup.VALIDATE("Location Code",LocationCode);
      InventoryPostingSetup.VALIDATE("Invt. Posting Group Code",InvtPostingGroupCode);
      InventoryPostingSetup.VALIDATE("Inventory Account",InvtAccount);
      InventoryPostingSetup.VALIDATE("Material Variance Account",MatVarAccount);
      InventoryPostingSetup.VALIDATE("Capacity Variance Account",CapVarAcc);
      InventoryPostingSetup.VALIDATE("Cap. Overhead Variance Account",CapOvhdVarAcc);
      InventoryPostingSetup.VALIDATE("Mfg. Overhead Variance Account",MfgOvhdVarAcc);
      InventoryPostingSetup.VALIDATE("Inventory Account (Interim)",InvtAccInterim);
      LibraryERM.CreateGLAccount(GLAccount);
      InventoryPostingSetup.VALIDATE("WIP Account",GLAccount."No.");
      InventoryPostingSetup.INSERT(TRUE);
    END;

    PROCEDURE CreateInvtMovement@28(AssemblyHeaderNo@1000 : Code[20];NewCreateInvtPutAway@1001 : Boolean;NewCreateInvtPick@1002 : Boolean;NewCreateInvtMovement@1003 : Boolean);
    VAR
      TmpWarehouseRequest@1004 : Record 5765;
      WarehouseRequest@1006 : Record 5765;
      CreateInvtPutAwayPick@1005 : Report 7323;
    BEGIN
      WarehouseRequest.SETCURRENTKEY("Source Document","Source No.");
      WarehouseRequest.SETRANGE("Source Document",WarehouseRequest."Source Document"::"Assembly Consumption");
      WarehouseRequest.SETRANGE("Source No.",AssemblyHeaderNo);

      COMMIT;
      CreateInvtPutAwayPick.InitializeRequest(
        NewCreateInvtPutAway,NewCreateInvtPick,NewCreateInvtMovement,FALSE,FALSE);
      IF WarehouseRequest.HASFILTER THEN
        TmpWarehouseRequest.COPYFILTERS(WarehouseRequest)
      ELSE BEGIN
        WarehouseRequest.GET(WarehouseRequest.Type,
          WarehouseRequest."Location Code",
          WarehouseRequest."Source Type",
          WarehouseRequest."Source Subtype",
          WarehouseRequest."Source No.");
        TmpWarehouseRequest.SETRANGE(Type,WarehouseRequest.Type);
        TmpWarehouseRequest.SETRANGE("Location Code",WarehouseRequest."Location Code");
        TmpWarehouseRequest.SETRANGE("Source Type",WarehouseRequest."Source Type");
        TmpWarehouseRequest.SETRANGE("Source Subtype",WarehouseRequest."Source Subtype");
        TmpWarehouseRequest.SETRANGE("Source No.",WarehouseRequest."Source No.");
      END;
      CreateInvtPutAwayPick.SETTABLEVIEW(TmpWarehouseRequest);
      CreateInvtPutAwayPick.USEREQUESTPAGE(FALSE);
      CreateInvtPutAwayPick.RUNMODAL;
    END;

    PROCEDURE AsmOrder_CreateInvtMovement@94(VAR WarehouseRequest@1008 : Record 5765;NewCreateInvtPutAway@1006 : Boolean;NewCreateInvtPick@1005 : Boolean;NewCreateInvtMovement@1007 : Boolean;NewPrintDocument@1001 : Boolean;NewShowError@1002 : Boolean);
    VAR
      TmpWarehouseRequest@1000 : Record 5765;
      CreateInvtPutAwayPick@1004 : Report 7323;
    BEGIN
      // TODO - align with previous function

      COMMIT;
      CreateInvtPutAwayPick.InitializeRequest(
        NewCreateInvtPutAway,NewCreateInvtPick,NewCreateInvtMovement,NewPrintDocument,NewShowError);
      IF WarehouseRequest.HASFILTER THEN
        TmpWarehouseRequest.COPYFILTERS(WarehouseRequest)
      ELSE BEGIN
        WarehouseRequest.GET(WarehouseRequest.Type,
          WarehouseRequest."Location Code",
          WarehouseRequest."Source Type",
          WarehouseRequest."Source Subtype",
          WarehouseRequest."Source No.");
        TmpWarehouseRequest.SETRANGE(Type,WarehouseRequest.Type);
        TmpWarehouseRequest.SETRANGE("Location Code",WarehouseRequest."Location Code");
        TmpWarehouseRequest.SETRANGE("Source Type",WarehouseRequest."Source Type");
        TmpWarehouseRequest.SETRANGE("Source Subtype",WarehouseRequest."Source Subtype");
        TmpWarehouseRequest.SETRANGE("Source No.",WarehouseRequest."Source No.");
      END;
      CreateInvtPutAwayPick.SETTABLEVIEW(TmpWarehouseRequest);
      CreateInvtPutAwayPick.USEREQUESTPAGE(FALSE);
      CreateInvtPutAwayPick.RUNMODAL;
    END;

    PROCEDURE CreateWhsePick@30(AssemblyHeader@1000 : Record 900;AssignedUserID@1001 : Code[50];SortingMethod@1002 : Option;SetBreakBulkFilter@1003 : Boolean;DoNotFillQtyToHandle@1004 : Boolean;PrintDocument@1005 : Boolean);
    BEGIN
      AssemblyHeader.CreatePick(FALSE,AssignedUserID,SortingMethod,SetBreakBulkFilter,DoNotFillQtyToHandle,PrintDocument);
    END;

    PROCEDURE CreateMultipleLvlTree@85(VAR Item@1001 : Record 27;VAR Item1@1002 : Record 27;ReplenishmentMethod@1006 : Option;CostingMethod@1005 : Option;TreeDepth@1000 : Integer;NoOfComps@1007 : Integer);
    VAR
      BOMComponent@1008 : Record 90;
      Item2@1004 : Record 27;
      Depth@1003 : Integer;
    BEGIN
      CreateItem(Item,CostingMethod,ReplenishmentMethod,'','');
      IF ReplenishmentMethod = Item."Replenishment System"::"Prod. Order" THEN
        CreateBOM(Item,NoOfComps)
      ELSE
        CreateAssemblyList(Item."Costing Method"::Standard,Item."No.",TRUE,NoOfComps,NoOfComps,NoOfComps,1,'','');

      CreateItem(Item1,Item."Costing Method"::Standard,Item."Replenishment System"::Assembly,'','');
      CreateAssemblyList(Item."Costing Method"::Standard,Item1."No.",TRUE,2,1,0,1,'','');
      CreateAssemblyListComponent(
        BOMComponent.Type::Item,Item."No.",Item1."No.",'',BOMComponent."Resource Usage Type"::Direct,
        LibraryRandom.RandDec(20,2),TRUE);

      FOR Depth := 2 TO TreeDepth DO BEGIN
        CreateItem(Item2,Item."Costing Method"::Standard,Item."Replenishment System"::Assembly,'','');
        CreateAssemblyList(Item."Costing Method"::Standard,Item2."No.",TRUE,2,1,0,1,'','');
        CreateAssemblyListComponent(BOMComponent.Type::Item,Item1."No.",Item2."No.",'',BOMComponent."Resource Usage Type"::Direct,
          LibraryRandom.RandDec(20,2),TRUE);
        Item := Item1;
        Item1 := Item2;
        Item.FIND;
        Item.VALIDATE("Replenishment System",ReplenishmentMethod);
        Item.MODIFY(TRUE);
        IF ReplenishmentMethod = Item."Replenishment System"::"Prod. Order" THEN
          CreateBOM(Item,NoOfComps);
      END;
      COMMIT;
    END;

    [Normal]
    PROCEDURE CreateItemSubstitution@140(VAR ItemSubstitution@1001 : Record 5715;ItemNo@1000 : Code[20]);
    VAR
      Item1@1002 : Record 27;
    BEGIN
      CreateItem(Item1,Item1."Costing Method"::Standard,Item1."Replenishment System"::Purchase,'','');
      CLEAR(ItemSubstitution);
      ItemSubstitution.INIT;
      ItemSubstitution.VALIDATE(Type,ItemSubstitution.Type::Item);
      ItemSubstitution.VALIDATE("No.",ItemNo);
      ItemSubstitution.VALIDATE("Substitute Type",ItemSubstitution."Substitute Type"::Item);
      ItemSubstitution.VALIDATE("Substitute No.",Item1."No.");
      ItemSubstitution.INSERT;
    END;

    [Normal]
    PROCEDURE CreateAdjustmentSource@153(AssemblyHeader@1000 : Record 900;PostingDate@1005 : Date;AdjustHeader@1001 : Boolean;AdjustmentSource@1002 : Option;ItemNo@1011 : Code[20];ResourceNo@1012 : Code[20]);
    VAR
      PurchaseHeader@1003 : Record 38;
      PurchaseLine@1004 : Record 39;
      AssemblyLine@1006 : Record 901;
      Item@1007 : Record 27;
      ItemJournalLine@1008 : Record 83;
      Resource@1010 : Record 156;
    BEGIN
      IF AdjustHeader THEN
        ItemNo := AssemblyHeader."Item No.";
      Item.GET(ItemNo);

      CASE AdjustmentSource OF
        AdjSource::Purchase:
          BEGIN
            LibraryPurchase.CreatePurchHeader(
              PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
            LibraryPurchase.CreatePurchaseLine(
              PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,LibraryRandom.RandInt(10));
            PurchaseHeader.VALIDATE(
              "Vendor Invoice No.",LibraryUtility.GenerateRandomCode(PurchaseHeader.FIELDNO("Vendor Invoice No."),
                DATABASE::"Purchase Header"));
            PurchaseHeader.MODIFY(TRUE);
            LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
          END;
        AdjSource::Revaluation:
          BEGIN
            RevaluateItem(Item,ItemJournalLine,Item."Unit Cost",PostingDate);
            LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
          END;
        AdjSource::"Item Card":
          BEGIN
            Item."Unit Cost" := Item."Unit Cost" + LibraryRandom.RandDec(10,2);
            IF Item."Costing Method" = Item."Costing Method"::Standard THEN
              Item."Standard Cost" := Item."Standard Cost" + LibraryRandom.RandDec(10,2);
            Item.MODIFY(TRUE);
          END;
        AdjSource::"Order Lines":
          BEGIN
            ResourceNo := CreateResource(Resource,TRUE,Item."Gen. Prod. Posting Group");
            EditAssemblyLines(ChangeType::Add,AssemblyLine.Type::Resource,AssemblyLine.Type::Resource,ResourceNo,
              AssemblyHeader."No.",TRUE);
          END;
        AdjSource::Resource:
          BEGIN
            Resource.GET(ResourceNo);
            Resource."Unit Cost" := Resource."Unit Cost" + LibraryRandom.RandDec(10,2);
            Resource.MODIFY(TRUE);
          END
      END;
    END;

    [Normal]
    PROCEDURE CreateItemWithSKU@208(VAR Item@1008 : Record 27;CostingMethod@1003 : Option;ReplenishmentSystem@1004 : Option;CreatePer@1007 : 'Location,Variant,Location & Variant';GenProdPostingGr@1005 : Code[10];InvtPostingGr@1001 : Code[10];LocationCode@1000 : Code[10]);
    VAR
      ItemVariant@1002 : Record 5401;
    BEGIN
      CreateItem(Item,CostingMethod,ReplenishmentSystem,GenProdPostingGr,InvtPostingGr);
      IF CreatePer <> CreatePer::Location THEN
        LibraryInventory.CreateVariant(ItemVariant,Item);
      Item."Location Filter" := LocationCode;
      Item.MODIFY;
      Item.SETRANGE("Location Filter",LocationCode);
      Item.SETRECFILTER;
      LibraryInventory.CreateStockKeepingUnit(Item,CreatePer,FALSE,TRUE);
      UpdateSKUCards(Item);
    END;

    [Normal]
    PROCEDURE CheckOrderDimensions@72(AssemblyHeader@1000 : Record 900;DimensionsFrom@1001 : Option);
    VAR
      AssemblyLine@1005 : Record 901;
      AssemblySetup@1002 : Record 905;
      TableID@1003 : Integer;
    BEGIN
      VerifyEntityDimensions(
        DATABASE::Item,AssemblyHeader."Item No.",AssemblyHeader."Item No.",TRUE,AssemblyHeader."Dimension Set ID");

      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      IF AssemblyLine.FINDSET THEN
        REPEAT
          CASE AssemblyLine.Type OF
            AssemblyLine.Type::Item:
              TableID := DATABASE::Item;
            AssemblyLine.Type::Resource:
              TableID := DATABASE::Resource;
            AssemblyLine.Type::" ":
              BEGIN
                TableID := 0;
                AssemblyLine.TESTFIELD("Dimension Set ID",0);
              END;
          END;
          VerifyEntityDimensions(
            TableID,AssemblyLine."No.",AssemblyHeader."Item No.",
            DimensionsFrom = AssemblySetup."Copy Component Dimensions from"::"Order Header",
            AssemblyLine."Dimension Set ID");
        UNTIL AssemblyLine.NEXT = 0;
    END;

    PROCEDURE CreateResource@3(VAR Resource@1000 : Record 156;UseRelatedUnitOfMeasure@1002 : Boolean;GenProdPostingGroup@1005 : Code[10]) : Code[20];
    VAR
      GeneralPostingSetup@1006 : Record 252;
      ResourceUnitOfMeasure@1001 : Record 205;
      UnitOfMeasure@1003 : Record 204;
      VATPostingSetup@1004 : Record 325;
    BEGIN
      LibraryERM.FindVATPostingSetup(VATPostingSetup,VATPostingSetup."VAT Calculation Type"::"Normal VAT");
      LibraryResource.CreateResource(Resource,VATPostingSetup."VAT Bus. Posting Group");
      UnitOfMeasure.SETFILTER(Code,'<>%1',Resource."Base Unit of Measure");
      UnitOfMeasure.FINDFIRST;

      // Add a second non-base unit of measure.
      CLEAR(ResourceUnitOfMeasure);
      ResourceUnitOfMeasure.INIT;
      ResourceUnitOfMeasure.VALIDATE("Resource No.",Resource."No.");
      ResourceUnitOfMeasure.VALIDATE(Code,UnitOfMeasure.Code);
      ResourceUnitOfMeasure.INSERT(TRUE);
      ResourceUnitOfMeasure.VALIDATE("Qty. per Unit of Measure",RANDOM(10));
      ResourceUnitOfMeasure.VALIDATE("Related to Base Unit of Meas.",UseRelatedUnitOfMeasure);
      ResourceUnitOfMeasure.MODIFY(TRUE);

      IF GenProdPostingGroup = '' THEN BEGIN
        LibraryERM.FindGeneralPostingSetupInvtToGL(GeneralPostingSetup);
        GenProdPostingGroup := GeneralPostingSetup."Gen. Prod. Posting Group";
      END;
      Resource.VALIDATE("Gen. Prod. Posting Group",GenProdPostingGroup);
      Resource.MODIFY(TRUE);

      EXIT(Resource."No.")
    END;

    [Normal]
    PROCEDURE DeleteAssemblyLine@10(ComponentType@1000 : Option;AssemblyHeaderNo@1005 : Code[20]);
    VAR
      AssemblyLine@1004 : Record 901;
    BEGIN
      AssemblyLine.SETCURRENTKEY("Document Type","Document No.",Type);
      AssemblyLine.SETRANGE("Document Type",AssemblyLine."Document Type"::Order);
      AssemblyLine.SETRANGE("Document No.",AssemblyHeaderNo);
      AssemblyLine.SETRANGE(Type,ComponentType);
      IF NOT AssemblyLine.FINDSET THEN
        EXIT;
      AssemblyLine.NEXT(RANDOM(AssemblyLine.COUNT));
      AssemblyLine.DELETE;
    END;

    [Normal]
    PROCEDURE DeleteAssemblyLines@9(AssemblyHeaderNo@1005 : Code[20]);
    VAR
      AssemblyLine@1004 : Record 901;
    BEGIN
      AssemblyLine.SETRANGE("Document No.",AssemblyHeaderNo);
      AssemblyLine.DELETEALL;
    END;

    PROCEDURE DeleteAssemblyListComponent@26(ComponentType@1000 : Option;ParentItemNo@1005 : Code[20]);
    VAR
      BOMComponent@1004 : Record 90;
    BEGIN
      BOMComponent.SETRANGE("Parent Item No.",ParentItemNo);
      BOMComponent.SETRANGE(Type,ComponentType);
      IF NOT BOMComponent.FINDSET THEN
        EXIT;
      BOMComponent.NEXT(RANDOM(BOMComponent.COUNT));
      BOMComponent.DELETE;
    END;

    PROCEDURE DeleteAssemblyList@44(ParentItemNo@1005 : Code[20]);
    VAR
      BOMComponent@1004 : Record 90;
    BEGIN
      BOMComponent.SETRANGE("Parent Item No.",ParentItemNo);
      BOMComponent.DELETEALL;
    END;

    PROCEDURE EditAssemblyListComponent@23(ComponentType@1000 : Option;NewComponentType@1007 : Option;NewComponentNo@1006 : Code[20];ParentItemNo@1005 : Code[20];ResourceUsage@1008 : Option;Qty@1002 : Decimal;UseBaseUnitOfMeasure@1003 : Boolean);
    VAR
      BOMComponent@1004 : Record 90;
    BEGIN
      BOMComponent.SETRANGE("Parent Item No.",ParentItemNo);
      BOMComponent.SETRANGE(Type,ComponentType);
      IF NOT BOMComponent.FINDSET THEN
        EXIT;

      BOMComponent.NEXT(RANDOM(BOMComponent.COUNT));
      IF NewComponentNo <> '' THEN BEGIN
        BOMComponent.VALIDATE(Type,NewComponentType);
        BOMComponent.VALIDATE("No.",NewComponentNo);
        BOMComponent.VALIDATE("Unit of Measure Code",GetUnitOfMeasureCode(NewComponentType,NewComponentNo,UseBaseUnitOfMeasure));
      END ELSE
        BOMComponent.VALIDATE("Unit of Measure Code",GetUnitOfMeasureCode(BOMComponent.Type,BOMComponent."No.",UseBaseUnitOfMeasure));
      IF ComponentType = BOMComponent.Type::Resource THEN
        BOMComponent.VALIDATE("Resource Usage Type",ResourceUsage);
      BOMComponent.VALIDATE("Quantity per",Qty);
      BOMComponent.VALIDATE(
        Description,LibraryUtility.GenerateRandomCode(BOMComponent.FIELDNO(Description),DATABASE::"BOM Component"));
      BOMComponent.MODIFY(TRUE);
    END;

    PROCEDURE EditAssemblyList@79(ChangeType@1000 : ' ,Add,Replace,Delete,Edit,Delete all,Edit cards';ComponentType@1003 : Option;NewComponentType@1001 : Option;NewComponentNo@1002 : Code[20];ParentItemNo@1004 : Code[20]);
    VAR
      BOMComponent@1006 : Record 90;
    BEGIN
      CASE ChangeType OF
        ChangeType::Add:
          CreateAssemblyListComponent(
            NewComponentType,NewComponentNo,ParentItemNo,'',BOMComponent."Resource Usage Type"::Direct,
            LibraryRandom.RandDec(20,2),TRUE);
        ChangeType::Replace:
          EditAssemblyListComponent(
            ComponentType,NewComponentType,NewComponentNo,ParentItemNo,BOMComponent."Resource Usage Type"::Direct,
            LibraryRandom.RandDec(20,2),TRUE);
        ChangeType::Delete:
          DeleteAssemblyListComponent(ComponentType,ParentItemNo);
        ChangeType::Edit:
          EditAssemblyListComponent(
            ComponentType,NewComponentType,'',ParentItemNo,BOMComponent."Resource Usage Type"::Direct,
            LibraryRandom.RandDec(20,2),FALSE);
        ChangeType::"Delete all":
          DeleteAssemblyList(ParentItemNo);
        ChangeType::"Edit cards":
          ModifyCostParams(ParentItemNo,FALSE,0,0);
      END;
    END;

    [Normal]
    PROCEDURE EditAssemblyLine@11(ComponentType@1000 : Option;NewComponentType@1007 : Option;NewComponentNo@1006 : Code[20];AssemblyHeaderNo@1005 : Code[20];Qty@1002 : Decimal;UseBaseUnitOfMeasure@1003 : Boolean);
    VAR
      AssemblyLine@1004 : Record 901;
    BEGIN
      AssemblyLine.SETCURRENTKEY("Document Type","Document No.",Type);
      AssemblyLine.SETRANGE("Document Type",AssemblyLine."Document Type"::Order);
      AssemblyLine.SETRANGE("Document No.",AssemblyHeaderNo);
      AssemblyLine.SETRANGE(Type,ComponentType);
      IF NOT AssemblyLine.FINDSET THEN
        EXIT;
      AssemblyLine.NEXT(RANDOM(AssemblyLine.COUNT));

      IF AssemblyLine.Type = AssemblyLine.Type::Item THEN
        AssemblyLine.VALIDATE("Variant Code",LibraryInventory.GetVariant(AssemblyLine."No.",AssemblyLine."Variant Code"));
      AssemblyLine.VALIDATE(Description,
        LibraryUtility.GenerateRandomCode(AssemblyLine.FIELDNO(Description),DATABASE::"Assembly Line"));
      AssemblyLine.VALIDATE("Quantity per",Qty);

      IF NewComponentNo <> '' THEN BEGIN
        AssemblyLine.VALIDATE(Type,NewComponentType);
        AssemblyLine.VALIDATE("No.",NewComponentNo);
        AssemblyLine.VALIDATE("Unit of Measure Code",GetUnitOfMeasureCode(NewComponentType,NewComponentNo,UseBaseUnitOfMeasure));
      END ELSE
        AssemblyLine.VALIDATE("Unit of Measure Code",
          GetUnitOfMeasureCode(AssemblyLine.Type,AssemblyLine."No.",UseBaseUnitOfMeasure));

      AssemblyLine.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE EditAssemblyLines@8(ChangeType@1000 : ' ,Add,Replace,Delete,Edit,Delete all,Edit cards,Usage';ComponentType@1003 : Option;NewComponentType@1001 : Option;NewComponentNo@1002 : Code[20];AssemblyHeaderNo@1004 : Code[20];UseBaseUnitOfMeasure@1005 : Boolean);
    VAR
      AssemblyHeader@1006 : Record 900;
      AssemblyLine@1007 : Record 901;
    BEGIN
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,AssemblyHeaderNo);
      CASE ChangeType OF
        ChangeType::Add:
          CreateAssemblyLine(AssemblyHeader,AssemblyLine,NewComponentType,NewComponentNo,
            GetUnitOfMeasureCode(NewComponentType,NewComponentNo,TRUE),AssemblyHeader.Quantity,1,'');
        ChangeType::Replace:
          EditAssemblyLine(
            ComponentType,NewComponentType,NewComponentNo,AssemblyHeaderNo,LibraryRandom.RandDec(20,2),
            UseBaseUnitOfMeasure);
        ChangeType::Delete:
          DeleteAssemblyLine(ComponentType,AssemblyHeaderNo);
        ChangeType::Edit:
          EditAssemblyLine(
            ComponentType,NewComponentType,'',AssemblyHeaderNo,LibraryRandom.RandDec(20,2),UseBaseUnitOfMeasure);
        ChangeType::"Delete all":
          DeleteAssemblyLines(AssemblyHeaderNo);
        ChangeType::"Edit cards":
          ModifyCostParams(AssemblyHeaderNo,FALSE,0,0);
        ChangeType::Usage:
          ChangeResourceUsage(AssemblyHeaderNo);
      END;
      COMMIT;
    END;

    [Normal]
    PROCEDURE EditOrderDimensions@105(AssemblyHeader@1000 : Record 900);
    VAR
      TempDimension@1003 : TEMPORARY Record 348;
      TempDimensionValue@1004 : TEMPORARY Record 349;
    BEGIN
      CreateDimensionSetup(TempDimension,TempDimensionValue);
      AssemblyHeader.VALIDATE("Dimension Set ID",
        LibraryDimension.CreateDimSet(AssemblyHeader."Dimension Set ID",TempDimension.Code,TempDimensionValue.Code));
    END;

    [Normal]
    LOCAL PROCEDURE FindHeaderValueEntries@113(VAR ValueEntry@1002 : Record 5802;PostedAssemblyHeader@1000 : Record 910;EntryType@1003 : Option;ItemLedgerEntryType@1004 : Option);
    BEGIN
      ValueEntry.RESET;
      ValueEntry.SETRANGE("Item No.",PostedAssemblyHeader."Item No.");
      ValueEntry.SETRANGE("Item Ledger Entry Type",ItemLedgerEntryType);
      ValueEntry.SETRANGE("Entry Type",EntryType);
      ValueEntry.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      ValueEntry.SETRANGE("Location Code",PostedAssemblyHeader."Location Code");
      ValueEntry.SETRANGE("Variant Code",PostedAssemblyHeader."Variant Code");
      ValueEntry.SETRANGE("Inventory Posting Group",PostedAssemblyHeader."Inventory Posting Group");
      ValueEntry.SETRANGE("Gen. Prod. Posting Group",PostedAssemblyHeader."Gen. Prod. Posting Group");
      ValueEntry.SETRANGE("Item Ledger Entry Quantity",0);
      ValueEntry.SETRANGE("Invoiced Quantity",0);
      ValueEntry.SETRANGE("Valued Quantity",PostedAssemblyHeader.Quantity);
      ValueEntry.SETRANGE("Order Type",ValueEntry."Order Type"::Assembly);
      ValueEntry.SETRANGE("Order No.",PostedAssemblyHeader."Order No.");
      ValueEntry.SETRANGE("Order Line No.",0);
    END;

    [Normal]
    LOCAL PROCEDURE FindLineValueEntries@96(VAR ValueEntry@1002 : Record 5802;PostedAssemblyLine@1000 : Record 911;EntryType@1003 : Option;ItemLedgerEntryType@1004 : Option);
    BEGIN
      ValueEntry.RESET;
      IF PostedAssemblyLine.Type = PostedAssemblyLine.Type::Item THEN
        ValueEntry.SETRANGE("Item No.",PostedAssemblyLine."No.")
      ELSE BEGIN
        ValueEntry.SETRANGE(Type,ValueEntry.Type::Resource);
        ValueEntry.SETRANGE("No.",PostedAssemblyLine."No.");
      END;
      ValueEntry.SETRANGE("Item Ledger Entry Type",ItemLedgerEntryType);
      ValueEntry.SETRANGE("Entry Type",EntryType);
      ValueEntry.SETRANGE("Document No.",PostedAssemblyLine."Document No.");
      ValueEntry.SETRANGE("Location Code",PostedAssemblyLine."Location Code");
      ValueEntry.SETRANGE("Variant Code",PostedAssemblyLine."Variant Code");
      IF ItemLedgerEntryType = ValueEntry."Item Ledger Entry Type"::"Assembly Consumption" THEN
        ValueEntry.SETRANGE("Valued Quantity",-PostedAssemblyLine.Quantity)
      ELSE
        ValueEntry.SETRANGE("Valued Quantity",PostedAssemblyLine.Quantity);
      ValueEntry.SETRANGE("Order Type",ValueEntry."Order Type"::Assembly);
      ValueEntry.SETRANGE("Order No.",PostedAssemblyLine."Order No.");
      ValueEntry.SETRANGE("Order Line No.",PostedAssemblyLine."Order Line No.");
    END;

    PROCEDURE FindPostedAssemblyLines@55(VAR PostedAssemblyLine@1000 : Record 911;PostedAssemblyHeader@1001 : Record 910);
    BEGIN
      PostedAssemblyLine.RESET;
      PostedAssemblyLine.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      PostedAssemblyLine.SETRANGE("Order No.",PostedAssemblyHeader."Order No.");
      PostedAssemblyLine.SETRANGE(Type,PostedAssemblyLine.Type::Item);
    END;

    PROCEDURE FindPostedAssemblyHeaders@40(VAR PostedAssemblyHeader@1001 : Record 910;AssemblyHeader@1000 : Record 900);
    BEGIN
      PostedAssemblyHeader.RESET;
      PostedAssemblyHeader.SETRANGE("Order No.",AssemblyHeader."No.");
      PostedAssemblyHeader.SETRANGE("Item No.",AssemblyHeader."Item No.");
    END;

    [Normal]
    PROCEDURE GetBOMComponentLines@36(VAR TempBOMComponent@1000 : TEMPORARY Record 90;ParentItemNo@1001 : Code[20]);
    VAR
      BOMComponent@1002 : Record 90;
      Item@1003 : Record 27;
    BEGIN
      BOMComponent.SETRANGE("Parent Item No.",ParentItemNo);
      BOMComponent.SETRANGE(Type,BOMComponent.Type::Item);
      IF BOMComponent.FINDSET THEN
        REPEAT
          Item.GET(BOMComponent."No.");
          IF Item."Assembly BOM" THEN
            GetBOMComponentLines(TempBOMComponent,Item."No.")
          ELSE BEGIN
            TempBOMComponent := BOMComponent;
            TempBOMComponent.INSERT;
          END;
        UNTIL BOMComponent.NEXT = 0;

      BOMComponent.SETRANGE(Type,BOMComponent.Type::Resource);
      IF BOMComponent.FINDSET THEN
        REPEAT
          TempBOMComponent := BOMComponent;
          TempBOMComponent.INSERT;
        UNTIL BOMComponent.NEXT = 0;
    END;

    [Normal]
    PROCEDURE GetCostInformation@61(VAR UnitCost@1006 : Decimal;VAR Overhead@1005 : Decimal;VAR IndirectCost@1004 : Decimal;Type@1000 : Option;No@1001 : Code[20];VariantCode@1008 : Code[10];LocationCode@1009 : Code[10]) : Boolean;
    VAR
      Resource@1002 : Record 156;
      Item@1003 : Record 27;
      AssemblyLine@1007 : Record 901;
      StockkeepingUnit@1010 : Record 5700;
    BEGIN
      CASE Type OF
        AssemblyLine.Type::Item:
          BEGIN
            Item.GET(No);
            StockkeepingUnit.SETCURRENTKEY("Location Code","Item No.","Variant Code");
            IF StockkeepingUnit.GET(LocationCode,Item."No.",VariantCode) THEN
              UnitCost := StockkeepingUnit."Unit Cost"
            ELSE
              UnitCost := Item."Unit Cost";
            Overhead := Item."Overhead Rate";
            IndirectCost := Item."Indirect Cost %";
            EXIT(Item."Cost is Adjusted");
          END;
        AssemblyLine.Type::Resource:
          BEGIN
            Resource.GET(No);
            UnitCost := Resource."Unit Cost";
            Overhead := Resource."Unit Cost" - Resource."Direct Unit Cost";
            IndirectCost := Resource."Indirect Cost %";
            EXIT(FALSE);
          END;
      END;
    END;

    PROCEDURE GetUnitOfMeasureCode@14(ComponentType@1000 : Option;ComponentNo@1001 : Code[20];UseBaseUnitOfMeasure@1002 : Boolean) : Code[10];
    VAR
      Item@1003 : Record 27;
      Resource@1004 : Record 156;
      ItemUnitOfMeasure@1005 : Record 5404;
      ResourceUnitOfMeasure@1006 : Record 205;
      BOMComponent@1007 : Record 90;
    BEGIN
      CASE ComponentType OF
        BOMComponent.Type::Item:
          BEGIN
            Item.GET(ComponentNo);
            IF UseBaseUnitOfMeasure THEN
              EXIT(Item."Base Unit of Measure");
            ItemUnitOfMeasure.SETRANGE("Item No.",Item."No.");
            ItemUnitOfMeasure.SETFILTER(Code,'<>%1',Item."Base Unit of Measure");
            IF ItemUnitOfMeasure.FINDFIRST THEN
              EXIT(ItemUnitOfMeasure.Code);
          END;
        BOMComponent.Type::Resource:
          BEGIN
            Resource.GET(ComponentNo);
            IF UseBaseUnitOfMeasure THEN
              EXIT(Resource."Base Unit of Measure");
            ResourceUnitOfMeasure.SETRANGE("Resource No.",Resource."No.");
            ResourceUnitOfMeasure.SETFILTER(Code,'<>%1',Resource."Base Unit of Measure");
            IF ResourceUnitOfMeasure.FINDFIRST THEN
              EXIT(ResourceUnitOfMeasure.Code);
          END
      END;
      EXIT('');
    END;

    [Normal]
    PROCEDURE GetAdjAmounts@206(VAR VarianceAmount@1002 : Decimal;VAR AdjAmount@1006 : Decimal;PostedAssemblyHeader@1000 : Record 910);
    VAR
      ValueEntry@1001 : Record 5802;
      DirectCostAmount@1004 : Decimal;
      OutputNotAdjAmount@1005 : Decimal;
    BEGIN
      ValueEntry.RESET;
      ValueEntry.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      ValueEntry.SETRANGE("Order Type",ValueEntry."Order Type"::Assembly);
      ValueEntry.SETRANGE("Order No.",PostedAssemblyHeader."Order No.");
      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::"Direct Cost");
      DirectCostAmount := 0;
      OutputNotAdjAmount := 0;

      IF ValueEntry.FINDSET THEN
        REPEAT
          CASE ValueEntry."Item Ledger Entry Type" OF
            ValueEntry."Item Ledger Entry Type"::" ":
              DirectCostAmount += -ValueEntry."Cost Amount (Actual)";
            ValueEntry."Item Ledger Entry Type"::"Assembly Consumption":
              DirectCostAmount += ValueEntry."Cost Amount (Actual)";
            ValueEntry."Item Ledger Entry Type"::"Assembly Output":
              IF NOT ValueEntry.Adjustment THEN
                OutputNotAdjAmount += ValueEntry."Cost Amount (Actual)";
          END;
        UNTIL ValueEntry.NEXT = 0;

      AdjAmount := DirectCostAmount + OutputNotAdjAmount;
      VarianceAmount := DirectCostAmount + PostedAssemblyHeader."Cost Amount";
    END;

    [Normal]
    PROCEDURE GetCompsToAdjust@5(VAR ItemNo@1001 : ARRAY [10] OF Code[20];VAR ResourceNo@1005 : ARRAY [10] OF Code[20];AssemblyHeader@1000 : Record 900) : Text[250];
    VAR
      AssemblyLine@1002 : Record 901;
      ItemFilter@1003 : Text[250];
      i@1004 : Integer;
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      ItemFilter := AssemblyHeader."Item No.";
      i := 1;
      IF AssemblyLine.FINDSET THEN
        REPEAT
          ItemNo[i] := AssemblyLine."No.";
          ItemFilter += '|' + ItemNo[i];
          i += 1;
        UNTIL AssemblyLine.NEXT = 0;
      ItemFilter := DELCHR(ItemFilter,'>','|');

      i := 1;
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Resource);
      IF AssemblyLine.FINDSET THEN
        REPEAT
          ResourceNo[i] := AssemblyLine."No.";
          i += 1;
        UNTIL AssemblyLine.NEXT = 0;

      EXIT(ItemFilter)
    END;

    [Normal]
    LOCAL PROCEDURE GetValueEntriesAmount@87(PostedAssemblyHeader@1000 : Record 910;ItemLedgerEntryType@1003 : Option;EntryType@1004 : Option;VarianceType@1005 : Option;ItemNo@1007 : Code[20];PostedToGL@1006 : Boolean) : Decimal;
    VAR
      ValueEntry@1001 : Record 5802;
      Amount@1002 : Decimal;
    BEGIN
      ValueEntry.RESET;
      ValueEntry.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      ValueEntry.SETRANGE("Order Type",ValueEntry."Order Type"::Assembly);
      ValueEntry.SETRANGE("Order No.",PostedAssemblyHeader."Order No.");
      ValueEntry.SETRANGE("Item Ledger Entry Type",ItemLedgerEntryType);
      ValueEntry.SETRANGE("Variance Type",VarianceType);
      ValueEntry.SETRANGE("Entry Type",EntryType);
      IF ItemNo <> '' THEN
        ValueEntry.SETRANGE("Item No.",ItemNo);
      IF PostedToGL THEN
        ValueEntry.SETFILTER("Cost Posted to G/L",'<>%1',0);
      Amount := 0;
      IF ValueEntry.FINDSET THEN
        REPEAT
          Amount += ValueEntry."Cost Amount (Actual)";
        UNTIL ValueEntry.NEXT = 0;
      EXIT(Amount);
    END;

    [Normal]
    PROCEDURE GetPostingSetup@68(VAR GeneralPostingSetup@1001 : Record 252;VAR InventoryPostingSetup@1002 : Record 5813;GenProdPostingGr@1000 : Code[10];InvtPostingGroup@1004 : Code[10];LocationCode@1007 : Code[10]);
    BEGIN
      GeneralPostingSetup.GET('',GenProdPostingGr);
      InventoryPostingSetup.GET(LocationCode,InvtPostingGroup);
    END;

    PROCEDURE ModifyCostParams@15(ParentItemNo@1000 : Code[20];CostAdjNeeded@1001 : Boolean;IndirectCost@1002 : Decimal;Overhead@1003 : Decimal);
    VAR
      Resource@1005 : Record 156;
      BOMComponent@1006 : Record 90;
    BEGIN
      BOMComponent.SETRANGE("Parent Item No.",ParentItemNo);
      IF BOMComponent.FINDSET THEN
        REPEAT
          CASE BOMComponent.Type OF
            BOMComponent.Type::Item:
              ModifyItem(BOMComponent."No.",CostAdjNeeded,IndirectCost,Overhead);
            BOMComponent.Type::Resource:
              BEGIN
                Resource.GET(BOMComponent."No.");
                Resource.VALIDATE("Unit Price",Resource."Unit Price" + LibraryRandom.RandDec(10,2));
                IF CostAdjNeeded THEN BEGIN
                  Resource.VALIDATE("Direct Unit Cost",Resource."Direct Unit Cost" + LibraryRandom.RandDec(10,2));
                  Resource.VALIDATE("Indirect Cost %",IndirectCost);
                END;
                Resource.MODIFY(TRUE);
              END
          END;
        UNTIL BOMComponent.NEXT = 0;
    END;

    PROCEDURE ModifyItem@24(ItemNo@1000 : Code[20];CostAdjNeeded@1001 : Boolean;IndirectCost@1002 : Decimal;Overhead@1003 : Decimal);
    VAR
      Item@1004 : Record 27;
    BEGIN
      Item.GET(ItemNo);
      IF CostAdjNeeded THEN BEGIN
        Item.VALIDATE("Indirect Cost %",IndirectCost);
        Item.VALIDATE("Overhead Rate",Overhead);
        IF Item."Costing Method" = Item."Costing Method"::Standard THEN
          Item.VALIDATE("Standard Cost",Item."Standard Cost" + LibraryRandom.RandDec(10,2))
        ELSE
          Item.VALIDATE("Unit Cost",Item."Unit Cost" + LibraryRandom.RandDec(10,2));
      END;

      Item.VALIDATE("Unit Price",Item."Unit Price" + LibraryRandom.RandDec(10,2));
      Item.VALIDATE("Lot Size",Item."Lot Size" + LibraryRandom.RandInt(10));
      Item.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE ModifyOrderCostParams@13(AssemblyHeaderNo@1000 : Code[20];CostAdjNeeded@1001 : Boolean;IndirectCost@1002 : Decimal;Overhead@1003 : Decimal);
    VAR
      Resource@1005 : Record 156;
      AssemblyLine@1006 : Record 901;
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyLine."Document Type"::Order);
      AssemblyLine.SETRANGE("Document No.",AssemblyHeaderNo);
      IF AssemblyLine.FINDSET THEN
        REPEAT
          CASE AssemblyLine.Type OF
            AssemblyLine.Type::Item:
              ModifyItem(AssemblyLine."No.",CostAdjNeeded,IndirectCost,Overhead);
            AssemblyLine.Type::Resource:
              BEGIN
                Resource.GET(AssemblyLine."No.");
                Resource.VALIDATE("Indirect Cost %",IndirectCost);
                Resource.VALIDATE("Unit Price",Resource."Unit Price" + LibraryRandom.RandDec(10,2));
                Resource.VALIDATE("Unit Cost",Resource."Unit Cost" + LibraryRandom.RandDec(10,2));
                Resource.MODIFY(TRUE);
              END
          END;
        UNTIL AssemblyLine.NEXT = 0;
    END;

    PROCEDURE NeedsAdjustment@20(VAR AdjUnitCost@1002 : Decimal;Item@1000 : Record 27;PostedAssemblyLine@1001 : Record 911;FinalAdjSource@1004 : Option;UnitCost@1006 : Decimal) : Boolean;
    VAR
      ValueEntry@1003 : Record 5802;
    BEGIN
      AdjUnitCost := UnitCost - PostedAssemblyLine."Unit Cost";

      ValueEntry.RESET;
      ValueEntry.SETRANGE("Item No.",Item."No.");
      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::Revaluation);
      IF ValueEntry.FINDFIRST AND (FinalAdjSource = AdjSource::Revaluation) THEN
        AdjUnitCost -= ValueEntry."Cost per Unit";

      EXIT(
        Item."Cost is Adjusted" AND
        (ABS(AdjUnitCost) > LibraryERM.GetAmountRoundingPrecision) AND
        (ABS(AdjUnitCost * PostedAssemblyLine.Quantity) >= LibraryERM.GetAmountRoundingPrecision)
        )
    END;

    [Normal]
    PROCEDURE PostAssemblyHeader@172(AssemblyHeader@1000 : Record 900;ExpectedError@1002 : Text[1024]);
    VAR
      AssemblyPost@1003 : Codeunit 900;
    BEGIN
      IF ExpectedError = '' THEN
        AssemblyPost.RUN(AssemblyHeader)
      ELSE BEGIN
        ASSERTERROR AssemblyPost.RUN(AssemblyHeader);
        Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ExpectedError) > 0,
          'Expected:' + ExpectedError + '. Actual:' + GETLASTERRORTEXT);
        CLEARLASTERROR;
      END;
      COMMIT;
    END;

    PROCEDURE PostInvtCostToGL@1(PerPostingGroup@1002 : Boolean;ItemNo@1005 : Code[20];DocNo@1001 : Code[20];PreviewDumpFilePath@1003 : Text[1024]);
    VAR
      PostValueEntryToGL@1006 : Record 5811;
      PostInventoryCostToGL@1000 : Report 1002;
      PostMethod@1004 : 'per Posting Group,per Entry';
    BEGIN
      COMMIT;
      PostValueEntryToGL.SETFILTER("Item No.",'>=%1',ItemNo);

      IF PerPostingGroup THEN
        PostMethod := PostMethod::"per Posting Group"
      ELSE
        PostMethod := PostMethod::"per Entry";
      PostInventoryCostToGL.InitializeRequest(PostMethod,DocNo,TRUE);
      PostInventoryCostToGL.SETTABLEVIEW(PostValueEntryToGL);
      PostInventoryCostToGL.USEREQUESTPAGE(FALSE);
      PostInventoryCostToGL.SAVEASPDF(PreviewDumpFilePath);
    END;

    [Normal]
    PROCEDURE PrepareOrderPosting@31(VAR AssemblyHeader@1000 : Record 900;VAR TempAssemblyLine@1006 : TEMPORARY Record 901;HeaderQtyFactor@1005 : Integer;CompQtyFactor@1001 : Integer;UpdateAllComps@1002 : Boolean;PostingDate@1007 : Date);
    VAR
      AssemblyLine@1004 : Record 901;
    BEGIN
      TempAssemblyLine.DELETEALL;
      AssemblyHeader.VALIDATE("Quantity to Assemble",AssemblyHeader."Quantity to Assemble" * HeaderQtyFactor / 100);
      AssemblyHeader.VALIDATE(Description,
        LibraryUtility.GenerateRandomCode(AssemblyHeader.FIELDNO(Description),DATABASE::"Assembly Header"));
      AssemblyHeader.VALIDATE("Posting Date",PostingDate);
      AddAssemblyHeaderComment(AssemblyHeader,0);
      AssemblyHeader.MODIFY(TRUE);

      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      IF AssemblyLine.FINDSET THEN
        REPEAT
          AssemblyLine.VALIDATE("Quantity to Consume",AssemblyLine.Quantity * CompQtyFactor / 100);
          AssemblyLine.VALIDATE(Description,
            LibraryUtility.GenerateRandomCode(AssemblyLine.FIELDNO(Description),DATABASE::"Assembly Line"));
          AddAssemblyHeaderComment(AssemblyHeader,AssemblyLine."Line No.");
          AssemblyLine.MODIFY(TRUE);
          IF AssemblyLine."Quantity to Consume" > 0 THEN BEGIN
            TempAssemblyLine := AssemblyLine;
            TempAssemblyLine.INSERT;
          END;
        UNTIL (AssemblyLine.NEXT = 0) OR (NOT UpdateAllComps);
    END;

    PROCEDURE ReopenAO@75(VAR AssemblyHeader@1000 : Record 900);
    VAR
      ReleaseAssemblyDoc@1001 : Codeunit 903;
    BEGIN
      ReleaseAssemblyDoc.Reopen(AssemblyHeader);
    END;

    PROCEDURE ReleaseAO@84(VAR AssemblyHeader@1000 : Record 900);
    BEGIN
      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);
    END;

    PROCEDURE RevaluateItem@194(VAR Item@1006 : Record 27;VAR ItemJournalLine@1010 : Record 83;OldUnitCost@1009 : Decimal;PostingDate@1002 : Date);
    VAR
      ItemJournalTemplate@1000 : Record 82;
      ItemJournalBatch@1001 : Record 233;
      CalculatePer@1008 : 'Item Ledger Entry,Item';
      CalculationBase@1007 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Revaluation);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type::Revaluation,ItemJournalTemplate.Name);
      LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::Purchase,Item."No.",0);
      Item.SETRANGE("No.",Item."No.");
      LibraryCosting.CreateRevaluationJnlLines(Item,ItemJournalLine,ItemJournalLine."Document No.",CalculatePer::Item,
        CalculationBase::" ",TRUE,TRUE,TRUE,PostingDate);

      ItemJournalLine.RESET;
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalLine."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalLine."Journal Batch Name");
      ItemJournalLine.SETRANGE("Item No.",Item."No.");
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE("Unit Cost (Revalued)",OldUnitCost + RANDOM(50));
      ItemJournalLine.MODIFY(TRUE);
    END;

    PROCEDURE RollUpAsmCost@73(VAR SalesLine@1000 : Record 37);
    BEGIN
      SalesLine.RollUpAsmCost;
    END;

    PROCEDURE RollUpAsmPrice@71(VAR SalesLine@1000 : Record 37);
    BEGIN
      SalesLine.RollupAsmPrice;
    END;

    [Normal]
    PROCEDURE SetupComponents@25(VAR TempItem@1000 : TEMPORARY Record 27;VAR TempResource@1001 : TEMPORARY Record 156;CostingMethod@1004 : Option;NoOfItems@1002 : Integer;NoOfResources@1003 : Integer;GenProdPostingGroup@1008 : Code[10];InventoryPostingGroup@1009 : Code[10]);
    VAR
      Item@1006 : Record 27;
      Resource@1007 : Record 156;
      AssemblyLine@1010 : Record 901;
      CompCount@1005 : Integer;
    BEGIN
      TempItem.DELETEALL;
      TempResource.DELETEALL;

      FOR CompCount := 1 TO NoOfItems DO BEGIN
        CLEAR(Item);
        CreateItem(Item,CostingMethod,Item."Replenishment System"::Purchase,GenProdPostingGroup,InventoryPostingGroup);
        AddEntityDimensions(AssemblyLine.Type::Item,Item."No.");
        TempItem := Item;
        TempItem.INSERT;
      END;

      FOR CompCount := 1 TO NoOfResources DO BEGIN
        CreateResource(Resource,TRUE,GenProdPostingGroup);
        AddEntityDimensions(AssemblyLine.Type::Resource,Resource."No.");
        TempResource := Resource;
        TempResource.INSERT;
      END;
    END;

    [Normal]
    PROCEDURE CreateAssemblyOrder@19(VAR AssemblyHeader@1001 : Record 900;DueDate@1004 : Date;LocationCode@1008 : Code[10];NoOfItems@1003 : Integer);
    VAR
      Item@1000 : Record 27;
    BEGIN
      SetupAssemblyItem(
        Item,Item."Costing Method"::Standard,Item."Costing Method"::Standard,Item."Replenishment System"::Assembly,LocationCode,FALSE,
        NoOfItems,
        LibraryRandom.RandIntInRange(1,3),
        LibraryRandom.RandIntInRange(1,3),
        LibraryRandom.RandIntInRange(1,10));

      CreateAssemblyHeader(AssemblyHeader,DueDate,Item."No.",LocationCode,LibraryRandom.RandDec(10,2),'');
    END;

    [Normal]
    PROCEDURE SetupAssemblyData@2(VAR AssemblyHeader@1001 : Record 900;DueDate@1012 : Date;ParentCostingMethod@1003 : Option;CompCostingMethod@1004 : Option;ReplenishmentSystem@1011 : Option;LocationCode@1008 : Code[10];UpdateUnitCost@1009 : Boolean);
    VAR
      Item@1000 : Record 27;
    BEGIN
      SetupAssemblyItem(Item,ParentCostingMethod,CompCostingMethod,ReplenishmentSystem,LocationCode,UpdateUnitCost,1,1,1,1);

      CreateAssemblyHeader(AssemblyHeader,DueDate,Item."No.",LocationCode,LibraryRandom.RandDec(10,2),'');
    END;

    [Normal]
    PROCEDURE SetupAssemblyItem@88(VAR Item@1001 : Record 27;ParentCostingMethod@1003 : Option;CompCostingMethod@1004 : Option;ReplenishmentSystem@1011 : Option;LocationCode@1008 : Code[10];UpdateUnitCost@1009 : Boolean;NoOfItems@1014 : Integer;NoOfResources@1013 : Integer;NoOfTexts@1000 : Integer;QtyPerFactor@1015 : Integer);
    VAR
      AssemblyLine@1010 : Record 901;
      CalculateStandardCost@1002 : Codeunit 5812;
      GenProdPostingGr@1006 : Code[10];
      AsmInvtPostingGr@1005 : Code[10];
      CompInvtPostingGr@1007 : Code[10];
    BEGIN
      SetupPostingToGL(GenProdPostingGr,AsmInvtPostingGr,CompInvtPostingGr,LocationCode);
      CreateItem(Item,ParentCostingMethod,ReplenishmentSystem,GenProdPostingGr,AsmInvtPostingGr);
      AddEntityDimensions(AssemblyLine.Type::Item,Item."No.");
      CreateAssemblyList(
        CompCostingMethod,Item."No.",TRUE,NoOfItems,NoOfResources,NoOfTexts,QtyPerFactor,GenProdPostingGr,CompInvtPostingGr);

      IF UpdateUnitCost THEN BEGIN
        CalculateStandardCost.CalcItem(Item."No.",TRUE);
        CalculateStandardCost.CalcAssemblyItemPrice(Item."No.");
      END;
    END;

    [Normal]
    PROCEDURE SetupItemJournal@138(VAR ItemJournalTemplate@1000 : Record 82;VAR ItemJournalBatch@1001 : Record 233);
    VAR
      NoSeries@1069 : Record 308;
      NoSeriesLine@1070 : Record 309;
    BEGIN
      CLEAR(ItemJournalTemplate);
      ItemJournalTemplate.INIT;
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);

      CLEAR(ItemJournalBatch);
      ItemJournalBatch.INIT;
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      IF ItemJournalBatch."No. Series" = '' THEN BEGIN
        LibraryUtility.CreateNoSeries(NoSeries,TRUE,TRUE,TRUE);
        LibraryUtility.CreateNoSeriesLine(NoSeriesLine,NoSeries.Code,'','');
        ItemJournalBatch.VALIDATE("No. Series",NoSeries.Code);
        ItemJournalBatch.MODIFY(TRUE);
      END;
    END;

    [Normal]
    PROCEDURE SetupWarehouseJournal@35(VAR WarehouseJournalTemplate@1000 : Record 7309;VAR WarehouseJournalBatch@1001 : Record 7310;LocationCode@1002 : Code[10]);
    BEGIN
      CLEAR(WarehouseJournalTemplate);
      WarehouseJournalTemplate.INIT;
      LibraryWarehouse.SelectWhseJournalTemplateName(WarehouseJournalTemplate,WarehouseJournalTemplate.Type::Item);
      WarehouseJournalTemplate.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      WarehouseJournalTemplate.MODIFY(TRUE);

      CLEAR(WarehouseJournalBatch);
      WarehouseJournalBatch.INIT;
      LibraryWarehouse.SelectWhseJournalBatchName(WarehouseJournalBatch,WarehouseJournalTemplate.Type,WarehouseJournalTemplate.Name,
        LocationCode);
      WarehouseJournalBatch.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      WarehouseJournalBatch.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE SetupPostingToGL@177(VAR GenProdPostingGr@1008 : Code[10];VAR AsmInvtPostingGr@1011 : Code[10];VAR CompInvtPostingGr@1012 : Code[10];LocationCode@1006 : Code[10]);
    VAR
      InventoryPostingGroup@1000 : Record 94;
      GLAccount@1001 : Record 15;
      GLAccount2@1002 : Record 15;
      GLAccount3@1003 : Record 15;
      GLAccount4@1005 : Record 15;
      GLAccount5@1004 : Record 15;
      GLAccount6@1250 : Record 15;
      GeneralPostingSetup@1010 : Record 252;
      InvtPostingSetup@1009 : Record 5813;
    BEGIN
      // Create Inventory posting setup accounts.
      // Assembly Item Inventory.
      CreateGLAccount(GLAccount,GLAccount."Income/Balance"::"Balance Sheet",'Output Inventory');
      // Material Variance.
      CreateGLAccount(GLAccount2,GLAccount."Income/Balance"::"Income Statement",'Material Variance');
      // Capacity Variance.
      CreateGLAccount(GLAccount3,GLAccount."Income/Balance"::"Income Statement",'Capacity Variance');
      // Capacity Overhead Variance.
      CreateGLAccount(GLAccount4,GLAccount."Income/Balance"::"Income Statement",'Capacity Overhead Variance');
      // Mfg. Overhead Variance.
      CreateGLAccount(GLAccount5,GLAccount."Income/Balance"::"Income Statement",'Mfg. Overhead Variance');
      // Inventory account (Interim)
      CreateGLAccount(GLAccount6,GLAccount."Income/Balance"::"Balance Sheet",'Inventory Account (Interim)');

      // Create Inventory Posting Group for Assembly Item.
      LibraryInventory.CreateInventoryPostingGroup(InventoryPostingGroup);
      AsmInvtPostingGr := InventoryPostingGroup.Code;

      // Create Inventory Posting Setup for Assembly Item.
      CreateInvtPostingSetup(InvtPostingSetup,LocationCode,InventoryPostingGroup.Code,GLAccount."No.",GLAccount2."No.",
        GLAccount3."No.",GLAccount4."No.",GLAccount5."No.",GLAccount6."No.");

      // Component Inventory Account.
      CreateGLAccount(GLAccount,GLAccount."Income/Balance"::"Balance Sheet",'Component Item Inventory');

      // Create Inventory Posting Group for Component.
      LibraryInventory.CreateInventoryPostingGroup(InventoryPostingGroup);
      CompInvtPostingGr := InventoryPostingGroup.Code;

      // Create Inventory Posting Setup for Assembly Item.
      CreateInvtPostingSetup(InvtPostingSetup,LocationCode,InventoryPostingGroup.Code,GLAccount."No.",GLAccount2."No.",
        GLAccount3."No.",GLAccount4."No.",GLAccount5."No.",GLAccount6."No.");

      LibraryERM.FindGeneralPostingSetupInvtToGL(GeneralPostingSetup);
      GenProdPostingGr := GeneralPostingSetup."Gen. Prod. Posting Group";
    END;

    PROCEDURE UndoPostedAssembly@74(VAR PostedAssemblyHeader@1000 : Record 910;RestoreAO@1003 : Boolean;ExpectedError@1002 : Text[1024]);
    VAR
      AsmPostCtrl@1001 : Codeunit 900;
    BEGIN
      CLEAR(AsmPostCtrl);
      IF ExpectedError = '' THEN
        AsmPostCtrl.Undo(PostedAssemblyHeader,RestoreAO)
      ELSE BEGIN
        ASSERTERROR AsmPostCtrl.Undo(PostedAssemblyHeader,RestoreAO);
        Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ExpectedError) > 0,'Actual:' + GETLASTERRORTEXT);
        CLEARLASTERROR;
      END;
    END;

    PROCEDURE UpdateOrderCost@137(VAR AssemblyHeader@1000 : Record 900);
    VAR
      Item@1002 : Record 27;
    BEGIN
      COMMIT;
      IF AssemblyHeader.Quantity = 0 THEN BEGIN
        ASSERTERROR AssemblyHeader.UpdateUnitCost;
        Assert.AreEqual(
          STRSUBSTNO(ErrorZeroQty,AssemblyHeader."No."),GETLASTERRORTEXT,
          'Actual:' + GETLASTERRORTEXT + '; Expected:' + STRSUBSTNO(ErrorZeroQty,AssemblyHeader."No."));
        CLEARLASTERROR;
        EXIT;
      END;

      Item.GET(AssemblyHeader."Item No.");
      IF Item."Costing Method" <> Item."Costing Method"::Standard THEN
        AssemblyHeader.UpdateUnitCost
      ELSE BEGIN
        ASSERTERROR AssemblyHeader.UpdateUnitCost;
        Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ErrorStdCost) > 0,'Actual:' + GETLASTERRORTEXT + '; Expected:' + ErrorStdCost);
        CLEARLASTERROR;
      END;

      COMMIT;
    END;

    [Normal]
    PROCEDURE UpdateAssemblySetup@18(VAR AssemblySetup@1004 : Record 905;LocationCode@1000 : Code[10];DimensionsFrom@1002 : Option;PostedOrdersNo@1003 : Code[10]);
    BEGIN
      AssemblySetup.GET;
      IF AssemblySetup."Assembly Order Nos." = '' THEN
        AssemblySetup.VALIDATE("Assembly Order Nos.",
          LibraryUtility.GetGlobalNoSeriesCode);
      AssemblySetup.VALIDATE("Copy Component Dimensions from",DimensionsFrom);
      AssemblySetup.VALIDATE("Default Location for Orders",LocationCode);
      AssemblySetup.VALIDATE("Posted Assembly Order Nos.",PostedOrdersNo);
      AssemblySetup.MODIFY(TRUE);
    END;

    PROCEDURE UpdateInventorySetup@49(VAR InventorySetup@1001 : Record 313;AutomaticCostPosting@1000 : Boolean;ExpectedCostPostingtoGL@1002 : Boolean;AutomaticCostAdjustment@1003 : Option;AverageCostCalcType@1004 : Option;AverageCostPeriod@1005 : Option);
    BEGIN
      InventorySetup.GET;
      InventorySetup."Automatic Cost Posting" := AutomaticCostPosting;
      InventorySetup."Expected Cost Posting to G/L" := ExpectedCostPostingtoGL;
      InventorySetup."Automatic Cost Adjustment" := AutomaticCostAdjustment;
      InventorySetup."Average Cost Calc. Type" := AverageCostCalcType;
      InventorySetup."Average Cost Period" := AverageCostPeriod;
      InventorySetup.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE UpdateAssemblyLine@92(VAR AssemblyLine@1000 : Record 901;FieldNo@1001 : Integer;Value@1004 : Variant);
    VAR
      RecRef@1002 : RecordRef;
      FieldRef@1003 : FieldRef;
    BEGIN
      RecRef.GETTABLE(AssemblyLine);
      FieldRef := RecRef.FIELD(FieldNo);
      FieldRef.VALIDATE(Value);
      RecRef.SETTABLE(AssemblyLine);
      AssemblyLine.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE UpdateAssemblyHeader@91(VAR AssemblyHeader@1000 : Record 900;FieldNo@1001 : Integer;Value@1004 : Variant);
    VAR
      RecRef@1002 : RecordRef;
      FieldRef@1003 : FieldRef;
    BEGIN
      RecRef.GETTABLE(AssemblyHeader);
      FieldRef := RecRef.FIELD(FieldNo);
      FieldRef.VALIDATE(Value);
      RecRef.SETTABLE(AssemblyHeader);
      AssemblyHeader.MODIFY(TRUE);
    END;

    [Normal]
    PROCEDURE UpdateInvtPeriod@161(VAR InventoryPeriod@1000 : Record 5814;ReOpen@1003 : Boolean);
    VAR
      ItemLedgerEntry@1001 : Record 32;
      CloseInventoryPeriod@1002 : Codeunit 5820;
    BEGIN
      LibraryCosting.AdjustCostItemEntries('','');
      ItemLedgerEntry.SETRANGE(Open,TRUE);
      IF ItemLedgerEntry.FINDFIRST THEN
        ItemLedgerEntry.DELETE;

      CloseInventoryPeriod.SetReOpen(ReOpen);
      CloseInventoryPeriod.SetHideDialog(TRUE);
      CloseInventoryPeriod.RUN(InventoryPeriod);

      IF ReOpen THEN
        InventoryPeriod.DELETE;
    END;

    [Normal]
    PROCEDURE UpdateSKUCards@171(Item@1001 : Record 27);
    VAR
      StockkeepingUnit@1000 : Record 5700;
    BEGIN
      StockkeepingUnit.SETRANGE("Item No.",Item."No.");
      IF StockkeepingUnit.FINDSET THEN
        REPEAT
          IF Item."Costing Method" = Item."Costing Method"::Standard THEN
            StockkeepingUnit.VALIDATE("Standard Cost",Item."Standard Cost" + LibraryRandom.RandDec(10,2))
          ELSE
            StockkeepingUnit.VALIDATE("Unit Cost",Item."Unit Cost" + LibraryRandom.RandDec(10,2));
          StockkeepingUnit.MODIFY(TRUE);
        UNTIL StockkeepingUnit.NEXT = 0;
    END;

    PROCEDURE VerifytAsmReservationEntryATO@60(AssemblyHeader@1002 : Record 900) : Integer;
    VAR
      ReservationEntry@1000 : Record 337;
    BEGIN
      CLEAR(ReservationEntry);
      ReservationEntry.SETRANGE(Positive,TRUE);
      ReservationEntry.SETRANGE("Item No.",AssemblyHeader."Item No.");
      ReservationEntry.SETRANGE(Description,AssemblyHeader.Description);
      ReservationEntry.SETRANGE("Location Code",AssemblyHeader."Location Code");
      ReservationEntry.SETRANGE("Reservation Status",ReservationEntry."Reservation Status"::Reservation);
      ReservationEntry.SETRANGE("Source Type",DATABASE::"Assembly Header");
      ReservationEntry.SETRANGE("Source Subtype",AssemblyHeader."Document Type");
      ReservationEntry.SETRANGE("Source Ref. No.",0);
      ReservationEntry.SETRANGE("Source ID",AssemblyHeader."No.");
      ReservationEntry.SETRANGE(Quantity,AssemblyHeader.Quantity);
      ReservationEntry.SETRANGE(Binding,ReservationEntry.Binding::"Order-to-Order");
      ReservationEntry.SETRANGE("Planning Flexibility",ReservationEntry."Planning Flexibility"::None);
      ReservationEntry.SETRANGE("Shipment Date",AssemblyHeader."Due Date");
      ReservationEntry.SETRANGE("Variant Code",AssemblyHeader."Variant Code");
      ReservationEntry.SETRANGE("Disallow Cancellation",TRUE);
      Assert.AreEqual(1,ReservationEntry.COUNT,'Couldn''t find the AO reservation entry with the filters: ' +
        ReservationEntry.GETFILTERS);

      EXIT(ReservationEntry."Entry No.");
    END;

    PROCEDURE VerifyHardLinkEntry@50(SalesLine@1001 : Record 37;AssemblyHeader@1000 : Record 900;NoOfEntries@1003 : Integer);
    VAR
      ATOLink@1002 : Record 904;
    BEGIN
      CLEAR(ATOLink);
      ATOLink.SETRANGE("Assembly Document Type",AssemblyHeader."Document Type");
      ATOLink.SETRANGE("Assembly Document No.",AssemblyHeader."No.");
      ATOLink.SETRANGE(Type,ATOLink.Type::Sale);
      ATOLink.SETRANGE("Document Type",SalesLine."Document Type");
      ATOLink.SETRANGE("Document No.",SalesLine."Document No.");
      ATOLink.SETRANGE("Document Line No.",SalesLine."Line No.");
      ATOLink.SETRANGE("Assembled Quantity",AssemblyHeader."Assembled Quantity");

      Assert.AreEqual(NoOfEntries,ATOLink.COUNT,'There are no ' + FORMAT(NoOfEntries) + ' entries within the filter ' +
        ATOLink.GETFILTERS);
    END;

    PROCEDURE VerifySaleReservationEntryATO@39(SalesLine@1001 : Record 37) : Integer;
    VAR
      ReservationEntry@1000 : Record 337;
    BEGIN
      CLEAR(ReservationEntry);
      ReservationEntry.SETRANGE(Positive,FALSE);
      ReservationEntry.SETRANGE("Item No.",SalesLine."No.");
      ReservationEntry.SETRANGE(Description,SalesLine.Description);
      ReservationEntry.SETRANGE("Location Code",SalesLine."Location Code");
      ReservationEntry.SETRANGE("Reservation Status",ReservationEntry."Reservation Status"::Reservation);
      ReservationEntry.SETRANGE("Source Type",DATABASE::"Sales Line");
      ReservationEntry.SETRANGE("Source Subtype",SalesLine."Document Type");
      ReservationEntry.SETRANGE("Source Ref. No.",SalesLine."Line No.");
      ReservationEntry.SETRANGE("Source ID",SalesLine."Document No.");
      ReservationEntry.SETRANGE(Quantity,-SalesLine."Qty. to Assemble to Order");
      ReservationEntry.SETRANGE(Binding,ReservationEntry.Binding::"Order-to-Order");
      ReservationEntry.SETRANGE("Planning Flexibility",ReservationEntry."Planning Flexibility"::None);
      ReservationEntry.SETRANGE("Shipment Date",SalesLine."Shipment Date");
      ReservationEntry.SETRANGE("Variant Code",SalesLine."Variant Code");
      ReservationEntry.SETRANGE("Disallow Cancellation",TRUE);

      Assert.AreEqual(1,ReservationEntry.COUNT,'Couldn''t find the SOL reservation entry with the filters: ' +
        ReservationEntry.GETFILTERS);

      EXIT(ReservationEntry."Entry No.");
    END;

    [Normal]
    PROCEDURE VerifyEntityDimensions@59(TableID@1002 : Integer;EntityNo@1003 : Code[20];ParentItemNo@1005 : Code[20];CopyFromHeader@1006 : Boolean;DimensionSetID@1004 : Integer);
    VAR
      DefaultDimension@1000 : Record 352;
      DimensionSetEntry@1001 : Record 480;
    BEGIN
      IF (TableID <= 0) OR (DimensionSetID <= 0) THEN
        EXIT;
      LibraryDimension.FindDefaultDimension(DefaultDimension,TableID,EntityNo);
      IF CopyFromHeader THEN
        LibraryDimension.FindDefaultDimension(DefaultDimension,27,ParentItemNo);

      LibraryDimension.FindDimensionSetEntry(DimensionSetEntry,DimensionSetID);
      REPEAT
        DimensionSetEntry.SETRANGE("Dimension Code",DefaultDimension."Dimension Code");
        DimensionSetEntry.SETRANGE("Dimension Value Code",DefaultDimension."Dimension Value Code");
        Assert.AreEqual(
          1,DimensionSetEntry.COUNT,'Wrong no. of dimension set entries for dimension ' + FORMAT(DefaultDimension."Dimension Code"));
        DimensionSetEntry.FINDFIRST;
      UNTIL DefaultDimension.NEXT = 0;
    END;

    [Normal]
    PROCEDURE VerifyILEs@32(VAR TempAssemblyLine@1000 : TEMPORARY Record 901;AssemblyHeader@1002 : Record 900;AssembledQty@1003 : Decimal);
    BEGIN
      VerifyILEsGeneric(TempAssemblyLine,AssemblyHeader,AssembledQty,FALSE);
    END;

    [Normal]
    PROCEDURE VerifyILEsGeneric@56(VAR TempAssemblyLine@1000 : TEMPORARY Record 901;AssemblyHeader@1002 : Record 900;AssembledQty@1003 : Decimal;IsATO@1004 : Boolean);
    VAR
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      // General filtering.
      ItemLedgerEntry.RESET;
      ItemLedgerEntry.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      ItemLedgerEntry.SETRANGE("Source No.",AssemblyHeader."Item No.");
      ItemLedgerEntry.SETRANGE("Source Type",ItemLedgerEntry."Source Type"::Item);
      ItemLedgerEntry.SETRANGE("Order Type",ItemLedgerEntry."Order Type"::Assembly);
      ItemLedgerEntry.SETRANGE("Order No.",AssemblyHeader."No.");
      ItemLedgerEntry.SETRANGE("Cost Amount (Expected)",0);

      // Output entry.
      ItemLedgerEntry.SETRANGE("Item No.",AssemblyHeader."Item No.");
      ItemLedgerEntry.SETRANGE("Variant Code",AssemblyHeader."Variant Code");
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::"Assembly Output");
      ItemLedgerEntry.SETRANGE("Location Code",AssemblyHeader."Location Code");
      ItemLedgerEntry.SETRANGE(Quantity,AssembledQty);
      ItemLedgerEntry.SETRANGE("Invoiced Quantity",AssembledQty);
      ItemLedgerEntry.SETRANGE("Unit of Measure Code",AssemblyHeader."Unit of Measure Code");
      ItemLedgerEntry.SETRANGE("Document Line No.",0);
      ItemLedgerEntry.SETRANGE("Order Line No.",0);
      ItemLedgerEntry.SETRANGE("Dimension Set ID",AssemblyHeader."Dimension Set ID");
      ItemLedgerEntry.SETRANGE("Assemble to Order",FALSE);
      IF IsATO THEN BEGIN
        ItemLedgerEntry.SETRANGE("Remaining Quantity",0);
        ItemLedgerEntry.SETRANGE(Open,FALSE);
      END ELSE BEGIN
        ItemLedgerEntry.SETRANGE("Remaining Quantity",AssembledQty);
        ItemLedgerEntry.SETRANGE(Open,TRUE);
      END;
      Assert.AreEqual(1,ItemLedgerEntry.COUNT,'Wrong no. of output entries for item ' + AssemblyHeader."Item No.");
      ItemLedgerEntry.FINDFIRST;
      VerifyApplicationEntry(ItemLedgerEntry);

      // Consumption entries.
      // Find posted assembly lines.
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);

      IF TempAssemblyLine.FINDSET THEN
        REPEAT
          CLEAR(ItemLedgerEntry);
          ItemLedgerEntry.SETRANGE("Item No.",TempAssemblyLine."No.");
          ItemLedgerEntry.SETRANGE("Variant Code",TempAssemblyLine."Variant Code");
          ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::"Assembly Consumption");
          // ItemLedgerEntry.SETRANGE(Description,TempAssemblyLine.Description); - bug in ATO - description is not filled in
          ItemLedgerEntry.SETRANGE("Location Code",TempAssemblyLine."Location Code");
          ItemLedgerEntry.SETRANGE(Quantity,-TempAssemblyLine."Quantity to Consume (Base)");
          ItemLedgerEntry.SETRANGE("Remaining Quantity",0);
          ItemLedgerEntry.SETRANGE("Invoiced Quantity",-TempAssemblyLine."Quantity to Consume (Base)");
          ItemLedgerEntry.SETRANGE("Unit of Measure Code",TempAssemblyLine."Unit of Measure Code");
          ItemLedgerEntry.SETRANGE(Open,FALSE);
          ItemLedgerEntry.SETRANGE("Document Line No.",TempAssemblyLine."Line No.");
          ItemLedgerEntry.SETRANGE("Order Line No.",TempAssemblyLine."Line No.");
          ItemLedgerEntry.SETRANGE("Dimension Set ID",TempAssemblyLine."Dimension Set ID");
          ItemLedgerEntry.SETRANGE("Assemble to Order",FALSE);
          Assert.AreEqual(1,ItemLedgerEntry.COUNT,'Wrong no. of consumpt. ILEs for item ' + TempAssemblyLine."No.");
          ItemLedgerEntry.FINDFIRST;
          VerifyApplicationEntry(ItemLedgerEntry);
        UNTIL TempAssemblyLine.NEXT = 0;
    END;

    [Normal]
    PROCEDURE VerifyILEsForAsmOnATO@54(VAR TempAssemblyLine@1000 : TEMPORARY Record 901;AssemblyHeader@1002 : Record 900;AssembledQty@1003 : Decimal);
    BEGIN
      VerifyILEsGeneric(TempAssemblyLine,AssemblyHeader,AssembledQty,TRUE);
    END;

    [Normal]
    PROCEDURE VerifyILEsUndo@78(VAR TempPostedAssemblyHeader@1000 : TEMPORARY Record 910;VAR TempPostedAssemblyLine@1004 : TEMPORARY Record 911;UndoEntries@1002 : Boolean);
    VAR
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      // General filtering.
      ItemLedgerEntry.RESET;
      ItemLedgerEntry.SETRANGE("Posting Date",TempPostedAssemblyHeader."Posting Date");
      ItemLedgerEntry.SETRANGE("Source No.",TempPostedAssemblyHeader."Item No.");
      ItemLedgerEntry.SETRANGE("Source Type",ItemLedgerEntry."Source Type"::Item);
      ItemLedgerEntry.SETRANGE("Order Type",ItemLedgerEntry."Order Type"::Assembly);
      ItemLedgerEntry.SETRANGE("Order No.",TempPostedAssemblyHeader."Order No.");
      ItemLedgerEntry.SETRANGE("Cost Amount (Expected)",0);

      // Output entry.
      ItemLedgerEntry.SETRANGE("Item No.",TempPostedAssemblyHeader."Item No.");
      ItemLedgerEntry.SETRANGE("Variant Code",TempPostedAssemblyHeader."Variant Code");
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::"Assembly Output");
      ItemLedgerEntry.SETRANGE("Location Code",TempPostedAssemblyHeader."Location Code");
      IF UndoEntries THEN BEGIN
        ItemLedgerEntry.SETRANGE(Quantity,-TempPostedAssemblyHeader."Quantity (Base)");
        ItemLedgerEntry.SETRANGE("Invoiced Quantity",-TempPostedAssemblyHeader."Quantity (Base)");
      END ELSE BEGIN
        ItemLedgerEntry.SETRANGE(Quantity,TempPostedAssemblyHeader."Quantity (Base)");
        ItemLedgerEntry.SETRANGE("Invoiced Quantity",TempPostedAssemblyHeader."Quantity (Base)");
      END;

      ItemLedgerEntry.SETRANGE("Assemble to Order",FALSE);
      ItemLedgerEntry.SETRANGE("Unit of Measure Code",TempPostedAssemblyHeader."Unit of Measure Code");
      ItemLedgerEntry.SETRANGE("Document Line No.",0);
      ItemLedgerEntry.SETRANGE("Order Line No.",0);
      ItemLedgerEntry.SETRANGE("Dimension Set ID",TempPostedAssemblyHeader."Dimension Set ID");
      ItemLedgerEntry.SETRANGE("Remaining Quantity",0);
      ItemLedgerEntry.SETRANGE(Open,FALSE);
      ItemLedgerEntry.SETRANGE(Correction,UndoEntries);
      Assert.AreEqual(1,ItemLedgerEntry.COUNT,'Wrong no. of output entries for item ' + TempPostedAssemblyHeader."Item No.");

      // Verify application entries
      ItemLedgerEntry.FINDFIRST;
      VerifyApplicationEntryUndo(ItemLedgerEntry);

      // Consumption entries.
      // Find posted assembly lines.
      TempPostedAssemblyLine.SETRANGE(Type,TempPostedAssemblyLine.Type::Item);

      IF TempPostedAssemblyLine.FINDSET THEN
        REPEAT
          CLEAR(ItemLedgerEntry);
          ItemLedgerEntry.SETRANGE("Order Type",ItemLedgerEntry."Order Type"::Assembly);
          ItemLedgerEntry.SETRANGE("Order No.",TempPostedAssemblyHeader."Order No.");
          ItemLedgerEntry.SETRANGE("Item No.",TempPostedAssemblyLine."No.");
          ItemLedgerEntry.SETRANGE("Variant Code",TempPostedAssemblyLine."Variant Code");
          ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::"Assembly Consumption");
          ItemLedgerEntry.SETRANGE("Location Code",TempPostedAssemblyLine."Location Code");
          IF UndoEntries THEN BEGIN
            ItemLedgerEntry.SETRANGE(Quantity,TempPostedAssemblyLine."Quantity (Base)");
            ItemLedgerEntry.SETRANGE("Remaining Quantity",TempPostedAssemblyLine."Quantity (Base)");
            ItemLedgerEntry.SETRANGE("Invoiced Quantity",TempPostedAssemblyLine."Quantity (Base)");
          END ELSE BEGIN
            ItemLedgerEntry.SETRANGE(Quantity,-TempPostedAssemblyLine."Quantity (Base)");
            ItemLedgerEntry.SETRANGE("Remaining Quantity",0);
            ItemLedgerEntry.SETRANGE("Invoiced Quantity",-TempPostedAssemblyLine."Quantity (Base)");
          END;
          ItemLedgerEntry.SETRANGE("Assemble to Order",FALSE);
          ItemLedgerEntry.SETRANGE("Unit of Measure Code",TempPostedAssemblyLine."Unit of Measure Code");
          ItemLedgerEntry.SETRANGE(Open,UndoEntries);
          ItemLedgerEntry.SETRANGE(Correction,UndoEntries);
          ItemLedgerEntry.SETRANGE("Document Line No.",TempPostedAssemblyLine."Line No.");
          ItemLedgerEntry.SETRANGE("Order Line No.",TempPostedAssemblyLine."Line No.");
          ItemLedgerEntry.SETRANGE("Dimension Set ID",TempPostedAssemblyLine."Dimension Set ID");
          Assert.AreEqual(1,ItemLedgerEntry.COUNT,'Wrong no. of consumpt. ILEs for item ' + TempPostedAssemblyLine."No.");
          ItemLedgerEntry.FINDFIRST;
          VerifyApplicationEntryUndo(ItemLedgerEntry);
        UNTIL TempPostedAssemblyLine.NEXT = 0;
    END;

    [Normal]
    PROCEDURE VerifyILEATOAndSale@89(AssemblyHeader@1002 : Record 900;SalesLine@1000 : Record 37;AssembledQty@1003 : Decimal;Invoiced@1004 : Boolean;NoOfLines@1005 : Integer);
    VAR
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      // General filtering.
      ItemLedgerEntry.RESET;
      ItemLedgerEntry.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      ItemLedgerEntry.SETRANGE("Source No.",AssemblyHeader."Item No.");
      ItemLedgerEntry.SETRANGE("Source Type",ItemLedgerEntry."Source Type"::Item);
      ItemLedgerEntry.SETRANGE("Order Type",ItemLedgerEntry."Order Type"::Assembly);
      ItemLedgerEntry.SETRANGE("Order No.",AssemblyHeader."No.");
      ItemLedgerEntry.SETRANGE("Cost Amount (Expected)",0);

      // Output entry.
      ItemLedgerEntry.SETRANGE("Item No.",AssemblyHeader."Item No.");
      ItemLedgerEntry.SETRANGE("Variant Code",AssemblyHeader."Variant Code");
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::"Assembly Output");
      ItemLedgerEntry.SETRANGE("Location Code",AssemblyHeader."Location Code");
      ItemLedgerEntry.SETRANGE(Quantity,AssembledQty);
      ItemLedgerEntry.SETRANGE("Invoiced Quantity",AssembledQty);
      ItemLedgerEntry.SETRANGE("Unit of Measure Code",AssemblyHeader."Unit of Measure Code");
      ItemLedgerEntry.SETRANGE("Document Line No.",0);
      ItemLedgerEntry.SETRANGE("Order Line No.",0);
      ItemLedgerEntry.SETRANGE("Dimension Set ID",AssemblyHeader."Dimension Set ID");
      ItemLedgerEntry.SETRANGE("Assemble to Order",FALSE);
      ItemLedgerEntry.SETRANGE("Remaining Quantity",0);
      ItemLedgerEntry.SETRANGE(Open,FALSE);
      Assert.AreEqual(NoOfLines,ItemLedgerEntry.COUNT,'Wrong no. of output entries for item ' + AssemblyHeader."Item No.");
      IF ItemLedgerEntry.FINDSET THEN
        REPEAT
          VerifyILESale(SalesLine,AssembledQty,ItemLedgerEntry."Entry No.",TRUE,Invoiced);
        UNTIL ItemLedgerEntry.NEXT = 0;
    END;

    [Normal]
    PROCEDURE VerifyILESale@90(SalesLine@1001 : Record 37;AssembledQty@1002 : Decimal;EntryNo@1003 : Integer;IsAto@1005 : Boolean;Invoiced@1004 : Boolean);
    VAR
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      // General filtering.
      ItemLedgerEntry.RESET;
      ItemLedgerEntry.SETRANGE("Source No.",SalesLine."Sell-to Customer No.");
      ItemLedgerEntry.SETRANGE("Source Type",ItemLedgerEntry."Source Type"::Customer);
      ItemLedgerEntry.SETRANGE("Order Type",ItemLedgerEntry."Order Type"::" ");
      ItemLedgerEntry.SETRANGE("Cost Amount (Expected)",0);

      // Output entry.
      ItemLedgerEntry.SETRANGE("Item No.",SalesLine."No.");
      ItemLedgerEntry.SETRANGE("Variant Code",SalesLine."Variant Code");
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::Sale);
      ItemLedgerEntry.SETRANGE("Location Code",SalesLine."Location Code");
      ItemLedgerEntry.SETRANGE(Quantity,-AssembledQty);
      IF Invoiced THEN
        ItemLedgerEntry.SETRANGE("Invoiced Quantity",-AssembledQty)
      ELSE
        ItemLedgerEntry.SETRANGE("Invoiced Quantity",0);
      ItemLedgerEntry.SETRANGE("Unit of Measure Code",SalesLine."Unit of Measure Code");
      ItemLedgerEntry.SETRANGE("Document Line No.",SalesLine."Line No.");
      ItemLedgerEntry.SETRANGE("Order Line No.",0);
      ItemLedgerEntry.SETRANGE("Dimension Set ID",SalesLine."Dimension Set ID");
      ItemLedgerEntry.SETRANGE("Assemble to Order",IsAto);
      ItemLedgerEntry.SETRANGE(Open,NOT IsAto);
      IF IsAto THEN
        ItemLedgerEntry.SETRANGE("Remaining Quantity",0)
      ELSE
        ItemLedgerEntry.SETRANGE("Remaining Quantity",-AssembledQty);
      ItemLedgerEntry.SETRANGE("Applies-to Entry",EntryNo);
      Assert.AreEqual(1,ItemLedgerEntry.COUNT,'Wrong no. of sale entries for item ' + SalesLine."No.");
    END;

    [Normal]
    PROCEDURE VerifySKUCost@4(VAR TempAssemblyLine@1006 : TEMPORARY Record 901;AssemblyHeader@1000 : Record 900);
    VAR
      Item@1005 : Record 27;
      UnitCost@1001 : Decimal;
      Overhead@1003 : Decimal;
      IndirectCost@1004 : Decimal;
    BEGIN
      // Check header item SKU cost.
      Item.GET(AssemblyHeader."Item No.");
      GetCostInformation(UnitCost,Overhead,IndirectCost,TempAssemblyLine.Type::Item,AssemblyHeader."Item No.",
        AssemblyHeader."Variant Code",AssemblyHeader."Location Code");
      IF Item."Costing Method" = Item."Costing Method"::Standard THEN
        AssemblyHeader.TESTFIELD("Unit Cost",UnitCost);

      // Check item components SKU cost.
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      IF TempAssemblyLine.FINDSET THEN
        REPEAT
          GetCostInformation(UnitCost,Overhead,IndirectCost,TempAssemblyLine.Type::Item,TempAssemblyLine."No.",
            TempAssemblyLine."Variant Code",TempAssemblyLine."Location Code");
          TempAssemblyLine.TESTFIELD("Unit Cost",UnitCost);
        UNTIL TempAssemblyLine.NEXT = 0
    END;

    [Normal]
    PROCEDURE VerifyValueEntries@33(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;AssemblyHeader@1000 : Record 900;AssembledQty@1002 : Decimal);
    BEGIN
      VerifyValueEntriesAsm(TempAssemblyLine,AssemblyHeader,AssembledQty);
    END;

    [Normal]
    PROCEDURE VerifyValueEntriesAsm@70(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;AssemblyHeader@1000 : Record 900;AssembledQty@1002 : Decimal);
    VAR
      ValueEntry@1001 : Record 5802;
    BEGIN
      ValueEntry.RESET;
      // General filtering.
      ValueEntry.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      ValueEntry.SETRANGE("Source No.",AssemblyHeader."Item No.");
      ValueEntry.SETRANGE("Source Type",ValueEntry."Source Type"::Item);
      ValueEntry.SETRANGE("Order Type",ValueEntry."Order Type"::Assembly);
      ValueEntry.SETRANGE("Order No.",AssemblyHeader."No.");
      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::"Direct Cost");

      // Output entry.
      ValueEntry.SETRANGE("Item No.",AssemblyHeader."Item No.");
      ValueEntry.SETRANGE("Variant Code",AssemblyHeader."Variant Code");
      ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::"Assembly Output");
      ValueEntry.SETRANGE("Location Code",AssemblyHeader."Location Code");
      ValueEntry.SETRANGE("Valued Quantity",AssembledQty);
      ValueEntry.SETRANGE("Item Ledger Entry Quantity",AssembledQty);
      ValueEntry.SETRANGE("Invoiced Quantity",AssembledQty);
      ValueEntry.SETRANGE("Document Line No.",0);
      ValueEntry.SETRANGE("Order Line No.",0);
      ValueEntry.SETRANGE("Dimension Set ID",AssemblyHeader."Dimension Set ID");

      ValueEntry.SETRANGE(Adjustment,FALSE);
      Assert.AreEqual(1,ValueEntry.COUNT,'Wrong no. of output value entries for item' + AssemblyHeader."Item No.");
      ValueEntry.FINDFIRST;
      Assert.AreNearlyEqual(ROUND(AssemblyHeader."Cost Amount" * AssembledQty / AssemblyHeader.Quantity,
          LibraryERM.GetAmountRoundingPrecision),
        ValueEntry."Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,'Wrong value entry cost amount for header.');

      // Consumption value entries for items.
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      IF TempAssemblyLine.FINDSET THEN
        REPEAT
          ValueEntry.SETRANGE("Item No.",TempAssemblyLine."No.");
          ValueEntry.SETRANGE("Variant Code",TempAssemblyLine."Variant Code");
          ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::"Assembly Consumption");
          ValueEntry.SETRANGE("Location Code",TempAssemblyLine."Location Code");
          // ValueEntry.SETRANGE(Description,TempAssemblyLine.Description); - bug for ATO
          ValueEntry.SETRANGE("Valued Quantity",-TempAssemblyLine."Quantity to Consume (Base)");
          ValueEntry.SETRANGE("Item Ledger Entry Quantity",-TempAssemblyLine."Quantity to Consume (Base)");
          ValueEntry.SETRANGE("Invoiced Quantity",-TempAssemblyLine."Quantity to Consume (Base)");
          ValueEntry.SETRANGE("Document Line No.",TempAssemblyLine."Line No.");
          ValueEntry.SETRANGE("Order Line No.",TempAssemblyLine."Line No.");
          ValueEntry.SETRANGE("Dimension Set ID",TempAssemblyLine."Dimension Set ID");
          Assert.AreEqual(1,ValueEntry.COUNT,'Wrong no. of consumpt. value entries for item' + TempAssemblyLine."No.");
          ValueEntry.FINDFIRST;
          Assert.AreNearlyEqual(
            TempAssemblyLine."Cost Amount" * ROUND(TempAssemblyLine."Quantity to Consume" / TempAssemblyLine.Quantity),
            -ValueEntry."Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,
            'Wrong value entry cost amount for item ' + TempAssemblyLine."No.");
        UNTIL TempAssemblyLine.NEXT = 0;

      // Consumption value entries for resources.
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Resource);
      IF TempAssemblyLine.FINDSET THEN
        REPEAT
          ValueEntry.SETRANGE("Item No.",'');
          ValueEntry.SETRANGE("Variant Code",TempAssemblyLine."Variant Code");
          ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::" ");
          ValueEntry.SETRANGE("Location Code",TempAssemblyLine."Location Code");
          ValueEntry.SETRANGE(Description,TempAssemblyLine.Description);
          ValueEntry.SETRANGE("Valued Quantity",TempAssemblyLine."Quantity to Consume");
          ValueEntry.SETRANGE("Item Ledger Entry Quantity",0);
          ValueEntry.SETRANGE("Invoiced Quantity",TempAssemblyLine."Quantity to Consume");
          ValueEntry.SETRANGE("Document Line No.",TempAssemblyLine."Line No.");
          ValueEntry.SETRANGE("Order Line No.",TempAssemblyLine."Line No.");
          ValueEntry.SETRANGE("Dimension Set ID",TempAssemblyLine."Dimension Set ID");
          ValueEntry.SETRANGE(Type,ValueEntry.Type::Resource);
          ValueEntry.SETRANGE("No.",TempAssemblyLine."No.");
          Assert.AreEqual(1,ValueEntry.COUNT,'Wrong no. of res. consumpt. value entries for res. ' + TempAssemblyLine."No.");
          ValueEntry.FINDFIRST;
          Assert.AreNearlyEqual(TempAssemblyLine."Cost Amount" * TempAssemblyLine."Quantity to Consume" /
            TempAssemblyLine.Quantity,ValueEntry."Cost Amount (Actual)",
            LibraryERM.GetAmountRoundingPrecision,'Wrong value entry cost amount for res. ' + TempAssemblyLine."No.");
        UNTIL TempAssemblyLine.NEXT = 0;
    END;

    [Normal]
    PROCEDURE VerifyValueEntriesATO@67(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;SalesHeader@1004 : Record 36;AssemblyHeader@1000 : Record 900;AssembledQty@1002 : Decimal);
    BEGIN
      VerifyValueEntriesAsm(TempAssemblyLine,AssemblyHeader,AssembledQty);
      VerifyValueEntriesSale(SalesHeader,AssemblyHeader,AssembledQty);
    END;

    [Normal]
    PROCEDURE VerifyValueEntriesSale@69(SalesHeader@1005 : Record 36;AssemblyHeader@1000 : Record 900;AssembledQty@1002 : Decimal);
    VAR
      ValueEntry@1001 : Record 5802;
    BEGIN
      ValueEntry.RESET;
      ValueEntry.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      ValueEntry.SETRANGE("Source No.",SalesHeader."Sell-to Customer No.");
      ValueEntry.SETRANGE("Source Type",ValueEntry."Source Type"::Customer);
      ValueEntry.SETRANGE("Order Type",ValueEntry."Order Type"::" ");
      ValueEntry.SETRANGE("Order No.",'');
      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::"Direct Cost");
      ValueEntry.SETRANGE("Item No.",AssemblyHeader."Item No.");
      ValueEntry.SETRANGE("Variant Code",AssemblyHeader."Variant Code");
      ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::Sale);
      ValueEntry.SETRANGE("Location Code",AssemblyHeader."Location Code");
      ValueEntry.SETRANGE("Valued Quantity",-AssembledQty);
      ValueEntry.SETRANGE("Item Ledger Entry Quantity",-AssembledQty);
      ValueEntry.SETRANGE("Invoiced Quantity",-AssembledQty);
      ValueEntry.SETRANGE(Adjustment,FALSE);

      Assert.AreEqual(1,ValueEntry.COUNT,'Wrong no. of sales value entries for item' + AssemblyHeader."Item No.");
      ValueEntry.FINDFIRST;

      Assert.AreNearlyEqual(ROUND(AssemblyHeader."Cost Amount" * AssembledQty / AssemblyHeader.Quantity,
          LibraryERM.GetAmountRoundingPrecision),
        ValueEntry."Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,'Wrong value entry cost amount for header.');
    END;

    [Normal]
    PROCEDURE VerifyValueEntriesUndo@81(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;AssemblyHeader@1000 : Record 900;AssembledQty@1002 : Decimal);
    VAR
      ValueEntry@1001 : Record 5802;
    BEGIN
      ValueEntry.RESET;
      // General filtering.
      ValueEntry.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      ValueEntry.SETRANGE("Source No.",AssemblyHeader."Item No.");
      ValueEntry.SETRANGE("Source Type",ValueEntry."Source Type"::Item);
      ValueEntry.SETRANGE("Order Type",ValueEntry."Order Type"::Assembly);
      ValueEntry.SETRANGE("Order No.",AssemblyHeader."No.");
      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::"Direct Cost");

      // Output entry.
      ValueEntry.SETRANGE("Item No.",AssemblyHeader."Item No.");
      ValueEntry.SETRANGE("Variant Code",AssemblyHeader."Variant Code");
      ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::"Assembly Output");
      ValueEntry.SETRANGE("Location Code",AssemblyHeader."Location Code");
      ValueEntry.SETRANGE("Valued Quantity",AssembledQty);
      ValueEntry.SETRANGE("Item Ledger Entry Quantity",AssembledQty);
      ValueEntry.SETRANGE("Invoiced Quantity",AssembledQty);
      ValueEntry.SETRANGE("Document Line No.",0);
      ValueEntry.SETRANGE("Order Line No.",0);
      ValueEntry.SETRANGE("Dimension Set ID",AssemblyHeader."Dimension Set ID");

      ValueEntry.SETRANGE(Adjustment,FALSE);
      Assert.AreEqual(1,ValueEntry.COUNT,'Wrong no. of output value entries for item' + AssemblyHeader."Item No.");
      ValueEntry.FINDFIRST;
      Assert.AreNearlyEqual(ROUND(AssemblyHeader."Cost Amount" * AssembledQty / AssemblyHeader.Quantity,
          LibraryERM.GetAmountRoundingPrecision),
        ValueEntry."Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,'Wrong value entry cost amount for header.');

      // Consumption value entries for items.
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      IF TempAssemblyLine.FINDSET THEN
        REPEAT
          ValueEntry.SETRANGE("Item No.",TempAssemblyLine."No.");
          ValueEntry.SETRANGE("Variant Code",TempAssemblyLine."Variant Code");
          ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::"Assembly Consumption");
          ValueEntry.SETRANGE("Location Code",TempAssemblyLine."Location Code");
          // ValueEntry.SETRANGE(Description,TempAssemblyLine.Description); - bug for ATO
          ValueEntry.SETRANGE("Valued Quantity",-TempAssemblyLine."Quantity to Consume (Base)");
          ValueEntry.SETRANGE("Item Ledger Entry Quantity",-TempAssemblyLine."Quantity to Consume (Base)");
          ValueEntry.SETRANGE("Invoiced Quantity",-TempAssemblyLine."Quantity to Consume (Base)");
          ValueEntry.SETRANGE("Document Line No.",TempAssemblyLine."Line No.");
          ValueEntry.SETRANGE("Order Line No.",TempAssemblyLine."Line No.");
          ValueEntry.SETRANGE("Dimension Set ID",TempAssemblyLine."Dimension Set ID");
          Assert.AreEqual(1,ValueEntry.COUNT,'Wrong no. of consumpt. value entries for item' + TempAssemblyLine."No.");
          ValueEntry.FINDFIRST;
          Assert.AreNearlyEqual(ROUND(TempAssemblyLine."Cost Amount" * TempAssemblyLine."Quantity to Consume" /
              TempAssemblyLine.Quantity,LibraryERM.GetAmountRoundingPrecision),
            -ValueEntry."Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,
            'Wrong value entry cost amount for item ' + TempAssemblyLine."No.");
        UNTIL TempAssemblyLine.NEXT = 0;

      // Consumption value entries for resources.
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Resource);
      IF TempAssemblyLine.FINDSET THEN
        REPEAT
          ValueEntry.SETRANGE("Item No.",'');
          ValueEntry.SETRANGE("Variant Code",TempAssemblyLine."Variant Code");
          ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::" ");
          ValueEntry.SETRANGE("Location Code",TempAssemblyLine."Location Code");
          ValueEntry.SETRANGE(Description,TempAssemblyLine.Description);
          ValueEntry.SETRANGE("Valued Quantity",TempAssemblyLine."Quantity to Consume");
          ValueEntry.SETRANGE("Item Ledger Entry Quantity",0);
          ValueEntry.SETRANGE("Invoiced Quantity",TempAssemblyLine."Quantity to Consume");
          ValueEntry.SETRANGE("Document Line No.",TempAssemblyLine."Line No.");
          ValueEntry.SETRANGE("Order Line No.",TempAssemblyLine."Line No.");
          ValueEntry.SETRANGE("Dimension Set ID",TempAssemblyLine."Dimension Set ID");
          ValueEntry.SETRANGE(Type,ValueEntry.Type::Resource);
          ValueEntry.SETRANGE("No.",TempAssemblyLine."No.");
          Assert.AreEqual(1,ValueEntry.COUNT,'Wrong no. of res. consumpt. value entries for res. ' + TempAssemblyLine."No.");
          ValueEntry.FINDFIRST;
          Assert.AreNearlyEqual(TempAssemblyLine."Cost Amount" * TempAssemblyLine."Quantity to Consume" /
            TempAssemblyLine.Quantity,ValueEntry."Cost Amount (Actual)",
            LibraryERM.GetAmountRoundingPrecision,'Wrong value entry cost amount for res. ' + TempAssemblyLine."No.");
        UNTIL TempAssemblyLine.NEXT = 0;
    END;

    [Normal]
    PROCEDURE VerifyResEntries@34(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;AssemblyHeader@1002 : Record 900);
    BEGIN
      VerifyResEntriesGeneric(TempAssemblyLine,AssemblyHeader,FALSE);
    END;

    [Normal]
    PROCEDURE VerifyResEntriesATO@58(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;AssemblyHeader@1002 : Record 900);
    BEGIN
      VerifyResEntriesGeneric(TempAssemblyLine,AssemblyHeader,TRUE);
    END;

    [Normal]
    PROCEDURE VerifyResEntriesGeneric@57(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;AssemblyHeader@1002 : Record 900;IsATO@1000 : Boolean);
    VAR
      ResLedgerEntry@1001 : Record 203;
      SourceCodeSetup@1140 : Record 242;
    BEGIN
      SourceCodeSetup.GET;
      ResLedgerEntry.RESET;
      // General filtering.
      ResLedgerEntry.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      ResLedgerEntry.SETRANGE("Order Type",ResLedgerEntry."Order Type"::Assembly);
      ResLedgerEntry.SETRANGE("Order No.",AssemblyHeader."No.");
      ResLedgerEntry.SETRANGE("Entry Type",ResLedgerEntry."Entry Type"::Usage);
      IF IsATO THEN
        ResLedgerEntry.SETRANGE("Source Code",SourceCodeSetup.Sales)
      ELSE
        ResLedgerEntry.SETRANGE("Source Code",SourceCodeSetup.Assembly);

      // Usage entries.
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Resource);
      IF TempAssemblyLine.FINDSET THEN
        REPEAT
          ResLedgerEntry.SETRANGE("Resource No.",TempAssemblyLine."No.");
          ResLedgerEntry.SETRANGE(Quantity,TempAssemblyLine."Quantity to Consume");
          ResLedgerEntry.SETRANGE("Unit of Measure Code",TempAssemblyLine."Unit of Measure Code");
          IF NOT IsATO THEN BEGIN // if ATO then dimensions can come from SOL also - skip checking them
            ResLedgerEntry.SETRANGE("Global Dimension 1 Code",TempAssemblyLine."Shortcut Dimension 1 Code");
            ResLedgerEntry.SETRANGE("Global Dimension 2 Code",TempAssemblyLine."Shortcut Dimension 2 Code");
            ResLedgerEntry.SETRANGE("Dimension Set ID",TempAssemblyLine."Dimension Set ID");
          END;
          ResLedgerEntry.SETRANGE("Order Line No.",TempAssemblyLine."Line No.");
          Assert.AreEqual(1,ResLedgerEntry.COUNT,'Wrong no. of res ledger entries for res. ' + TempAssemblyLine."No.");
          ResLedgerEntry.FINDFIRST;
          Assert.AreNearlyEqual(ROUND(TempAssemblyLine."Cost Amount" * TempAssemblyLine."Quantity to Consume" /
              TempAssemblyLine.Quantity,LibraryERM.GetAmountRoundingPrecision),ResLedgerEntry."Total Cost",
            LibraryERM.GetAmountRoundingPrecision,'Wrong Res. Ledger Cost amount for res. ' + TempAssemblyLine."No.")
        UNTIL TempAssemblyLine.NEXT = 0;
    END;

    [Normal]
    PROCEDURE VerifyCapEntries@41(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;AssemblyHeader@1000 : Record 900);
    BEGIN
      VerifyCapEntriesGeneric(TempAssemblyLine,AssemblyHeader,FALSE);
    END;

    [Normal]
    PROCEDURE VerifyCapEntriesATO@62(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;AssemblyHeader@1000 : Record 900);
    BEGIN
      VerifyCapEntriesGeneric(TempAssemblyLine,AssemblyHeader,TRUE);
    END;

    [Normal]
    PROCEDURE VerifyCapEntriesGeneric@65(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;AssemblyHeader@1000 : Record 900;IsATO@1002 : Boolean);
    VAR
      CapacityLedgerEntry@1001 : Record 5832;
    BEGIN
      CapacityLedgerEntry.RESET;
      // General filtering.
      CapacityLedgerEntry.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      CapacityLedgerEntry.SETRANGE(Type,CapacityLedgerEntry.Type::Resource);
      CapacityLedgerEntry.SETRANGE("Item No.",AssemblyHeader."Item No.");
      CapacityLedgerEntry.SETRANGE("Variant Code",AssemblyHeader."Variant Code");
      CapacityLedgerEntry.SETRANGE("Unit of Measure Code",AssemblyHeader."Unit of Measure Code");
      CapacityLedgerEntry.SETRANGE("Order Type",CapacityLedgerEntry."Order Type"::Assembly);
      CapacityLedgerEntry.SETRANGE("Order No.",AssemblyHeader."No.");

      // Usage entries.
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Resource);
      IF TempAssemblyLine.FINDSET THEN
        REPEAT
          CapacityLedgerEntry.SETRANGE("No.",TempAssemblyLine."No.");
          CapacityLedgerEntry.SETRANGE(Description,TempAssemblyLine.Description);
          CapacityLedgerEntry.SETRANGE(Quantity,TempAssemblyLine."Quantity to Consume");
          CapacityLedgerEntry.SETRANGE("Invoiced Quantity",TempAssemblyLine."Quantity to Consume");
          CapacityLedgerEntry.SETRANGE("Cap. Unit of Measure Code",TempAssemblyLine."Unit of Measure Code");
          IF NOT IsATO THEN BEGIN // if ATO then dimensions can come from SOL also - skip checking them
            CapacityLedgerEntry.SETRANGE("Global Dimension 1 Code",TempAssemblyLine."Shortcut Dimension 1 Code");
            CapacityLedgerEntry.SETRANGE("Global Dimension 2 Code",TempAssemblyLine."Shortcut Dimension 2 Code");
            CapacityLedgerEntry.SETRANGE("Dimension Set ID",TempAssemblyLine."Dimension Set ID");
          END;
          Assert.AreEqual(1,CapacityLedgerEntry.COUNT,'Wrong no. of capacity ledger entries for res. ' + TempAssemblyLine."No.");
          CapacityLedgerEntry.FINDFIRST;
          CapacityLedgerEntry.CALCFIELDS("Direct Cost");
          Assert.AreNearlyEqual(TempAssemblyLine."Cost Amount" * TempAssemblyLine."Quantity to Consume" /
            TempAssemblyLine.Quantity,CapacityLedgerEntry."Direct Cost",
            LibraryERM.GetAmountRoundingPrecision,'Wrong Cap. Ledger Cost amount for res. ' + TempAssemblyLine."No.")
        UNTIL TempAssemblyLine.NEXT = 0;
    END;

    [Normal]
    PROCEDURE VerifyCapEntriesUndo@77(VAR TempPostedAssemblyHeader@1000 : TEMPORARY Record 910;VAR TempPostedAssemblyLine@1003 : TEMPORARY Record 911;IsUndo@1002 : Boolean);
    VAR
      CapacityLedgerEntry@1001 : Record 5832;
    BEGIN
      CapacityLedgerEntry.RESET;
      // General filtering.
      CapacityLedgerEntry.SETRANGE("Posting Date",TempPostedAssemblyHeader."Posting Date");
      CapacityLedgerEntry.SETRANGE(Type,CapacityLedgerEntry.Type::Resource);
      CapacityLedgerEntry.SETRANGE("Item No.",TempPostedAssemblyHeader."Item No.");
      CapacityLedgerEntry.SETRANGE("Variant Code",TempPostedAssemblyHeader."Variant Code");
      CapacityLedgerEntry.SETRANGE("Unit of Measure Code",TempPostedAssemblyHeader."Unit of Measure Code");
      CapacityLedgerEntry.SETRANGE("Order Type",CapacityLedgerEntry."Order Type"::Assembly);
      CapacityLedgerEntry.SETRANGE("Order No.",TempPostedAssemblyHeader."Order No.");

      // Usage entries.
      TempPostedAssemblyLine.SETRANGE(Type,TempPostedAssemblyLine.Type::Resource);
      IF TempPostedAssemblyLine.FINDSET THEN
        REPEAT
          CapacityLedgerEntry.SETRANGE("No.",TempPostedAssemblyLine."No.");
          CapacityLedgerEntry.SETRANGE(Description,TempPostedAssemblyLine.Description);
          CapacityLedgerEntry.SETRANGE("Cap. Unit of Measure Code",TempPostedAssemblyLine."Unit of Measure Code");
          CapacityLedgerEntry.SETRANGE("Global Dimension 1 Code",TempPostedAssemblyLine."Shortcut Dimension 1 Code");
          CapacityLedgerEntry.SETRANGE("Global Dimension 2 Code",TempPostedAssemblyLine."Shortcut Dimension 2 Code");
          CapacityLedgerEntry.SETRANGE("Dimension Set ID",TempPostedAssemblyLine."Dimension Set ID");
          IF IsUndo THEN BEGIN
            CapacityLedgerEntry.SETRANGE(Quantity,-TempPostedAssemblyLine."Quantity (Base)");
            CapacityLedgerEntry.SETRANGE("Invoiced Quantity",-TempPostedAssemblyLine."Quantity (Base)");
          END ELSE BEGIN
            CapacityLedgerEntry.SETRANGE(Quantity,TempPostedAssemblyLine."Quantity (Base)");
            CapacityLedgerEntry.SETRANGE("Invoiced Quantity",TempPostedAssemblyLine."Quantity (Base)");
          END;
          Assert.AreEqual(1,CapacityLedgerEntry.COUNT,'Wrong no. of capacity ledger entries for res. ' + TempPostedAssemblyLine."No.");
        UNTIL TempPostedAssemblyLine.NEXT = 0;
    END;

    PROCEDURE VerifyComments@82(AssemblyHeader@1000 : Record 900);
    VAR
      AssemblyLine@1001 : Record 901;
    BEGIN
      VerifyLineComment(AssemblyHeader,0);

      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      IF AssemblyLine.FINDSET THEN
        REPEAT
          VerifyLineComment(AssemblyHeader,AssemblyLine."Line No.");
        UNTIL AssemblyLine.NEXT = 0;
    END;

    [Normal]
    PROCEDURE VerifyLineComment@83(AssemblyHeader@1000 : Record 900;AssemblyLineNo@1002 : Integer);
    VAR
      AssemblyCommentLine@1001 : Record 906;
    BEGIN
      AssemblyCommentLine.RESET;
      AssemblyCommentLine.SETRANGE("Document Type",AssemblyCommentLine."Document Type"::"Assembly Order");
      AssemblyCommentLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyCommentLine.SETRANGE("Document Line No.",AssemblyLineNo);
      AssemblyCommentLine.SETRANGE(Comment,'Order:' + AssemblyHeader."No." + ', Line:' + FORMAT(AssemblyLineNo));
      AssemblyCommentLine.FINDFIRST;
      Assert.AreEqual(1,AssemblyCommentLine.COUNT,'Wrong no. of comment lines.');
    END;

    [Normal]
    PROCEDURE VerifyItemRegister@37(AssemblyHeader@1000 : Record 900);
    VAR
      SourceCodeSetup@1140 : Record 242;
      ItemLedgerEntry@1001 : Record 32;
      CapacityLedgerEntry@1002 : Record 5832;
      ValueEntry@1003 : Record 5802;
      ItemRegister@1004 : Record 46;
      ILEMin@1005 : Integer;
      ILEMax@1006 : Integer;
      ValueEntryMin@1007 : Integer;
      ValueEntryMax@1008 : Integer;
      CapEntryMin@1009 : Integer;
      CapEntryMax@1010 : Integer;
    BEGIN
      SourceCodeSetup.GET;
      ItemLedgerEntry.RESET;
      ItemLedgerEntry.SETRANGE("Order Type",ItemLedgerEntry."Order Type"::Assembly);
      ItemLedgerEntry.SETRANGE("Order No.",AssemblyHeader."No.");
      ItemLedgerEntry.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      IF ItemLedgerEntry.FINDFIRST THEN
        ILEMin := ItemLedgerEntry."Entry No.";
      IF ItemLedgerEntry.FINDLAST THEN
        ILEMax := ItemLedgerEntry."Entry No.";

      ValueEntry.RESET;
      ValueEntry.SETRANGE("Order Type",ValueEntry."Order Type"::Assembly);
      ValueEntry.SETRANGE("Order No.",AssemblyHeader."No.");
      ValueEntry.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      ValueEntry.SETRANGE("Source Code",SourceCodeSetup.Assembly);
      IF ValueEntry.FINDFIRST THEN
        ValueEntryMin := ValueEntry."Entry No.";
      IF ValueEntry.FINDLAST THEN
        ValueEntryMax := ValueEntry."Entry No.";

      CapacityLedgerEntry.RESET;
      CapacityLedgerEntry.SETRANGE("Order Type",CapacityLedgerEntry."Order Type"::Assembly);
      CapacityLedgerEntry.SETRANGE("Order No.",AssemblyHeader."No.");
      CapacityLedgerEntry.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      IF CapacityLedgerEntry.FINDFIRST THEN
        CapEntryMin := CapacityLedgerEntry."Entry No.";
      IF CapacityLedgerEntry.FINDLAST THEN
        CapEntryMax := CapacityLedgerEntry."Entry No.";

      ItemRegister.RESET;
      ItemRegister.SETRANGE("From Entry No.",ILEMin);
      ItemRegister.SETRANGE("To Entry No.",ILEMax);
      ItemRegister.SETRANGE("From Value Entry No.",ValueEntryMin);
      ItemRegister.SETRANGE("To Value Entry No.",ValueEntryMax);
      ItemRegister.SETRANGE("From Capacity Entry No.",CapEntryMin);
      ItemRegister.SETRANGE("To Capacity Entry No.",CapEntryMax);
      ItemRegister.SETRANGE("Source Code",SourceCodeSetup.Assembly);
      ItemRegister.FINDFIRST;
    END;

    [Normal]
    PROCEDURE VerifyApplicationEntry@46(ItemLedgerEntry@1000 : Record 32);
    VAR
      ItemApplicationEntry@1001 : Record 339;
    BEGIN
      ItemApplicationEntry.RESET;
      ItemApplicationEntry.SETRANGE("Item Ledger Entry No.",ItemLedgerEntry."Entry No.");
      ItemApplicationEntry.SETRANGE(Quantity,ItemLedgerEntry.Quantity);
      CASE ItemLedgerEntry."Entry Type" OF
        ItemLedgerEntry."Entry Type"::"Assembly Consumption":
          ItemApplicationEntry.SETRANGE("Outbound Item Entry No.",ItemLedgerEntry."Entry No.");
        ItemLedgerEntry."Entry Type"::"Assembly Output":
          BEGIN
            ItemApplicationEntry.SETRANGE("Inbound Item Entry No.",ItemLedgerEntry."Entry No.");
            ItemApplicationEntry.SETRANGE("Outbound Item Entry No.",0);
          END;
      END;
      ItemApplicationEntry.FINDFIRST;
      Assert.AreEqual(1,ItemApplicationEntry.COUNT,
        'Wrong no. of application entries for ILE no ' + FORMAT(ItemLedgerEntry."Entry No."));
    END;

    [Normal]
    PROCEDURE VerifyApplicationEntryUndo@80(ItemLedgerEntry@1000 : Record 32);
    VAR
      ItemApplicationEntry@1001 : Record 339;
    BEGIN
      ItemApplicationEntry.RESET;
      CASE ItemLedgerEntry."Entry Type" OF
        ItemLedgerEntry."Entry Type"::"Assembly Consumption":
          IF ItemLedgerEntry.Correction THEN BEGIN
            // Check reversed entry
            ItemApplicationEntry.SETRANGE("Item Ledger Entry No.",ItemLedgerEntry."Entry No.");
            ItemApplicationEntry.SETRANGE("Inbound Item Entry No.",ItemLedgerEntry."Entry No.");
            ItemApplicationEntry.SETRANGE(Quantity,ItemLedgerEntry.Quantity);
            ItemApplicationEntry.FINDFIRST;
            Assert.AreEqual(
              1,ItemApplicationEntry.COUNT,'Wrong no. of application entries for ILE no ' + FORMAT(ItemLedgerEntry."Entry No."));
          END ELSE BEGIN
            // Check initial posted entry
            ItemApplicationEntry.SETRANGE("Item Ledger Entry No.",ItemLedgerEntry."Entry No.");
            ItemApplicationEntry.SETRANGE("Outbound Item Entry No.",ItemLedgerEntry."Entry No.");
            ItemApplicationEntry.SETRANGE(Quantity,ItemLedgerEntry.Quantity);
            ItemApplicationEntry.FINDFIRST;
            Assert.AreEqual(
              1,ItemApplicationEntry.COUNT,'Wrong no. of application entries for ILE no ' + FORMAT(ItemLedgerEntry."Entry No."));
          END;
        ItemLedgerEntry."Entry Type"::"Assembly Output":
          IF ItemLedgerEntry.Correction THEN BEGIN
            // Check reversed entry
            ItemApplicationEntry.SETRANGE("Item Ledger Entry No.",ItemLedgerEntry."Entry No.");
            ItemApplicationEntry.SETRANGE("Outbound Item Entry No.",ItemLedgerEntry."Entry No.");
            ItemApplicationEntry.SETRANGE(Quantity,ItemLedgerEntry.Quantity);
            ItemApplicationEntry.FINDFIRST;
            Assert.AreEqual(
              1,ItemApplicationEntry.COUNT,'Wrong no. of application entries for ILE no ' + FORMAT(ItemLedgerEntry."Entry No."));
          END ELSE BEGIN
            // Check initial posted entry
            ItemApplicationEntry.SETRANGE("Item Ledger Entry No.",ItemLedgerEntry."Entry No.");
            ItemApplicationEntry.SETRANGE("Outbound Item Entry No.",0);
            ItemApplicationEntry.SETRANGE("Inbound Item Entry No.",ItemLedgerEntry."Entry No.");
            ItemApplicationEntry.SETRANGE(Quantity,ItemLedgerEntry.Quantity);
            Assert.AreEqual(
              1,ItemApplicationEntry.COUNT,'Wrong no. of application entries for ILE no ' + FORMAT(ItemLedgerEntry."Entry No."));
          END;
      END;
    END;

    [Normal]
    PROCEDURE VerifyPostedLineComment@47(PostedAssemblyHeader@1000 : Record 910;PostedAssemblyLineNo@1002 : Integer);
    VAR
      AssemblyCommentLine@1001 : Record 906;
    BEGIN
      AssemblyCommentLine.RESET;
      AssemblyCommentLine.SETRANGE("Document Type",AssemblyCommentLine."Document Type"::"Posted Assembly");
      AssemblyCommentLine.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      AssemblyCommentLine.SETRANGE("Document Line No.",PostedAssemblyLineNo);
      AssemblyCommentLine.SETRANGE(Comment,'Order:' + PostedAssemblyHeader."Order No." + ', Line:' + FORMAT(PostedAssemblyLineNo));
      AssemblyCommentLine.FINDFIRST;
      Assert.AreEqual(1,AssemblyCommentLine.COUNT,'Wrong no. of comment lines.');
    END;

    [Normal]
    PROCEDURE VerifyGLEntries@66(PostedAssemblyHeader@1000 : Record 910;PerPostingGroup@1017 : Boolean);
    VAR
      GLEntry@1001 : Record 17;
      PostedAssemblyLine@1002 : Record 911;
      InventoryPostingSetup@1003 : Record 5813;
      GeneralPostingSetup@1004 : Record 252;
      ValueEntry@1008 : Record 5802;
      TotalAmount@1007 : Decimal;
      OutputDirectCost@1009 : Decimal;
      ResDirectCost@1015 : Decimal;
      ItemDirectCost@1016 : Decimal;
      CompDirectCost@1005 : Decimal;
      OutputIndirectCost@1013 : Decimal;
      CompIndirectCost@1012 : Decimal;
      MaterialVariance@1014 : Decimal;
      CapacityVariance@1011 : Decimal;
      CapOverhead@1010 : Decimal;
      ManufOverhead@1006 : Decimal;
    BEGIN
      // Get expected posting accounts for assembly item.
      GetPostingSetup(GeneralPostingSetup,InventoryPostingSetup,PostedAssemblyHeader."Gen. Prod. Posting Group",
        PostedAssemblyHeader."Inventory Posting Group",PostedAssemblyHeader."Location Code");

      // Get output costs.
      OutputDirectCost := GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::"Assembly Output",
          ValueEntry."Entry Type"::"Direct Cost",ValueEntry."Variance Type"::" ",PostedAssemblyHeader."Item No.",TRUE);

      OutputIndirectCost := GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::"Assembly Output",
          ValueEntry."Entry Type"::"Indirect Cost",ValueEntry."Variance Type"::" ",PostedAssemblyHeader."Item No.",TRUE);

      MaterialVariance := GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::"Assembly Output",
          ValueEntry."Entry Type"::Variance,ValueEntry."Variance Type"::Material,PostedAssemblyHeader."Item No.",TRUE);

      CapacityVariance := GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::"Assembly Output",
          ValueEntry."Entry Type"::Variance,ValueEntry."Variance Type"::Capacity,PostedAssemblyHeader."Item No.",TRUE);

      CapOverhead := GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::"Assembly Output",
          ValueEntry."Entry Type"::Variance,ValueEntry."Variance Type"::"Capacity Overhead",PostedAssemblyHeader."Item No.",TRUE);

      ManufOverhead := GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::"Assembly Output",
          ValueEntry."Entry Type"::Variance,ValueEntry."Variance Type"::"Manufacturing Overhead",PostedAssemblyHeader."Item No.",TRUE);

      // Get component costs.
      ResDirectCost :=
        GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::" ",
          ValueEntry."Entry Type"::"Direct Cost",ValueEntry."Variance Type"::" ",'',TRUE);

      ItemDirectCost :=
        GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::"Assembly Consumption",
          ValueEntry."Entry Type"::"Direct Cost",ValueEntry."Variance Type"::" ",'',TRUE);

      // Get consumption direct and indirect costs.
      CompDirectCost := -ItemDirectCost + ResDirectCost;

      CompIndirectCost :=
        GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::"Assembly Consumption",
          ValueEntry."Entry Type"::"Indirect Cost",ValueEntry."Variance Type"::" ",'',TRUE) +
        GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::" ",
          ValueEntry."Entry Type"::"Indirect Cost",ValueEntry."Variance Type"::" ",'',TRUE);

      // Verify GL entries.

      // Verify Inventory Account for output.
      VerifyGLEntry(PostedAssemblyHeader."No.",InventoryPostingSetup."Inventory Account",PostedAssemblyHeader."Posting Date",
        OutputDirectCost + OutputIndirectCost + MaterialVariance + CapacityVariance + CapOverhead + ManufOverhead,'<>');

      // Verify Material variance account for header.
      VerifyGLEntry(PostedAssemblyHeader."No.",InventoryPostingSetup."Material Variance Account",PostedAssemblyHeader."Posting Date",
        -MaterialVariance,'<>');

      // Verify Capacity variance account for header.
      VerifyGLEntry(PostedAssemblyHeader."No.",InventoryPostingSetup."Capacity Variance Account",PostedAssemblyHeader."Posting Date",
        -CapacityVariance,'<>');

      // Verify Capacity overhead variance account for header.
      VerifyGLEntry(PostedAssemblyHeader."No.",InventoryPostingSetup."Cap. Overhead Variance Account",PostedAssemblyHeader.
        "Posting Date",
        -CapOverhead,'<>');

      // Verify Mfg. overhead variance account for header.
      VerifyGLEntry(PostedAssemblyHeader."No.",InventoryPostingSetup."Mfg. Overhead Variance Account",PostedAssemblyHeader.
        "Posting Date",
        -ManufOverhead,'<>');

      // Verify Inventory Adjustment account, both header and component.
      VerifyGLEntry(PostedAssemblyHeader."No.",GeneralPostingSetup."Inventory Adjmt. Account",PostedAssemblyHeader."Posting Date",
        CompDirectCost + CompIndirectCost - OutputDirectCost,'<>');

      // Verify Overhead applied account, both header and component.
      VerifyGLEntry(PostedAssemblyHeader."No.",GeneralPostingSetup."Overhead Applied Account",PostedAssemblyHeader."Posting Date",
        -OutputIndirectCost - CompIndirectCost,'<>');

      // Verify consumption entries.
      PostedAssemblyLine.RESET;
      PostedAssemblyLine.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      PostedAssemblyLine.SETRANGE("Order No.",PostedAssemblyHeader."Order No.");
      PostedAssemblyLine.SETRANGE(Type,PostedAssemblyLine.Type::Item);
      IF PostedAssemblyLine.FINDFIRST THEN
        GetPostingSetup(GeneralPostingSetup,InventoryPostingSetup,PostedAssemblyLine."Gen. Prod. Posting Group",
          PostedAssemblyLine."Inventory Posting Group",PostedAssemblyLine."Location Code");

      // Verify cost aggregation under the document no. for 'Per posting group' option in posting.
      ValueEntry.SETRANGE("Item No.",PostedAssemblyLine."No.");
      ValueEntry.SETRANGE("Variant Code",PostedAssemblyLine."Variant Code");
      ValueEntry.SETRANGE("Location Code",PostedAssemblyLine."Location Code");
      ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::"Positive Adjmt.");
      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::"Direct Cost");
      IF ValueEntry.FINDFIRST AND PerPostingGroup THEN
        VerifyGLEntry(PostedAssemblyHeader."No.",GeneralPostingSetup."Inventory Adjmt. Account",ValueEntry."Posting Date",
          -ValueEntry."Cost Amount (Actual)",'<>');

      // Verify Inventory account for item consumption.
      VerifyGLEntry(PostedAssemblyHeader."No.",InventoryPostingSetup."Inventory Account",PostedAssemblyHeader."Posting Date",
        ItemDirectCost,'<>');

      // Verify Direct Cost account for resource consumption.
      VerifyGLEntry(PostedAssemblyHeader."No.",GeneralPostingSetup."Direct Cost Applied Account",PostedAssemblyHeader."Posting Date",
        -ResDirectCost,'<>');

      // Check G/L transaction is balanced.
      GLEntry.SETCURRENTKEY("Document No.","Posting Date");
      GLEntry.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      GLEntry.SETRANGE("Posting Date",PostedAssemblyHeader."Posting Date");
      GLEntry.FINDSET;
      REPEAT
        TotalAmount += GLEntry.Amount;
      UNTIL GLEntry.NEXT = 0;

      Assert.AreEqual(0,TotalAmount,'Transaction must be balanced:' + PostedAssemblyHeader."No.");
    END;

    [Normal]
    PROCEDURE VerifyGLEntry@124(DocumentNo@1000 : Code[20];AccountNo@1001 : Code[20];PostingDate@1006 : Date;Amount@1003 : Decimal;Sign@1005 : Text[30]);
    VAR
      GLEntry@1002 : Record 17;
      ActualAmount@1004 : Decimal;
    BEGIN
      ActualAmount := 0;
      GLEntry.RESET;
      GLEntry.SETRANGE("Document No.",DocumentNo);
      GLEntry.SETRANGE("G/L Account No.",AccountNo);
      GLEntry.SETRANGE("Posting Date",PostingDate);
      GLEntry.SETFILTER(Amount,Sign + '%1',0);
      IF GLEntry.FINDSET THEN
        REPEAT
          ActualAmount += GLEntry.Amount;
        UNTIL GLEntry.NEXT = 0;
      Assert.AreNearlyEqual(Amount,ActualAmount,LibraryERM.GetAmountRoundingPrecision,'Account:' + AccountNo);
    END;

    [Normal]
    PROCEDURE VerifyLineAdjustmentEntry@218(PostedAssemblyLine@1000 : Record 911;FinalAdjSource@1002 : Option);
    VAR
      Item@1007 : Record 27;
      ValueEntry@1001 : Record 5802;
      UnitCost@1003 : Decimal;
      Overhead@1004 : Decimal;
      IndirectCost@1005 : Decimal;
      AdjUnitCost@1008 : Decimal;
    BEGIN
      Item.GET(PostedAssemblyLine."No.");
      GetCostInformation(UnitCost,Overhead,IndirectCost,PostedAssemblyLine.Type::Item,
        PostedAssemblyLine."No.",PostedAssemblyLine."Variant Code",PostedAssemblyLine."Location Code");
      FindLineValueEntries(ValueEntry,PostedAssemblyLine,ValueEntry."Entry Type"::"Direct Cost",
        ValueEntry."Item Ledger Entry Type"::"Assembly Consumption");
      ValueEntry.SETRANGE(Adjustment,TRUE);

      IF NeedsAdjustment(AdjUnitCost,Item,PostedAssemblyLine,FinalAdjSource,UnitCost)
      THEN BEGIN
        Assert.AreEqual(1,ValueEntry.COUNT,'Different than 1 entry for comp. item no. ' + PostedAssemblyLine."No.");
        ValueEntry.FINDFIRST;
        Assert.AreNearlyEqual(ABS(AdjUnitCost),ABS(ValueEntry."Cost per Unit"),
          LibraryERM.GetAmountRoundingPrecision,'Wrong unit cost for adj.');
        Assert.AreNearlyEqual(ValueEntry."Cost Amount (Actual)",ValueEntry."Cost per Unit" * ValueEntry."Valued Quantity",
          LibraryERM.GetAmountRoundingPrecision,'Wrong adj. entry cost amount.');
      END ELSE BEGIN
        // For differences in adj. amount less than 0.01, eliminate rounding adjustment entries.
        ValueEntry.SETFILTER("Cost Amount (Actual)",'>%1',LibraryERM.GetAmountRoundingPrecision);
        Assert.IsTrue(ValueEntry.ISEMPTY,'Unexpected adj. entries for comp item no. ' + PostedAssemblyLine."No.");
      END;
    END;

    [Normal]
    PROCEDURE VerifyAdjustmentEntries@222(AssemblyHeader@1000 : Record 900;FinalAdjSource@1006 : Option);
    VAR
      PostedAssemblyHeader@1001 : Record 910;
      PostedAssemblyLine@1002 : Record 911;
      Item@1004 : Record 27;
      StockkeepingUnit@1007 : Record 5700;
      AdjAmount@1003 : Decimal;
      VarianceAmount@1005 : Decimal;
    BEGIN
      COMMIT;
      PostedAssemblyHeader.RESET;
      PostedAssemblyHeader.SETRANGE("Order No.",AssemblyHeader."No.");
      PostedAssemblyHeader.SETRANGE("Item No.",AssemblyHeader."Item No.");
      PostedAssemblyHeader.SETRANGE("Variant Code",AssemblyHeader."Variant Code");
      PostedAssemblyHeader.FINDFIRST;

      PostedAssemblyLine.RESET;
      PostedAssemblyLine.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      PostedAssemblyLine.SETRANGE("Order No.",AssemblyHeader."No.");
      PostedAssemblyLine.SETRANGE(Type,PostedAssemblyLine.Type::Item);
      PostedAssemblyLine.SETFILTER("No.",'<>%1',AssemblyHeader."Item No.");  // Skip validation for auto consumption.

      IF PostedAssemblyLine.FINDSET THEN
        REPEAT
          VerifyLineAdjustmentEntry(PostedAssemblyLine,FinalAdjSource);
        UNTIL PostedAssemblyLine.NEXT = 0;

      GetAdjAmounts(VarianceAmount,AdjAmount,PostedAssemblyHeader);
      VerifyHeaderAdjustmentEntry(PostedAssemblyHeader,AdjAmount);
      Item.GET(AssemblyHeader."Item No.");
      IF Item."Costing Method" = Item."Costing Method"::Standard THEN BEGIN
        IF StockkeepingUnit.GET(PostedAssemblyHeader."Location Code",Item."No.",PostedAssemblyHeader."Variant Code") THEN
          VarianceAmount := VarianceAmount - PostedAssemblyHeader."Cost Amount" + Item."Standard Cost" * PostedAssemblyHeader.Quantity;
        VerifyHeaderVarianceEntry(PostedAssemblyHeader,VarianceAmount);
      END;
    END;

    [Normal]
    PROCEDURE VerifyHeaderAdjustmentEntry@195(PostedAssemblyHeader@1000 : Record 910;AdjAmount@1004 : Decimal);
    VAR
      ValueEntry@1002 : Record 5802;
    BEGIN
      FindHeaderValueEntries(ValueEntry,PostedAssemblyHeader,ValueEntry."Entry Type"::"Direct Cost",
        ValueEntry."Item Ledger Entry Type"::"Assembly Output");
      ValueEntry.SETRANGE(Adjustment,TRUE);

      IF AdjAmount <> 0 THEN BEGIN
        ValueEntry.FINDFIRST;
        Assert.AreEqual(1,ValueEntry.COUNT,'Wrong no. of adjustment entries for header.');
        Assert.AreNearlyEqual(-AdjAmount,ValueEntry."Cost Amount (Actual)",
          LibraryERM.GetAmountRoundingPrecision,'Wrong header adj. entry cost amount.');
        Assert.AreNearlyEqual(ValueEntry."Cost Amount (Actual)",ValueEntry."Cost per Unit" * ValueEntry."Valued Quantity",
          LibraryERM.GetAmountRoundingPrecision,'Wrong header adj. entry cost per unit.');
      END ELSE
        Assert.IsTrue(ValueEntry.ISEMPTY,'Unexpected adj. entries for header ' + PostedAssemblyHeader."No.");
    END;

    [Normal]
    PROCEDURE VerifyHeaderVarianceEntry@215(PostedAssemblyHeader@1000 : Record 910;VarianceAmount@1005 : Decimal);
    VAR
      ValueEntry@1002 : Record 5802;
      ActualVarianceAmount@1004 : Decimal;
    BEGIN
      FindHeaderValueEntries(ValueEntry,PostedAssemblyHeader,ValueEntry."Entry Type"::Variance,
        ValueEntry."Item Ledger Entry Type"::"Assembly Output");
      ValueEntry.SETRANGE(Adjustment,TRUE);
      IF VarianceAmount <> 0 THEN BEGIN
        ValueEntry.FINDSET;
        ActualVarianceAmount := 0;
        REPEAT
          ActualVarianceAmount += ValueEntry."Cost Amount (Actual)";
        UNTIL ValueEntry.NEXT = 0;
        Assert.AreNearlyEqual(VarianceAmount,ActualVarianceAmount,LibraryERM.GetAmountRoundingPrecision,
          'Wrong variance entry cost amount for header.');
      END ELSE
        Assert.IsTrue(ValueEntry.ISEMPTY,'Unexpected variance entry for ' + PostedAssemblyHeader."No.");
    END;

    [Normal]
    PROCEDURE VerifyIndirectCostEntries@76(AssemblyHeader@1000 : Record 900);
    VAR
      ValueEntry@1002 : Record 5802;
      PostedAssemblyLine@1003 : Record 911;
      PostedAssemblyHeader@1008 : Record 910;
      Resource@1004 : Record 156;
      IndirectCostAmount@1001 : Decimal;
      UnitCost@1005 : Decimal;
      Overhead@1006 : Decimal;
      IndirectCost@1007 : Decimal;
      ActualIndirectCostAmount@1009 : Decimal;
    BEGIN
      GetCostInformation(UnitCost,Overhead,IndirectCost,PostedAssemblyLine.Type::Item,AssemblyHeader."Item No.",
        AssemblyHeader."Variant Code",AssemblyHeader."Location Code");
      PostedAssemblyHeader.RESET;
      PostedAssemblyHeader.SETRANGE("Order No.",AssemblyHeader."No.");
      PostedAssemblyHeader.FINDFIRST;

      // Output indirect cost.
      IndirectCostAmount :=
        GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::"Assembly Output",
          ValueEntry."Entry Type"::"Direct Cost",ValueEntry."Variance Type"::" ",PostedAssemblyHeader."Item No.",FALSE) *
        IndirectCost / 100;

      ActualIndirectCostAmount :=
        GetValueEntriesAmount(PostedAssemblyHeader,ValueEntry."Item Ledger Entry Type"::"Assembly Output",
          ValueEntry."Entry Type"::"Indirect Cost",ValueEntry."Variance Type"::" ",PostedAssemblyHeader."Item No.",FALSE);

      Assert.AreNearlyEqual(IndirectCostAmount,ActualIndirectCostAmount,LibraryERM.GetAmountRoundingPrecision,
        'Wrong Output indirect cost');

      // Resource component indirect cost.
      PostedAssemblyLine.RESET;
      PostedAssemblyLine.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      PostedAssemblyLine.SETRANGE("Order No.",PostedAssemblyHeader."Order No.");
      PostedAssemblyLine.SETRANGE(Type,PostedAssemblyLine.Type::Resource);
      IF PostedAssemblyLine.FINDSET THEN
        REPEAT
          FindLineValueEntries(ValueEntry,PostedAssemblyLine,ValueEntry."Entry Type"::"Direct Cost",
            ValueEntry."Item Ledger Entry Type"::" ");
          ValueEntry.FINDFIRST;
          Resource.GET(PostedAssemblyLine."No.");
          IndirectCostAmount := ValueEntry."Cost Amount (Actual)" * Resource."Indirect Cost %" / 100;
          FindLineValueEntries(ValueEntry,PostedAssemblyLine,ValueEntry."Entry Type"::"Indirect Cost",
            ValueEntry."Item Ledger Entry Type"::" ");
          IF ValueEntry.FINDFIRST THEN
            Assert.AreNearlyEqual(IndirectCostAmount,ValueEntry."Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,
              'Wrong component indirect cost');
        UNTIL PostedAssemblyLine.NEXT = 0;
    END;

    [Normal]
    PROCEDURE VerifyPartialPosting@63(AssemblyHeader@1000 : Record 900;HeaderQtyFactor@1003 : Decimal);
    VAR
      AssemblyLine@1001 : Record 901;
    BEGIN
      IF HeaderQtyFactor <> 100 THEN BEGIN
        AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
        AssemblyHeader.TESTFIELD("Quantity to Assemble",AssemblyHeader.Quantity * (100 - HeaderQtyFactor) / 100);
        AssemblyHeader.TESTFIELD("Remaining Quantity",AssemblyHeader."Quantity to Assemble");
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.FINDSET;
        REPEAT
          IF AssemblyLine."Resource Usage Type" <> AssemblyLine."Resource Usage Type"::Fixed THEN BEGIN
            Assert.AreNearlyEqual(AssemblyHeader.Quantity * AssemblyHeader."Qty. per Unit of Measure" *
              AssemblyLine."Quantity per",AssemblyLine.Quantity,
              LibraryERM.GetUnitAmountRoundingPrecision,'Wrong partial line quantity.');
            Assert.AreNearlyEqual(
              AssemblyHeader."Remaining Quantity" * AssemblyHeader."Qty. per Unit of Measure" * AssemblyLine."Quantity per",
              AssemblyLine."Quantity to Consume",
              LibraryERM.GetUnitAmountRoundingPrecision,'Wrong partial line qty. to consume.');
          END ELSE BEGIN
            Assert.AreNearlyEqual(AssemblyLine."Quantity per",AssemblyLine.Quantity,
              LibraryERM.GetUnitAmountRoundingPrecision,'Wrong partial line qty. - fixed.');
            Assert.AreNearlyEqual(
              AssemblyLine.Quantity - AssemblyLine."Consumed Quantity",AssemblyLine."Quantity to Consume",
              LibraryERM.GetUnitAmountRoundingPrecision,'Wrong partial line qty. to consume - fixed.');
          END;
        UNTIL AssemblyLine.NEXT = 0;
      END;
    END;

    [Normal]
    PROCEDURE VerifyPostedAssemblyHeader@29(VAR TempAssemblyLine@1003 : TEMPORARY Record 901;AssemblyHeader@1000 : Record 900;AssembledQty@1004 : Decimal);
    VAR
      PostedAssemblyLine@1002 : Record 911;
      PostedAssemblyHeader@1001 : Record 910;
    BEGIN
      PostedAssemblyHeader.RESET;
      PostedAssemblyHeader.SETRANGE("Order No.",AssemblyHeader."No.");
      PostedAssemblyHeader.SETRANGE("Item No.",AssemblyHeader."Item No.");
      PostedAssemblyHeader.SETRANGE("Variant Code",AssemblyHeader."Variant Code");
      PostedAssemblyHeader.SETRANGE(Description,AssemblyHeader.Description);
      PostedAssemblyHeader.SETRANGE("Inventory Posting Group",AssemblyHeader."Inventory Posting Group");
      PostedAssemblyHeader.SETRANGE("Gen. Prod. Posting Group",AssemblyHeader."Gen. Prod. Posting Group");
      PostedAssemblyHeader.SETRANGE("Location Code",AssemblyHeader."Location Code");
      PostedAssemblyHeader.SETRANGE("Shortcut Dimension 1 Code",AssemblyHeader."Shortcut Dimension 1 Code");
      PostedAssemblyHeader.SETRANGE("Shortcut Dimension 2 Code",AssemblyHeader."Shortcut Dimension 2 Code");
      PostedAssemblyHeader.SETRANGE("Posting Date",AssemblyHeader."Posting Date");
      PostedAssemblyHeader.SETRANGE(Quantity,AssembledQty);
      PostedAssemblyHeader.SETRANGE("Unit Cost",AssemblyHeader."Unit Cost");
      PostedAssemblyHeader.SETRANGE("Unit of Measure Code",AssemblyHeader."Unit of Measure Code");
      PostedAssemblyHeader.SETRANGE("Dimension Set ID",AssemblyHeader."Dimension Set ID");
      Assert.AreEqual(1,PostedAssemblyHeader.COUNT,'Wrong no. of posted assembly order records!');
      PostedAssemblyHeader.FINDFIRST;
      Assert.AreNearlyEqual(AssemblyHeader."Cost Amount" * AssembledQty / AssemblyHeader.Quantity,PostedAssemblyHeader."Cost Amount",
        LibraryERM.GetAmountRoundingPrecision,'Wrong posted cost amount.');
      IF TempAssemblyLine.FINDSET THEN
        REPEAT
          PostedAssemblyLine.RESET;
          PostedAssemblyLine.SETRANGE("Document No.",PostedAssemblyHeader."No.");
          PostedAssemblyLine.SETRANGE("Order Line No.",TempAssemblyLine."Line No.");
          PostedAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type);
          PostedAssemblyLine.SETRANGE("No.",TempAssemblyLine."No.");
          PostedAssemblyLine.SETRANGE("Variant Code",TempAssemblyLine."Variant Code");
          PostedAssemblyLine.SETRANGE(Description,TempAssemblyLine.Description);
          PostedAssemblyLine.SETRANGE("Resource Usage Type",TempAssemblyLine."Resource Usage Type");
          PostedAssemblyLine.SETRANGE("Location Code",TempAssemblyLine."Location Code");
          PostedAssemblyLine.SETRANGE("Shortcut Dimension 1 Code",TempAssemblyLine."Shortcut Dimension 1 Code");
          PostedAssemblyLine.SETRANGE("Shortcut Dimension 2 Code",TempAssemblyLine."Shortcut Dimension 2 Code");
          PostedAssemblyLine.SETRANGE(Quantity,TempAssemblyLine."Quantity to Consume");
          PostedAssemblyLine.SETRANGE("Unit of Measure Code",TempAssemblyLine."Unit of Measure Code");
          PostedAssemblyLine.SETRANGE("Dimension Set ID",TempAssemblyLine."Dimension Set ID");
          PostedAssemblyLine.SETRANGE("Unit Cost",TempAssemblyLine."Unit Cost");
          Assert.AreEqual(1,PostedAssemblyLine.COUNT,'Wrong no. of posted lines for ' + TempAssemblyLine."No.");
          PostedAssemblyLine.FINDFIRST;
          // Do not check cost amount for comment lines.
          IF TempAssemblyLine.Type <> TempAssemblyLine.Type::" " THEN
            Assert.AreNearlyEqual(
              TempAssemblyLine."Cost Amount" * TempAssemblyLine."Quantity to Consume" / TempAssemblyLine.Quantity,
              PostedAssemblyLine."Cost Amount",LibraryERM.GetAmountRoundingPrecision,'Wrong posted line cost amount.');
        UNTIL TempAssemblyLine.NEXT = 0;
    END;

    PROCEDURE VerifyPostedComments@42(AssemblyHeader@1000 : Record 900);
    VAR
      PostedAssemblyLine@1001 : Record 911;
      PostedAssemblyHeader@1002 : Record 910;
    BEGIN
      FindPostedAssemblyHeaders(PostedAssemblyHeader,AssemblyHeader);
      PostedAssemblyHeader.FINDFIRST;
      VerifyPostedLineComment(PostedAssemblyHeader,0);

      FindPostedAssemblyLines(PostedAssemblyLine,PostedAssemblyHeader);
      IF PostedAssemblyLine.FINDSET THEN
        REPEAT
          VerifyPostedLineComment(PostedAssemblyHeader,PostedAssemblyLine."Line No.");
        UNTIL PostedAssemblyLine.NEXT = 0;
    END;

    PROCEDURE VerifyWarehouseEntries@125(VAR TempAssemblyHeader@1001 : TEMPORARY Record 900;VAR TempAssemblyLine@1002 : TEMPORARY Record 901;IsUndo@1005 : Boolean);
    VAR
      WarehouseEntry@1000 : Record 7312;
      SourceCodeSetup@1140 : Record 242;
    BEGIN
      SourceCodeSetup.GET;
      WarehouseEntry.RESET;
      WarehouseEntry.SETRANGE("Source Code",SourceCodeSetup.Assembly);
      // TODO - bug as fields are not populated
      // WarehouseEntry.SETRANGE("Whse. Document Type",WarehouseEntry."Whse. Document Type"::Assembly);
      // WarehouseEntry.SETRANGE("Whse. Document No.",TempAssemblyHeader."No.");
      // WarehouseEntry.SETRANGE("Source Document",WarehouseEntry."Source Document"::"Assembly Order");
      // WarehouseEntry.SETRANGE("Source Line No.",0);
      WarehouseEntry.SETRANGE("Source No.",TempAssemblyHeader."No.");
      WarehouseEntry.SETRANGE("Registering Date",TempAssemblyHeader."Posting Date");
      WarehouseEntry.SETRANGE("User ID",USERID);
      WarehouseEntry.SETRANGE("Variant Code",TempAssemblyHeader."Variant Code");
      WarehouseEntry.SETRANGE("Unit of Measure Code",TempAssemblyHeader."Unit of Measure Code");
      IF IsUndo THEN BEGIN
        WarehouseEntry.SETRANGE(Quantity,-TempAssemblyHeader."Quantity to Assemble");
        WarehouseEntry.SETRANGE("Entry Type",WarehouseEntry."Entry Type"::"Negative Adjmt.")
      END ELSE BEGIN
        WarehouseEntry.SETRANGE("Entry Type",WarehouseEntry."Entry Type"::"Positive Adjmt.");
        WarehouseEntry.SETRANGE(Quantity,TempAssemblyHeader."Quantity to Assemble");
      END;
      WarehouseEntry.SETRANGE("Location Code",TempAssemblyHeader."Location Code");
      WarehouseEntry.SETRANGE("Bin Code",TempAssemblyHeader."Bin Code");
      WarehouseEntry.SETRANGE(
        "Zone Code",LibraryWarehouse.GetZoneForBin(TempAssemblyHeader."Location Code",TempAssemblyHeader."Bin Code"));
      WarehouseEntry.SETRANGE("Item No.",TempAssemblyHeader."Item No.");

      Assert.AreEqual(1,WarehouseEntry.COUNT,'Incorect number of warehouse entries for assembly ' + TempAssemblyHeader."No.");

      // Verify warehouse entries for components
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;
      REPEAT
        WarehouseEntry.RESET;
        WarehouseEntry.SETRANGE("Source Code",SourceCodeSetup.Assembly);
        // TODO - bug as fields are not populated
        // WarehouseEntry.SETRANGE("Whse. Document Type",WarehouseEntry."Whse. Document Type"::Assembly);
        // WarehouseEntry.SETRANGE("Whse. Document No.",TempAssemblyHeader."No.");
        // WarehouseEntry.SETRANGE("Source Document",WarehouseEntry."Source Document"::"Assembly Consumption");
        // WarehouseEntry.SETRANGE("Source Line No.",0);
        WarehouseEntry.SETRANGE("Source No.",TempAssemblyHeader."No.");
        WarehouseEntry.SETRANGE("Registering Date",TempAssemblyHeader."Posting Date");
        WarehouseEntry.SETRANGE("User ID",USERID);
        WarehouseEntry.SETRANGE("Variant Code",TempAssemblyLine."Variant Code");
        WarehouseEntry.SETRANGE("Unit of Measure Code",TempAssemblyLine."Unit of Measure Code");
        IF IsUndo THEN BEGIN
          WarehouseEntry.SETRANGE(Quantity,TempAssemblyLine."Quantity to Consume");
          WarehouseEntry.SETRANGE("Entry Type",WarehouseEntry."Entry Type"::"Positive Adjmt.")
        END ELSE BEGIN
          WarehouseEntry.SETRANGE(Quantity,-TempAssemblyLine."Quantity to Consume");
          WarehouseEntry.SETRANGE("Entry Type",WarehouseEntry."Entry Type"::"Negative Adjmt.");
        END;
        WarehouseEntry.SETRANGE("Location Code",TempAssemblyLine."Location Code");
        WarehouseEntry.SETRANGE("Bin Code",TempAssemblyLine."Bin Code");
        WarehouseEntry.SETRANGE("Item No.",TempAssemblyLine."No.");
        Assert.AreEqual(1,WarehouseEntry.COUNT,'Incorrect number of warehouse entries for assembly line ' + TempAssemblyLine."No.");
      UNTIL TempAssemblyLine.NEXT = 0;
    END;

    PROCEDURE VerifyBinContent@101(LocationCode@1003 : Code[20];BinCode@1000 : Code[20];ItemNo@1002 : Code[20];VariantCode@1005 : Code[10];UOMCode@1006 : Code[10];Quantity@1001 : Decimal);
    VAR
      BinContent@1004 : Record 7302;
    BEGIN
      BinContent.RESET;
      BinContent.SETRANGE("Location Code",LocationCode);
      BinContent.SETRANGE("Bin Code",BinCode);
      BinContent.SETRANGE("Item No.",ItemNo);
      BinContent.SETRANGE("Variant Code",VariantCode);
      BinContent.SETRANGE("Unit of Measure Code",UOMCode);
      IF BinContent.FINDFIRST THEN BEGIN
        BinContent.CALCFIELDS(Quantity);
        BinContent.TESTFIELD(Quantity,Quantity);
      END ELSE
        Assert.AreEqual(Quantity,0,'Incorrect Bin Code Qty for Item: ' + ItemNo + ' in Bin: ' + BinCode);
    END;

    PROCEDURE VerifyBinContents@86(VAR TempAssemblyHeader@1000 : TEMPORARY Record 900;VAR TempAssemblyLine@1001 : TEMPORARY Record 901;AdditionalQty@1002 : Decimal);
    BEGIN
      // This function has to be called after the AO has been posted and no other "output" qtities exist in inventory

      // Verify bin content for header assembly item does not exist
      VerifyBinContent(
        TempAssemblyHeader."Location Code",TempAssemblyHeader."Bin Code",TempAssemblyHeader."Item No.",
        TempAssemblyHeader."Variant Code",TempAssemblyHeader."Unit of Measure Code",0);

      // Verify bin contents for components
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;
      REPEAT
        VerifyBinContent(
          TempAssemblyLine."Location Code",TempAssemblyLine."Bin Code",TempAssemblyLine."No.",TempAssemblyLine."Variant Code",
          TempAssemblyLine."Unit of Measure Code",
          AdditionalQty + TempAssemblyLine.Quantity);
      UNTIL TempAssemblyLine.NEXT = 0;
    END;

    PROCEDURE SetLinkToLines@182(AsmHeader@1000 : Record 900;VAR AsmLine@1001 : Record 901);
    BEGIN
      AsmLine.SETRANGE("Document Type",AsmHeader."Document Type");
      AsmLine.SETRANGE("Document No.",AsmHeader."No.");
    END;

    PROCEDURE EarliestAvailableDate@183(AsmHeader@1000 : Record 900;VAR AssemblyLine@1001 : Record 901;VAR ReturnQtyAvailable@1002 : Decimal;VAR EarliestDueDate@1003 : Date);
    VAR
      Item@1017 : Record 27;
      ReqLine@1020 : Record 246;
      LeadTimeMgt@1006 : Codeunit 5404;
      LineAvailabilityDate@1004 : Date;
      LineStartingDate@1005 : Date;
      EarliestEndingDate@1019 : Date;
      EarliestStartingDate@1018 : Date;
      LineProportion@1007 : Decimal;
      Proportion@1008 : Decimal;
      GrossRequirement@1009 : Decimal;
      ScheduledRcpt@1010 : Decimal;
      ExpectedInventory@1014 : Decimal;
      LineAbleToAssemble@1016 : Decimal;
      LineInventory@1021 : Decimal;
    BEGIN
      SetLinkToLines(AsmHeader,AssemblyLine);
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.SETFILTER("No.",'<>%1','');
      AssemblyLine.SETFILTER("Quantity per",'<>%1',0);
      Proportion := AsmHeader."Remaining Quantity";
      IF AssemblyLine.FINDFIRST THEN
        REPEAT
          AssemblyLine.CalcAvailToAssemble(
            AsmHeader,
            Item,
            GrossRequirement,
            ScheduledRcpt,
            ExpectedInventory,
            LineInventory,
            LineAvailabilityDate,
            LineAbleToAssemble);

          LineProportion := LineAbleToAssemble;
          IF LineProportion < Proportion THEN
            Proportion := LineProportion;
          IF LineAvailabilityDate > 0D THEN BEGIN
            LineStartingDate := CALCDATE(AssemblyLine."Lead-Time Offset",LineAvailabilityDate);
            IF LineStartingDate > EarliestStartingDate THEN
              EarliestStartingDate := LineStartingDate; // latest of all line starting dates
          END;
        UNTIL AssemblyLine.NEXT = 0;

      ReturnQtyAvailable := Proportion;
      WITH AsmHeader DO BEGIN
        EarliestDueDate := 0D;
        IF EarliestStartingDate > 0D THEN BEGIN
          EarliestEndingDate := // earliest starting date + lead time calculation
            LeadTimeMgt.PlannedEndingDate2("Item No.","Location Code","Variant Code",
              '',LeadTimeMgt.ManufacturingLeadTime("Item No.","Location Code","Variant Code"),
              ReqLine."Ref. Order Type"::Assembly,EarliestStartingDate);
          EarliestDueDate := // earliest ending date + (default) safety lead time
            LeadTimeMgt.PlannedDueDate("Item No.","Location Code","Variant Code",
              EarliestEndingDate,'',ReqLine."Ref. Order Type"::Assembly);
        END;
      END;
    END;

    PROCEDURE ComponentsAvailable@184(AssemblyHeader@1000 : Record 900) : Boolean;
    VAR
      AssemblyLine@1007 : Record 901;
      ItemCheckAvail@1006 : Codeunit 311;
      Inventory@1005 : Decimal;
      GrossRequirement@1004 : Decimal;
      ReservedRequirement@1008 : Decimal;
      ScheduledReceipts@1003 : Decimal;
      ReservedReceipts@1009 : Decimal;
      QtyAvailToMake@1002 : Decimal;
      EarliestAvailableDateX@1001 : Date;
    BEGIN
      SetLinkToLines(AssemblyHeader,AssemblyLine);
      ItemCheckAvail.AsmOrderCalculate(AssemblyHeader,Inventory,
        GrossRequirement,ReservedRequirement,ScheduledReceipts,ReservedReceipts);
      EarliestAvailableDate(AssemblyHeader,AssemblyLine,QtyAvailToMake,EarliestAvailableDateX);
      EXIT(QtyAvailToMake >= AssemblyHeader."Remaining Quantity");
    END;

    PROCEDURE LineCount@45(AssemblyHeader@1000 : Record 900) : Integer;
    VAR
      AssemblyLine@1001 : Record 901;
    BEGIN
      SetLinkToLines(AssemblyHeader,AssemblyLine);
      EXIT(AssemblyLine.COUNT);
    END;

    BEGIN
    END.
  }
}

