OBJECT Codeunit 137289 SCM Inventory Costing IV
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      Assert@1007 : Codeunit 130000;
      LibraryCosting@1008 : Codeunit 132200;
      LibraryERM@1006 : Codeunit 131300;
      LibraryInventory@1005 : Codeunit 132201;
      LibraryManufacturing@1013 : Codeunit 132202;
      LibraryPurchase@1004 : Codeunit 130512;
      LibraryPlanning@1035 : Codeunit 132203;
      LibrarySales@1003 : Codeunit 130509;
      LibraryUtility@1009 : Codeunit 131000;
      LibraryVariableStorage@1002 : Codeunit 131004;
      LibraryWarehouse@1010 : Codeunit 132204;
      LibraryRandom@1001 : Codeunit 130440;
      LibraryReportDataset@1038 : Codeunit 131007;
      isInitialized@1000 : Boolean;
      ValueEntryNotMatched@1011 : TextConst 'ENU=%1 must be %2 in %3.';
      UndoReceiptMessage@1014 : TextConst 'ENU=Do you really want to undo the selected Receipt lines?';
      AppliedQuantityUndoError@1012 : TextConst 'ENU="Remaining Quantity must be equal to ''%1''  in Item Ledger Entry: Entry No.=%2. Current value is ''0''."';
      UndoRcptReservedQtyError@1015 : TextConst 'ENU="Reserved Quantity must be equal to "';
      UndoChargeItemReceiptError@1016 : TextConst 'ENU=Undo Receipt can be performed only for lines of type Item. Please select a line of the Item type and repeat the procedure.';
      PutAwayCreatedUndoError@1019 : TextConst 'ENU=You cannot undo line 10000 because warehouse put-away lines have already been created.';
      UndoInvoicedReceiptError@1020 : TextConst 'ENU=You cannot undo line 10000 because an item charge has already been invoiced.';
      UndoChargeItemRetShptError@1017 : TextConst 'ENU=Undo Return Shipment can be performed only for lines of type Item. Please select a line of the Item type and repeat the procedure.';
      UndoPurchRetOrderMessage@1023 : TextConst 'ENU=Do you really want to undo the selected Return Shipment lines?';
      UndoPickedLineMessage@1024 : TextConst 'ENU=The items have been picked.';
      UndoChargeItemSaleShptError@1025 : TextConst 'ENU=Undo Shipment can be performed only for lines of type Item. Please select a line of the Item type and repeat the procedure.';
      UndoSalesShipmentMsg@1026 : TextConst 'ENU=Do you really want to undo the selected Shipment lines?';
      UndoDropShipmentError@1027 : TextConst 'ENU=Drop Shipment must be equal to ''No''  in Sales Shipment Line';
      ChangeLocationMessage@1028 : TextConst 'ENU=You have changed Location Code on the sales header, but it has not been changed on the existing sales lines.';
      UndoSalesRetReceiptMsg@1029 : TextConst 'ENU=Do you really want to undo the selected Return Receipt lines?';
      UndoChargeItemRetRcptMsg@1030 : TextConst 'ENU=Undo Return Receipt can be performed only for lines of type Item.';
      AutoCostPostinMessage@1021 : TextConst 'ENU=The field Automatic Cost Posting should not be set to Yes if field Use Legacy G/L Entry Locking in General Ledger Setup table is set to No because of possibility of deadlocks.';
      ChangeCurrCodeMessage@1033 : TextConst 'ENU=If you change';
      ChangePostingDateMessage@1034 : TextConst 'ENU=You have changed Posting Date on the sales header, but it has not been changed on the existing sales lines.';
      BeforeWorkDateErr@1031 : TextConst 'ENU=is before work date %1 in one or more of the assembly lines';
      AdjustCostErr@1032 : TextConst 'ENU=Cost Amount (Actual) for Assembled Item in Sale type item ledger entry should equal the negative of the sum of components''s cost after running adjust cost';
      ExpandBOMErr@1036 : TextConst 'ENU=BOM component should not exist for Item %1';
      CostAmountNonInvtblErr@1037 : TextConst 'ENU=Cost Amount (Non-Invtbl.) is not negative';
      CostAmountActualACYErr@1039 : TextConst 'ENU=Cost Amount (Actual) (ACY) on Item Ledger Entry is incorrect.';
      CostAmountExpectedACYErr@1040 : TextConst 'ENU=Cost Amount (Expected) (ACY) on Item Ledger Entry is incorrect.';
      CostPerUnitACYErr@1041 : TextConst 'ENU=Cost per Unit (ACY) on Value Entry is incorrect.';
      CostPostedToGLACYErr@1042 : TextConst 'ENU=Cost Posted to G/L (ACY) on Value Entry is incorrect.';
      ItemNoIsUnexpectedErr@1043 : TextConst 'ENU=Value of  Item."No." is unexpected.';

    [Test]
    PROCEDURE AdjustSalesOrderChangeOfUnitCost@12();
    VAR
      Item@1000 : Record 27;
      PurchaseHeader@1003 : Record 38;
      PurchaseLine@1002 : Record 39;
      ValueEntry@1006 : Record 5802;
      CostPerUnit@1009 : Decimal;
      Amount@1008 : Decimal;
      Quantity@1004 : Decimal;
      DocumentNo@1007 : Code[20];
    BEGIN
      // Verify Value Entry for Sales Document after change of Unit Cost.

      // Setup.
      Initialize;
      Quantity := 10 + LibraryRandom.RandDec(100,1);  // Taking 10 + Random to make sure Quantity not less than 10.
      CreateAndUpdatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::Item,LibraryRandom.RandDec(100,1),Quantity,
        Quantity / 2,CreateItem(0,Item."Costing Method"::FIFO),PurchaseLine."Location Code");
      Amount := PurchaseLine."Direct Unit Cost" * PurchaseLine."Qty. to Receive";
      PostPurchaseDocument(PurchaseLine,TRUE);
      DocumentNo := CreateAndPostSalesDocument(CreateCustomer,PurchaseLine."No.",Quantity,TRUE,TRUE);

      // Update Purchase Line and Post as Invoice.
      UpdatePurchaseLine(
        PurchaseLine,PurchaseLine."Direct Unit Cost" + LibraryRandom.RandDec(100,1),PurchaseLine."Qty. to Receive",
        PurchaseLine."Location Code");
      CostPerUnit := (PurchaseLine."Direct Unit Cost" * PurchaseLine."Qty. to Receive" - Amount) / Quantity;
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      UpdatePurchaseHeader(PurchaseHeader);  // Update Vendor Invoice and Vendor Credit Memo No.
      PostPurchaseDocument(PurchaseLine,TRUE);

      // Exercise: Run Adjust Cost Item Entries.
      LibraryCosting.AdjustCostItemEntries(PurchaseLine."No.",'');

      // Verify: Verify Adjustment Entry in Value Entry table.
      FindValueEntry(ValueEntry,DocumentNo,'','',TRUE);
      ValueEntry.TESTFIELD("Valued Quantity",-Quantity);
      Assert.AreNearlyEqual(
        CostPerUnit,ValueEntry."Cost per Unit",LibraryERM.GetAmountRoundingPrecision,
        STRSUBSTNO(ValueEntryNotMatched,ValueEntry.FIELDCAPTION("Cost per Unit"),CostPerUnit,ValueEntry.TABLECAPTION));
    END;

    [Test]
    PROCEDURE AdjustSalesOrderChangeOfIndirectCost@10();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1010 : Record 32;
      PurchaseLine@1002 : Record 39;
      ValueEntry@1006 : Record 5802;
      Quantity@1004 : Decimal;
      PstdPurchaseDocumentNo@1011 : Code[20];
      PstdSalesDocumentNo@1007 : Code[20];
    BEGIN
      // Verify Value Entry for Sales Document after change of Indirect Cost.

      // Setup.
      Initialize;
      Quantity := 10 + LibraryRandom.RandDec(100,1);  // Taking 10 + Random to make sure Quantity not less than 10.
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::Item,CreateVendor,
        CreateItem(LibraryRandom.RandDec(100,1),Item."Costing Method"::FIFO),Quantity);
      PostPurchaseDocument(PurchaseLine,TRUE);
      PstdSalesDocumentNo := CreateAndPostSalesDocument(CreateCustomer,PurchaseLine."No.",Quantity,TRUE,TRUE);

      Item.GET(PurchaseLine."No.");
      Item.VALIDATE("Indirect Cost %",Item."Indirect Cost %" + LibraryRandom.RandDec(100,1));
      Item.MODIFY(TRUE);

      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::Item,PurchaseLine."Buy-from Vendor No.",
        PurchaseLine."No.",Quantity);
      PstdPurchaseDocumentNo := PostPurchaseDocument(PurchaseLine,FALSE);

      // Find Item Leger Entry for Posted Purchase Order and Update Entry No. in Purchase Credit Memo.
      FindItemLedgerEntry(ItemLedgerEntry,PstdPurchaseDocumentNo,ItemLedgerEntry."Entry Type"::Purchase);
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::"Credit Memo",PurchaseLine.Type::Item,PurchaseLine."Buy-from Vendor No.",
        Item."No.",Quantity);
      PurchaseLine.VALIDATE("Appl.-to Item Entry",ItemLedgerEntry."Entry No.");
      PurchaseLine.MODIFY(TRUE);
      PostPurchaseDocument(PurchaseLine,TRUE);

      // Exercise: Run Adjust Cost Item Entries.
      LibraryCosting.AdjustCostItemEntries(PurchaseLine."No.",'');

      // Verify: Verify Adjustment Entry in Value Entry table.
      FindValueEntry(ValueEntry,PstdSalesDocumentNo,'','',TRUE);
      ValueEntry.TESTFIELD("Valued Quantity",-Quantity);
    END;

    [Test]
    PROCEDURE AdjustTransferOrderChangeOfUnitCost@26();
    VAR
      Item@1001 : Record 27;
      Location@1012 : Record 14;
      PurchaseLine@1002 : Record 39;
      SalesHeader@1000 : Record 36;
      SalesLine@1003 : Record 37;
      TransferHeader@1013 : Record 5740;
      CostAmountActual@1017 : Decimal;
      CostPerUnit@1009 : Decimal;
      Quantity@1004 : Decimal;
      PstdSalesDocumentNo@1007 : Code[20];
      PstdTransferReceiptDocumentNo@1016 : Code[20];
      PstdTransferShipmentDocumentNo@1015 : Code[20];
    BEGIN
      // Verify Value Entry for Transfer Order after change of Unit Cost.

      // Setup: Create and Post Purchase as Receive and Post Transfer Order.
      Initialize;
      Quantity := 10 + LibraryRandom.RandDec(100,1);  // Taking 10 + Random to make sure Quantity not less than 10.
      Location.SETRANGE("Bin Mandatory",FALSE);
      Location.FINDFIRST;
      Item.GET(CreateItem(0,Item."Costing Method"::FIFO));
      CreateAndUpdatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::Item,0,Quantity,Quantity,Item."No.",Location.Code);  // Using 0 for Direct Unit Cost.
      PostPurchaseDocument(PurchaseLine,FALSE);
      CreateTransferOrder(TransferHeader,Location.Code,PurchaseLine."No.",Quantity);
      LibraryWarehouse.PostTransferOrder(TransferHeader,TRUE,TRUE);

      PstdTransferReceiptDocumentNo :=
        FindTransferReceiptHeader(TransferHeader."Transfer-from Code",TransferHeader."Transfer-to Code");
      PstdTransferShipmentDocumentNo :=
        FindTransferShipmentHeader(TransferHeader."Transfer-from Code",TransferHeader."Transfer-to Code");

      CreateSalesDocument(SalesHeader,SalesHeader."Document Type"::Order,SalesLine.Type::Item,CreateCustomer,Item."No.",Quantity);
      UpdateLocationCodeOnSalesLine(SalesHeader,TransferHeader."Transfer-to Code");
      PstdSalesDocumentNo := LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Update Direct Unit Cost on Purchase Order and Post as Invoice.
      UpdatePurchaseLine(PurchaseLine,LibraryRandom.RandDec(100,1),0,PurchaseLine."Location Code");
      PostPurchaseDocument(PurchaseLine,TRUE);
      CostPerUnit := PurchaseLine."Direct Unit Cost" - Item."Unit Cost";
      CostAmountActual := Quantity * CostPerUnit;

      // Exercise: Run Adjust Cost Item Entries.
      LibraryCosting.AdjustCostItemEntries(PurchaseLine."No.",'');

      // Verify: Verify Adjustment Entry for Transfer and Sales Entry in Value Entry table.
      VerifyValueEntry(PstdSalesDocumentNo,TransferHeader."Transfer-to Code",-CostAmountActual,CostPerUnit,-Quantity);
      VerifyValueEntry(
        PstdTransferShipmentDocumentNo,TransferHeader."Transfer-from Code",-PurchaseLine.Amount,PurchaseLine."Direct Unit Cost",
        -Quantity);
      VerifyValueEntry(
        PstdTransferReceiptDocumentNo,TransferHeader."Transfer-to Code",PurchaseLine.Amount,PurchaseLine."Direct Unit Cost",Quantity);
      VerifyValueEntry(
        PstdTransferReceiptDocumentNo,TransferHeader."In-Transit Code",-PurchaseLine.Amount,PurchaseLine."Direct Unit Cost",-Quantity);
    END;

    [Test]
    PROCEDURE AdjustUnitCostForZeroQuantityWithNonZeroCost@8();
    VAR
      Item@1008 : Record 27;
      ItemChargeAssignmentPurch@1001 : Record 5805;
      ItemLedgerEntry@1004 : Record 32;
      PurchaseLine@1005 : Record 39;
      ReturnReceiptLine@1009 : Record 6661;
      SalesHeader@1000 : Record 36;
      SalesLine@1002 : Record 37;
      NoSeriesManagement@1007 : Codeunit 396;
      DocumentNo@1003 : Code[20];
      Quantity@1010 : Decimal;
    BEGIN
      // Verify Item Ledger Entry for Sales Document with Non Zero Cost.

      // Setup.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,1);

      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::Invoice,SalesLine.Type::Item,CreateCustomer,LibraryInventory.CreateItem(Item),
        Quantity);
      DocumentNo := NoSeriesManagement.GetNextNo(SalesHeader."Shipping No. Series",WORKDATE,FALSE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Find Item Leger Entry for Posted Sales Invoice and Update Entry No. in Sales Credit Memo.
      FindItemLedgerEntry(ItemLedgerEntry,DocumentNo,ItemLedgerEntry."Entry Type"::Sale);
      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::"Credit Memo",SalesLine.Type::Item,SalesHeader."Sell-to Customer No.",Item."No.",
        Quantity);
      FindSalesLine(SalesLine,SalesHeader);
      SalesLine.VALIDATE("Appl.-from Item Entry",ItemLedgerEntry."Entry No.");
      SalesLine.MODIFY(TRUE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Find Return Receipt Line and Create Purchase Order for Charge Item.
      ReturnReceiptLine.SETRANGE("No.",Item."No.");
      ReturnReceiptLine.FINDFIRST;
      CreateAndUpdatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Invoice,PurchaseLine.Type::"Charge (Item)",LibraryRandom.RandInt(100),1,1,
        LibraryInventory.CreateItemChargeNo,'');  // Using 1 for Charge Item and blank value for Location.
      LibraryInventory.CreateItemChargeAssignPurchase(
        ItemChargeAssignmentPurch,PurchaseLine,ItemChargeAssignmentPurch."Applies-to Doc. Type"::"Return Receipt",
        ReturnReceiptLine."Document No.",ReturnReceiptLine."Line No.",Item."No.");
      PostPurchaseDocument(PurchaseLine,TRUE);

      // Exercise: Run Adjust Cost Item Entries.
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Verify: Verify Item Ledger Entry for Sales Shipment and Return Receipt Lines.
      VerifyItemLedgerEntry(DocumentNo,-Quantity,0);
      VerifyItemLedgerEntry(ReturnReceiptLine."Document No.",Quantity,PurchaseLine.Amount);
    END;

    [Test]
    PROCEDURE RevalueFIFOItemByItemLedgerEntry@28();
    VAR
      Item@1000 : Record 27;
      CalculatePer@1005 : 'Item Ledger Entry,Item';
    BEGIN
      // Verify sum of Invoiced Quantity and Cost Amount (Actual) of all Value Entries after Inventory Revaluation per Item Ledger Entry and Adjust Cost - Item Entries for FIFO Item.

      // Setup and Exercise.
      Initialize;
      Item.GET(CreateItem(0,Item."Costing Method"::FIFO));  // 0 for Indirect Cost Pct.
      RevaluateInventoryAndRunAdjustCostItemEntries(Item."No.",CalculatePer::"Item Ledger Entry");

      // Verify: Verify sum of Invoiced Quantity and Cost Amount (Actual) for Value Entries.
      VerifyValueEntryAfterAdjustCostItemEntries(Item."No.",0);  // Sum of Cost Amount (Actual) must be zero.
    END;

    [Test]
    PROCEDURE RevalueFIFOItemByItem@25();
    VAR
      Item@1001 : Record 27;
      CalculatePer@1000 : 'Item Ledger Entry,Item';
    BEGIN
      // Verify sum of Invoiced Quantity and Cost Amount (Actual) of all Value Entries after Inventory Revaluation per Item and Adjust Cost - Item Entries for FIFO Item.

      // Setup and Exercise.
      Initialize;
      Item.GET(CreateItem(0,Item."Costing Method"::FIFO));  // 0 for Indirect Cost Pct.
      RevaluateInventoryAndRunAdjustCostItemEntries(Item."No.",CalculatePer::Item);

      // Verify: Verify sum of Invoiced Quantity and Cost Amount (Actual) for Value Entries.
      VerifyValueEntryAfterAdjustCostItemEntries(Item."No.",0);  // Sum of Cost Amount (Actual) must be zero.
    END;

    [Test]
    PROCEDURE RevalueAverageItemByItem@19();
    VAR
      Item@1001 : Record 27;
      CalculatePer@1000 : 'Item Ledger Entry,Item';
      CostAmountActual@1002 : Decimal;
    BEGIN
      // Verify sum of Invoiced Quantity and Cost Amount (Actual) of all Value Entries after Inventory Revaluation per Item and Adjust Cost - Item Entries for an Average Item.

      // Setup and Exercise.
      Initialize;
      Item.GET(CreateItem(0,Item."Costing Method"::Average));  // 0 for Indirect Cost Pct.
      CostAmountActual := RevaluateInventoryAndRunAdjustCostItemEntries(Item."No.",CalculatePer::Item);

      // Verify: Verify sum of Invoiced Quantity and Cost Amount (Actual) for Value Entries.
      VerifyValueEntryAfterAdjustCostItemEntries(Item."No.",CostAmountActual);
    END;

    [Test]
    PROCEDURE PostPurchChrgInvWithACY@24();
    VAR
      Currency@1000 : Record 4;
      GeneralLedgerSetup@1002 : Record 98;
      Item@1005 : Record 27;
      PurchaseLine@1003 : Record 39;
      PurchRcptLine@1004 : Record 121;
      ItemChargeAssignmentPurch@1001 : Record 5805;
      CostAmountActualACY@1007 : Decimal;
      DocumentNo@1008 : Code[20];
      Quantity@1006 : Decimal;
    BEGIN
      // Verify Value Entry for Cost Amount (Actual) (ACY) and Cost per Unit (ACY) when post Purchase Invoice for Charge Item with Additional Reporting Currency.

      // Setup: Create Currency with Exchange Rate. Update General Ledger Setup for Additional Reporting Currency. Post Purchase Invoice without Currency with Random Direct Unit Cost.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,2);  // Use Random value.
      GeneralLedgerSetup.GET;
      CreateCurrencyWithExchangeRate(Currency);
      UpdateGeneralLedgerSetupForACY(Currency.Code);
      CreateAndUpdatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Invoice,PurchaseLine.Type::Item,LibraryRandom.RandDec(10,2),Quantity,
        Quantity,CreateItem(0,Item."Costing Method"::FIFO),'');  // Use 0 for Indirect Cost Pct.
      PostPurchaseDocument(PurchaseLine,TRUE);
      FindReceiptLine(PurchRcptLine,PurchaseLine."No.");

      // Create Purchase Invoice for Item Charge with Currency and assign to previous posted Receipt.
      PurchaseInvoiceItemChargeAssign(
        PurchaseLine,PurchaseLine."Document Type"::Invoice,PurchRcptLine."Buy-from Vendor No.",
        ItemChargeAssignmentPurch."Applies-to Doc. Type"::Receipt,PurchRcptLine."Document No.",PurchRcptLine."No.",Currency.Code);
      CostAmountActualACY := PurchaseLine.Quantity * PurchaseLine."Direct Unit Cost";

      // Exercise: Post Purchase Invoice.
      DocumentNo := PostPurchaseDocument(PurchaseLine,TRUE);

      // Verify: Verify Value Entry for Cost Amount (Actual) (ACY) and Cost per Unit (ACY).
      VerifyValueEntryAmountsInACY(
        DocumentNo,PurchaseLine."No.",Currency."Unit-Amount Rounding Precision",CostAmountActualACY,
        CostAmountActualACY / PurchRcptLine.Quantity,0);  // Zero value for Cost Amount Expected.

      // Tear Down.
      UpdateGeneralLedgerSetupForACY(GeneralLedgerSetup."Additional Reporting Currency");
    END;

    [Test]
    PROCEDURE PostPurchChrgInvWithoutACY@23();
    VAR
      Item@1000 : Record 27;
      PurchaseLine@1003 : Record 39;
      PurchRcptLine@1004 : Record 121;
      ItemChargeAssignmentPurch@1001 : Record 5805;
      DocumentNo@1005 : Code[20];
      Quantity@1002 : Decimal;
    BEGIN
      // Verify Value Entry for Cost Amount (Actual) (ACY) and Cost per Unit (ACY) when post Purchase Invoice for Charge Item without Additional Reporting Currency.

      // Setup: Create And Post Purchase Invoice without Currency and Random Direct Unit Cost.
      Initialize;
      Quantity := LibraryRandom.RandDec(10,2);  // Use Random value.
      CreateAndUpdatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Invoice,PurchaseLine.Type::Item,LibraryRandom.RandDec(10,2),Quantity,
        Quantity,CreateItem(0,Item."Costing Method"::FIFO),'');  // Use 0 for Indirect Cost Pct.
      PostPurchaseDocument(PurchaseLine,TRUE);
      FindReceiptLine(PurchRcptLine,PurchaseLine."No.");

      // Create Purchase Invoice for Item Charge without Currency and assign to previous posted Receipt.
      PurchaseInvoiceItemChargeAssign(
        PurchaseLine,PurchaseLine."Document Type"::Invoice,PurchRcptLine."Buy-from Vendor No.",
        ItemChargeAssignmentPurch."Applies-to Doc. Type"::Receipt,PurchRcptLine."Document No.",PurchRcptLine."No.",'');

      // Exercise: Post Purchase Invoice.
      DocumentNo := PostPurchaseDocument(PurchaseLine,TRUE);

      // Verify: Verify Value Entry for Cost Amount (Actual) (ACY) and Cost per Unit (ACY).
      VerifyValueEntryAmountsInACY(DocumentNo,PurchaseLine."No.",LibraryERM.GetAmountRoundingPrecision,0,0,0);  // Cost Amount Actual (ACY), Cost per Unit (ACY), Cost Amount Expected and Cost Amount Expected (ACY) must be zero.
    END;

    [Test]
    [HandlerFunctions(PurchItemChargeAssignmentHandler,SalesShipmentLinePageHandler,ItemChargeAssignmentMenuHandler)]
    PROCEDURE PostPurchChrgInvToSalesOrderWithACY@94();
    VAR
      PurchaseLine@1003 : Record 39;
    BEGIN
      // Verify Value Entry for Cost Amount (Non-Invtbl.)(ACY) when post Purchase Order for Charge Item with Additional Reporting Currency.
      Initialize;
      PostPurchDocumentToSalesOrderWithACY(PurchaseLine."Document Type"::Order);
    END;

    [Test]
    [HandlerFunctions(PurchItemChargeAssignmentHandler,SalesShipmentLinePageHandler,ItemChargeAssignmentMenuHandler)]
    PROCEDURE PostPurchChrgOrderToSalesOrderWithACY@104();
    VAR
      PurchaseLine@1004 : Record 39;
    BEGIN
      // Verify Value Entry for Cost Amount (Non-Invtbl.)(ACY) when post Purchase Invoice for Charge Item with Additional Reporting Currency.
      Initialize;
      PostPurchDocumentToSalesOrderWithACY(PurchaseLine."Document Type"::Invoice);
    END;

    LOCAL PROCEDURE PostPurchDocumentToSalesOrderWithACY@102(DocumentType@1000 : Option);
    VAR
      Item@1008 : Record 27;
      Currency@1007 : Record 4;
      GeneralLedgerSetup@1006 : Record 98;
      CurrencyExchangeRate@1005 : Record 330;
      PurchaseLine@1004 : Record 39;
      ValueEntry@1002 : Record 5802;
      DocumentNo@1001 : Code[20];
      CostAmountNonInvtblACY@1009 : Decimal;
    BEGIN
      // Setup: Create Currency with Exchange Rate. Update General Ledger Setup for Additional Reporting Currency.
      // Create and post Sales Order as Ship.
      GeneralLedgerSetup.GET;
      CreateCurrencyWithExchangeRate1(Currency,CurrencyExchangeRate);
      UpdateGeneralLedgerSetupForACY(Currency.Code);
      DocumentNo := CreateAndPostSalesDocument(
          CreateCustomer,CreateItem(0,Item."Costing Method"::FIFO),LibraryRandom.RandDec(10,2),TRUE,FALSE);

      // Exercise: Create Purchase Document for Item Charge and assign to previous posted Shipment.
      AssignItemChargeToSalesShptLines(PurchaseLine,DocumentType,DocumentNo);

      // Post Purchase Document.
      DocumentNo := PostPurchaseDocument(PurchaseLine,TRUE);

      // Verify: Verify Value Entry for Cost Amount (Non-Invtbl.)(ACY).
      WITH ValueEntry DO BEGIN
        SETRANGE("Document No.",DocumentNo);
        SETRANGE("Item Charge No.",PurchaseLine."No.");
        FINDFIRST;
        CostAmountNonInvtblACY := ROUND("Cost Amount (Non-Invtbl.)" * CurrencyExchangeRate."Exchange Rate Amount" /
            CurrencyExchangeRate."Relational Exch. Rate Amount",LibraryERM.GetAmountRoundingPrecision);
        TESTFIELD("Cost Amount (Non-Invtbl.)(ACY)",CostAmountNonInvtblACY);
      END;

      // Tear Down.
      UpdateGeneralLedgerSetupForACY(GeneralLedgerSetup."Additional Reporting Currency");
    END;

    [Test]
    PROCEDURE PostManufacturingOutputWithACY@20();
    VAR
      Currency@1001 : Record 4;
      GeneralLedgerSetup@1000 : Record 98;
      Item@1003 : Record 27;
      ItemJournalLine@1005 : Record 83;
      ProductionOrder@1002 : Record 5405;
      CostAmountExpectedACY@1009 : Decimal;
    BEGIN
      // Verify Value Entry for Cost Amount (Expected) (ACY) when post Output Journal with Additional Reporting Currency.

      // Setup: Create Currency with Exchange Rate. Update General Ledger Setup for Additional Reporting Currency.
      Initialize;
      GeneralLedgerSetup.GET;
      CreateCurrencyWithExchangeRate(Currency);
      UpdateGeneralLedgerSetupForACY(Currency.Code);
      Item.GET(CreateItem(0,Item."Costing Method"::FIFO));  // Use 0 for Indirect Cost Pct.

      // Create Production Order.
      CreateAndRefreshProductionOrder(ProductionOrder,Item."No.");
      CostAmountExpectedACY := LibraryERM.ConvertCurrency(Item."Unit Cost" * ProductionOrder.Quantity,'',Currency.Code,WORKDATE);

      // Exercise: Post Output Journal.
      CreateAndPostOutputJournal(ItemJournalLine,Item."No.",ProductionOrder."No.");

      // Verify: Verify Value Entry for Cost Amount (Expected) (ACY).
      VerifyValueEntryAmountsInACY(ProductionOrder."No.",'',LibraryERM.GetAmountRoundingPrecision,0,0,CostAmountExpectedACY);  // Zero value for Cost Amount Actual (ACY) and Cost per Unit (ACY).

      // Tear Down.
      UpdateGeneralLedgerSetupForACY(GeneralLedgerSetup."Additional Reporting Currency");
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE ErrorOnUndoPurchRcptWithReservation@14();
    VAR
      PurchaseLine@1001 : Record 39;
      SalesLine@1000 : Record 37;
    BEGIN
      // Verify Error while Undo Receipt after reservation of the Item from Sales Order.

      // Setup: Create Purchase Order and Post, create Sale Order and reserve the Item.
      Initialize;
      CreateAndPostPurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::Item,LibraryRandom.RandDec(50,1),FALSE);  // Use Random value.
      CreateSalesDocumentAndReserve(SalesLine,PurchaseLine."No.",PurchaseLine.Quantity);
      LibraryVariableStorage.Enqueue(UndoReceiptMessage);  // Enqueue ConfirmMessageHandler.

      // Exercise.
      ASSERTERROR UndoPurchaseReceiptLines(PurchaseLine);

      // Verify. Verify Error while Undo Receipt of reserved Item.
      Assert.ExpectedError(UndoRcptReservedQtyError);
    END;

    [Test]
    PROCEDURE ErrorOnUndoPurchRcptForChargeItem@35();
    VAR
      PurchaseLine@1000 : Record 39;
    BEGIN
      // Verify Error while Undo Receipt for Charge Item.

      // Setup: Create and post Purchase Order for Item Charge.
      Initialize;
      CreateAndUpdatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::"Charge (Item)",LibraryRandom.RandDec(10,2),
        LibraryRandom.RandDec(50,1),LibraryRandom.RandDec(10,1),LibraryInventory.CreateItemChargeNo,'');  // Use Random value.
      PostPurchaseDocument(PurchaseLine,FALSE);
      LibraryVariableStorage.Enqueue(UndoReceiptMessage);  // Enqueue ConfirmMessageHandler.

      // Exercise.
      ASSERTERROR UndoPurchaseReceiptLines(PurchaseLine);

      // Verify. Verify Error while Undo Receipt for Charge Item.
      Assert.ExpectedError(UndoChargeItemReceiptError);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,GetReceiptLinesHandler)]
    PROCEDURE GetReceiptLineFromPurchInvAfterUndoReceipt@36();
    VAR
      PurchaseLine@1001 : Record 39;
      PurchaseLine2@1006 : Record 39;
    BEGIN
      // Verify Get Receipt Line page, not find any Receipt Line from Purchase Invoice.

      // Setup: Create Purchase Order, Post and undo Receipt.
      Initialize;
      CreateAndPostPurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::Item,LibraryRandom.RandDec(50,1),FALSE);  // Use Random value.
      LibraryVariableStorage.Enqueue(UndoReceiptMessage);  // Enqueue ConfirmMessageHandler.
      UndoPurchaseReceiptLines(PurchaseLine);

      // Create Purchase Invoice and Get Receipt Line.
      CreatePurchaseDocument(
        PurchaseLine2,PurchaseLine2."Document Type"::Invoice,PurchaseLine2.Type::Item,PurchaseLine."Buy-from Vendor No.",
        PurchaseLine."No.",PurchaseLine.Quantity);

      // Exercise.
      CODEUNIT.RUN(CODEUNIT::"Purch.-Get Receipt",PurchaseLine2);

      // Verify: Verify Get Receipt Line page, done by GetReceiptLinesHandler.
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE UndoPurchRcptWithAppliedQuantity@37();
    VAR
      ItemLedgerEntry@1005 : Record 32;
      PurchaseHeader@1001 : Record 38;
      PurchaseLine@1002 : Record 39;
    BEGIN
      // Verify error when undo a Purchase Receipt Line with applied Quantity.

      // Setup: Create Purchase Order and Receive Purchase Order.
      Initialize;
      PurchaseApplication(PurchaseLine,PurchaseLine."Document Type"::Order,LibraryRandom.RandDec(50,1));  // Use Random value.
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      FindItemLedgerEntry(ItemLedgerEntry,PurchaseHeader."Last Receiving No.",ItemLedgerEntry."Entry Type"::Purchase);
      LibraryVariableStorage.Enqueue(UndoReceiptMessage);  // Enqueue value for ConfirmHandler.

      // Exercise: Undo Purchase Receipt Line.
      ASSERTERROR UndoPurchaseReceiptLines(PurchaseLine);

      // Verify: Verify error after undo Receipt with applied Quantity.
      Assert.ExpectedError(STRSUBSTNO(AppliedQuantityUndoError,PurchaseLine.Quantity,ItemLedgerEntry."Entry No."));
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE UndoPurchRcptWithPutAway@42();
    VAR
      PurchaseLine@1002 : Record 39;
    BEGIN
      // Verify error after undo Receipt with Put Away created after post Warehouse Receipt.

      // Setup: Create Purchase Order with Warehouse Location and create Whse. Receipt and Post.
      Initialize;
      CreatePurchaseDocumentWithWhseLocation(PurchaseLine,PurchaseLine."Document Type"::Order);  // Use Random value.
      CreateAndPostWarehouseReceiptFromPO(PurchaseLine);
      LibraryVariableStorage.Enqueue(UndoReceiptMessage);  // Enqueue value for ConfirmHandler.

      // Exercise: Undo Purchase Receipt Line.
      ASSERTERROR UndoPurchaseReceiptLines(PurchaseLine);

      // Verify: Verify error after undo Receipt with Whse. Receipt.
      Assert.ExpectedError(PutAwayCreatedUndoError);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE UndoPurchRcptAfterCreateItemChargeInvoice@46();
    VAR
      PurchaseLine@1000 : Record 39;
      PurchRcptLine@1001 : Record 121;
    BEGIN
      // Verify undo Purchase Receipt for that Invoice created with Item Charge Assignment.

      // Setup: Create Purchase Order, Post, create Purchase Invoice with Item Charge Assignment.
      Initialize;
      PurchaseDocumentWithItemChargeAssignment(PurchaseLine,FALSE);

      // Exercise: Undo Purchase Receipt Line.
      UndoPurchaseReceiptLines(PurchaseLine);

      // Verify: Verify Error while Undo Invoiced Purchase Receipt.
      FindReceiptLine(PurchRcptLine,PurchaseLine."No.");
      PurchRcptLine.TESTFIELD(Correction,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE UndoPurchRcptAfterPostItemChargeInvoice@40();
    VAR
      PurchaseLine@1000 : Record 39;
    BEGIN
      // Verify Error while undo Purchase Receipt which Invoiced with Item Charge Assignment.

      // Setup: Create Purchase Order, Post, create Purchase Invoice with Item Charge Assignment and Post.
      Initialize;
      PurchaseDocumentWithItemChargeAssignment(PurchaseLine,TRUE);

      // Exercise: Undo Purchase Receipt Line.
      ASSERTERROR UndoPurchaseReceiptLines(PurchaseLine);

      // Verify: Verify Error while Undo Invoiced Purchase Receipt.
      Assert.ExpectedError(UndoInvoicedReceiptError);
    END;

    [Test]
    PROCEDURE ErrorOnUndoPurchRetShptForChargeItem@44();
    VAR
      PurchaseLine@1000 : Record 39;
    BEGIN
      // Verify Error while Undo Purchase Return Order Shipment for Charge Item.

      // Setup: Create and post Purchase Return Order for Item Charge.
      Initialize;
      CreateAndUpdatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::"Return Order",PurchaseLine.Type::"Charge (Item)",
        LibraryRandom.RandDec(10,2),LibraryRandom.RandDec(50,1),0,LibraryInventory.CreateItemChargeNo,'');  // Use Random value.
      PostPurchaseDocument(PurchaseLine,FALSE);

      // Exercise.
      ASSERTERROR UndoReturnShipment(PurchaseLine);

      // Verify. Verify Error while Undo Purchase Return Order Shipment for Charge Item.
      Assert.ExpectedError(UndoChargeItemRetShptError);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE UndoRetShptAfterCreateWhsePick@59();
    VAR
      PurchaseLine@1000 : Record 39;
      ItemJournalLine@1003 : Record 83;
      WarehouseShipmentHeader@1001 : Record 7320;
      ReturnShipmentLine@1004 : Record 6651;
    BEGIN
      // Verify Corrective Line on Return Shipment after create Pick, Register and post Whse. Shipment.

      // Setup: Create Purchase Return Order, create and post Item Journal Line, create Whse. Shipment, Register and Post.
      Initialize;
      CreatePurchaseDocumentWithWhseLocation(PurchaseLine,PurchaseLine."Document Type"::"Return Order");
      CreateAndPostItemJournalLine(ItemJournalLine,PurchaseLine."No.",PurchaseLine.Quantity,PurchaseLine."Location Code");
      CreatePickAndRegisterWhseShipment(WarehouseShipmentHeader,PurchaseLine."Document No.",PurchaseLine."Location Code",FALSE);
      LibraryVariableStorage.Enqueue(UndoPurchRetOrderMessage);  // Enqueue value for ConfirmHandler.
      LibraryVariableStorage.Enqueue(UndoPickedLineMessage);  // Enqueue value for ConfirmHandler.

      // Exercise.
      UndoReturnShipment(PurchaseLine);

      // Verify: Verify Corrective Line on Return Shipment after create Pick, Register and post Whse. Shipment.
      FindReturnShipmentLine(ReturnShipmentLine,PurchaseLine);
      ReturnShipmentLine.TESTFIELD(Correction,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE UndoPurchRetShptAfterCreateItemChargeCrMemo@55();
    VAR
      PurchaseLine@1000 : Record 39;
      ReturnShipmentLine@1001 : Record 6651;
    BEGIN
      // Verify undo Purchase Return Shipment for that Invoice created with Item Charge Assignment.

      // Setup: Create Purchase Return Order, Post, create Purchase Invoice with Item Charge Assignment.
      Initialize;
      PurchaseReturnWithItemChargeAssignment(PurchaseLine,FALSE);

      // Exercise: Undo Purchase Return Shipment Line.
      UndoReturnShipment(PurchaseLine);

      // Verify: Verify Corrective Purchase Return Shipment Lines.
      FindReturnShipmentLine(ReturnShipmentLine,PurchaseLine);
      ReturnShipmentLine.TESTFIELD(Correction,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE ErrorOnUndoPurchRetShptAfterPostItemChargeCrMemo@53();
    VAR
      PurchaseLine@1004 : Record 39;
    BEGIN
      // Verify Error while undo Purchase Return Shipment which Invoiced with Item Charge Assignment.

      // Setup: Create Purchase Return Order, Post, create Purchase Invoice with Item Charge Assignment and Post.
      Initialize;
      PurchaseReturnWithItemChargeAssignment(PurchaseLine,TRUE);

      // Exercise: Undo Purchase Receipt Shipment Line.
      ASSERTERROR UndoReturnShipment(PurchaseLine);

      // Verify: Verify Error while Undo Invoiced Purchase Return Shipment.
      Assert.ExpectedError(UndoInvoicedReceiptError);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE ErrorOnUndoPurchRetShptWithAppliedNegQuantity@58();
    VAR
      PurchaseHeader@1003 : Record 38;
      PurchaseLine@1002 : Record 39;
      ItemLedgerEntry@1001 : Record 32;
    BEGIN
      // Verify Corrective Line after undo Purchase Return Shipment Line with applied Quantity.

      // Setup: Create Purchase Return Order and Ship, create Sales Order for same Item and Post.
      Initialize;
      PurchaseApplication(PurchaseLine,PurchaseLine."Document Type"::"Return Order",-LibraryRandom.RandDec(50,1));
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      FindItemLedgerEntry(ItemLedgerEntry,PurchaseHeader."Last Return Shipment No.",ItemLedgerEntry."Entry Type"::Purchase);
      LibraryVariableStorage.Enqueue(UndoPurchRetOrderMessage);  // Enqueue value for ConfirmHandler.

      // Exercise: Undo Purchase Receipt Line.
      ASSERTERROR UndoReturnShipment(PurchaseLine);

      // Verify: Verify error after undo Receipt with applied negative Quantity.
      Assert.ExpectedError(STRSUBSTNO(AppliedQuantityUndoError,ABS(PurchaseLine.Quantity),ItemLedgerEntry."Entry No."));
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,GetReturnShipmentHandler)]
    PROCEDURE GetRetShptLineFromPurchCrMemoAfterUndoRetShpt@84();
    VAR
      PurchaseLine@1001 : Record 39;
      PurchaseLine2@1006 : Record 39;
    BEGIN
      // Verify Get Return Shipment Line page, not find any Return Shipment Line from Purchase Credit Memo.

      // Setup: Create Purchase Order, Post and undo Receipt.
      Initialize;
      CreateAndPostPurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::"Return Order",PurchaseLine.Type::Item,LibraryRandom.RandDec(50,1),FALSE);  // Use Random value.
      LibraryVariableStorage.Enqueue(UndoPurchRetOrderMessage);  // Enqueue value for ConfirmHandler.
      UndoReturnShipment(PurchaseLine);

      // Create Purchase Invoice and Get Receipt Line.
      CreatePurchaseDocument(
        PurchaseLine2,PurchaseLine2."Document Type"::"Credit Memo",PurchaseLine2.Type::Item,PurchaseLine."Buy-from Vendor No.",
        PurchaseLine."No.",PurchaseLine.Quantity);

      // Exercise.
      CODEUNIT.RUN(CODEUNIT::"Purch.-Get Return Shipments",PurchaseLine2);

      // Verify: Verify Get Return Shipment Line page, done by GetReturnShipmentLinesHandler.
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE UndoRetShptOfReservedNegQuantity@61();
    VAR
      PurchaseLine@1001 : Record 39;
      ReturnShipmentLine@1000 : Record 6651;
      SalesLine@1002 : Record 37;
    BEGIN
      // Verify Corrective Lines  Undo Purchase Return Shipment after reservation of the Item from Sales Order.

      // Setup: Create Purchase Return Order and Post, create Sale Order and reserve the Item.
      Initialize;
      CreateAndPostPurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::"Return Order",PurchaseLine.Type::Item,-LibraryRandom.RandDec(50,1),FALSE);  // Use Random value.
      CreateSalesDocumentAndReserve(SalesLine,PurchaseLine."No.",PurchaseLine.Quantity);
      LibraryVariableStorage.Enqueue(UndoPurchRetOrderMessage);  // Enqueue value for ConfirmHandler.

      // Exercise.
      UndoReturnShipment(PurchaseLine);

      // Verify: Verify Corrective Purchase Return Shipment Lines.
      FindReturnShipmentLine(ReturnShipmentLine,PurchaseLine);
      ReturnShipmentLine.TESTFIELD(Correction,TRUE);
    END;

    [Test]
    PROCEDURE ErrorOnUndoSalesShipmentForChargeItem@64();
    VAR
      SalesLine@1002 : Record 37;
    BEGIN
      // Verify Error while Undo Shipment for Charge Item.

      // Setup: Create and post Sales Order for Item Charge.
      Initialize;
      CreateAndShipSalesDocument(
        SalesLine,SalesLine."Document Type"::Order,SalesLine.Type::"Charge (Item)",LibraryInventory.CreateItemChargeNo,1);  // 1 used as Quantity Factor.

      // Exercise.
      ASSERTERROR UndoSalesShipment(SalesLine);

      // Verify: Verify Error while Undo Shipment for Charge Item.
      Assert.ExpectedError(UndoChargeItemSaleShptError);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE ErrorOnUndoReservedSalesShipment@140();
    VAR
      Item@1004 : Record 27;
      SalesLine@1002 : Record 37;
      SalesLine2@1000 : Record 37;
    BEGIN
      // Verify Error while Undo Reserved Sales Shipment.

      // Setup: Create and post Sales Order, Create another Sales Order and Reserved.
      Initialize;
      CreateAndShipSalesDocument(
        SalesLine,SalesLine."Document Type"::Order,SalesLine.Type::Item,CreateItem(0,Item."Costing Method"::FIFO),-1);  // 1 used as Quantity Factor.
      CreateSalesDocumentAndReserve(SalesLine2,SalesLine."No.",ABS(SalesLine.Quantity));
      LibraryVariableStorage.Enqueue(UndoSalesShipmentMsg);  // Enqueue value for ConfirmHandler.

      // Exercise.
      ASSERTERROR UndoSalesShipment(SalesLine);

      // Verify: Verify Error while Undo Reserved Shipment.
      Assert.ExpectedError(UndoRcptReservedQtyError);
    END;

    [Test]
    [HandlerFunctions(SalesListPageHandler,ConfirmHandler)]
    PROCEDURE ErrorOnUndoShipmentOfDropShipment@66();
    VAR
      SalesLine@1002 : Record 37;
    BEGIN
      // Verify Error while Undo Sales Shipment which have Drop Shipment.

      // Setup: Create Sales Order with Drop Shipment and create Purchase Order, Get Drop Shipment and Receive.
      Initialize;
      SalesOrderUpdatedWithDropShipment(SalesLine);
      GetDropShptFromPurchaseOrder(SalesLine."Sell-to Customer No.");
      LibraryVariableStorage.Enqueue(UndoSalesShipmentMsg);

      // Exercise.
      ASSERTERROR UndoSalesShipment(SalesLine);

      // Verify: Verify Error while Undo Sales Shipment which have Drop Shipment.
      Assert.ExpectedError(UndoDropShipmentError);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE UndoShptWithWhseActivityLines@72();
    VAR
      SalesLine@1000 : Record 37;
      SalesHeader@1003 : Record 36;
      PurchaseLine@1002 : Record 39;
      SalesShipmentLine@1001 : Record 111;
      WarehouseShipmentHeader@1004 : Record 7320;
    BEGIN
      // Verify Undo Sales Shipment Line after Warehouse Shipment, create Pick and Register.

      // Setup: Create Purhcase Warehouse Receipt and Register, create Sales Order, Warehouse Shipment, Pick and Register.
      Initialize;
      PurchaseWhseRcptAndRegister(PurchaseLine);
      CreateSalesDocumentWithLocation(
        SalesHeader,SalesHeader."Document Type"::Order,PurchaseLine."No.",PurchaseLine."Location Code",PurchaseLine.Quantity);
      CreatePickAndRegisterWhseShipment(WarehouseShipmentHeader,SalesHeader."No.",SalesHeader."Location Code",TRUE);
      FindSalesLine(SalesLine,SalesHeader);
      LibraryVariableStorage.Enqueue(UndoSalesShipmentMsg);  // Enqueue value for ConfirmHandler.
      LibraryVariableStorage.Enqueue(UndoPickedLineMessage);  // Enqueue value for ConfirmHandler.

      // Exercise.
      UndoSalesShipment(SalesLine);

      // Verify: Verify Corrective Sales Shipment Lines.
      FindShipmentLine(SalesShipmentLine,SalesLine."No.");
      SalesShipmentLine.TESTFIELD(Correction,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,GetShipmentLinesHandler)]
    PROCEDURE CorrectionLinesUnavailableForGetShipmentLines@79();
    VAR
      Item@1000 : Record 27;
      SalesLine@1001 : Record 37;
      SalesHeader@1003 : Record 36;
    BEGIN
      // Verify Get Shipment Lines after undo Shipment Lines.

      // Setup: Create Sales Order, Ship and undo Shipment, create Sales Invoice.
      Initialize;
      CreateAndShipSalesDocument(
        SalesLine,SalesLine."Document Type"::Order,SalesLine.Type::Item,CreateItem(0,Item."Costing Method"::FIFO),1);  // 1 used as Quantity Factor.
      LibraryVariableStorage.Enqueue(UndoSalesShipmentMsg);  // Enqueue value for ConfirmHandler.
      UndoSalesShipment(SalesLine);
      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::Invoice,SalesLine.Type::Item,CreateCustomer,SalesLine."No.",SalesLine.Quantity);  // Use Random Quantity.
      FindSalesLine(SalesLine,SalesHeader);

      // Exercise. Get Shipment Lines.
      CODEUNIT.RUN(CODEUNIT::"Sales-Get Shipment",SalesLine);

      // Verify: Verify Get Shipment Lines after undo Shipment Lines, done by GetShipmentLinesHandler.
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE ErrorOnUndoReservedSalesRetReceipt@96();
    VAR
      Item@1004 : Record 27;
      SalesLine@1002 : Record 37;
      SalesLine2@1000 : Record 37;
    BEGIN
      // Verify Error while Undo Reserved Sales Return Receipt.

      // Setup: Create and post Sales Order, Create another Sales Order and Reserved.
      Initialize;
      CreateAndShipSalesDocument(
        SalesLine,SalesLine."Document Type"::"Return Order",SalesLine.Type::Item,CreateItem(0,Item."Costing Method"::FIFO),1);  // 1 used as Quantity Factor.
      CreateSalesDocumentAndReserve(SalesLine2,SalesLine."No.",ABS(SalesLine.Quantity));
      LibraryVariableStorage.Enqueue(UndoSalesRetReceiptMsg);  // Enqueue value for ConfirmHandler.

      // Exercise.
      ASSERTERROR UndoReturnReceipt(SalesLine);

      // Verify: Verify Error while Undo Reserved Shipment.
      Assert.ExpectedError(UndoRcptReservedQtyError);
    END;

    [Test]
    PROCEDURE ErrorOnUndoSalesRetReceiptForChargeItem@108();
    VAR
      SalesLine@1002 : Record 37;
    BEGIN
      // Verify Error while Undo Sales Return Receipt for Charge Item.

      // Setup: Create and post Sales Order for Item Charge.
      Initialize;
      CreateAndShipSalesDocument(
        SalesLine,SalesLine."Document Type"::"Return Order",SalesLine.Type::"Charge (Item)",LibraryInventory.CreateItemChargeNo,1);  // 1 used as Quantity Factor.

      // Exercise.
      ASSERTERROR UndoReturnReceipt(SalesLine);

      // Verify: Verify Error while Undo Return Receipt for Charge Item.
      Assert.ExpectedError(UndoChargeItemRetRcptMsg);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,GetReturnReceiptHandler)]
    PROCEDURE CorrectionLinesUnavailableForGetRetRcptLines@117();
    VAR
      Item@1000 : Record 27;
      SalesLine@1001 : Record 37;
      SalesHeader@1003 : Record 36;
    BEGIN
      // Verify Get Sales Return Receipt Lines after undo Return Receipt Line.

      // Setup: Create Return Sales Order, Post and undo Return Receipt, create Sales Credit Memo.
      Initialize;
      CreateAndShipSalesDocument(
        SalesLine,SalesLine."Document Type"::"Return Order",SalesLine.Type::Item,CreateItem(0,Item."Costing Method"::FIFO),1);  // 1 used as Quantity Factor.
      LibraryVariableStorage.Enqueue(UndoSalesRetReceiptMsg);  // Enqueue value for ConfirmHandler.
      UndoReturnReceipt(SalesLine);
      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::"Credit Memo",SalesLine.Type::Item,CreateCustomer,SalesLine."No.",SalesLine.Quantity);  // Use Random Quantity.
      FindSalesLine(SalesLine,SalesHeader);

      // Exercise. Get Return Receipt Line.
      CODEUNIT.RUN(CODEUNIT::"Sales-Get Return Receipts",SalesLine);

      // Verify: Verify Get Return Receipt Line after undo Return Receipt Line, done by GetReturnReceiptHandler.
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE UndoReturnReceiptWithWhseActivityLines@82();
    VAR
      Item@1001 : Record 27;
      Location@1002 : Record 14;
      SalesHeader@1003 : Record 36;
      SalesLine@1000 : Record 37;
    BEGIN
      // Verify error while undo Sales Return Receipt Line after Warehouse Receipt and create Put-away.

      // Setup: Create Sales Return Order with Location, create Warehouse Receipt and Post.
      Initialize;
      CreateLocation(Location);
      CreateSalesDocumentWithLocation(
        SalesHeader,SalesHeader."Document Type"::"Return Order",CreateItem(0,Item."Costing Method"::FIFO),Location.Code,
        LibraryRandom.RandDec(50,1));  // Use Random value.
      FindSalesLine(SalesLine,SalesHeader);
      CreateAndPostWhseRcptFromSalesReturn(SalesLine);
      LibraryVariableStorage.Enqueue(UndoSalesRetReceiptMsg);  // Enqueue value for ConfirmHandler.

      // Exercise.
      ASSERTERROR UndoReturnReceipt(SalesLine);

      // Verify: Verify error while undo Sales Return Receipt after create Put-away.
      Assert.ExpectedError(PutAwayCreatedUndoError);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE AdjustCostForDifferentCurrencyExchangeRate@63();
    VAR
      Item@1004 : Record 27;
      Currency@1000 : Record 4;
      SalesHeader@1002 : Record 36;
      ValueEntry@1001 : Record 5802;
      ItemNo@1003 : Code[20];
    BEGIN
      // Verify Value Entries in 'Cost Amount (Expected)(ACY)' of Item Ledger Entry when transactions posted with different Currency Exchange Rates.

      // Setup: Create Currency, add Additional Reporting Currency and update Inventory Setup.
      Initialize;
      CreateCurrencyWithExchangeRate(Currency);
      ItemNo := CreateItem(LibraryRandom.RandInt(10),Item."Costing Method"::Average);  // Take random for Indirect Cost Percent.
      SetupForAdjustCostOnACY(SalesHeader,ItemNo,Currency.Code);

      // Exercise.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');

      // Verify:
      FindValueEntry(ValueEntry,SalesHeader."Last Posting No.",'','',TRUE);
      ValueEntry.TESTFIELD("Document Type",ValueEntry."Document Type"::"Sales Invoice");
      ValueEntry.TESTFIELD(
        "Cost Amount (Actual) (ACY)",
        ROUND(ValueEntry."Cost per Unit (ACY)" * ValueEntry."Valued Quantity",LibraryERM.GetAmountRoundingPrecision,'='));

      // Tear Down.
      UpdateInventorySetup(FALSE);
      UpdateGeneralLedgerSetupForACY('');
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE PostPurchOrderWithDiffCurrencyExchangeRate@279();
    VAR
      Item@1004 : Record 27;
      Currency@1000 : Record 4;
      InventorySetup@1009 : Record 313;
      SalesHeader@1002 : Record 36;
      SalesLine@1005 : Record 37;
      PurchaseLine@1007 : Record 39;
      ValueEntry@1001 : Record 5802;
      ItemNo@1003 : Code[20];
      UnitPrice@1006 : Decimal;
    BEGIN
      // Verify Value Entries with ACY transactions on different Posting Dates after run Adjust Cost Item batch job.

      // Setup: Create Currency, add Additional Reporting Currency and update Inventory Setup.
      Initialize;
      InventorySetup.GET;
      CreateCurrencyWithExchangeRate(Currency);
      ItemNo := CreateItem(LibraryRandom.RandInt(10),Item."Costing Method"::Average);  // Take random for Indirect Cost Percent.
      SetupForAdjustCostOnACY(SalesHeader,ItemNo,Currency.Code);

      // Create Sales Document and Post, create Purchase Document and Receive.
      LibraryVariableStorage.Enqueue(ChangeCurrCodeMessage);  // Enqueue value for ConfirmHandler.
      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::Order,SalesLine.Type::Item,CreateCustomer,ItemNo,LibraryRandom.RandInt(20));  // Use Random Quantity.
      UnitPrice := PurchaseLine."Direct Unit Cost" + LibraryRandom.RandInt(20); // Required Unit Price more than Direct Unit Cost.

      UpdateSalesDocument(SalesLine,SalesHeader,SalesHeader."Posting Date",Currency.Code,UnitPrice);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      CreatePurchaseOrderWithCurrency(
        PurchaseLine,ItemNo,Currency.Code,SalesHeader."Posting Date",LibraryRandom.RandInt(50),
        SalesLine.Quantity + LibraryRandom.RandInt(40));
      PostPurchaseDocument(PurchaseLine,FALSE);

      // Exercise.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');

      // Verify:
      FindValueEntry(ValueEntry,SalesHeader."Last Posting No.",'','',TRUE);
      ValueEntry.TESTFIELD("Document Type",ValueEntry."Document Type"::"Sales Invoice");
      ValueEntry.TESTFIELD(
        "Cost Amount (Actual) (ACY)",
        ROUND(ValueEntry."Cost per Unit (ACY)" * ValueEntry."Valued Quantity",LibraryERM.GetAmountRoundingPrecision,'='));

      // Tear Down.
      UpdateInventorySetup(InventorySetup."Automatic Cost Posting");
      UpdateGeneralLedgerSetupForACY('')
    END;

    [Test]
    [HandlerFunctions(ChangeExchangeRatePageHandler)]
    PROCEDURE PostSalesOrderAfterUpdateExchangeRate@71();
    VAR
      Currency@1000 : Record 4;
      SalesHeader@1003 : Record 36;
      SalesLine@1004 : Record 37;
      CurrencyExchangeRate@1005 : Record 330;
      Item@1001 : Record 27;
    BEGIN
      // Verify Sales Amount on Item Ledger Entry after updating Currency Exchange Rate on Sales Order.

      // Setup: Create Currency, create Sales Order and update Currency Exchange.
      Initialize;
      CreateCurrencyWithExchangeRate(Currency);
      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::Order,SalesLine.Type::Item,CreateAndUpdateCustomer(Currency.Code),
        CreateItem(0,Item."Costing Method"::FIFO),LibraryRandom.RandDec(10,2));
      UpdateSalesDocument(SalesLine,SalesHeader,WORKDATE,Currency.Code,LibraryRandom.RandDec(10,2));  // Random value for Unit Price.
      UpdateCurrencyExchangeRateOnSalesOrder(CurrencyExchangeRate,Currency.Code,SalesLine."Document No.");
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");

      // Exercise: Post Sales Order.
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify: Verify Sales Amount on Item Ledger Entry.
      VerifySalesAmountOnItemLedgerEntry(
        SalesLine."No.",
        (SalesLine."Line Amount" * CurrencyExchangeRate."Relational Exch. Rate Amount") / CurrencyExchangeRate."Exchange Rate Amount");
    END;

    [Test]
    [HandlerFunctions(ChangeExchangeRatePageHandler)]
    PROCEDURE PostPurchOrderAfterUpdateExchangeRate@127();
    VAR
      Currency@1000 : Record 4;
      CurrencyExchangeRate@1005 : Record 330;
      Item@1001 : Record 27;
      ItemLedgerEntry@1003 : Record 32;
      PurchaseLine@1010 : Record 39;
      PurchaseHeader@1004 : Record 38;
      PstdPurchaseDocumentNo@1011 : Code[20];
    BEGIN
      // Verify Cost Amount on Item Ledger Entry after updating Currency Exchange Rate on Purchase Order.

      // Setup: Create Currency, create Purchase Order and update Currency Exchange.
      Initialize;
      LibraryERM.SetWorkDate;
      CreateCurrencyWithExchangeRate(Currency);
      CreatePurchaseOrderWithCurrency(
        PurchaseLine,CreateItem(0,Item."Costing Method"::FIFO),Currency.Code,WORKDATE,LibraryRandom.RandDec(10,2),
        LibraryRandom.RandDec(10,2));  // Use random value for Direct Unit Cost and Quantity.
      UpdateCurrencyExchangeRateOnPurchOrder(CurrencyExchangeRate,Currency.Code,PurchaseLine."Document No.");
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");

      // Exercise: Post Purchase Order.
      PstdPurchaseDocumentNo := LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // Verify: Verify Cost Amount on Item Ledger Entry.
      FindItemLedgerEntry(ItemLedgerEntry,PstdPurchaseDocumentNo,ItemLedgerEntry."Entry Type"::Purchase);
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      ItemLedgerEntry.TESTFIELD(
        "Cost Amount (Actual)",
        (PurchaseLine."Line Amount" * CurrencyExchangeRate."Relational Exch. Rate Amount") /
        CurrencyExchangeRate."Exchange Rate Amount");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE AdjustCostItemEntriesForAssembledItemWithFilter@90();
    VAR
      Item@1000 : Record 27;
      Item2@1007 : Record 27;
      AssemblyItem@1002 : Record 27;
      BomComponent@1003 : Record 90;
      BomComponent2@1009 : Record 90;
      ItemJournalLine@1001 : Record 83;
      ItemLedgerEntry@1008 : Record 32;
      Quantity@1005 : Decimal;
    BEGIN
      // Verify Cost Amount (Actual) on Item Ledger Entry after running Adjust Cost item entries with filtering on Assembled item

      // Setup: Create Assembly Item with 2 BOM components
      Initialize;
      CreateAssemblyItemWithBOM(AssemblyItem,BomComponent,BomComponent2,AssemblyItem."Assembly Policy"::"Assemble-to-Order");

      Quantity := LibraryRandom.RandDec(10,2); // Generate the Quantity to sell for Assembly Item
      CreateAndPostItemJournalLine(ItemJournalLine,BomComponent."No.",Quantity * BomComponent."Quantity per",''); // Increase inventory for components
      CreateAndPostItemJournalLine(ItemJournalLine,BomComponent2."No.",Quantity * BomComponent2."Quantity per",''); // Increase inventory for components

      LibraryVariableStorage.Enqueue(STRSUBSTNO(BeforeWorkDateErr,WORKDATE)); // Enqueue variable for Message handler

      // Post Sales Order for Assembly Item
      CreateAndPostSalesDocument(CreateCustomer,AssemblyItem."No.",Quantity,TRUE,TRUE);

      // Excercise: Adjust Cost Item Entries with filtering on the Assembly Item No.
      LibraryCosting.AdjustCostItemEntries(AssemblyItem."No.",'');

      // Verify: Verify "Cost Amount (Actual)" on Sale Entry Type Line in Item Ledger Entry
      Item.GET(BomComponent."No.");
      Item2.GET(BomComponent2."No.");

      WITH ItemLedgerEntry DO BEGIN
        SETRANGE("Item No.",AssemblyItem."No.");
        SETRANGE("Entry Type","Entry Type"::Sale);
        FINDFIRST;
        CALCFIELDS("Cost Amount (Actual)"); // CALCFIELDS because "Cost Amount (Actual)" is a flow field
      END;

      Assert.AreNearlyEqual(
        -Quantity * (BomComponent."Quantity per" * Item."Unit Cost" + BomComponent2."Quantity per" * Item2."Unit Cost"),
        ItemLedgerEntry."Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,AdjustCostErr);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE AssemblyBOMConsumeExistingInventory@111();
    BEGIN
      // Verify Assembly BOM Item consume existing Inventory for Planning.
      CalcRegenPlanForPlanWksh(FALSE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE ReCalcRegenPlanForPlanWksh@126();
    BEGIN
      // Verify Planning Worksheeet after Re-Calculate Regenerate Plan.
      CalcRegenPlanForPlanWksh(TRUE);
    END;

    LOCAL PROCEDURE CalcRegenPlanForPlanWksh@130(ReCalcRegenPlan@1005 : Boolean);
    VAR
      AssemblyItem@1002 : Record 27;
      ItemJournalLine@1001 : Record 83;
      RequisitionLine@1004 : Record 246;
      SalesHeader@1006 : Record 36;
      SalesLine@1003 : Record 37;
      Quantity@1000 : Decimal;
    BEGIN
      // Setup: Create Assembly BOM with Component. Create Item Journal for Assembly BOM.
      Initialize;
      CreateAssemblyItemWithBOMForPlanning(AssemblyItem,LibraryRandom.RandInt(10));
      Quantity := LibraryRandom.RandDecInRange(2,10,2);
      CreateAndPostItemJournalLine(ItemJournalLine,AssemblyItem."No.",Quantity,'');

      // Create Sales Order for Assembly BOM.
      LibraryVariableStorage.Enqueue(STRSUBSTNO(BeforeWorkDateErr,WORKDATE)); // Enqueue variable for Message handler.
      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::Order,SalesLine.Type::Item,CreateCustomer,AssemblyItem."No.",3 * Quantity);

      // Update "Qty. to Assemble to Order" on Sales Line.
      LibraryVariableStorage.Enqueue(STRSUBSTNO(BeforeWorkDateErr,WORKDATE)); // Enqueue variable for Message handler.
      UpdateQtyToAssembleForSalesDocument(SalesHeader,Quantity);

      // Exercise: Calculate Regenerative Plan for Assembly BOM.
      LibraryPlanning.CalcRegenPlanForPlanWksh(AssemblyItem,WORKDATE,CALCDATE('<CY>',WORKDATE));

      IF ReCalcRegenPlan THEN BEGIN
        FindRequisitionLine(RequisitionLine,AssemblyItem."No.");
        RequisitionLine.DELETE(TRUE);
        LibraryPlanning.CalcRegenPlanForPlanWksh(AssemblyItem,WORKDATE,CALCDATE('<CY>',WORKDATE));
      END;

      // Verify: Verify Calculated Planning Lines.
      // There are 1 Quantity on Inventory, and 1 Quantity to assemble,
      // 3 Quantity demand on sales line, so there should be 3-1-1=1 Quantity for planning.
      FindRequisitionLine(RequisitionLine,AssemblyItem."No.");
      RequisitionLine.TESTFIELD(Quantity,Quantity);
    END;

    [Test]
    [HandlerFunctions(BOMCostSharesPageHandler)]
    PROCEDURE BOMCostSharesWithMultipleAssemblyBOMLevels@137();
    VAR
      TopAssemblyItem@1002 : Record 27;
      AssemblyItem@1003 : Record 27;
      ItemNo@1000 : Code[20];
      QtyPer@1004 : Decimal;
    BEGIN
      // Setup: Create Top Assembly BOM with Assembly Item as Component. Create Component Item for Assembly Item.
      Initialize;
      QtyPer := LibraryRandom.RandInt(10);
      ItemNo := CreateAssemblyItemWithBOMForPlanning(TopAssemblyItem,QtyPer);
      CreateBOMComponentItem(ItemNo,LibraryRandom.RandInt(10));

      // Exercise: Run BOM Cost Shares Page for Top Assembly Item.
      // Verify: Verify Rolled-up Material Cost of the 2nd BOM which is a Purchase Item and it does not account cost from its component.
      AssemblyItem.GET(ItemNo);
      LibraryVariableStorage.Enqueue(AssemblyItem."Unit Cost" * QtyPer);
      LibraryVariableStorage.Enqueue(AssemblyItem."No.");
      RunBOMCostSharesPage(TopAssemblyItem);
    END;

    [Test]
    [HandlerFunctions(StatementRequestPageHandler)]
    PROCEDURE CustomerStatementReportWithMultiCurrency@134();
    VAR
      SalesLine@1000 : Record 37;
      SalesLine2@1001 : Record 37;
      CurrencyCode@1002 : Code[10];
      CurrencyCode2@1003 : Code[10];
      CustomerNo@1004 : Code[20];
    BEGIN
      // Verify that it shows the right balance amount for multiple Currency code when date range is outside of transaction date on Customer Statement Report.

      // Setup: Create and post sales order with currency.
      CustomerNo := CreateCustomer;
      CurrencyCode := CreateAndPostSalesOrderWithCurrency(SalesLine,CustomerNo);
      CurrencyCode2 := CreateAndPostSalesOrderWithCurrency(SalesLine2,CustomerNo);
      LibraryVariableStorage.Enqueue(CustomerNo); // Enqueue value for StatementRequestPageHandler.

      // Exercise: Run Customer Statement report.
      REPORT.RUN(REPORT::Statement);

      // Verify: Verify the total currency balance on the report.
      LibraryReportDataset.LoadDataSetFile;
      VerifyCustomerStatementReport(CurrencyCode,SalesLine."Amount Including VAT");
      VerifyCustomerStatementReport(CurrencyCode2,SalesLine2."Amount Including VAT");
    END;

    [Test]
    [HandlerFunctions(PurchItemChargeAssignmentHandler,SalesShipmentLinePageHandler,ItemChargeAssignmentMenuHandler)]
    PROCEDURE VerifyCostAmountForItemChargeAssignedFromPurchInv@154();
    VAR
      DocumentNo@1001 : Code[20];
    BEGIN
      // Verify that 'Cost Amount (Non-Invtbl)' in Value Entry is negative, if cost is assigned to Sales Shipment Line from Purchase Invoice.

      // Setup
      Initialize;

      // Exercise
      DocumentNo := SalesDocumentWithItemChargeAssignment;

      // Verify
      CheckValueEntryCostAmountNonInvtblNegSign(DocumentNo);
    END;

    [Test]
    PROCEDURE UpdateAddReportingCurrBeforeRevaluation@148();
    VAR
      GeneralLedgerSetup@1000 : Record 98;
      PurchaseLine@1002 : Record 39;
      PurchRcptLine@1010 : Record 121;
      Currency@1001 : Record 4;
      CurrencyExchangeRate@1005 : Record 330;
      RevaluedFactor@1009 : Integer;
    BEGIN
      // Verify Cost Amount (Actual) (ACY) on Item Ledger Entry with updating Additional Reporting Currency before revaluation.

      // Setup: Create Currency with multiple Exchange Rates. Update Additional Reporting Currency on General Ledger Setup.
      Initialize;
      CreateCurrencyWithMultipleExchangeRates(Currency,CurrencyExchangeRate);
      GeneralLedgerSetup.GET;
      UpdateGeneralLedgerSetupForACY(Currency.Code);
      RevaluedFactor := LibraryRandom.RandIntInRange(2,5);

      // Exercise: Create and post Purchase Order as Receive and Invoice.
      // Create and post Revaluation Journal with new Unit Cost (Revalued).
      PostPurchaseOrderAndRevaluationJournal(PurchaseLine,TRUE,RevaluedFactor);

      // Verify: Verify Cost Amount (Actual) (ACY) on Item Ledger Entry with updating Additional Reporting Currency before revaluation.
      FindReceiptLine(PurchRcptLine,PurchaseLine."No.");
      VerifyCostAmountActualACYOnItemLedgerEntry(
        PurchRcptLine."Document No.",CalculateRevaluedCostAmount(PurchaseLine,CurrencyExchangeRate,RevaluedFactor),
        Currency."Amount Rounding Precision");

      // Tear Down: Restore Additional Reporting Currency on General Ledger Setup.
      UpdateGeneralLedgerSetupForACY(GeneralLedgerSetup."Additional Reporting Currency");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE UpdateAddReportingCurrAfterRevaluation@149();
    VAR
      PurchaseLine@1002 : Record 39;
      PurchRcptLine@1010 : Record 121;
      Currency@1001 : Record 4;
      CurrencyExchangeRate@1005 : Record 330;
      UnitCostRevaluated@1004 : Decimal;
      RevaluedFactor@1009 : Integer;
    BEGIN
      // Verify Cost Amount (Actual) (ACY) on Item Ledger Entry, Cost per Unit (ACY) and Cost Posted to G/L (ACY) on Value Entry
      // with updating Additional Reporting Currency after revaluation.

      // Setup: Update Automatic Cost Posting on Inventory Setup. Create Currency with multiple Exchange Rates.
      // Create and post Purchase Order as Receive and Invoice. Run Adjust Cost Item Entries.
      // Create and post Revaluation Journal with new Unit Cost (Revalued).
      Initialize;
      LibraryVariableStorage.Enqueue(AutoCostPostinMessage); // Enqueue value for MessageHandler.
      UpdateInventorySetup(TRUE);
      CreateCurrencyWithMultipleExchangeRates(Currency,CurrencyExchangeRate);
      RevaluedFactor := LibraryRandom.RandIntInRange(2,5);
      UnitCostRevaluated :=
        PostPurchaseOrderAndRevaluationJournal(PurchaseLine,TRUE,RevaluedFactor);

      // Exercise: Run Adjust Add. Reporting Currency.
      LibraryERM.RunAddnlReportingCurrency(Currency.Code,Currency.Code,Currency."Residual Gains Account");

      // Verify: Verify Cost Amount (Actual) (ACY) on Item Ledger Entry. Verify Cost per Unit (ACY) and Cost Posted to G/L (ACY) on Value Entry.
      FindReceiptLine(PurchRcptLine,PurchaseLine."No.");
      VerifyCostAmountActualACYOnItemLedgerEntry(
        PurchRcptLine."Document No.",CalculateRevaluedCostAmount(PurchaseLine,CurrencyExchangeRate,RevaluedFactor),
        Currency."Amount Rounding Precision");
      VerifyAmountsInACYOnValueEntry(
        PurchaseLine."No.",UnitCostRevaluated * CurrencyExchangeRate."Exchange Rate Amount" /
        CurrencyExchangeRate."Relational Exch. Rate Amount",Currency."Amount Rounding Precision",
        UnitCostRevaluated * PurchaseLine.Quantity * CurrencyExchangeRate."Exchange Rate Amount" /
        CurrencyExchangeRate."Relational Exch. Rate Amount");

      // Tear Down: Restore Automatic Cost Posting on Inventory Setup.
      UpdateInventorySetup(FALSE);
    END;

    [Test]
    PROCEDURE UpdateAddReportingCurrAfterRevaluationWithPostReceiveOnPurchOrd@153();
    VAR
      PurchaseLine@1003 : Record 39;
      PurchRcptLine@1010 : Record 121;
      Currency@1001 : Record 4;
      CurrencyExchangeRate@1005 : Record 330;
      RevaluedFactor@1009 : Integer;
    BEGIN
      // Verify Cost Amount (Expected) (ACY) on Item Ledger Entry with updating Additional Reporting Currency after revaluation.

      // Setup: Create Currency with multiple Exchange Rates. Create and post Purchase Order as Receive.
      // Run Adjust Cost Item Entries. Create and post Revaluation Journal with new Unit Cost (Revalued).
      Initialize;
      CreateCurrencyWithMultipleExchangeRates(Currency,CurrencyExchangeRate);
      RevaluedFactor := LibraryRandom.RandIntInRange(2,5);
      PostPurchaseOrderAndRevaluationJournal(PurchaseLine,FALSE,RevaluedFactor);

      // Exercise: Run Adjust Add. Reporting Currency.
      LibraryERM.RunAddnlReportingCurrency(Currency.Code,Currency.Code,Currency."Residual Gains Account");

      // Verify: Verify Cost Amount (Actual) (ACY) on Item Ledger Entry with updating Additional Reporting Currency before revaluation.
      FindReceiptLine(PurchRcptLine,PurchaseLine."No.");
      VerifyCostAmountExpectedACYOnItemLedgerEntry(
        PurchRcptLine."Document No.",CalculateRevaluedCostAmount(PurchaseLine,CurrencyExchangeRate,RevaluedFactor),
        Currency."Amount Rounding Precision");
    END;

    [Test]
    PROCEDURE OpenBOMCostSharesPageWhenFirstInFilterItemHasNoBOMButOthersHave@151();
    VAR
      NoBOMItem@1000 : Record 27;
      BOMItem@1001 : Record 27;
      BOMCostShares@1004 : TestPage 5872;
      ItemFilter@1005 : Text;
      ItemFilterHead@1007 : Code[10];
      NoBOMItemNo@1003 : Code[20];
      BOMItemNo@1002 : Code[20];
      ReadItemNo@1006 : Code[20];
    BEGIN
      // [FEATURE] [BOM Cost Shares]
      // [SCENARIO 380466] If first Item in filter doesn't contain BOM the ERROR "None of the items in the filter have a BOM" must not occur.
      Initialize;

      // [GIVEN] Two Items, First without BOM, second with BOM. Their primary key values: First - ABCDE, Second - ABC.
      ItemFilterHead := LibraryUtility.GenerateRandomCode(BOMItem.FIELDNO("No."),DATABASE::Item);
      NoBOMItemNo := ItemFilterHead;
      BOMItemNo := ItemFilterHead + LibraryUtility.GenerateRandomCode(BOMItem.FIELDNO("No."),DATABASE::Item);

      // [GIVEN] Item Filter in BOM Cost Shares Page is ABC*
      ItemFilter := ItemFilterHead + '*';

      CreateNamedItem(NoBOMItem,NoBOMItemNo);
      CreateNamedProductionBOMItem(BOMItem,BOMItemNo);

      BOMCostShares.OPENVIEW;

      // [WHEN] Set Value of Item Filter in BOM Cost Shares Page
      BOMCostShares.ItemFilter.SETVALUE(ItemFilter);

      // [THEN] No ERROR occurs.

      ReadItemNo := BOMCostShares."No.".VALUE;
      BOMCostShares.CLOSE;

      // [THEN] Read Item."No." from BOM Cost Shares Page is equal to Second Item."No."
      Assert.AreEqual(BOMItemNo,ReadItemNo,ItemNoIsUnexpectedErr);
    END;

    LOCAL PROCEDURE Initialize@4();
    VAR
      InventorySetup@1000 : Record 313;
      LibraryERMCountryData@1002 : Codeunit 131305;
    BEGIN
      LibraryVariableStorage.Clear;
      IF isInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.CreateGeneralPostingSetupData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.UpdatePurchasesPayablesSetup;
      LibraryInventory.NoSeriesSetup(InventorySetup);
      isInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE CreateAndPostItemJournalLine@48(VAR ItemJournalLine@1000 : Record 83;ItemNo@1002 : Code[20];Quantity@1003 : Decimal;LocationCode@1004 : Code[10]);
    VAR
      ItemJournalBatch@1001 : Record 233;
      ItemJournalTemplate@1005 : Record 82;
    BEGIN
      SelectAndClearItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Type::Item);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Quantity);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateAndPostOutputJournal@76(VAR ItemJournalLine@1003 : Record 83;ItemNo@1002 : Code[20];ProductionOrderNo@1000 : Code[20]);
    VAR
      ItemJournalBatch@1001 : Record 233;
      ItemJournalTemplate@1005 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Output);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      LibraryManufacturing.CreateOutputJournal(ItemJournalLine,ItemJournalTemplate,ItemJournalBatch,ItemNo,ProductionOrderNo);
      CODEUNIT.RUN(CODEUNIT::"Output Jnl.-Expl. Route",ItemJournalLine);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseDocument@52(VAR PurchaseLine@1000 : Record 39;DocumentType@1001 : Option;Type@1002 : Option;Quantity@1005 : Decimal;Invoice@1003 : Boolean);
    VAR
      Item@1004 : Record 27;
    BEGIN
      CreatePurchaseDocument(
        PurchaseLine,DocumentType,Type,CreateVendor,CreateItem(LibraryRandom.RandDec(10,1),Item."Costing Method"::FIFO),
        Quantity);
      PostPurchaseDocument(PurchaseLine,Invoice);
    END;

    LOCAL PROCEDURE CreatePurchaseOrderWithCurrency@114(VAR PurchaseLine@1000 : Record 39;No@1001 : Code[20];CurrencyCode@1002 : Code[10];PostingDate@1006 : Date;DirectUnitCost@1008 : Decimal;Quantity@1005 : Decimal);
    VAR
      PurchaseHeader@1007 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,CreateVendor);
      PurchaseHeader.VALIDATE("Posting Date",PostingDate);
      PurchaseHeader.VALIDATE("Currency Code",CurrencyCode);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,No,Quantity);
      PurchaseLine.VALIDATE("Direct Unit Cost",DirectUnitCost);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndPostSalesOrderWithCurrency@135(VAR SalesLine@1000 : Record 37;CustomerNo@1001 : Code[20]) : Code[10];
    VAR
      SalesHeader@1002 : Record 36;
      Currency@1003 : Record 4;
    BEGIN
      // Create Sales Header with currency.
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CustomerNo);
      CreateCurrencyWithExchangeRate(Currency);
      UpdateSalesHeader(SalesHeader,Currency.Code);

      // Create Sales Line with G/L Account and random quantity and unit price.
      LibrarySales.CreateSalesLine(
        SalesLine,SalesHeader,SalesLine.Type::"G/L Account",CreateGLAccount,LibraryRandom.RandInt(100));
      UpdateSalesLine(SalesLine,LibraryRandom.RandInt(100));

      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      EXIT(Currency.Code);
    END;

    LOCAL PROCEDURE CreateAndPostSalesDocument@54(CustomerNo@1003 : Code[20];ItemNo@1001 : Code[20];Quantity@1002 : Decimal;Ship@1005 : Boolean;Invoice@1006 : Boolean) : Code[20];
    VAR
      SalesHeader@1000 : Record 36;
      SalesLine@1004 : Record 37;
    BEGIN
      CreateSalesDocument(SalesHeader,SalesHeader."Document Type"::Order,SalesLine.Type::Item,CustomerNo,ItemNo,Quantity);
      EXIT(LibrarySales.PostSalesDocument(SalesHeader,Ship,Invoice));
    END;

    LOCAL PROCEDURE CreateAndPostRevaluationJournal@22(ItemNo@1000 : Code[20];NewPostingDate@1002 : Date;CalculatePer@1004 : Option;RevalueFactor@1008 : Integer) : Decimal;
    VAR
      Item@1003 : Record 27;
      ItemJournalBatch@1005 : Record 233;
      ItemJournalLine@1001 : Record 83;
      ItemJournalTemplate@1007 : Record 82;
      CalcBase@1006 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
    BEGIN
      SelectAndClearItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Type::Revaluation);
      Item.SETRANGE("No.",ItemNo);
      LibraryCosting.CreateRevaluationJournal(
        ItemJournalBatch,Item,NewPostingDate,LibraryUtility.GenerateGUID,CalculatePer,FALSE,FALSE,FALSE,CalcBase::" ",FALSE);
      ItemJournalLine.SETRANGE("Item No.",ItemNo);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE("Unit Cost (Revalued)",RevalueFactor * ItemJournalLine."Unit Cost (Calculated)");
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      EXIT(ItemJournalLine."Unit Cost (Revalued)" - ItemJournalLine."Unit Cost (Calculated)");
    END;

    LOCAL PROCEDURE CreateAndPostWarehouseReceiptFromPO@39(PurchaseLine@1000 : Record 39);
    VAR
      PurchaseHeader@1001 : Record 38;
      WarehouseReceiptHeader@1002 : Record 7316;
      WarehouseReceiptLine@1003 : Record 7317;
    BEGIN
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      LibraryPurchase.ReleasePurchaseDocument(PurchaseHeader);
      LibraryWarehouse.CreateWhseReceiptFromPO(PurchaseHeader);
      FindWarehouseReceiptLine(WarehouseReceiptLine,PurchaseHeader."No.",WarehouseReceiptLine."Source Document"::"Purchase Order");
      WarehouseReceiptHeader.GET(WarehouseReceiptLine."No.");
      LibraryWarehouse.PostWhseReceipt(WarehouseReceiptHeader);
    END;

    LOCAL PROCEDURE CreateAndPostWhseRcptFromSalesReturn@87(SalesLine@1000 : Record 37);
    VAR
      SalesHeader@1001 : Record 36;
      WarehouseReceiptHeader@1002 : Record 7316;
      WarehouseReceiptLine@1003 : Record 7317;
    BEGIN
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");
      LibrarySales.ReleaseSalesDocument(SalesHeader);
      LibraryWarehouse.CreateWhseReceiptFromSalesReturnOrder(SalesHeader);
      FindWarehouseReceiptLine(WarehouseReceiptLine,SalesHeader."No.",WarehouseReceiptLine."Source Document"::"Sales Return Order");
      WarehouseReceiptHeader.GET(WarehouseReceiptLine."No.");
      LibraryWarehouse.PostWhseReceipt(WarehouseReceiptHeader);
    END;

    LOCAL PROCEDURE CreateAndRefreshProductionOrder@49(VAR ProductionOrder@1002 : Record 5405;SourceNo@1001 : Code[20]);
    BEGIN
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,SourceNo,
        LibraryRandom.RandDec(10,2));  // Use Random Quantity.
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateAndShipSalesDocument@69(VAR SalesLine@1004 : Record 37;DocumentType@1002 : Option;Type@1003 : Option;ItemNo@1001 : Code[20];QuantityFactor@1005 : Integer);
    VAR
      SalesHeader@1000 : Record 36;
    BEGIN
      CreateSalesDocument(SalesHeader,DocumentType,Type,CreateCustomer,ItemNo,(LibraryRandom.RandDec(10,2) * QuantityFactor));  // Use Random Quantity.
      FindSalesLine(SalesLine,SalesHeader);
      SalesLine.VALIDATE("Unit Price",LibraryRandom.RandDec(10,2));  // Using Random value for Unit Price.
      SalesLine.MODIFY(TRUE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateAndUpdatePurchaseDocument@100(VAR PurchaseLine@1000 : Record 39;DocumentType@1006 : Option;Type@1007 : Option;DirectUnitCost@1003 : Decimal;Quantity@1005 : Decimal;QtyToReceive@1002 : Decimal;ItemNo@1004 : Code[20];LocationCode@1001 : Code[10]);
    BEGIN
      CreatePurchaseDocument(PurchaseLine,DocumentType,Type,CreateVendor,ItemNo,Quantity);
      UpdatePurchaseLine(PurchaseLine,DirectUnitCost,QtyToReceive,LocationCode);
    END;

    LOCAL PROCEDURE CreateAndUpdateCustomer@124(CurrencyCode@1000 : Code[10]) : Code[20];
    VAR
      Customer@1001 : Record 18;
    BEGIN
      Customer.GET(CreateCustomer);
      Customer.VALIDATE("Currency Code",CurrencyCode);
      Customer.MODIFY(TRUE);
      EXIT(Customer."No.");
    END;

    LOCAL PROCEDURE CreateCurrencyWithExchangeRate@29(VAR Currency@1001 : Record 4);
    VAR
      GLAccount@1002 : Record 15;
    BEGIN
      LibraryERM.FindGLAccount(GLAccount);
      LibraryERM.CreateCurrency(Currency);
      Currency.VALIDATE("Residual Gains Account",GLAccount."No.");
      Currency.VALIDATE("Residual Losses Account",GLAccount."No.");
      Currency.MODIFY(TRUE);
      LibraryERM.CreateRandomExchangeRate(Currency.Code);
    END;

    LOCAL PROCEDURE CreateCurrencyWithExchangeRate1@112(VAR Currency@1001 : Record 4;VAR CurrencyExchangeRate@1000 : Record 330);
    VAR
      GLAccount@1002 : Record 15;
    BEGIN
      LibraryERM.FindGLAccount(GLAccount);
      LibraryERM.CreateCurrency(Currency);
      Currency.VALIDATE("Residual Gains Account",GLAccount."No.");
      Currency.VALIDATE("Residual Losses Account",GLAccount."No.");
      Currency.MODIFY(TRUE);
      LibraryERM.CreateExchRate(CurrencyExchangeRate,Currency.Code,WORKDATE);
      CurrencyExchangeRate.VALIDATE("Exchange Rate Amount",LibraryRandom.RandInt(100));
      CurrencyExchangeRate.VALIDATE("Adjustment Exch. Rate Amount",CurrencyExchangeRate."Exchange Rate Amount");
      CurrencyExchangeRate.VALIDATE("Relational Exch. Rate Amount",CurrencyExchangeRate."Exchange Rate Amount");
      CurrencyExchangeRate.VALIDATE("Relational Adjmt Exch Rate Amt",CurrencyExchangeRate."Exchange Rate Amount");
      CurrencyExchangeRate.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateCurrencyWithMultipleExchangeRates@166(VAR Currency@1001 : Record 4;VAR CurrencyExchangeRate@1000 : Record 330);
    BEGIN
      CreateCurrencyWithExchangeRate1(Currency,CurrencyExchangeRate);
      CreateExchangeRateForCurrency(Currency.Code,CALCDATE('<' + FORMAT(LibraryRandom.RandInt(5)) + 'D>',WORKDATE));

      // Make sure report Adjust Add. Reporting Currency can be run successfully. Since there're some demo entries posted in earlier years.
      CreateExchangeRateForCurrency(
        Currency.Code,CALCDATE('<-' + FORMAT(LibraryRandom.RandIntInRange(20,25)) + 'Y>',WORKDATE));
    END;

    LOCAL PROCEDURE CreateCustomer@13() : Code[20];
    VAR
      Customer@1000 : Record 18;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      EXIT(Customer."No.");
    END;

    LOCAL PROCEDURE CreateItem@95(IndirectCostPct@1002 : Decimal;CostingMethod@1003 : Option) : Code[20];
    VAR
      Item@1000 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Costing Method",CostingMethod);
      Item.VALIDATE("Unit Price",LibraryRandom.RandDec(10,2));  // Using Random value for Unit Price.
      Item.VALIDATE("Unit Cost",Item."Unit Price");
      Item.VALIDATE("Indirect Cost %",IndirectCostPct);
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateLocation@38(VAR Location@1000 : Record 14);
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      Location.VALIDATE("Require Put-away",TRUE);
      Location.VALIDATE("Require Pick",TRUE);
      Location.VALIDATE("Require Receive",TRUE);
      Location.VALIDATE("Require Shipment",TRUE);
      Location.MODIFY(TRUE);
      CreateWarehouseEmployee(Location.Code);
    END;

    LOCAL PROCEDURE CreatePickAndRegisterWhseShipment@123(VAR WarehouseShipmentHeader@1005 : Record 7320;DocumentNo@1003 : Code[20];LocationCode@1001 : Code[10];Sales@1000 : Boolean);
    VAR
      WarehouseActivityLine@1004 : Record 5767;
    BEGIN
      IF Sales THEN
        CreateWarehouseShipmentFromSO(DocumentNo)
      ELSE
        CreateWarehouseShipment(DocumentNo);
      FindWarehouseShipmentHeader(WarehouseShipmentHeader,LocationCode);
      LibraryWarehouse.CreatePick(WarehouseShipmentHeader);
      RegisterWarehouseActivity(DocumentNo,WarehouseActivityLine."Activity Type"::Pick);
      LibraryWarehouse.PostWhseShipment(WarehouseShipmentHeader,FALSE);
    END;

    LOCAL PROCEDURE CreatePurchaseDocument@15(VAR PurchaseLine@1001 : Record 39;DocumentType@1005 : Option;Type@1002 : Option;BuyFromVendorNo@1006 : Code[20];No@1003 : Code[20];Quantity@1004 : Decimal);
    VAR
      PurchaseHeader@1000 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,DocumentType,BuyFromVendorNo);
      UpdatePurchaseHeader(PurchaseHeader);  // Update Vendor Invoice and Vendor Credit Memo No.
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,Type,No,Quantity);
    END;

    LOCAL PROCEDURE CreatePurchaseDocumentWithWhseLocation@57(VAR PurchaseLine@1001 : Record 39;DocumentType@1000 : Option);
    VAR
      Item@1003 : Record 27;
      Location@1002 : Record 14;
    BEGIN
      CreateLocation(Location);
      CreatePurchaseDocument(
        PurchaseLine,DocumentType,PurchaseLine.Type::Item,CreateVendor,
        CreateItem(LibraryRandom.RandDec(100,1),Item."Costing Method"::FIFO),LibraryRandom.RandDec(50,1));  // Use Random value.
      UpdatePurchaseLine(PurchaseLine,0,0,Location.Code);  // Used 0 for Direct Unit Cost and Quantity to Receive.
    END;

    LOCAL PROCEDURE CreateSalesDocument@9(VAR SalesHeader@1003 : Record 36;DocumentType@1001 : Option;Type@1004 : Option;SellToCustomerNo@1002 : Code[20];ItemNo@1000 : Code[20];Quantity@1008 : Decimal);
    VAR
      SalesLine@1006 : Record 37;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,DocumentType,SellToCustomerNo);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,Type,ItemNo,Quantity);
    END;

    LOCAL PROCEDURE CreateSalesDocumentAndReserve@74(VAR SalesLine@1004 : Record 37;ItemNo@1000 : Code[20];Quantity@1001 : Decimal);
    VAR
      SalesHeader@1002 : Record 36;
    BEGIN
      CreateSalesDocument(SalesHeader,SalesHeader."Document Type"::Order,SalesLine.Type::Item,CreateCustomer,ItemNo,Quantity);
      FindSalesLine(SalesLine,SalesHeader);
      LibrarySales.AutoReserveSalesLine(SalesLine);
    END;

    LOCAL PROCEDURE CreateSalesDocumentWithLocation@67(VAR SalesHeader@1004 : Record 36;DocumentType@1003 : Option;ItemNo@1001 : Code[20];LocationCode@1002 : Code[10];Quantity@1005 : Decimal);
    VAR
      SalesLine@1000 : Record 37;
    BEGIN
      LibraryVariableStorage.Enqueue(ChangeLocationMessage);  // Enqueue ConfirmHandler.
      CreateSalesDocument(SalesHeader,DocumentType,SalesLine.Type::Item,CreateCustomer,ItemNo,Quantity);  // Use Random value.
      SalesHeader.VALIDATE("Location Code",LocationCode);
      SalesHeader.MODIFY(TRUE);
      UpdateLocationCodeOnSalesLine(SalesHeader,LocationCode);
    END;

    LOCAL PROCEDURE CreateTransferOrder@7(VAR TransferHeader@1000 : Record 5740;FromLocation@1002 : Code[10];ItemNo@1005 : Code[20];Quantity@1006 : Decimal);
    VAR
      InTransitLocation@1004 : Record 14;
      ToLocation@1003 : Record 14;
      TransferLine@1001 : Record 5741;
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(ToLocation);
      LibraryWarehouse.CreateInTransitLocation(InTransitLocation);
      LibraryWarehouse.CreateTransferHeader(TransferHeader,FromLocation,ToLocation.Code,InTransitLocation.Code);
      LibraryWarehouse.CreateTransferLine(TransferHeader,TransferLine,ItemNo,Quantity)
    END;

    LOCAL PROCEDURE CreateVendor@85() : Code[20];
    VAR
      Vendor@1000 : Record 23;
    BEGIN
      LibraryPurchase.CreateVendor(Vendor);
      EXIT(Vendor."No.");
    END;

    LOCAL PROCEDURE CreateGLAccount@136() : Code[20];
    VAR
      VATPostingSetup@1000 : Record 325;
      GLAccount@1001 : Record 15;
    BEGIN
      LibraryERM.FindVATPostingSetup(VATPostingSetup,VATPostingSetup."VAT Calculation Type"::"Normal VAT");
      EXIT(LibraryERM.CreateGLAccountWithVATPostingSetup(VATPostingSetup,GLAccount."Gen. Posting Type"::Sale));
    END;

    LOCAL PROCEDURE CreateWarehouseEmployee@143(LocationCode@1000 : Code[10]);
    VAR
      WarehouseEmployee@1001 : Record 7301;
    BEGIN
      WarehouseEmployee.DELETEALL;
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,LocationCode,TRUE);
    END;

    LOCAL PROCEDURE CreateWarehouseLocation@116(VAR Location@1000 : Record 14);
    BEGIN
      LibraryWarehouse.CreateFullWMSLocation(Location,2);
      Location.VALIDATE("Always Create Pick Line",TRUE);
      Location.MODIFY(TRUE);
      CreateWarehouseEmployee(Location.Code)
    END;

    LOCAL PROCEDURE CreateWarehouseShipment@99(DocumentNo@1001 : Code[20]);
    VAR
      PurchaseHeader@1003 : Record 38;
    BEGIN
      PurchaseHeader.GET(PurchaseHeader."Document Type"::"Return Order",DocumentNo);
      LibraryPurchase.ReleasePurchaseDocument(PurchaseHeader);
      LibraryWarehouse.CreateWhseShipmentFromPurchaseReturnOrder(PurchaseHeader);
    END;

    LOCAL PROCEDURE CreateWarehouseShipmentFromSO@86(DocumentNo@1001 : Code[20]);
    VAR
      SalesHeader@1003 : Record 36;
    BEGIN
      SalesHeader.GET(SalesHeader."Document Type"::Order,DocumentNo);
      LibrarySales.ReleaseSalesDocument(SalesHeader);
      LibraryWarehouse.CreateWhseShipmentFromSO(SalesHeader);
    END;

    LOCAL PROCEDURE CreateAssemblyBomComponent@105(VAR BomComponent@1000 : Record 90;ParentItemNo@1001 : Code[20]);
    VAR
      Item@1003 : Record 27;
      RecRef@1002 : RecordRef;
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(10,2));
      Item.MODIFY(TRUE);

      WITH BomComponent DO BEGIN
        INIT;
        VALIDATE("Parent Item No.",ParentItemNo);
        RecRef.GETTABLE(BomComponent);
        VALIDATE("Line No.",LibraryUtility.GetNewLineNo(RecRef,FIELDNO("Line No.")));
        VALIDATE(Type,Type::Item);
        VALIDATE("No.",Item."No.");
        VALIDATE("Quantity per",LibraryRandom.RandInt(10));
        INSERT(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateAssemblyItemWithBOM@101(VAR AssemblyItem@1000 : Record 27;VAR BomComponent@1001 : Record 90;VAR BomComponent2@1002 : Record 90;AssemblyPolicy@1003 : Option);
    BEGIN
      LibraryInventory.CreateItem(AssemblyItem);
      AssemblyItem.VALIDATE("Replenishment System",AssemblyItem."Replenishment System"::Assembly);
      AssemblyItem.VALIDATE("Assembly Policy",AssemblyPolicy);
      AssemblyItem.MODIFY(TRUE);

      // Create Component Item and set as Assembly BOM
      CreateAssemblyBomComponent(BomComponent,AssemblyItem."No.");
      CreateAssemblyBomComponent(BomComponent2,AssemblyItem."No.");
      COMMIT; // Save the BOM Component record created above
    END;

    LOCAL PROCEDURE CreateAssemblyItemWithBOMForPlanning@113(VAR AssemblyItem@1000 : Record 27;QtyPer@1001 : Decimal) ItemNo : Code[20];
    BEGIN
      LibraryInventory.CreateItem(AssemblyItem);
      UpdateItemParametersForPlanning(
        AssemblyItem,AssemblyItem."Replenishment System"::Assembly,AssemblyItem."Reordering Policy"::"Lot-for-Lot",TRUE);
      ItemNo := CreateBOMComponentItem(AssemblyItem."No.",QtyPer);
    END;

    LOCAL PROCEDURE CreateBOMComponentItem@139(AssemblyItemNo@1002 : Code[20];QtyPer@1003 : Decimal) : Code[20];
    VAR
      ComponentItem@1000 : Record 27;
      BOMComponent@1001 : Record 90;
    BEGIN
      LibraryInventory.CreateItem(ComponentItem);
      UpdateItemParametersForPlanning(
        ComponentItem,ComponentItem."Replenishment System"::Purchase,ComponentItem."Reordering Policy"::"Lot-for-Lot",FALSE);
      LibraryManufacturing.CreateBOMComponent(BOMComponent,AssemblyItemNo,BOMComponent.Type::Item,ComponentItem."No.",QtyPer,'');
      EXIT(ComponentItem."No.");
    END;

    LOCAL PROCEDURE CreateExchangeRateForCurrency@141(CurrencyCode@1000 : Code[10];StartingDate@1002 : Date);
    VAR
      CurrencyExchangeRate@1001 : Record 330;
    BEGIN
      LibraryERM.CreateExchRate(CurrencyExchangeRate,CurrencyCode,StartingDate);
      WITH CurrencyExchangeRate DO BEGIN
        VALIDATE("Exchange Rate Amount",LibraryRandom.RandDec(10,2));
        VALIDATE("Relational Exch. Rate Amount",LibraryRandom.RandDec(10,2));
        VALIDATE("Adjustment Exch. Rate Amount","Exchange Rate Amount");
        VALIDATE("Relational Adjmt Exch Rate Amt","Relational Exch. Rate Amount");
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CalculateRevaluedCostAmount@138(VAR PurchaseLine@1000 : Record 39;VAR CurrencyExchangeRate@1002 : Record 330;RevaluedFactor@1001 : Integer) : Decimal;
    BEGIN
      EXIT(PurchaseLine."Direct Unit Cost" * RevaluedFactor * PurchaseLine.Quantity *
        CurrencyExchangeRate."Exchange Rate Amount" / CurrencyExchangeRate."Relational Exch. Rate Amount");
    END;

    LOCAL PROCEDURE AssignItemChargeToSalesShptLines@155(VAR PurchaseLine@1003 : Record 39;PurchaseDocumentType@1004 : Option;SalesDocumentNo@1000 : Code[20]);
    BEGIN
      LibraryVariableStorage.Enqueue(SalesDocumentNo); // Enqueue value for SalesShipmentLinePageHandler.
      LibraryVariableStorage.Enqueue(2); // Select Amount when suggest item charge.

      PurchaseDocumentItemChargeAssignByGetSalesShipmentLines(PurchaseLine,PurchaseDocumentType,CreateVendor);
    END;

    LOCAL PROCEDURE FindItemLedgerEntry@18(VAR ItemLedgerEntry@1000 : Record 32;DocumentNo@1001 : Code[20];EntryType@1002 : Option);
    BEGIN
      ItemLedgerEntry.SETRANGE("Document No.",DocumentNo);
      ItemLedgerEntry.SETRANGE("Entry Type",EntryType);
      ItemLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindPurchasingCode@68() : Code[10];
    VAR
      Purchasing@1000 : Record 5721;
    BEGIN
      Purchasing.SETRANGE("Drop Shipment",TRUE);
      Purchasing.FINDFIRST;
      EXIT(Purchasing.Code);
    END;

    LOCAL PROCEDURE FindReceiptLine@31(VAR PurchRcptLine@1000 : Record 121;No@1001 : Code[20]);
    BEGIN
      PurchRcptLine.SETRANGE("No.",No);
      PurchRcptLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindReturnReceiptLine@81(VAR ReturnReceiptLine@1000 : Record 6661;SalesLine@1001 : Record 37);
    BEGIN
      ReturnReceiptLine.SETRANGE("Return Order No.",SalesLine."Document No.");
      ReturnReceiptLine.SETRANGE("No.",SalesLine."No.");
      ReturnReceiptLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindReturnShipmentLine@47(VAR ReturnShipmentLine@1000 : Record 6651;PurchaseLine@1002 : Record 39);
    BEGIN
      ReturnShipmentLine.SETRANGE("No.",PurchaseLine."No.");
      ReturnShipmentLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindRequisitionLine@122(VAR RequisitionLine@1000 : Record 246;No@1001 : Code[20]);
    BEGIN
      WITH RequisitionLine DO BEGIN
        SETRANGE(Type,Type::Item);
        SETRANGE("No.",No);
        FINDFIRST;
      END
    END;

    LOCAL PROCEDURE FindSalesLine@60(VAR SalesLine@1001 : Record 37;SalesHeader@1000 : Record 36);
    BEGIN
      SalesLine.SETRANGE("Document Type",SalesHeader."Document Type");
      SalesLine.SETRANGE("Document No.",SalesHeader."No.");
      SalesLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindShipmentLine@75(VAR SalesShipmentLine@1000 : Record 111;No@1001 : Code[20]);
    BEGIN
      SalesShipmentLine.SETRANGE("No.",No);
      SalesShipmentLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindTransferReceiptHeader@6(TransferFromCode@1000 : Code[10];TransferToCode@1002 : Code[10]) : Code[20];
    VAR
      TransferReceiptHeader@1001 : Record 5746;
    BEGIN
      TransferReceiptHeader.SETRANGE("Transfer-from Code",TransferFromCode);
      TransferReceiptHeader.SETRANGE("Transfer-to Code",TransferToCode);
      TransferReceiptHeader.FINDFIRST;
      EXIT(TransferReceiptHeader."No.");
    END;

    LOCAL PROCEDURE FindTransferShipmentHeader@5(TransferFromCode@1002 : Code[10];TransferToCode@1001 : Code[10]) : Code[20];
    VAR
      TransferShipmentHeader@1000 : Record 5744;
    BEGIN
      TransferShipmentHeader.SETRANGE("Transfer-from Code",TransferFromCode);
      TransferShipmentHeader.SETRANGE("Transfer-to Code",TransferToCode);
      TransferShipmentHeader.FINDFIRST;
      EXIT(TransferShipmentHeader."No.");
    END;

    LOCAL PROCEDURE FindValueEntry@33(VAR ValueEntry@1001 : Record 5802;DocumentNo@1000 : Code[20];ItemChargeNo@1004 : Code[20];LocationCode@1003 : Code[10];Adjustment@1002 : Boolean);
    BEGIN
      ValueEntry.SETRANGE("Document No.",DocumentNo);
      ValueEntry.SETRANGE("Item Charge No.",ItemChargeNo);
      ValueEntry.SETRANGE(Adjustment,Adjustment);
      ValueEntry.SETRANGE("Location Code",LocationCode);
      ValueEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindWarehouseActivityLine@50(VAR WarehouseActivityLine@1000 : Record 5767;SourceNo@1002 : Code[20];ActivityType@1003 : Option);
    BEGIN
      WarehouseActivityLine.SETRANGE("Source No.",SourceNo);
      WarehouseActivityLine.SETRANGE("Activity Type",ActivityType);
      WarehouseActivityLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindWarehouseReceiptLine@93(VAR WarehouseReceiptLine@1000 : Record 7317;SourceNo@1001 : Code[20];SourceDocument@1002 : Option);
    BEGIN
      WarehouseReceiptLine.SETRANGE("Source Document",SourceDocument);
      WarehouseReceiptLine.SETRANGE("Source No.",SourceNo);
      WarehouseReceiptLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindWarehouseShipmentHeader@91(VAR WarehouseShipmentHeader@1000 : Record 7320;LocationCode@1001 : Code[10]);
    BEGIN
      WarehouseShipmentHeader.SETRANGE("Location Code",LocationCode);
      WarehouseShipmentHeader.FINDFIRST;
    END;

    LOCAL PROCEDURE GetDropShptFromPurchaseOrder@78(SelltoCustomerNo@1000 : Code[20]);
    VAR
      PurchaseHeader@1001 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,CreateVendor);
      PurchaseHeader.VALIDATE("Sell-to Customer No.",SelltoCustomerNo);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.GetDropShipment(PurchaseHeader);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);
    END;

    LOCAL PROCEDURE ModifyQtyToInvoiceOnSalesLine@17(SalesHeader@1001 : Record 36;QtyToInvoice@1002 : Decimal);
    VAR
      SalesLine@1000 : Record 37;
    BEGIN
      FindSalesLine(SalesLine,SalesHeader);
      SalesLine.VALIDATE("Qty. to Invoice",QtyToInvoice);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE PostPurchaseDocument@3(PurchaseLine@1000 : Record 39;Invoice@1002 : Boolean) : Code[20];
    VAR
      PurchaseHeader@1001 : Record 38;
    BEGIN
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      EXIT(LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,Invoice));
    END;

    LOCAL PROCEDURE PostPurchaseOrderAndRevaluationJournal@169(VAR PurchaseLine@1001 : Record 39;Invoice@1002 : Boolean;RevaluedFactor@1008 : Integer) UnitCostRevaluated : Decimal;
    VAR
      Item@1000 : Record 27;
      CalculatePer@1004 : 'Item Ledger Entry,Item';
      Quantity@1003 : Decimal;
    BEGIN
      // Create and post Purchase Order.
      Item.GET(CreateItem(0,Item."Costing Method"::Standard)); // Use 0 for Indirect Cost Pct.
      Quantity := LibraryRandom.RandInt(10);
      CreateAndUpdatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::Item,Item."Unit Cost",Quantity,Quantity,Item."No.",'');
      PostPurchaseDocument(PurchaseLine,Invoice);

      // Run Adjust Cost Item Entries. Create and post Revaluation Journal with new Unit Cost (Revalued).
      LibraryCosting.AdjustCostItemEntries(PurchaseLine."No.",'');
      UnitCostRevaluated := CreateAndPostRevaluationJournal(
          PurchaseLine."No.",CALCDATE('<' + FORMAT(LibraryRandom.RandInt(5)) + 'M>',WORKDATE),
          CalculatePer::Item,RevaluedFactor);
    END;

    LOCAL PROCEDURE PurchaseApplication@70(VAR PurchaseLine@1000 : Record 39;DocumentType@1002 : Option;Quantity@1003 : Decimal);
    VAR
      SalesHeader@1001 : Record 36;
    BEGIN
      // Create Purchase Document and Post.
      CreateAndPostPurchaseDocument(PurchaseLine,DocumentType,PurchaseLine.Type::Item,Quantity,FALSE);

      // Create Sales Order and Ship and Invoice Sales Order.
      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::Order,PurchaseLine.Type::Item,CreateCustomer,PurchaseLine."No.",
        ABS(PurchaseLine.Quantity));
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE PurchaseDocumentWithItemChargeAssignment@43(VAR PurchaseLine@1000 : Record 39;Invoice@1005 : Boolean);
    VAR
      PurchaseHeader@1003 : Record 38;
      PurchaseLine2@1004 : Record 39;
      PurchRcptLine@1002 : Record 121;
      ItemChargeAssignmentPurch@1006 : Record 5805;
    BEGIN
      // Create Purchase Order, Post.
      CreateAndPostPurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::Item,LibraryRandom.RandDec(50,1),FALSE);  // Use Random value.

      // Create Purchase Invoice for Item Charge without Currency and assign to previous posted Receipt.
      FindReceiptLine(PurchRcptLine,PurchaseLine."No.");
      PurchaseInvoiceItemChargeAssign(
        PurchaseLine2,PurchaseLine."Document Type"::Invoice,PurchRcptLine."Buy-from Vendor No.",
        ItemChargeAssignmentPurch."Applies-to Doc. Type"::Receipt,PurchRcptLine."Document No.",PurchRcptLine."No.",'');  // Use blank for Currency Code.
      IF Invoice THEN BEGIN
        PurchaseHeader.GET(PurchaseLine2."Document Type",PurchaseLine2."Document No.");
        LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE);
      END;
      LibraryVariableStorage.Enqueue(UndoReceiptMessage);  // Enqueue value for ConfirmHandler.
    END;

    LOCAL PROCEDURE PurchaseInvoiceItemChargeAssign@45(VAR PurchaseLine@1005 : Record 39;DocumentType@1008 : Option;BuyFromVendorNo@1003 : Code[20];AppliestoDocType@1004 : Option;DocumentNo@1006 : Code[20];ItemNo@1007 : Code[20];CurrencyCode@1009 : Code[10]);
    VAR
      ItemChargeAssignmentPurch@1000 : Record 5805;
      PurchaseHeader@1002 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,DocumentType,BuyFromVendorNo);
      PurchaseHeader.VALIDATE("Currency Code",CurrencyCode);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.CreatePurchaseLine(
        PurchaseLine,PurchaseHeader,PurchaseLine.Type::"Charge (Item)",LibraryInventory.CreateItemChargeNo,1);  // 1 for Charge Item Quantity.
      PurchaseLine.VALIDATE("Direct Unit Cost",LibraryRandom.RandDec(10,2));  // Use Random value.
      PurchaseLine.MODIFY(TRUE);
      LibraryInventory.CreateItemChargeAssignPurchase(
        ItemChargeAssignmentPurch,PurchaseLine,AppliestoDocType,DocumentNo,PurchaseLine."Line No.",ItemNo);
    END;

    LOCAL PROCEDURE PurchaseDocumentItemChargeAssignByGetSalesShipmentLines@121(VAR PurchaseLine@1005 : Record 39;DocumentType@1008 : Option;BuyFromVendorNo@1003 : Code[20]);
    VAR
      PurchaseHeader@1002 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,DocumentType,BuyFromVendorNo);
      LibraryPurchase.CreatePurchaseLine(
        PurchaseLine,PurchaseHeader,PurchaseLine.Type::"Charge (Item)",
        LibraryInventory.CreateItemChargeNo,LibraryRandom.RandInt(5));
      PurchaseLine.VALIDATE("Direct Unit Cost",LibraryRandom.RandDec(10,2)); // Use Random value.
      PurchaseLine.MODIFY(TRUE);
      PurchaseLine.ShowItemChargeAssgnt; // Trigger the PurchItemChargeAssignmentHandler.
    END;

    LOCAL PROCEDURE PurchaseReturnWithItemChargeAssignment@125(VAR PurchaseLine@1000 : Record 39;CrMemo@1001 : Boolean);
    VAR
      PurchaseLine2@1005 : Record 39;
      PurchaseHeader@1004 : Record 38;
      ReturnShipmentLine@1003 : Record 6651;
      ItemChargeAssignmentPurch@1002 : Record 5805;
    BEGIN
      // Create Purchase Return Order and Post.
      CreateAndPostPurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::"Return Order",PurchaseLine.Type::Item,LibraryRandom.RandDec(50,1),FALSE);  // Use Random value.

      // Create Purchase Credit Memo for Item Charge without Currency and assign to previous posted Receipt.
      FindReturnShipmentLine(ReturnShipmentLine,PurchaseLine);
      PurchaseInvoiceItemChargeAssign(
        PurchaseLine2,PurchaseLine."Document Type"::"Credit Memo",ReturnShipmentLine."Buy-from Vendor No.",
        ItemChargeAssignmentPurch."Applies-to Doc. Type"::"Return Shipment",ReturnShipmentLine."Document No.",
        ReturnShipmentLine."No.",'');
      IF CrMemo THEN BEGIN
        PurchaseHeader.GET(PurchaseLine2."Document Type",PurchaseLine2."Document No.");
        UpdatePurchaseHeader(PurchaseHeader);
        LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      END;
      LibraryVariableStorage.Enqueue(UndoPurchRetOrderMessage);  // Enqueue value for ConfirmHandler.
    END;

    LOCAL PROCEDURE PurchaseWhseRcptAndRegister@80(VAR PurchaseLine@1000 : Record 39);
    VAR
      Item@1003 : Record 27;
      Location@1002 : Record 14;
      WarehouseActivityLine@1001 : Record 5767;
    BEGIN
      // Create Purchase Order with Warehouse Location.
      CreateWarehouseLocation(Location);
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::Item,CreateVendor,
        CreateItem(LibraryRandom.RandDec(100,1),Item."Costing Method"::FIFO),LibraryRandom.RandDec(50,1));  // Use Random value.
      UpdatePurchaseLine(PurchaseLine,0,0,Location.Code);

      // Create Warehouse Receipt and Register.
      CreateAndPostWarehouseReceiptFromPO(PurchaseLine);
      RegisterWarehouseActivity(PurchaseLine."Document No.",WarehouseActivityLine."Activity Type"::"Put-away");
    END;

    LOCAL PROCEDURE RegisterWarehouseActivity@142(SourceNo@1001 : Code[20];ActivityType@1003 : Option);
    VAR
      WarehouseActivityHeader@1002 : Record 5766;
      WarehouseActivityLine@1000 : Record 5767;
    BEGIN
      FindWarehouseActivityLine(WarehouseActivityLine,SourceNo,ActivityType);
      WarehouseActivityHeader.GET(WarehouseActivityLine."Activity Type",WarehouseActivityLine."No.");
      LibraryWarehouse.RegisterWhseActivity(WarehouseActivityHeader);
    END;

    LOCAL PROCEDURE RevaluateInventoryAndRunAdjustCostItemEntries@27(ItemNo@1000 : Code[20];CalculatePer@1006 : Option) CostAmountActual : Decimal;
    VAR
      Customer@1002 : Record 18;
      PurchaseLine@1001 : Record 39;
      SalesHeader@1003 : Record 36;
      UnitCostRevaluated@1007 : Decimal;
      Quantity@1009 : Decimal;
    BEGIN
      // Create Item and Post Purchase Order.
      Quantity := LibraryRandom.RandDec(100,2);  // Use Random value.
      CreateAndUpdatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,PurchaseLine.Type::Item,LibraryRandom.RandDec(100,2),Quantity,
        Quantity,ItemNo,'');  // Blank value for Location and Random for Direct Unit Cost.
      PostPurchaseDocument(PurchaseLine,TRUE);

      // Invoice partial Sales Order.
      Customer.GET(CreateCustomer);
      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::Order,PurchaseLine.Type::Item,Customer."No.",ItemNo,PurchaseLine.Quantity / 2);
      ModifyQtyToInvoiceOnSalesLine(SalesHeader,PurchaseLine.Quantity / 3);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Calculate Inventory and post Revaluation Journal.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');
      UnitCostRevaluated := CreateAndPostRevaluationJournal(ItemNo,WORKDATE,CalculatePer,LibraryRandom.RandIntInRange(2,5));
      CostAmountActual := ROUND((PurchaseLine.Quantity / 2) * UnitCostRevaluated);

      // Create and Post another Sales Order. Invoice the remaining Quantity of first Sales Order.
      CreateAndPostSalesDocument(Customer."No.",ItemNo,PurchaseLine.Quantity / 2,TRUE,TRUE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Exercise: Run Adjust Cost - Item Entries.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');
    END;

    LOCAL PROCEDURE RunBOMCostSharesPage@209(VAR Item@1000 : Record 27);
    VAR
      BOMCostShares@1001 : Page 5872;
    BEGIN
      BOMCostShares.InitItem(Item);
      BOMCostShares.RUN;
    END;

    LOCAL PROCEDURE SalesOrderUpdatedWithDropShipment@77(VAR SalesLine@1001 : Record 37);
    VAR
      SalesHeader@1000 : Record 36;
      Item@1002 : Record 27;
    BEGIN
      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::Order,SalesLine.Type::Item,CreateCustomer,CreateItem(0,Item."Costing Method"::FIFO),
        LibraryRandom.RandDec(50,1));
      FindSalesLine(SalesLine,SalesHeader);
      SalesLine.VALIDATE("Drop Shipment",TRUE);
      SalesLine.VALIDATE("Purchasing Code",FindPurchasingCode);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE SalesDocumentWithItemChargeAssignment@156() : Code[20];
    VAR
      PurchaseHeader@1003 : Record 38;
      PurchaseLine@1000 : Record 39;
      Item@1007 : Record 27;
      DocumentNo@1001 : Code[20];
    BEGIN
      DocumentNo := CreateAndPostSalesDocument(
          CreateCustomer,CreateItem(0,Item."Costing Method"::FIFO),LibraryRandom.RandDec(10,2),TRUE,FALSE);

      AssignItemChargeToSalesShptLines(PurchaseLine,PurchaseLine."Document Type"::Invoice,DocumentNo);

      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      EXIT(LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE));
    END;

    LOCAL PROCEDURE SelectAndClearItemJournalBatch@21(VAR ItemJournalBatch@1001 : Record 233;Type@1002 : Option);
    VAR
      ItemJournalTemplate@1000 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,Type);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalBatch."Template Type"::Item,ItemJournalTemplate.Name);
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
    END;

    LOCAL PROCEDURE SetupForAdjustCostOnACY@225(VAR SalesHeader@1004 : Record 36;ItemNo@1006 : Code[20];CurrencyCode@1008 : Code[10]);
    VAR
      SalesHeader2@1005 : Record 36;
      SalesLine@1001 : Record 37;
      PurchaseLine@1003 : Record 39;
      ItemJournalLine@1002 : Record 83;
      UnitPrice@1000 : Decimal;
    BEGIN
      // Create Item Journal and Post, create Purchase Order and Receive.
      LibraryVariableStorage.Enqueue(AutoCostPostinMessage);  // Enqueue value for MessageHandler.
      UpdateGeneralLedgerSetupForACY(CurrencyCode);
      UpdateInventorySetup(TRUE);
      CreateAndPostItemJournalLine(ItemJournalLine,ItemNo,LibraryRandom.RandInt(10) + 10,'');
      CreatePurchaseOrderWithCurrency(
        PurchaseLine,ItemNo,CurrencyCode,CALCDATE('<1M + ' + FORMAT(LibraryRandom.RandInt(3)) + 'D>',WORKDATE),
        LibraryRandom.RandInt(50),ItemJournalLine.Quantity + LibraryRandom.RandInt(40));
      // Use random value for Direct Unit Cost.
      PostPurchaseDocument(PurchaseLine,TRUE);

      // Create Sales Order and Ship, Purchase Order Invoiced.
      CreateSalesDocument(
        SalesHeader,SalesHeader."Document Type"::Order,SalesLine.Type::Item,CreateCustomer,ItemNo,PurchaseLine.Quantity);  // Use Random Quantity.
      UnitPrice := PurchaseLine."Direct Unit Cost" + LibraryRandom.RandInt(50); // Required Unit Price more than Direct Unti Cost.
      LibraryVariableStorage.Enqueue(ChangeCurrCodeMessage);
      UpdateSalesDocument(
        SalesLine,SalesHeader,CALCDATE('<1M + ' + FORMAT(LibraryRandom.RandInt(3)) + 'D>',WORKDATE),CurrencyCode,UnitPrice);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);

      // Undo Sale Shipment, update blank Currency in Sales Order and Post.
      LibraryVariableStorage.Enqueue(UndoSalesShipmentMsg);  // Enqueue value for ConfirmHandler.
      UndoSalesShipment(SalesLine);
      UpdateSalesDocument(SalesLine,SalesHeader,CALCDATE('<1D>',SalesHeader."Posting Date"),'',UnitPrice);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Create Credit Memo without Currency Code and Post.
      LibraryVariableStorage.Enqueue(ChangePostingDateMessage);
      CreateSalesDocument(
        SalesHeader2,SalesHeader2."Document Type"::"Credit Memo",SalesLine.Type::Item,CreateCustomer,ItemNo,SalesLine.Quantity);  // Use Random Quantity.
      UpdateSalesDocument(SalesLine,SalesHeader2,CALCDATE('<1D>',SalesHeader."Posting Date"),'',UnitPrice);
      LibrarySales.PostSalesDocument(SalesHeader2,TRUE,TRUE);
    END;

    LOCAL PROCEDURE UndoPurchaseReceiptLines@51(PurchaseLine@1000 : Record 39);
    VAR
      PurchRcptLine@1001 : Record 121;
    BEGIN
      FindReceiptLine(PurchRcptLine,PurchaseLine."No.");
      LibraryPurchase.UndoPurchaseReceiptLine(PurchRcptLine);
    END;

    LOCAL PROCEDURE UndoReturnShipment@41(PurchaseLine@1000 : Record 39);
    VAR
      ReturnShipmentLine@1002 : Record 6651;
    BEGIN
      FindReturnShipmentLine(ReturnShipmentLine,PurchaseLine);
      LibraryPurchase.UndoReturnShipmentLine(ReturnShipmentLine);
    END;

    LOCAL PROCEDURE UndoReturnReceipt@110(SalesLine@1000 : Record 37);
    VAR
      ReturnReceiptLine@1002 : Record 6661;
    BEGIN
      FindReturnReceiptLine(ReturnReceiptLine,SalesLine);
      LibrarySales.UndoReturnReceiptLine(ReturnReceiptLine);
    END;

    LOCAL PROCEDURE UndoSalesShipment@65(SalesLine@1000 : Record 37);
    VAR
      SalesShipmentLine@1001 : Record 111;
    BEGIN
      FindShipmentLine(SalesShipmentLine,SalesLine."No.");
      LibrarySales.UndoSalesShipmentLine(SalesShipmentLine);
    END;

    LOCAL PROCEDURE UpdateGeneralLedgerSetupForACY@30(CurrencyCode@1001 : Code[10]);
    VAR
      GeneralLedgerSetup@1000 : Record 98;
    BEGIN
      GeneralLedgerSetup.GET;
      GeneralLedgerSetup."Additional Reporting Currency" := CurrencyCode;
      GeneralLedgerSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCurrencyExchangeRate@83(VAR CurrencyExchangeRate@1001 : Record 330;CurrencyCode@1000 : Code[10]);
    BEGIN
      CurrencyExchangeRate.SETRANGE("Currency Code",CurrencyCode);
      CurrencyExchangeRate.FINDFIRST;
      CurrencyExchangeRate."Relational Exch. Rate Amount" :=
        CurrencyExchangeRate."Exchange Rate Amount" * LibraryRandom.RandInt(10);  // Use random value for update Relational Exchange Rate Amount.
      LibraryVariableStorage.Enqueue(CurrencyExchangeRate."Relational Exch. Rate Amount");  // Enqueue for ChangeExchangeRatePageHandler.
    END;

    LOCAL PROCEDURE UpdateCurrencyExchangeRateOnSalesOrder@119(VAR CurrencyExchangeRate@1002 : Record 330;CurrencyCode@1000 : Code[10];No@1001 : Code[20]);
    VAR
      SalesOrder@1003 : TestPage 42;
    BEGIN
      UpdateCurrencyExchangeRate(CurrencyExchangeRate,CurrencyCode);
      SalesOrder.OPENEDIT;
      SalesOrder.FILTER.SETFILTER("No.",No);
      SalesOrder."Currency Code".ASSISTEDIT;
    END;

    LOCAL PROCEDURE UpdateCurrencyExchangeRateOnPurchOrder@107(VAR CurrencyExchangeRate@1004 : Record 330;CurrencyCode@1001 : Code[10];No@1000 : Code[20]);
    VAR
      PurchaseOrder@1002 : TestPage 50;
    BEGIN
      UpdateCurrencyExchangeRate(CurrencyExchangeRate,CurrencyCode);
      PurchaseOrder.OPENEDIT;
      PurchaseOrder.FILTER.SETFILTER("No.",No);
      PurchaseOrder."Currency Code".ASSISTEDIT;
    END;

    LOCAL PROCEDURE UpdateInventorySetup@128(AutomaticCostPosting@1001 : Boolean);
    VAR
      InventorySetup@1000 : Record 313;
    BEGIN
      InventorySetup.GET;
      InventorySetup.VALIDATE("Automatic Cost Posting",AutomaticCostPosting);
      InventorySetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdatePurchaseHeader@2(VAR PurchaseHeader@1000 : Record 38);
    BEGIN
      PurchaseHeader.VALIDATE("Vendor Cr. Memo No.",LibraryUtility.GenerateGUID);
      PurchaseHeader.VALIDATE("Vendor Invoice No.",LibraryUtility.GenerateGUID);
      PurchaseHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdatePurchaseLine@1(VAR PurchaseLine@1000 : Record 39;DirectUnitCost@1002 : Decimal;QtyToReceive@1001 : Decimal;LocationCode@1003 : Code[10]);
    BEGIN
      PurchaseLine.GET(PurchaseLine."Document Type",PurchaseLine."Document No.",PurchaseLine."Line No.");
      PurchaseLine.VALIDATE("Location Code",LocationCode);
      PurchaseLine.VALIDATE("Qty. to Receive",QtyToReceive);
      PurchaseLine.VALIDATE("Direct Unit Cost",DirectUnitCost);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateLocationCodeOnSalesLine@16(SalesHeader@1000 : Record 36;LocationCode@1002 : Code[10]);
    VAR
      SalesLine@1003 : Record 37;
    BEGIN
      FindSalesLine(SalesLine,SalesHeader);
      SalesLine.VALIDATE("Location Code",LocationCode);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateQtyToAssembleForSalesDocument@118(SalesHeader@1000 : Record 36;QtyToAssemble@1002 : Decimal);
    VAR
      SalesLine@1001 : Record 37;
    BEGIN
      FindSalesLine(SalesLine,SalesHeader);
      SalesLine.VALIDATE("Qty. to Assemble to Order",QtyToAssemble);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateSalesDocument@98(VAR SalesLine@1001 : Record 37;SalesHeader@1000 : Record 36;PostingDate@1002 : Date;CurrencyCode@1003 : Code[10];UnitPrice@1004 : Decimal);
    BEGIN
      SalesHeader.VALIDATE("Posting Date",PostingDate);
      SalesHeader.VALIDATE("Currency Code",CurrencyCode);
      SalesHeader.MODIFY(TRUE);
      FindSalesLine(SalesLine,SalesHeader);
      SalesLine.VALIDATE("Unit Price",UnitPrice);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemParametersForPlanning@120(VAR Item@1000 : Record 27;ReplenishmentSystem@1003 : Option;ReorderingPolicy@1002 : Option;IncludeInventory@1001 : Boolean);
    BEGIN
      WITH Item DO BEGIN
        VALIDATE("Replenishment System",ReplenishmentSystem);
        VALIDATE("Reordering Policy",ReorderingPolicy);
        VALIDATE("Include Inventory",IncludeInventory);
        VALIDATE("Unit Cost",LibraryRandom.RandInt(10));
        MODIFY(TRUE);
      END
    END;

    LOCAL PROCEDURE UpdateSalesHeader@144(VAR SalesHeader@1000 : Record 36;CurrencyCode@1001 : Code[10]);
    BEGIN
      SalesHeader.VALIDATE("Currency Code",CurrencyCode);
      SalesHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateSalesLine@145(VAR SalesLine@1000 : Record 37;UnitPrice@1001 : Decimal);
    BEGIN
      SalesLine.VALIDATE("Unit Price",UnitPrice);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateNamedItem@157(VAR Item@1000 : Record 27;ItemNo@1006 : Code[20]);
    VAR
      ItemUnitOfMeasure@1001 : Record 5404;
    BEGIN
      Item."No." := ItemNo;
      Item.INSERT(TRUE);

      LibraryInventory.CreateItemUnitOfMeasure(ItemUnitOfMeasure,Item."No.",'',1);
      Item.VALIDATE(Description,Item."No.");  // Validation Description as No. because value is not important.
      Item.VALIDATE("Base Unit of Measure",ItemUnitOfMeasure.Code);

      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateNamedProductionBOMItem@174(VAR Item@1000 : Record 27;ItemNo@1002 : Code[20]);
    VAR
      ChildItem@1003 : Record 27;
      ProductionBOMHeader@1001 : Record 99000771;
    BEGIN
      CreateNamedItem(Item,ItemNo);
      LibraryInventory.CreateItem(ChildItem);
      LibraryManufacturing.CreateCertifiedProductionBOM(ProductionBOMHeader,ChildItem."No.",1);
      Item.VALIDATE("Production BOM No.",ProductionBOMHeader."No.");
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntry@73(DocumentNo@1000 : Code[20];Quantity@1001 : Decimal;CostAmountActual@1002 : Decimal);
    VAR
      ItemLedgerEntry@1003 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,DocumentNo,ItemLedgerEntry."Entry Type"::Sale);
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      ItemLedgerEntry.TESTFIELD(Quantity,Quantity);
      ItemLedgerEntry.TESTFIELD("Cost Amount (Actual)",CostAmountActual);
    END;

    LOCAL PROCEDURE VerifySalesAmountOnItemLedgerEntry@92(ItemNo@1000 : Code[20];SalesAmount@1003 : Decimal);
    VAR
      ItemLedgerEntry@1004 : Record 32;
    BEGIN
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.FINDFIRST;
      ItemLedgerEntry.CALCFIELDS("Sales Amount (Actual)");
      ItemLedgerEntry.TESTFIELD("Sales Amount (Actual)",SalesAmount);
    END;

    LOCAL PROCEDURE VerifyCostAmountActualACYOnItemLedgerEntry@289(DocumentNo@1001 : Code[20];CostAmountActualACY@1002 : Decimal;Delta@1004 : Decimal);
    VAR
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,DocumentNo,ItemLedgerEntry."Entry Type"::Purchase);
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual) (ACY)");
      Assert.AreNearlyEqual(
        CostAmountActualACY,ItemLedgerEntry."Cost Amount (Actual) (ACY)",Delta,CostAmountActualACYErr);
    END;

    LOCAL PROCEDURE VerifyCostAmountExpectedACYOnItemLedgerEntry@131(DocumentNo@1001 : Code[20];CostAmountExpectedACY@1003 : Decimal;Delta@1002 : Decimal);
    VAR
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,DocumentNo,ItemLedgerEntry."Entry Type"::Purchase);
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Expected) (ACY)");
      Assert.AreNearlyEqual(
        CostAmountExpectedACY,ItemLedgerEntry."Cost Amount (Expected) (ACY)",Delta,CostAmountExpectedACYErr);
    END;

    LOCAL PROCEDURE VerifyValueEntry@115(DocumentNo@1001 : Code[20];LocationCode@1002 : Code[10];CostAmountActual@1005 : Decimal;CostPerUnit@1004 : Decimal;Quantity@1003 : Decimal);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      FindValueEntry(ValueEntry,DocumentNo,'',LocationCode,TRUE);
      ValueEntry.TESTFIELD("Valued Quantity",Quantity);
      Assert.AreNearlyEqual(
        CostPerUnit,ValueEntry."Cost per Unit",LibraryERM.GetAmountRoundingPrecision,
        STRSUBSTNO(ValueEntryNotMatched,ValueEntry.FIELDCAPTION("Cost per Unit"),CostPerUnit,ValueEntry.TABLECAPTION));
      Assert.AreNearlyEqual(
        CostAmountActual,ValueEntry."Cost Amount (Actual)",LibraryERM.GetAmountRoundingPrecision,
        STRSUBSTNO(ValueEntryNotMatched,ValueEntry.FIELDCAPTION("Cost Amount (Actual)"),CostPerUnit,ValueEntry.TABLECAPTION));
    END;

    LOCAL PROCEDURE VerifyValueEntryAfterAdjustCostItemEntries@11(ItemNo@1001 : Code[20];CostAmountActual@1004 : Decimal);
    VAR
      ValueEntry@1000 : Record 5802;
      AccumulatedInvdQty@1002 : Decimal;
      AccumulatedCostAmtActual@1003 : Decimal;
    BEGIN
      ValueEntry.SETRANGE("Item No.",ItemNo);
      REPEAT
        AccumulatedInvdQty := AccumulatedInvdQty + ValueEntry."Invoiced Quantity";
        AccumulatedCostAmtActual := AccumulatedCostAmtActual + ValueEntry."Cost Amount (Actual)";
      UNTIL ValueEntry.NEXT = 0;
      Assert.AreEqual(
        0,AccumulatedInvdQty,STRSUBSTNO(ValueEntryNotMatched,ValueEntry.FIELDCAPTION("Invoiced Quantity"),0,ValueEntry.TABLECAPTION));  // Sum of Invoiced Quantity must be zero.
      Assert.AreNearlyEqual(
        CostAmountActual,AccumulatedCostAmtActual,LibraryERM.GetAmountRoundingPrecision,
        STRSUBSTNO(ValueEntryNotMatched,ValueEntry.FIELDCAPTION("Cost Amount (Actual)"),CostAmountActual,ValueEntry.TABLECAPTION));
    END;

    LOCAL PROCEDURE VerifyValueEntryAmountsInACY@32(DocumentNo@1004 : Code[20];ItemChargeNo@1000 : Code[20];Delta@1005 : Decimal;CostAmountActualACY@1002 : Decimal;CostPerUnitACY@1003 : Decimal;CostAmountExpectedACY@1006 : Decimal);
    VAR
      ValueEntry@1001 : Record 5802;
    BEGIN
      FindValueEntry(ValueEntry,DocumentNo,ItemChargeNo,'',FALSE);
      Assert.AreNearlyEqual(
        CostPerUnitACY,ValueEntry."Cost per Unit (ACY)",Delta,
        STRSUBSTNO(ValueEntryNotMatched,ValueEntry.FIELDCAPTION("Cost per Unit (ACY)"),CostPerUnitACY,ValueEntry.TABLECAPTION));
      Assert.AreNearlyEqual(
        CostAmountExpectedACY,ValueEntry."Cost Amount (Expected) (ACY)",Delta,
        STRSUBSTNO(
          ValueEntryNotMatched,ValueEntry.FIELDCAPTION("Cost Amount (Expected) (ACY)"),CostAmountExpectedACY,ValueEntry.TABLECAPTION));
      Assert.AreNearlyEqual(
        CostAmountActualACY,ValueEntry."Cost Amount (Actual) (ACY)",Delta,
        STRSUBSTNO(
          ValueEntryNotMatched,ValueEntry.FIELDCAPTION("Cost Amount (Actual) (ACY)"),CostAmountActualACY,ValueEntry.TABLECAPTION));
    END;

    LOCAL PROCEDURE VerifyCustomerStatementReport@146(CurrencyCode@1000 : Code[10];AmountIncludingVAT@1001 : Decimal);
    BEGIN
      LibraryReportDataset.AssertElementWithValueExists('Total_Caption2','Total'); // need to verify the label 'Total'.
      LibraryReportDataset.AssertElementWithValueExists('CurrencyCode3',CurrencyCode);
      LibraryReportDataset.AssertElementWithValueExists('CustBalance_CustLedgEntryHdr',ROUND(AmountIncludingVAT,1));
    END;

    LOCAL PROCEDURE CheckValueEntryCostAmountNonInvtblNegSign@150(DocumentNo@1000 : Code[20]);
    VAR
      ValueEntry@1001 : Record 5802;
    BEGIN
      WITH ValueEntry DO BEGIN
        SETRANGE("Document Type","Document Type"::"Purchase Invoice");
        SETRANGE("Document No.",DocumentNo);
        FINDFIRST;
        Assert.IsTrue("Cost Amount (Non-Invtbl.)" < 0,CostAmountNonInvtblErr);
      END;
    END;

    LOCAL PROCEDURE VerifyAmountsInACYOnValueEntry@288(ItemNo@1001 : Code[20];CostPerUnitACY@1002 : Decimal;Delta@1003 : Decimal;CostPostedToGLACY@1004 : Decimal);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      WITH ValueEntry DO BEGIN
        SETRANGE("Item No.",ItemNo);
        SETRANGE("Entry Type","Entry Type"::Revaluation);
        FINDFIRST;
        Assert.AreNearlyEqual(CostPerUnitACY,"Cost per Unit (ACY)",Delta,CostPerUnitACYErr);
        Assert.AreNearlyEqual(CostPostedToGLACY,"Cost Posted to G/L (ACY)",Delta,CostPostedToGLACYErr);
      END;
    END;

    [ModalPageHandler]
    PROCEDURE ChangeExchangeRatePageHandler@89(VAR ChangeExchangeRate@1000 : TestPage 511);
    VAR
      RefExchRate@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(RefExchRate);
      ChangeExchangeRate.RefExchRate.SETVALUE(RefExchRate);
      ChangeExchangeRate.OK.INVOKE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@34(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    VAR
      ExpectedMessage@1002 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ExpectedMessage);  // Dequeue variable.
      Assert.IsTrue(STRPOS(Question,ExpectedMessage) > 0,Question);
      Reply := TRUE;
    END;

    [ModalPageHandler]
    PROCEDURE GetReceiptLinesHandler@56(VAR GetReceiptLines@1000 : TestPage 5709);
    BEGIN
      GetReceiptLines.FIRST;
      GetReceiptLines."Document No.".ASSERTEQUALS('');
      GetReceiptLines.Cancel.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE GetReturnReceiptHandler@132(VAR GetReturnReceiptLines@1000 : TestPage 6638);
    BEGIN
      GetReturnReceiptLines.FIRST;
      GetReturnReceiptLines."Document No.".ASSERTEQUALS('');
      GetReturnReceiptLines.Cancel.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE GetReturnShipmentHandler@97(VAR GetReturnShipmentLines@1000 : TestPage 6648);
    BEGIN
      GetReturnShipmentLines.FIRST;
      GetReturnShipmentLines."Document No.".ASSERTEQUALS('');
      GetReturnShipmentLines.Cancel.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE GetShipmentLinesHandler@103(VAR GetShipmentLines@1000 : TestPage 5708);
    BEGIN
      GetShipmentLines.FIRST;
      GetShipmentLines."Document No.".ASSERTEQUALS('');
      GetShipmentLines.Cancel.INVOKE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@106(Message@1000 : Text[1024]);
    VAR
      ExpectedMessage@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ExpectedMessage);  // Dequeue Variable.
      Assert.IsTrue(STRPOS(Message,ExpectedMessage) > 0,Message);
    END;

    [ModalPageHandler]
    PROCEDURE SalesListPageHandler@88(VAR SalesList@1000 : TestPage 45);
    BEGIN
      SalesList.OK.INVOKE;
    END;

    [StrMenuHandler]
    PROCEDURE ItemChargeAssignmentMenuHandler@232(Option@1000 : Text[1024];VAR Choice@1001 : Integer;Instruction@1002 : Text[1024]);
    VAR
      OptionCount@1003 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(OptionCount);
      Choice := OptionCount;
    END;

    [ModalPageHandler]
    PROCEDURE PurchItemChargeAssignmentHandler@129(VAR PurchItemChargeAssignment@1000 : TestPage 5805);
    BEGIN
      PurchItemChargeAssignment.GetSalesShipmentLines.INVOKE;
      PurchItemChargeAssignment.SuggestItemChargeAssignment.INVOKE;
      PurchItemChargeAssignment.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE SalesShipmentLinePageHandler@133(VAR SalesShipmentLines@1000 : TestPage 5824);
    VAR
      PostedDocumentNo@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(PostedDocumentNo);
      SalesShipmentLines.FILTER.SETFILTER("Document No.",PostedDocumentNo);
      SalesShipmentLines.OK.INVOKE;
    END;

    [PageHandler]
    PROCEDURE BOMCostSharesPageHandler@210(VAR BOMCostShares@1000 : TestPage 5872);
    VAR
      RolledupMaterialCost@1001 : Variant;
      ItemNo@1002 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(RolledupMaterialCost);
      LibraryVariableStorage.Dequeue(ItemNo);
      BOMCostShares.EXPAND(TRUE);
      BOMCostShares.NEXT;
      BOMCostShares."No.".ASSERTEQUALS(ItemNo);
      BOMCostShares.HasWarning.ASSERTEQUALS(TRUE);
      BOMCostShares."Rolled-up Material Cost".ASSERTEQUALS(RolledupMaterialCost);

      // Verify no component item expanded.
      BOMCostShares.EXPAND(TRUE);
      Assert.IsFalse(BOMCostShares.NEXT,STRSUBSTNO(ExpandBOMErr,ItemNo));
      BOMCostShares.OK.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE StatementRequestPageHandler@147(VAR Statement@1000 : TestRequestPage 116);
    VAR
      CustomerNo@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(CustomerNo);
      Statement.Customer.SETFILTER("No.",CustomerNo);
      Statement."Start Date".SETVALUE(FORMAT(CALCDATE('<+1Y>',WORKDATE)));
      Statement."End Date".SETVALUE(FORMAT(CALCDATE('<+2Y>',WORKDATE)));
      Statement.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    BEGIN
    {
      // [FEATURE] [Inventory Costing] [SCM]
      Test for Costing Inventory:
       1. Verify Value Entry for Sales Document after change of Unit Cost.
       2. Verify Value Entry for Sales Document after change of Indirect Cost.
       3. Verify Value Entry for Transfer Order after change of Unit Cost.
       4. Verify Item Ledger Entry for Sales Document with Non Zero Cost.
       5. Verify sum of Invoiced Quantity and Cost Amount (Actual) of all Value Entries after Inventory Revaluation per Item Ledger Entry and Adjust Cost - Item Entries for FIFO Item.
       6. Verify sum of Invoiced Quantity and Cost Amount (Actual) of all Value Entries after Inventory Revaluation per Item and Adjust Cost - Item Entries for FIFO Item.
       7. Verify sum of Invoiced Quantity and Cost Amount (Actual) of all Value Entries after Inventory Revaluation per Item and Adjust Cost - Item Entries for an Average Item.
       8. Verify Value Entry for Cost Amount (Actual) (ACY) and Cost per Unit (ACY) when post Purchase Invoice for Charge Item with Additional Reporting Currency.
       9. Verify Value Entry for Cost Amount (Actual) (ACY) and Cost per Unit (ACY) when post Purchase Invoice for Charge Item without Additional Reporting Currency.
      10. Verify Value Entry for Cost Amount (Expected) (ACY) when post Output Journal with Additional Reporting Currency.
      11. Verify Error while Undo Receipt after resrervation of the Item from Sales Order.
      12. Verify Error while Undo Receipt for Charge Item.
      13. Verify Get Receipt Line page, not find any Receipt Line from Purchase Invoice.
      14. Verify error when undo a Purchase Receipt Line with applied Quantity.
      15. Verify error after undo Receipt with Put Away created after post Warehouse Receipt.
      16. Verify undo Purchase Receipt for that Invoice created with Item Charge Assignment.
      17. Verify Error while undo Purchase Receipt which Invoiced with Item Charge Assignment.
      18. Verify Error while Undo Purchase Return Order Shipment for Charge Item.
      19. Verify Corrective Line on Return Shipment after create Pick, Register and post Whse. Shipment.
      20. Verify undo Purchase Return Shipment for that Invoice created with Item Charge Assignment.
      21. Verify Error while undo Purchase Return Shipment which Invoiced with Item Charge Assignment.
      22. Verify Corrective Line after undo Purchase Return Shipment Line with applied Quantity.
      23. Verify Get Return Shipment Line page, not find any Return Shipment Line from Purchase Credit Memo.
      24. Verify Corrective Lines  Undo Purchase Return Shipment after reservation of the Item from Sales Order.
      25. Verify Error while Undo Shipment for Charge Item.
      26. Verify Error while Undo Reserved Sales Shipment.
      27. Verify Error while Undo Sales Shipment which have Drop Shipment.
      28. Verify Undo Sales Shipment Line after Warehouse Shipment, create Pick and Register.
      29. Verify Get Shipment Lines after undo Shipment Lines.
      30. Verify Error while Undo Reserved Sales Return Receipt.
      31. Verify Error while Undo Sales Return Receipt for Charge Item.
      32. Verify Get Sales Return Receipt Lines after undo Return Receipt Line.
      33. Verify error while undo Sales Return Receipt Line after Warehouse Receipt and create Put-away.
      34. Verify Value Entries in 'Cost Amount (Expected)(ACY)' of Item Ledger Entry when transactions posted with different currency exchange rates.
      35. Verify Value Entries with ACY transactions on different Posting Dates after run Adjust Cost Item batch job.
      36. Verify Sales Amount on Item Ledger Entry after updating Currency Exchange Rate on Sales Order.
      37. Verify Cost Amount on Item Ledger Entry after updating Currency Exchange Rate on Purchase Order.
      38. Verify Cost Amount (Actual) on Item Ledger Entry after running Adjust Cost item entries with filtering on Assembled item.
      39. Verify Assembly BOM Item consume existing Inventory for Planning.
      40. Verify Planning Worksheeet after Re-Calculate Regenerate Plan.
      41. Verify report BOM Cost Shares should not account for cost from Assembly BOM components if this is a Purchase item.
      42. Verify that it shows the right balance amount for multiple Currency code when date range is outside of transaction date on Customer
          Statement Report.
      43. Verify that 'Cost Amount (Non-Invtbl)' in Value Entry is negative, if cost is assigned to Sales Shipment Line from Purchase Invoice.
      44. Verify Cost Amount (Actual) (ACY) on Item Ledger Entry with updating Additional Reporting Currency before revaluation.
      45. Verify Cost Amount (Actual) (ACY) on Item Ledger Entry, Cost per Unit (ACY) and Cost Posted to G/L (ACY) on Value Entry
          with updating Additional Reporting Currency after revaluation.
      46. Verify Cost Amount (Expected) (ACY) on Item Ledger Entry with updating Additional Reporting Currency after revaluation.

      TFS_TS_ID = 295171
      Cover Test cases:
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                               TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      AdjustSalesOrderChangeOfUnitCost, AdjustSalesOrderChangeOfIndirectCost, AdjustTransferOrderChangeOfUnitCost      128298
      AdjustUnitCostForZeroQuantityWithNonZeroCost                                                                     128299

      Covers Test cases: for WI - 295170
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                               TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      RevalueFIFOItemByItemLedgerEntry, RevalueFIFOItemByItem, RevalueAverageItemByItem                                128293

      Covers Test cases: for WI - 295170
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                               TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      PostPurchChrgInvWithACY, PostPurchChrgInvWithoutACY, PostManufacturingOutputWithACY                              128296

      Covers Test cases: for WI - 298794
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                               TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      ErrorOnUndoPurchRcptWithReservation, ErrorOnUndoPurchRcptForChargeItem, GetReceiptLineFromPurchInvAfterUndoReceipt
      UndoPurchRcptWithAppliedQuantity, UndoPurchRcptWithPutAway, UndoPurchRcptAfterCreateItemChargeInvoice,
      UndoPurchRcptAfterCreateItemChargeInvoice                                                                         128292

      Covers Test cases: for WI - 308887
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                               TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      ErrorOnUndoPurchRetShptForChargeItem, UndoRetShptAfterCreateWhsePick,
      UndoPurchRetShptAfterCreateItemChargeCrMemo, ErrorOnUndoPurchRetShptAfterPostItemChargeCrMemo,
      ErrorOnUndoPurchRetShptWithAppliedNegQuantity, GetRetShptLineFromPurchCrMemoAfterUndoRetShpt,
      UndoRetShptOfReservedNegQuantity                                                                                  128292

      Covers Test cases: for WI - 309893
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                               TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      ErrorOnUndoSalesShipmentForChargeItem, ErrorOnUndoReservedSalesShipment, ErrorOnUndoShipmentOfDropShipment,
      UndoShptWithWhseActivityLines, CorrectionLinesUnavailableForGetShipmentLines,ErrorOnUndoReservedSalesRetReceipt,
      ErrorOnUndoSalesRetReceiptForChargeItem, CorrectionLinesUnavailableForGetRetRcptLines,
      UndoReturnReceiptWithWhseActivityLines                                                                            128292

      Covers Test cases: for WI - 309084
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      AdjustCostForDifferentCurrencyExchangeRate, PostPurchOrderWithDiffCurrencyExchangeRate                            268657
      PostSalesOrderAfterUpdateExchangeRate, PostPurchOrderAfterUpdateExchangeRate                                      265347

      Covers Test cases: for NAV7 SE BUG
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      AdjustCostItemEntriesForAssembledItemWithFilter                                                                   341826

      Covers Test cases: for NAV7 SE BUG
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      AssemblyBOMConsumeExistingInventory                                                                               345384

      Covers Test cases: for NAV7 SE BUG
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      ReCalcRegenPlanForPlanWksh                                                                                        346281

      Covers Test cases: for Merge Bug
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      BOMCostSharesWithMultipleAssemblyBOMLevels                                                                        97722

      Covers Test cases: for Merge Bug
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      CustomerStatementReportWithMultiCurrency                                                                          97777

      Covers Test cases: 356254
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      VerifyCostAmountForItemChargeAssignedFromPurchInv                                                                 356254

      Covers Test cases: for Merge BUG
      -----------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                                TFS ID
      -----------------------------------------------------------------------------------------------------------------------
      UpdateAddReportingCurrBeforeRevaluation                                                                           101578
      UpdateAddReportingCurrAfterRevaluation                                                                            101578
      UpdateAddReportingCurrAfterRevaluationWithPostReceiveOnPurchOrd                                                   101578
    }
    END.
  }
}

