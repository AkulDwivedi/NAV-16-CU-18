OBJECT Codeunit 134820 ERM Cost Accounting - Codeunit
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            IsInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      Assert@1003 : Codeunit 130000;
      CostAccountAllocation@1000 : Codeunit 1104;
      LibraryCostAccounting@1006 : Codeunit 131340;
      LibraryDimension@1002 : Codeunit 131001;
      LibraryUtility@1001 : Codeunit 131000;
      LibraryERM@1028 : Codeunit 131300;
      LibraryTimeSheet@1042 : Codeunit 131904;
      LibraryInventory@1047 : Codeunit 132201;
      LibrarySales@1046 : Codeunit 130509;
      LibraryERMCountryData@1048 : Codeunit 131305;
      LibraryRandom@1005 : Codeunit 130440;
      IsInitialized@1004 : Boolean;
      UpdateCountryData@1049 : Boolean;
      AllocSourceFound@1018 : TextConst 'ENU=Cost allocation sources were found.';
      AllocTargetShareIsZero@1012 : TextConst 'ENU=For cost allocation target %1, the Share equals 0.';
      AmountsAreDifferent@1020 : TextConst 'ENU=Posted amount %1 is different from original amount %2.';
      CostEntriesNotFound@1022 : TextConst 'ENU=Cost Entries were not found.';
      DynamicAllocTargetFound@1016 : TextConst 'ENU=Dynamic cost allocation targets were found.';
      DynamicAllocTargetNotFound@1014 : TextConst 'ENU=Dynamic Cost Allocation Targets were not found.';
      EmployeesFound@1009 : TextConst 'ENU=One or more Employee entries were found.';
      Rollback@1015 : TextConst 'ENU=Roll back the database to its previous state.';
      Text005@1013 : TextConst 'ENU=Expected value is %1.';
      TextBlocked@1011 : TextConst 'ENU=is blocked in Cost Accounting.';
      TextNotDefined@1010 : TextConst 'ENU=is not defined in Cost Accounting.';
      TextType@1008 : TextConst 'ENU=or Begin-Total.';
      UnexpectedMessageError@1007 : TextConst 'ENU=The actual message is: [%1], while the expected message is: [%2].';
      CostJournlLineError@1017 : TextConst 'ENU=%1 must be blank.';
      TemplateSelectionError@1019 : TextConst 'ENU=Template must exits in %1.';
      CostJnlBatchName@1021 : Code[10];
      ExpectedBatchError@1023 : TextConst 'ENU=Batch must be same as of %1.';
      ExpectedBalanceError@1026 : TextConst 'ENU=Balance on %1 must be equal to Expected Amount.';
      ExpectedTotBalanceError@1025 : TextConst 'ENU=Total Balance on %1 must be equal to Expected Total Amount.';
      NoGLEntriesTransferedError@1027 : TextConst 'ENU=Could not transfer general ledger entries to Cost Accounting.';
      ExpectedNoPostingMsg@1030 : TextConst 'ENU=Not all journals were posted. The journals that were not successfully posted are now marked.';
      ExpectedPostingMsg@1029 : TextConst 'ENU=The journals were successfully posted.';
      UnexpectedMessage@1031 : TextConst 'ENU=Actual Message [%1] must be equal to Expected Message [%2].';
      CostJnlBatchNameLengthError@1033 : TextConst '@@@="%1:Field Caption;%2:Field Value;%3:Table Caption;%4:Field Caption;%5:Field Value;%6:Field Caption;%7:Field Value;";ENU="%1 cannot exceed %2 characters in %3 %4=''%5'',%6=''%7''."';
      CostJournalLineBalanceError@1032 : TextConst '@@@="%1:Field Value;%2:Field Caption;%3:Field Caption;";ENU=The lines in Cost Journal are out of balance by %1. Verify that %2 and %3 are correct for each line.';
      CostTypeFilterDefinition@1034 : TextConst '@@@="%1 - Field Value;%2 - Field Value";ENU=%1..%2';
      CostCenterObjectFilterDefinition@1035 : TextConst '@@@="%1 - Field Value;%2 - Field Value;%3 - Field Value";ENU=%1|%2|%3';
      ExpectedTotaling3@1037 : TextConst 'ENU=Number of records without a Totaling value is not 3.';
      ExpectedTotaling1@1036 : TextConst 'ENU=Number of records with Totaling not empty is not 1.';
      ExpectedIndentationForTotaling@1038 : TextConst 'ENU=Indentation is not the same for Totaling records. The expected value is: %1.';
      ExpectedIndentationForNonTotaling@1039 : TextConst 'ENU=Indentation is not the same for non-Totaling records. The expected value is: %1.';
      ExpectedLevelDifference@1040 : TextConst 'ENU=Expected difference is 1 between 1st level as %1 and 2nd level as %2.';
      EndTotalError@1041 : TextConst 'ENU=End-Total %1 does not belong to Begin-Total.';
      PostingDateError@1043 : TextConst 'ENU=Posting Date is not within the permitted range of posting dates in Cost Journal Line';
      LinkCostTypeError@1044 : TextConst 'ENU=Cost type %1 should be assigned to G/L account %2.';
      ValuesAreWrong@1045 : TextConst 'ENU=The %1 values are not correct.';

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCAJnlPostConfirmNo@96();
    VAR
      CostJournalBatch@1002 : Record 1102;
      CostJournalLine@1000 : Record 1101;
      LineNo@1003 : Integer;
    BEGIN
      Initialize;
      LineNo := LibraryRandom.RandInt(100);

      // Pre-Setup
      CreateCostJournalBatch(CostJournalBatch);

      // Setup
      CostJournalLine."Journal Template Name" := CostJournalBatch."Journal Template Name";
      CostJournalLine."Journal Batch Name" := CostJournalBatch.Name;
      CostJournalLine."Line No." := LineNo;
      CostJournalLine.INSERT;

      // Exercise
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post",CostJournalLine);

      // Verify
      CostJournalLine.GET(CostJournalBatch."Journal Template Name",CostJournalBatch.Name,LineNo);

      // Cleanup
      CostJournalBatch.DELETE(TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCAJnlPostMultipleLines@145();
    VAR
      CostEntry@1004 : Record 1104;
      CostJournalBatch@1001 : Record 1102;
      CostJournalLine@1000 : Record 1101;
      Index@1002 : Integer;
      LastCostEntryNo@1003 : Integer;
    BEGIN
      Initialize;

      // Pre-Setup
      CreateCostJournalBatch(CostJournalBatch);

      // Setup
      FOR Index := 1 TO LibraryRandom.RandInt(3) DO BEGIN
        LibraryCostAccounting.CreateCostJournalLine(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);
        CLEAR(CostJournalLine);
      END;

      // Pre-Exercise
      CostEntry.FINDLAST;
      LastCostEntryNo := CostEntry."Entry No.";

      CostJournalLine.SETFILTER("Journal Template Name",'%1',CostJournalBatch."Journal Template Name");
      CostJournalLine.SETFILTER("Journal Batch Name",'%1',CostJournalBatch.Name);
      CostJournalLine.FINDFIRST;

      // Exercise
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post",CostJournalLine);

      // Verify
      CostEntry.SETFILTER("Entry No.",'%1..',LastCostEntryNo + 1);
      Assert.AreEqual(2 * Index,CostEntry.COUNT,CostEntriesNotFound);

      // Cleanup
      CostJournalBatch.DELETE(TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCAJnlPostSingleLine@144();
    VAR
      CostEntry@1000 : Record 1104;
      CostJournalBatch@1002 : Record 1102;
      CostJournalLine@1001 : Record 1101;
      Amount@1004 : Decimal;
      LastCostEntryNo@1003 : Integer;
    BEGIN
      Initialize;

      // Pre-Setup
      CreateCostJournalBatch(CostJournalBatch);

      // Setup
      LibraryCostAccounting.CreateCostJournalLine(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);

      // Post-Setup
      Amount := CostJournalLine.Amount;

      // Pre-Exercise
      CostEntry.FINDLAST;
      LastCostEntryNo := CostEntry."Entry No.";

      // Exercise
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post",CostJournalLine);

      // Verify
      CostEntry.GET(LastCostEntryNo + 1);
      Assert.AreEqual(Amount,CostEntry.Amount,STRSUBSTNO(AmountsAreDifferent,CostEntry.Amount,Amount));

      // Cleanup
      CostJournalBatch.DELETE(TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCAJnlPostPrintConfirmNo@95();
    VAR
      CostJournalBatch@1000 : Record 1102;
      CostJournalLine@1001 : Record 1101;
      LineNo@1002 : Integer;
    BEGIN
      Initialize;

      // Pre-Setup
      CreateCostJournalBatch(CostJournalBatch);
      UpdatePostingReportID(CostJournalBatch."Journal Template Name",REPORT::"Cost Register");

      // Setup
      LineNo := LibraryRandom.RandInt(1000);
      CostJournalLine."Journal Template Name" := CostJournalBatch."Journal Template Name";
      CostJournalLine."Journal Batch Name" := CostJournalBatch.Name;
      CostJournalLine."Line No." := LineNo;
      CostJournalLine.INSERT;

      // Exercise
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post+Print",CostJournalLine);

      // Verify
      CostJournalLine.GET(CostJournalBatch."Journal Template Name",CostJournalBatch.Name,LineNo);

      // Cleanup
      CostJournalBatch.DELETE(TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler,ReportHandlerCostRegister)]
    PROCEDURE TestCAJnlPostPrintConfirmYes@100();
    VAR
      CostEntry@1007 : Record 1104;
      CostJournalBatch@1000 : Record 1102;
      CostJournalLine@1001 : Record 1101;
      Amount@1006 : Decimal;
      LastCostEntryNo@1002 : Integer;
    BEGIN
      Initialize;

      // Pre-Setup
      CreateCostJournalBatch(CostJournalBatch);
      UpdatePostingReportID(CostJournalBatch."Journal Template Name",REPORT::"Cost Register");

      // Setup
      LibraryCostAccounting.CreateCostJournalLine(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);

      // Post-Setup
      Amount := CostJournalLine.Amount;

      // Pre-Exercise
      CostEntry.FINDLAST;
      LastCostEntryNo := CostEntry."Entry No.";

      // Exercise
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post+Print",CostJournalLine);

      // Verify
      CostEntry.GET(LastCostEntryNo + 1);
      Assert.AreEqual(Amount,CostEntry.Amount,STRSUBSTNO(AmountsAreDifferent,CostEntry.Amount,Amount));

      // Cleanup
      CostJournalBatch.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCAJnlPostPrintMissingPostingReportID@195();
    VAR
      CostJournalBatch@1002 : Record 1102;
      CostJournalLine@1001 : Record 1101;
    BEGIN
      Initialize;

      // Pre-Setup
      CreateCostJournalBatch(CostJournalBatch);
      UpdatePostingReportID(CostJournalBatch."Journal Template Name",0);

      // Setup
      CostJournalLine."Journal Template Name" := CostJournalBatch."Journal Template Name";
      CostJournalLine."Journal Batch Name" := CostJournalBatch.Name;
      CostJournalLine.INSERT;

      // Exercise and Verify
      ASSERTERROR CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post+Print",CostJournalLine);
    END;

    [Test]
    PROCEDURE TestCAJnlPostLineEmptyJournal@146();
    VAR
      CostJournalBatch@1000 : Record 1102;
      CostJournalLine@1001 : Record 1101;
      CostRegister@1002 : Record 1105;
    BEGIN
      Initialize;

      // Setup
      CreateCostJournalBatch(CostJournalBatch);
      CostJournalLine.SETRANGE("Journal Template Name",CostJournalBatch."Journal Template Name");
      CostJournalLine.SETRANGE("Journal Batch Name",CostJournalBatch.Name);

      // Exercise
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post Line",CostJournalLine);

      // Verify
      CostRegister.SETRANGE("Journal Batch Name",CostJournalBatch.Name);
      ASSERTERROR CostRegister.FINDFIRST;
    END;

    [Test]
    PROCEDURE TestCAJnlPostLineBudgetWithBalCostType@151();
    VAR
      CostBudgetName@1005 : Record 1110;
      CostCenter@1003 : Record 1112;
      CostJournalBatch@1000 : Record 1102;
      CostJournalLine@1001 : Record 1101;
      CostJournalTemplate@1002 : Record 1100;
    BEGIN
      Initialize;

      // Pre-Setup
      LibraryCostAccounting.CreateCostCenter(CostCenter);
      LibraryCostAccounting.CreateCostBudgetName(CostBudgetName);

      // Setup
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);

      // Post-Setup
      CostJournalLine.VALIDATE("Cost Center Code",CostCenter.Code);
      CostJournalLine.VALIDATE("Bal. Cost Center Code",CostCenter.Code);
      CostJournalLine.VALIDATE("Budget Name",CostBudgetName.Name);
      CostJournalLine.MODIFY(TRUE);

      // Exercise
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post Line",CostJournalLine);

      // Verify
      VerifyCostBudgetRegister(CostJournalBatch.Name,CostBudgetName.Name);
      VerifyCostBudgetEntry(CostBudgetName.Name,CostCenter.Code);
    END;

    [Test]
    PROCEDURE TestCalcAllocationKeyBothAllocTargets@83();
    VAR
      CostAllocationSource@1005 : Record 1106;
      CostAllocationTarget@1004 : Record 1107;
      DynamicLineNo@1002 : Integer;
      ID@1001 : Code[10];
      StaticLineNo@1000 : Integer;
    BEGIN
      Initialize;

      StaticLineNo := LibraryRandom.RandInt(10);
      DynamicLineNo := StaticLineNo + 1;

      // Pre-Setup
      CostAllocationTarget.DELETEALL;
      CostAllocationSource.DELETEALL;

      // Setup
      CreateStaticAllocTarget(CostAllocationTarget,StaticLineNo);
      ID := CostAllocationTarget.ID;

      CLEAR(CostAllocationTarget);
      CreateDynAllocTargetByAllocSourceID(CostAllocationTarget,ID,DynamicLineNo,
        CostAllocationTarget.Base::"Items Sold (Amount)",CostAllocationTarget."Date Filter Code"::"Last Year");

      // Pre-Verify
      VerifyAllocTargetShareIsZero(ID,DynamicLineNo);

      // Exercise
      CostAllocationSource.GET(ID);
      CostAccountAllocation.CalcAllocationKey(CostAllocationSource);

      // Post-Verify
      VerifyAllocTargetShareIsZero(ID,StaticLineNo);
      VerifyAllocTargetShareIsNonZero(ID,DynamicLineNo);

      // Cleanup
      ASSERTERROR ERROR(Rollback);
    END;

    [Test]
    PROCEDURE TestCalcAllocationKeyDynamicAllocTarget@73();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
      ID@1002 : Code[10];
      LineNo@1003 : Integer;
    BEGIN
      Initialize;
      LineNo := LibraryRandom.RandInt(10);

      // Pre-Setup
      CostAllocationTarget.DELETEALL;
      CostAllocationSource.DELETEALL;

      // Setup
      CreateDynAllocTargetItemsSoldAmount(CostAllocationTarget,LineNo);
      ID := CostAllocationTarget.ID;

      // Pre-Verify
      VerifyAllocTargetShareIsZero(ID,LineNo);

      // Exercise
      CostAllocationSource.GET(ID);
      CostAccountAllocation.CalcAllocationKey(CostAllocationSource);

      // Post-Verify
      VerifyAllocTargetShareIsNonZero(ID,LineNo);

      // Cleanup
      ASSERTERROR ERROR(Rollback);
    END;

    [Test]
    PROCEDURE TestCalcAllocationKeyStaticAllocTarget@71();
    VAR
      CostAllocationSource@1001 : Record 1106;
      CostAllocationTarget@1000 : Record 1107;
      ID@1002 : Code[10];
      LineNo@1003 : Integer;
    BEGIN
      Initialize;
      LineNo := LibraryRandom.RandInt(10);

      // Pre-Setup
      CostAllocationTarget.DELETEALL;
      CostAllocationSource.DELETEALL;

      // Setup
      CreateStaticAllocTarget(CostAllocationTarget,LineNo);
      ID := CostAllocationTarget.ID;

      // Exercise
      CostAllocationSource.GET(ID);
      CostAccountAllocation.CalcAllocationKey(CostAllocationSource);

      // Verify
      VerifyAllocTargetShareIsZero(ID,LineNo);

      // Cleanup
      ASSERTERROR ERROR(Rollback);
    END;

    [Test]
    PROCEDURE TestCalcAllocationKeysNoAllocSources@65();
    VAR
      CostAllocationSource@1001 : Record 1106;
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      Initialize;

      // Setup
      CostAllocationTarget.DELETEALL;
      CostAllocationSource.DELETEALL;

      // Exercise and Verify
      Assert.AreEqual(0,CostAccountAllocation.CalcAllocationKeys,AllocSourceFound);

      // Cleanup
      ASSERTERROR ERROR(Rollback);
    END;

    [Test]
    PROCEDURE TestCalcAllocationKeysBothAllocTargets@59();
    VAR
      CostAllocationSource@1001 : Record 1106;
      CostAllocationTarget@1000 : Record 1107;
      DynamicLineNo@1004 : Integer;
      ID@1003 : Code[10];
      StaticLineNo@1005 : Integer;
    BEGIN
      Initialize;

      StaticLineNo := LibraryRandom.RandInt(10);
      DynamicLineNo := StaticLineNo + 1;

      // Pre-Setup
      CostAllocationTarget.DELETEALL;
      CostAllocationSource.DELETEALL;

      // Setup
      CreateStaticAllocTarget(CostAllocationTarget,StaticLineNo);
      ID := CostAllocationTarget.ID;

      CLEAR(CostAllocationTarget);
      CreateDynAllocTargetByAllocSourceID(CostAllocationTarget,ID,DynamicLineNo,
        CostAllocationTarget.Base::"Items Sold (Amount)",CostAllocationTarget."Date Filter Code"::"Last Year");

      // Pre-Verify
      VerifyAllocTargetShareIsZero(ID,DynamicLineNo);

      // Exercise
      Assert.AreEqual(1,CostAccountAllocation.CalcAllocationKeys,DynamicAllocTargetNotFound);

      // Post-Verify
      VerifyAllocTargetShareIsZero(ID,StaticLineNo);
      VerifyAllocTargetShareIsNonZero(ID,DynamicLineNo);

      // Cleanup
      ASSERTERROR ERROR(Rollback);
    END;

    [Test]
    PROCEDURE TestCalcAllocationKeysDynamicAllocTarget@58();
    VAR
      CostAllocationSource@1001 : Record 1106;
      CostAllocationTarget@1000 : Record 1107;
      ID@1002 : Code[10];
      LineNo@1003 : Integer;
    BEGIN
      Initialize;
      LineNo := LibraryRandom.RandInt(10);

      // Pre-Setup
      CostAllocationTarget.DELETEALL;
      CostAllocationSource.DELETEALL;

      // Setup
      CreateDynAllocTargetItemsSoldAmount(CostAllocationTarget,LineNo);
      ID := CostAllocationTarget.ID;

      // Pre-Verify
      VerifyAllocTargetShareIsZero(ID,LineNo);

      // Exercise
      Assert.AreEqual(1,CostAccountAllocation.CalcAllocationKeys,DynamicAllocTargetNotFound);

      // Post-Verify
      VerifyAllocTargetShareIsNonZero(ID,LineNo);

      // Cleanup
      ASSERTERROR ERROR(Rollback);
    END;

    [Test]
    PROCEDURE TestCalcAllocationKeysStaticAllocTarget@51();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
      LineNo@1002 : Integer;
    BEGIN
      Initialize;
      LineNo := LibraryRandom.RandInt(10);

      // Pre-Setup
      CostAllocationTarget.DELETEALL;
      CostAllocationSource.DELETEALL;

      // Setup
      CreateStaticAllocTarget(CostAllocationTarget,LineNo);

      // Exercise and Verify
      Assert.AreEqual(0,CostAccountAllocation.CalcAllocationKeys,DynamicAllocTargetFound);

      // Cleanup
      ASSERTERROR ERROR(Rollback);
    END;

    [Test]
    PROCEDURE TestCalcEmployeeCountShareNoEmployees@46();
    VAR
      CostAllocationSource@1002 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
      Employee@1000 : Record 5200;
      LineNo@1004 : Integer;
      TotalShare@1003 : Decimal;
    BEGIN
      Initialize;
      LineNo := LibraryRandom.RandInt(10);

      // Pre-Setup
      CostAllocationTarget.DELETEALL;
      CostAllocationSource.DELETEALL;
      Employee.DELETEALL;

      // Setup
      Employee."No." :=
        COPYSTR(LibraryUtility.GenerateRandomCode(Employee.FIELDNO("No."),DATABASE::Employee),
          1,LibraryUtility.GetFieldLength(DATABASE::Employee,Employee.FIELDNO("No.")));
      Employee.Status := Employee.Status::Inactive;
      Employee.INSERT;
      CreateDynAllocTargetNoOfEmployees(CostAllocationTarget,LineNo);

      // Exercise
      CostAccountAllocation.CalcLineShare(CostAllocationTarget);

      // Veirfy
      CostAccountAllocation.GetTotalShare(TotalShare);
      Assert.AreEqual(0,TotalShare,EmployeesFound);

      // Cleanup
      ASSERTERROR ERROR(Rollback);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostAccMgtGetCostTypesFromChartOfAccountsNo@1();
    VAR
      CostAccountMgt@1000 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      ASSERTERROR CostAccountMgt.GetCostTypesFromChartOfAccount;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostAccMgtGetCostTypesFromChartOfAccountsYes@25();
    VAR
      GLAccount@1001 : Record 15;
      CostType@1002 : Record 1103;
      CostAccountingSetup@1003 : Record 1108;
      CostAccountMgt@1000 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      CostAccountMgt.GetCostTypesFromChartOfAccount;
      CostType.GET(GLAccount."No.");
      GLAccount.TESTFIELD("No.",CostType."No.");
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestCostAccMgtConfirmUpdateOnInsert@26();
    VAR
      CostAccountMgt@1000 : Codeunit 1100;
      CallingTrigger@1001 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      Initialize;

      CostAccountMgt.ConfirmUpdate(CallingTrigger::OnInsert,'','');
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestCostAccMgtConfirmUpdateOnRename@74();
    VAR
      CostAccountMgt@1000 : Codeunit 1100;
      CallingTrigger@1001 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      Initialize;

      CostAccountMgt.ConfirmUpdate(CallingTrigger::OnRename,'','');
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostTypeFromGLAccOnInsert@50();
    VAR
      GLAccount@1000 : Record 15;
      xGLAccount@1001 : Record 15;
      DimensionCC@1003 : Record 348;
      DimensionValueCC@1006 : Record 349;
      DimensionCO@1010 : Record 348;
      DimensionValueCO@1007 : Record 349;
      DefaultDimension@1011 : Record 352;
      CostType@1005 : Record 1103;
      CostCenter@1012 : Record 1112;
      CostObject@1013 : Record 1113;
      CostAccountingSetup@1002 : Record 1108;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostCenterDimension@1008 : Code[20];
      InitialCostObjectDimension@1009 : Code[20];
      CallingTrigger@1014 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 New GLAcc is inserted with valid CC and CO values coming from default dimenison.
      Initialize;

      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      LibraryDimension.CreateDimension(DimensionCC);
      LibraryDimension.CreateDimensionValue(DimensionValueCC,DimensionCC.Code);
      LibraryDimension.CreateDimension(DimensionCO);
      LibraryDimension.CreateDimensionValue(DimensionValueCO,DimensionCO.Code);
      LibraryDimension.CreateDefaultDimensionGLAcc(DefaultDimension,GLAccount."No.",DimensionCC.Code,DimensionValueCC.Code);
      LibraryDimension.CreateDefaultDimensionGLAcc(DefaultDimension,GLAccount."No.",DimensionCO.Code,DimensionValueCO.Code);
      CreateCostCenter(CostCenter,DimensionValueCC.Code);
      CreateCostObject(CostObject,DimensionValueCO.Code);

      CostAccountingSetup.GET;
      InitialCostCenterDimension := CostAccountingSetup."Cost Center Dimension";
      InitialCostObjectDimension := CostAccountingSetup."Cost Object Dimension";
      CostAccountingSetup.VALIDATE("Align G/L Account",CostAccountingSetup."Align G/L Account"::Automatic);
      CostAccountingSetup.VALIDATE("Cost Center Dimension",DimensionCC.Code);
      CostAccountingSetup.VALIDATE("Cost Object Dimension",DimensionCO.Code);
      CostAccountingSetup.MODIFY(TRUE);

      CostAccountMgt.UpdateCostTypeFromGLAcc(GLAccount,xGLAccount,CallingTrigger::OnInsert);

      CostType.GET(GLAccount."No.");
      GLAccount.TESTFIELD("No.",CostType."No.");
      CostCenter.TESTFIELD(Code,CostType."Cost Center Code");
      CostObject.TESTFIELD(Code,CostType."Cost Object Code");

      CostAccountingSetup.VALIDATE("Align G/L Account",CostAccountingSetup."Align G/L Account"::"No Alignment");
      CostAccountingSetup.VALIDATE("Cost Center Dimension",InitialCostCenterDimension);
      CostAccountingSetup.VALIDATE("Cost Object Dimension",InitialCostObjectDimension);
      CostAccountingSetup.MODIFY(TRUE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostTypeFromGLAccOnModify@47();
    VAR
      GLAccount@1000 : Record 15;
      xGLAccount@1001 : Record 15;
      CostType@1005 : Record 1103;
      CostAccountingSetup@1002 : Record 1108;
      CostAccountMgt@1004 : Codeunit 1100;
      RandomSearchName@1003 : Code[50];
      CallingTrigger@1006 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 existent GLAcc without valid CC and CO is modified, cost type is also existed so test will update it
      Initialize;

      LibraryCostAccounting.CreateCostTypeWithGLRange(CostType,FALSE);
      GLAccount.GET(CostType."No.");

      RandomSearchName :=
        COPYSTR(LibraryUtility.GenerateRandomCode(GLAccount.FIELDNO("Search Name"),DATABASE::"G/L Account"),
          1,LibraryUtility.GetFieldLength(DATABASE::"G/L Account",GLAccount.FIELDNO("Search Name")));

      GLAccount.VALIDATE("Search Name",RandomSearchName);
      GLAccount.MODIFY; // Code under trigger should not run.

      CostAccountMgt.UpdateCostTypeFromGLAcc(GLAccount,xGLAccount,CallingTrigger::OnModify);

      CostType.GET(GLAccount."No.");
      GLAccount.TESTFIELD("No.",CostType."No.");
      CostType.TESTFIELD("Cost Center Code",'');
      CostType.TESTFIELD("Cost Object Code",'');
      CostType.TESTFIELD("Search Name",RandomSearchName);

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostTypeFromGLAccOnRename@52();
    VAR
      GLAccount@1000 : Record 15;
      xGLAccount@1001 : Record 15;
      CostType@1005 : Record 1103;
      CostAccountingSetup@1002 : Record 1108;
      CostAccountMgt@1004 : Codeunit 1100;
      CallingTrigger@1003 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 existent GLAcc without valid CC and CO is renamed, cost type with new no is not existed, so old cost type should be renamed.
      Initialize;

      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      LibraryCostAccounting.CreateCostTypeWithGLRange(CostType,FALSE);
      xGLAccount.GET(CostType."No.");

      CostAccountMgt.UpdateCostTypeFromGLAcc(GLAccount,xGLAccount,CallingTrigger::OnRename);
      CostType.GET(GLAccount."No.");
      ASSERTERROR CostType.GET(xGLAccount."No.");

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostTypeFromGLAccOnRenameCTExists@48();
    VAR
      GLAccount@1000 : Record 15;
      xGLAccount@1001 : Record 15;
      CostType@1005 : Record 1103;
      CostAccountingSetup@1002 : Record 1108;
      CostAccountMgt@1004 : Codeunit 1100;
      CallingTrigger@1006 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 existent GLAcc without valid CC and CO is renamed, cost type with new no is existed, error message is expected.
      Initialize;

      LibraryCostAccounting.CreateCostTypeWithGLRange(CostType,FALSE);
      GLAccount.GET(CostType."No.");
      xGLAccount.COPY(GLAccount);

      ASSERTERROR CostAccountMgt.UpdateCostTypeFromGLAcc(GLAccount,xGLAccount,CallingTrigger::OnRename);

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostCenterFromDimOnInsert@3();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostCenter@1005 : Record 1112;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostCenterDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 New dimension created and Cost Center Does not exist
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      CostAccountMgt.UpdateCostCenterFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnInsert);

      CostCenter.GET(DimensionValue.Code);

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtUpdateCostCenterFromDimOnInsertCCExists@2();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostCenter@1005 : Record 1112;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostCenterDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 New Dimension Created and Cost Center exists
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);

      CreateCostCenter(CostCenter,DimensionValue.Code);
      ASSERTERROR CostAccountMgt.UpdateCostCenterFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnInsert);

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostCenterFromDimOnModify@21();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostCenter@1005 : Record 1112;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostCenterDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 Cost Center Does not exist
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);

      CostAccountMgt.UpdateCostCenterFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnModify);
      CostCenter.GET(DimensionValue.Code);

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostCenterFromDimOnModifyCCExists@22();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostCenter@1005 : Record 1112;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostCenterDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 Cost Center exists
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      DimensionValue.Blocked := TRUE;
      DimensionValue.MODIFY;

      CreateCostCenter(CostCenter,DimensionValue.Code);

      CostAccountMgt.UpdateCostCenterFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnModify);
      CostCenter.GET(DimensionValue.Code);

      CostCenter.TESTFIELD(Blocked,TRUE);

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostCenterFromDimOnRename@24();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostCenter@1005 : Record 1112;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostCenterDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 Cost Center exists and dimension value is renamed
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      LibraryDimension.CreateDimensionValue(XDimensionValue,Dimension.Code);

      CostAccountMgt.UpdateCostCenterFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnRename);
      CostCenter.GET(DimensionValue.Code);

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostCenterFromDimOnRenameNewCCExists@7();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostCenter@1005 : Record 1112;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostCenterDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 a Cost Center Exists with renamed dimension, error is expected.
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      LibraryDimension.CreateDimensionValue(XDimensionValue,Dimension.Code);

      CreateCostCenter(CostCenter,DimensionValue.Code);

      ASSERTERROR CostAccountMgt.UpdateCostCenterFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnRename);

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostCenterFromDimOnRenameOldCCNotExists@8();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostCenterDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 a Cost Center does not exists with old dimension, function should exit.
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      LibraryDimension.CreateDimensionValue(XDimensionValue,Dimension.Code);

      CostAccountMgt.UpdateCostCenterFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnRename);

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostObjectFromDimOnInsert@15();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostObject@1005 : Record 1113;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostObjectDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 New dimension created and Cost Object Does not exist
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);

      CostAccountMgt.UpdateCostObjectFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnInsert);
      CostObject.GET(DimensionValue.Code);

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtUpdateCostObjectFromDimOnInsertCOExists@14();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostObject@1005 : Record 1113;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostObjectDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 New Dimension Created and Cost Object exists
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);

      CreateCostObject(CostObject,DimensionValue.Code);
      ASSERTERROR CostAccountMgt.UpdateCostObjectFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnInsert);

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostObjectFromDimOnModify@13();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostObject@1005 : Record 1113;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostObjectDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 Cost Object Does not exist
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);

      CostAccountMgt.UpdateCostObjectFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnModify);
      CostObject.GET(DimensionValue.Code);

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostObjectFromDimOnModifyCOExists@12();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostObject@1005 : Record 1113;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostObjectDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 Cost Object exists
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      DimensionValue.Blocked := TRUE;
      DimensionValue.MODIFY;
      CreateCostObject(CostObject,DimensionValue.Code);

      CostAccountMgt.UpdateCostObjectFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnModify);
      CostObject.GET(DimensionValue.Code);
      CostObject.TESTFIELD(Blocked,TRUE);

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostObjectFromDimOnRename@11();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostObject@1005 : Record 1113;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostObjectDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 Cost Object exists and dimension value is renamed
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      LibraryDimension.CreateDimensionValue(XDimensionValue,Dimension.Code);

      CostAccountMgt.UpdateCostObjectFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnRename);
      CostObject.GET(DimensionValue.Code);

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostObjectFromDimOnRenameNewCOExists@10();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostObject@1005 : Record 1113;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostObjectDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 a Cost Object Exists with renamed dimension, error is expected.
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      LibraryDimension.CreateDimensionValue(XDimensionValue,Dimension.Code);

      CreateCostObject(CostObject,DimensionValue.Code);

      ASSERTERROR CostAccountMgt.UpdateCostObjectFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnRename);

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostObjectFromDimOnRenameOldCONotExists@9();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      XDimensionValue@1003 : Record 349;
      CostAccountMgt@1004 : Codeunit 1100;
      InitialCostObjectDimension@1006 : Code[20];
      CallingTrigger@1007 : 'OnInsert,OnModify,,OnRename';
    BEGIN
      // Cod1100 a Cost Object does not exists with old dimension, function should exit.
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      LibraryDimension.CreateDimensionValue(XDimensionValue,Dimension.Code);

      CostAccountMgt.UpdateCostObjectFromDim(DimensionValue,XDimensionValue,CallingTrigger::OnRename);

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostTypeFromDefaultDimensionCC@16();
    VAR
      GLAccount@1013 : Record 15;
      Dimension@1011 : Record 348;
      DimensionValue@1010 : Record 349;
      DefaultDimension@1007 : Record 352;
      CostType@1006 : Record 1103;
      CostCenter@1005 : Record 1112;
      CostAccountingSetup@1003 : Record 1108;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostCenterDimension@1001 : Code[20];
      CallingTrigger@1000 : 'OnInsert,OnModify,OnDelete';
    BEGIN
      // Cod1100
      Initialize;

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::Automatic);
      CostAccountingSetup.GET;
      InitialCostCenterDimension := CostAccountingSetup."Cost Center Dimension";

      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      LibraryDimension.CreateDimension(Dimension);
      LibraryDimension.CreateDimensionValue(DimensionValue,Dimension.Code);
      LibraryDimension.CreateDefaultDimensionGLAcc(DefaultDimension,GLAccount."No.",Dimension.Code,DimensionValue.Code);
      CreateCostCenter(CostCenter,DimensionValue.Code);

      CostAccountingSetup.VALIDATE("Cost Center Dimension",Dimension.Code);
      CostAccountingSetup.MODIFY(TRUE);

      CostAccountMgt.UpdateCostTypeFromDefaultDimension(DefaultDimension,GLAccount,CallingTrigger::OnInsert);

      CostType.RESET;
      CostType.GET(GLAccount."No.");
      GLAccount.TESTFIELD("No.",CostType."No.");
      CostCenter.TESTFIELD(Code,CostType."Cost Center Code");

      CostAccountingSetup.VALIDATE("Align G/L Account",CostAccountingSetup."Align G/L Account"::"No Alignment");
      CostAccountingSetup.VALIDATE("Cost Center Dimension",InitialCostCenterDimension);
      CostAccountingSetup.MODIFY(TRUE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostTypeFromDefaultDimensionCCNotExists@17();
    VAR
      GLAccount@1013 : Record 15;
      Dimension@1011 : Record 348;
      DimensionValue@1010 : Record 349;
      DefaultDimension@1007 : Record 352;
      CostType@1006 : Record 1103;
      CostAccountingSetup@1003 : Record 1108;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostCenterDimension@1001 : Code[20];
      CallingTrigger@1000 : 'OnInsert,OnModify,OnDelete';
    BEGIN
      // Cod1100
      Initialize;

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::Automatic);
      CostAccountingSetup.GET;
      InitialCostCenterDimension := CostAccountingSetup."Cost Center Dimension";

      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      LibraryDimension.CreateDimension(Dimension);
      LibraryDimension.CreateDimensionValue(DimensionValue,Dimension.Code);
      LibraryDimension.CreateDefaultDimensionGLAcc(DefaultDimension,GLAccount."No.",Dimension.Code,DimensionValue.Code);

      CostAccountingSetup.VALIDATE("Cost Center Dimension",Dimension.Code);
      CostAccountingSetup.MODIFY(TRUE);

      CostAccountMgt.UpdateCostTypeFromDefaultDimension(DefaultDimension,GLAccount,CallingTrigger::OnInsert);

      CostType.RESET;
      CostType.GET(GLAccount."No.");
      GLAccount.TESTFIELD("No.",CostType."No.");
      CostType.TESTFIELD("Cost Center Code",'');

      CostAccountingSetup.VALIDATE("Align G/L Account",CostAccountingSetup."Align G/L Account"::"No Alignment");
      CostAccountingSetup.VALIDATE("Cost Center Dimension",InitialCostCenterDimension);
      CostAccountingSetup.MODIFY(TRUE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostTypeFromDefaultDimensionCO@20();
    VAR
      GLAccount@1013 : Record 15;
      Dimension@1011 : Record 348;
      DimensionValue@1010 : Record 349;
      DefaultDimension@1007 : Record 352;
      CostType@1006 : Record 1103;
      CostObject@1005 : Record 1113;
      CostAccountingSetup@1003 : Record 1108;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostObjectDimension@1001 : Code[20];
      CallingTrigger@1000 : 'OnInsert,OnModify,OnDelete';
    BEGIN
      // Cod1100
      Initialize;

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::Automatic);
      CostAccountingSetup.GET;
      InitialCostObjectDimension := CostAccountingSetup."Cost Object Dimension";

      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      LibraryDimension.CreateDimension(Dimension);
      LibraryDimension.CreateDimensionValue(DimensionValue,Dimension.Code);
      LibraryDimension.CreateDefaultDimensionGLAcc(DefaultDimension,GLAccount."No.",Dimension.Code,DimensionValue.Code);
      CreateCostObject(CostObject,DimensionValue.Code);

      CostAccountingSetup.VALIDATE("Cost Object Dimension",Dimension.Code);
      CostAccountingSetup.MODIFY(TRUE);

      CostAccountMgt.UpdateCostTypeFromDefaultDimension(DefaultDimension,GLAccount,CallingTrigger::OnInsert);

      CostType.RESET;
      CostType.GET(GLAccount."No.");
      GLAccount.TESTFIELD("No.",CostType."No.");
      CostObject.TESTFIELD(Code,CostType."Cost Object Code");

      CostAccountingSetup.VALIDATE("Align G/L Account",CostAccountingSetup."Align G/L Account"::"No Alignment");
      CostAccountingSetup.VALIDATE("Cost Object Dimension",InitialCostObjectDimension);
      CostAccountingSetup.MODIFY(TRUE);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtUpdateCostTypeFromDefaultDimensionCONotExists@19();
    VAR
      GLAccount@1013 : Record 15;
      Dimension@1011 : Record 348;
      DimensionValue@1010 : Record 349;
      DefaultDimension@1007 : Record 352;
      CostType@1006 : Record 1103;
      CostAccountingSetup@1003 : Record 1108;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostObjectDimension@1001 : Code[20];
      CallingTrigger@1000 : 'OnInsert,OnModify,OnDelete';
    BEGIN
      // Cod1100
      Initialize;

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::Automatic);
      CostAccountingSetup.GET;
      InitialCostObjectDimension := CostAccountingSetup."Cost Object Dimension";

      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      LibraryDimension.CreateDimension(Dimension);
      LibraryDimension.CreateDimensionValue(DimensionValue,Dimension.Code);
      LibraryDimension.CreateDefaultDimensionGLAcc(DefaultDimension,GLAccount."No.",Dimension.Code,DimensionValue.Code);

      CostAccountingSetup.VALIDATE("Cost Object Dimension",Dimension.Code);
      CostAccountingSetup.MODIFY(TRUE);

      CostAccountMgt.UpdateCostTypeFromDefaultDimension(DefaultDimension,GLAccount,CallingTrigger::OnInsert);

      CostType.RESET;
      CostType.GET(GLAccount."No.");
      GLAccount.TESTFIELD("No.",CostType."No.");
      CostType.TESTFIELD("Cost Object Code",'');

      CostAccountingSetup.VALIDATE("Align G/L Account",CostAccountingSetup."Align G/L Account"::"No Alignment");
      CostAccountingSetup.VALIDATE("Cost Object Dimension",InitialCostObjectDimension);
      CostAccountingSetup.MODIFY(TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestCostAccMgtConfirmIndentCostTypesYes@23();
    VAR
      CostAccountMgt@1000 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      CostAccountMgt.ConfirmIndentCostTypes;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostAccMgtConfirmIndentCostTypesNo@33();
    VAR
      CostAccountMgt@1000 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      ASSERTERROR CostAccountMgt.ConfirmIndentCostTypes;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostAccMgtLinkCostTypesToGLAccountYNNo@30();
    VAR
      CostAccountMgt@1000 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      ASSERTERROR CostAccountMgt.LinkCostTypesToGLAccountsYN;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostAccMgtLinkCostTypesToGLAccountsYNYes@27();
    VAR
      GLAccount@1008 : Record 15;
      CostType@1003 : Record 1103;
      CostAccountingSetup@1002 : Record 1108;
      CostAccountMgt@1001 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::Automatic);
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);

      GLAccount.VALIDATE("Cost Type No.",'');
      GLAccount.MODIFY;

      CostAccountMgt.LinkCostTypesToGLAccountsYN;

      CostType.RESET;
      CostType.GET(GLAccount."No.");
      GLAccount.GET(GLAccount."No.");

      CostType.TESTFIELD("No.",GLAccount."Cost Type No.");

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostAccMgtCreateCostCenters@44();
    VAR
      Dimension@1005 : Record 348;
      DimensionValue@1004 : Record 349;
      CostCenter@1000 : Record 1112;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostCenterDimension@1001 : Code[20];
    BEGIN
      // Cod1100
      Initialize;
      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);

      CostAccountMgt.CreateCostCenters;
      CostCenter.GET(DimensionValue.Code);

      CostCenter.TESTFIELD(Code,DimensionValue.Code);

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostAccMgtCreateCostCentersNoCreatedCC@77();
    VAR
      DimensionValue@1004 : Record 349;
      CostCenter@1000 : Record 1112;
      CostAccountMgt@1002 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      DimensionValue.DELETEALL;
      CostCenter.DELETEALL;

      CostAccountMgt.CreateCostCenters;

      Assert.IsTrue(DimensionValue.ISEMPTY,STRSUBSTNO(Text005,TRUE));

      ASSERTERROR ERROR(Rollback);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestCostAccMgtIndentCostCentersYNYes@32();
    VAR
      CostAccountMgt@1000 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      CostAccountMgt.IndentCostCentersYN;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostAccMgtIndentCostCentersYNNo@31();
    VAR
      CostAccountMgt@1000 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      ASSERTERROR CostAccountMgt.IndentCostCentersYN;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostAccMgtCreateCostObjects@49();
    VAR
      Dimension@1005 : Record 348;
      DimensionValue@1004 : Record 349;
      CostObject@1000 : Record 1113;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostObjectDimension@1001 : Code[20];
    BEGIN
      // Cod1100
      Initialize;
      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);

      CostAccountMgt.CreateCostObjects;
      CostObject.GET(DimensionValue.Code);

      CostObject.TESTFIELD(Code,DimensionValue.Code);

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostAccMgtCreateCostObjectsNoCreatedCO@78();
    VAR
      DimensionValue@1004 : Record 349;
      CostObject@1000 : Record 1113;
      CostAccountMgt@1002 : Codeunit 1100;
    BEGIN
      Initialize;

      DimensionValue.DELETEALL;
      CostObject.DELETEALL;

      CostAccountMgt.CreateCostObjects;

      Assert.IsTrue(DimensionValue.ISEMPTY,STRSUBSTNO(Text005,TRUE));

      ASSERTERROR ERROR(Rollback);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestCostAccMgtIndentCostObjectsYNYes@35();
    VAR
      CostAccountMgt@1000 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      CostAccountMgt.IndentCostObjectsYN;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostAccMgtIndentCostObjectsYNNo@34();
    VAR
      CostAccountMgt@1000 : Codeunit 1100;
    BEGIN
      // Cod1100
      Initialize;

      ASSERTERROR CostAccountMgt.IndentCostObjectsYN;
    END;

    [Test]
    PROCEDURE TestCostAccMgtCheckValidCCAndCOInGLEntryCCNotExists@36();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      CostAccountMgt@1003 : Codeunit 1100;
      InitialCostCenterDimension@1005 : Code[20];
      DimSetID@1002 : Integer;
    BEGIN
      // Cod1100 Cost Center does not exists
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,DimensionValue."Dimension Code",DimensionValue.Code);

      ASSERTERROR CostAccountMgt.CheckValidCCAndCOInGLEntry(DimSetID);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,TextNotDefined) > 0,
        STRSUBSTNO(UnexpectedMessageError,GETLASTERRORTEXT,TextNotDefined));

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtCheckValidCCAndCOInGLEntryCCBlocked@39();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      CostCenter@1004 : Record 1112;
      CostAccountMgt@1003 : Codeunit 1100;
      InitialCostCenterDimension@1007 : Code[20];
      DimSetID@1002 : Integer;
    BEGIN
      // Cod1100 Cost Center is blocked
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,DimensionValue."Dimension Code",DimensionValue.Code);

      CreateCostCenter(CostCenter,DimensionValue.Code);
      CostCenter.VALIDATE(Blocked,TRUE);
      CostCenter.MODIFY(TRUE);

      ASSERTERROR CostAccountMgt.CheckValidCCAndCOInGLEntry(DimSetID);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,TextBlocked) > 0,
        STRSUBSTNO(UnexpectedMessageError,GETLASTERRORTEXT,TextBlocked));

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtCheckValidCCAndCOInGLEntryCCType@40();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      CostCenter@1004 : Record 1112;
      CostAccountMgt@1003 : Codeunit 1100;
      InitialCostCenterDimension@1007 : Code[20];
      DimSetID@1002 : Integer;
    BEGIN
      // Cod1100 Cost Center type is wrong
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,DimensionValue."Dimension Code",DimensionValue.Code);

      CreateCostCenter(CostCenter,DimensionValue.Code);
      CostCenter."Line Type" := CostCenter."Line Type"::Heading;
      CostCenter.MODIFY(TRUE);

      ASSERTERROR CostAccountMgt.CheckValidCCAndCOInGLEntry(DimSetID);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,TextType) > 0,
        STRSUBSTNO(UnexpectedMessageError,GETLASTERRORTEXT,TextType));

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtCheckValidCCAndCOInGLEntryCONotExists@43();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      CostAccountMgt@1003 : Codeunit 1100;
      InitialCostObjectDimension@1006 : Code[20];
      DimSetID@1002 : Integer;
    BEGIN
      // Cod1100 Cost Object does not exists
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,DimensionValue."Dimension Code",DimensionValue.Code);

      ASSERTERROR CostAccountMgt.CheckValidCCAndCOInGLEntry(DimSetID);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,TextNotDefined) > 0,
        STRSUBSTNO(UnexpectedMessageError,GETLASTERRORTEXT,TextNotDefined));

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtCheckValidCCAndCOInGLEntryCOBlocked@42();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      CostObject@1004 : Record 1113;
      CostAccountMgt@1003 : Codeunit 1100;
      InitialCostObjectDimension@1007 : Code[20];
      DimSetID@1002 : Integer;
    BEGIN
      // Cod1100 Cost Object is blocked
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,DimensionValue."Dimension Code",DimensionValue.Code);

      CreateCostObject(CostObject,DimensionValue.Code);
      CostObject.VALIDATE(Blocked,TRUE);
      CostObject.MODIFY(TRUE);

      ASSERTERROR CostAccountMgt.CheckValidCCAndCOInGLEntry(DimSetID);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,TextBlocked) > 0,
        STRSUBSTNO(UnexpectedMessageError,GETLASTERRORTEXT,TextBlocked));

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtCheckValidCCAndCOInGLEntryCOType@41();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      CostObject@1004 : Record 1113;
      CostAccountMgt@1003 : Codeunit 1100;
      InitialCostObjectDimension@1006 : Code[20];
      DimSetID@1002 : Integer;
    BEGIN
      // Cod1100 Cost Object type is wrong
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,DimensionValue."Dimension Code",DimensionValue.Code);

      CreateCostObject(CostObject,DimensionValue.Code);
      CostObject."Line Type" := CostObject."Line Type"::Heading;
      CostObject.MODIFY(TRUE);

      ASSERTERROR CostAccountMgt.CheckValidCCAndCOInGLEntry(DimSetID);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,TextType) > 0,
        STRSUBSTNO(UnexpectedMessageError,GETLASTERRORTEXT,TextType));

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtGetCostCenterCodeFromDimSet@54();
    VAR
      Dimension@1006 : Record 348;
      DimensionValue@1005 : Record 349;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostCenterDimension@1001 : Code[20];
      DimSetID@1000 : Integer;
    BEGIN
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,DimensionValue."Dimension Code",DimensionValue.Code);

      DimensionValue.TESTFIELD(Code,CostAccountMgt.GetCostCenterCodeFromDimSet(DimSetID));

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtGetCostCenterCodeFromInvalidDimSet@76();
    VAR
      DimensionValue@1000 : Record 349;
      CostAccountMgt@1001 : Codeunit 1100;
    BEGIN
      Initialize;
      DimensionValue.INIT;
      DimensionValue.TESTFIELD(Code,CostAccountMgt.GetCostCenterCodeFromDimSet(0));
    END;

    [Test]
    PROCEDURE TestCostAccMgtGetCostCenterCodeFromDefDim@55();
    VAR
      Dimension@1005 : Record 348;
      DimensionValue@1004 : Record 349;
      GLAccount@1006 : Record 15;
      DefaultDimension@1007 : Record 352;
      CostAccountMgt@1001 : Codeunit 1100;
      InitialCostCenterDimension@1000 : Code[20];
    BEGIN
      Initialize;

      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      LibraryDimension.CreateDefaultDimensionGLAcc(DefaultDimension,GLAccount."No.",Dimension.Code,DimensionValue.Code);

      DimensionValue.TESTFIELD(Code,CostAccountMgt.GetCostCenterCodeFromDefDim(DATABASE::"G/L Account",GLAccount."No."));

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtCostCenterExists@56();
    VAR
      Dimension@1006 : Record 348;
      DimensionValue@1005 : Record 349;
      CostCenter@1004 : Record 1112;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostCenterDimension@1001 : Code[20];
    BEGIN
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      CreateCostCenter(CostCenter,DimensionValue.Code);

      Assert.IsTrue(CostAccountMgt.CostCenterExists(DimensionValue.Code),STRSUBSTNO(Text005,TRUE));

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtCostCenterExistsAsDimValue@57();
    VAR
      Dimension@1006 : Record 348;
      DimensionValue@1005 : Record 349;
      CostCenter@1004 : Record 1112;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostCenterDimension@1001 : Code[20];
    BEGIN
      Initialize;

      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      CreateCostCenter(CostCenter,DimensionValue.Code);

      Assert.IsTrue(CostAccountMgt.CostCenterExistsAsDimValue(DimensionValue.Code),STRSUBSTNO(Text005,TRUE));

      CleanCostCenterTestCases(InitialCostCenterDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtGetCostObjectCodeFromDimSet@63();
    VAR
      Dimension@1006 : Record 348;
      DimensionValue@1005 : Record 349;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostObjectDimension@1001 : Code[20];
      DimSetID@1000 : Integer;
    BEGIN
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,DimensionValue."Dimension Code",DimensionValue.Code);

      DimensionValue.TESTFIELD(Code,CostAccountMgt.GetCostObjectCodeFromDimSet(DimSetID));

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtGetCostObjectCodeFromInvalidDimSet@75();
    VAR
      DimensionValue@1001 : Record 349;
      CostAccountMgt@1000 : Codeunit 1100;
    BEGIN
      Initialize;
      DimensionValue.INIT;
      DimensionValue.TESTFIELD(Code,CostAccountMgt.GetCostObjectCodeFromDimSet(0));
    END;

    [Test]
    PROCEDURE TestCostAccMgtGetCostObjectCodeFromDefDim@62();
    VAR
      Dimension@1005 : Record 348;
      DimensionValue@1004 : Record 349;
      GLAccount@1006 : Record 15;
      DefaultDimension@1007 : Record 352;
      CostAccountMgt@1001 : Codeunit 1100;
      InitialCostObjectDimension@1000 : Code[20];
    BEGIN
      Initialize;

      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      LibraryDimension.CreateDefaultDimensionGLAcc(DefaultDimension,GLAccount."No.",Dimension.Code,DimensionValue.Code);

      DimensionValue.TESTFIELD(Code,CostAccountMgt.GetCostObjectCodeFromDefDim(DATABASE::"G/L Account",GLAccount."No."));

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtCostObjectExists@61();
    VAR
      Dimension@1006 : Record 348;
      DimensionValue@1005 : Record 349;
      CostObject@1004 : Record 1113;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostObjectDimension@1001 : Code[20];
    BEGIN
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      CreateCostObject(CostObject,DimensionValue.Code);

      Assert.IsTrue(CostAccountMgt.CostObjectExists(DimensionValue.Code),STRSUBSTNO(Text005,TRUE));

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtCostObjectExistsAsDimValue@60();
    VAR
      Dimension@1006 : Record 348;
      DimensionValue@1005 : Record 349;
      CostObject@1004 : Record 1113;
      CostAccountMgt@1002 : Codeunit 1100;
      InitialCostObjectDimension@1001 : Code[20];
    BEGIN
      Initialize;

      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      CreateCostObject(CostObject,DimensionValue.Code);

      Assert.IsTrue(CostAccountMgt.CostObjectExistsAsDimValue(DimensionValue.Code),STRSUBSTNO(Text005,TRUE));

      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    PROCEDURE TestCostAccMgtInsertCostBudgetRegister@64();
    VAR
      CostBudgetRegister@1004 : Record 1111;
      CostBudgetName@1002 : Record 1110;
      CostAccountMgt@1005 : Codeunit 1100;
      CostBudgetAmount@1003 : Decimal;
      InsertedCostBudgetRegisterNo@1000 : Integer;
      CostBudgetEntryNo@1001 : Integer;
    BEGIN
      // COD 1100
      Initialize;

      CostBudgetEntryNo := LibraryRandom.RandInt(1000);
      LibraryCostAccounting.CreateCostBudgetName(CostBudgetName);
      CostBudgetAmount := LibraryRandom.RandDec(100,2);

      InsertedCostBudgetRegisterNo := CostAccountMgt.InsertCostBudgetRegister(CostBudgetEntryNo,CostBudgetName.Name,CostBudgetAmount);
      CostBudgetRegister.FINDLAST;
      CostBudgetRegister.TESTFIELD("No.",InsertedCostBudgetRegisterNo);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtIsGLAccNoFirstFromRangeGLAccFirst@72();
    VAR
      CostType@1003 : Record 1103;
      GLAcc@1002 : Record 15;
      CostAccountingSetup@1000 : Record 1108;
      CostAccountMgt@1001 : Codeunit 1100;
    BEGIN
      // COD 1100
      Initialize;

      LibraryCostAccounting.CreateCostTypeWithGLRange(CostType,TRUE);
      GLAcc.SETFILTER("No.",CostType."G/L Account Range");
      GLAcc.FINDFIRST;

      Assert.IsTrue(CostAccountMgt.IsGLAccNoFirstFromRange(CostType,GLAcc."No."),STRSUBSTNO(Text005,FALSE));
      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostAccMgtIsGLAccNoFirstFromRangeGLAccLast@81();
    VAR
      CostType@1003 : Record 1103;
      GLAcc@1002 : Record 15;
      CostAccountingSetup@1000 : Record 1108;
      CostAccountMgt@1001 : Codeunit 1100;
    BEGIN
      // COD 1100
      Initialize;

      LibraryCostAccounting.CreateCostTypeWithGLRange(CostType,TRUE);
      GLAcc.SETFILTER("No.",CostType."G/L Account Range");
      GLAcc.FINDLAST;

      Assert.IsFalse(CostAccountMgt.IsGLAccNoFirstFromRange(CostType,GLAcc."No."),STRSUBSTNO(Text005,FALSE));
      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");
    END;

    [Test]
    PROCEDURE TestCostAccMgtIsGLAccNoFirstFromRangeNoGLAccExists@80();
    VAR
      CostType@1003 : Record 1103;
      GLAcc@1002 : Record 15;
      CostAccountMgt@1001 : Codeunit 1100;
    BEGIN
      // COD 1100
      Initialize;
      CostType.INIT;
      GLAcc.INIT;
      Assert.IsFalse(CostAccountMgt.IsGLAccNoFirstFromRange(CostType,GLAcc."No."),STRSUBSTNO(Text005,FALSE));
    END;

    [Test]
    PROCEDURE TestCostAccMgtGetCostTypeCTNotExist@79();
    VAR
      GLAcc@1001 : Record 15;
      CostAccountingSetup@1004 : Record 1108;
      CostAccountMgt@1002 : Codeunit 1100;
      CostTypeExists@1003 : Boolean;
    BEGIN
      // COD 1100
      Initialize;

      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAcc);
      CostAccountMgt.GetCostType(GLAcc."No.",CostTypeExists);
      Assert.IsFalse(CostTypeExists,STRSUBSTNO(Text005,FALSE));
      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");
    END;

    [Test]
    PROCEDURE TestCostAccJnlCheckLineOnRun@67();
    VAR
      CostJournalLine@1000 : Record 1101;
      CostJournalTemplate@1001 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      CostObject@1005 : Record 1113;
      BalCostObject@1004 : Record 1113;
    BEGIN
      // COD 1101
      Initialize;

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      LibraryCostAccounting.CreateCostObject(CostObject);
      LibraryCostAccounting.CreateCostObject(BalCostObject);
      CostJournalLine."Cost Center Code" := CostObject.Code;
      CostJournalLine."Bal. Cost Center Code" := BalCostObject.Code;
      CostJournalLine.MODIFY;
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Check Line",CostJournalLine);
    END;

    [Test]
    PROCEDURE TestCostAccJnlCheckLineRunCheck@5();
    VAR
      CostJournalLine@1000 : Record 1101;
      CostJournalTemplate@1001 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      CostObject@1005 : Record 1113;
      BalCostObject@1004 : Record 1113;
      CAJnlCheckLine@1003 : Codeunit 1101;
    BEGIN
      // COD 1101
      Initialize;

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      LibraryCostAccounting.CreateCostObject(CostObject);
      LibraryCostAccounting.CreateCostObject(BalCostObject);
      CostJournalLine."Cost Center Code" := CostObject.Code;
      CostJournalLine."Bal. Cost Center Code" := BalCostObject.Code;
      CostJournalLine.MODIFY;
      CAJnlCheckLine.RunCheck(CostJournalLine);
    END;

    [Test]
    PROCEDURE TestCostAccJnlCheckLineRunCheckCostTypeAndBalCostTypeAreBlank@6();
    VAR
      CostJournalLine@1000 : Record 1101;
      CostJournalTemplate@1001 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      CAJnlCheckLine@1003 : Codeunit 1101;
    BEGIN
      // COD 1101
      Initialize;

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      CostJournalLine."Cost Type No." := '';
      CostJournalLine."Bal. Cost Type No." := '';
      CostJournalLine.MODIFY;
      ASSERTERROR CAJnlCheckLine.RunCheck(CostJournalLine);
    END;

    [Test]
    PROCEDURE TestCostAccJnlCheckLineRunCheckCostCenterAndCostObjectAreBlank@53();
    VAR
      CostJournalLine@1000 : Record 1101;
      CostJournalTemplate@1001 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      CAJnlCheckLine@1003 : Codeunit 1101;
    BEGIN
      // COD 1101
      Initialize;

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      CostJournalLine."Cost Center Code" := '';
      CostJournalLine."Cost Object Code" := '';
      CostJournalLine."Source Code" :=
        COPYSTR(LibraryUtility.GenerateRandomCode(CostJournalLine.FIELDNO("Source Code"),DATABASE::"Cost Journal Line"),
          1,LibraryUtility.GetFieldLength(DATABASE::"Cost Journal Line",CostJournalLine.FIELDNO("Source Code")));
      CostJournalLine.MODIFY;
      ASSERTERROR CAJnlCheckLine.RunCheck(CostJournalLine);
    END;

    [Test]
    PROCEDURE TestCostAccJnlCheckLineRunCheckCostCenterAndCostObjectAreNotBlank@66();
    VAR
      CostJournalLine@1000 : Record 1101;
      CostJournalTemplate@1001 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      CAJnlCheckLine@1003 : Codeunit 1101;
    BEGIN
      // COD 1101
      Initialize;

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      CostJournalLine."Cost Center Code" :=
        COPYSTR(LibraryUtility.GenerateRandomCode(CostJournalLine.FIELDNO("Cost Center Code"),DATABASE::"Cost Journal Line"),
          1,LibraryUtility.GetFieldLength(DATABASE::"Cost Journal Line",CostJournalLine.FIELDNO("Cost Center Code")));

      CostJournalLine."Cost Object Code" :=
        COPYSTR(LibraryUtility.GenerateRandomCode(CostJournalLine.FIELDNO("Cost Object Code"),DATABASE::"Cost Journal Line"),
          1,LibraryUtility.GetFieldLength(DATABASE::"Cost Journal Line",CostJournalLine.FIELDNO("Cost Object Code")));

      CostJournalLine.MODIFY;
      ASSERTERROR CAJnlCheckLine.RunCheck(CostJournalLine);
    END;

    [Test]
    PROCEDURE TestCostAccJnlCheckLineRunCheckBalanceCostCenterAndBalanceCostObjectAreBlank@69();
    VAR
      CostJournalLine@1000 : Record 1101;
      CostJournalTemplate@1001 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      CAJnlCheckLine@1003 : Codeunit 1101;
    BEGIN
      // COD 1101
      Initialize;

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      CostJournalLine."Bal. Cost Center Code" := '';
      CostJournalLine."Bal. Cost Object Code" := '';
      CostJournalLine.MODIFY;
      ASSERTERROR CAJnlCheckLine.RunCheck(CostJournalLine);
    END;

    [Test]
    PROCEDURE TestCostAccJnlCheckLineRunCheckBalanceCostCenterAndBalanceCostObjectAreNotBlank@68();
    VAR
      CostJournalLine@1000 : Record 1101;
      CostJournalTemplate@1001 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      CAJnlCheckLine@1003 : Codeunit 1101;
    BEGIN
      // COD 1101
      Initialize;

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      CostJournalLine."Bal. Cost Center Code" :=
        COPYSTR(LibraryUtility.GenerateRandomCode(CostJournalLine.FIELDNO("Bal. Cost Center Code"),DATABASE::"Cost Journal Line"),
          1,LibraryUtility.GetFieldLength(DATABASE::"Cost Journal Line",CostJournalLine.FIELDNO("Bal. Cost Center Code")));

      CostJournalLine."Bal. Cost Object Code" :=
        COPYSTR(LibraryUtility.GenerateRandomCode(CostJournalLine.FIELDNO("Bal. Cost Object Code"),DATABASE::"Cost Journal Line"),
          1,LibraryUtility.GetFieldLength(DATABASE::"Cost Journal Line",CostJournalLine.FIELDNO("Bal. Cost Object Code")));

      CostJournalLine.MODIFY;
      ASSERTERROR CAJnlCheckLine.RunCheck(CostJournalLine);
    END;

    [Test]
    PROCEDURE TestCostAccJnlPostLineCAJnlPostLineOnRun@70();
    VAR
      CostJournalLine@1005 : Record 1101;
      CostJournalTemplate@1004 : Record 1100;
      CostJournalBatch@1003 : Record 1102;
      CostObject@1001 : Record 1113;
      BalCostObject@1002 : Record 1113;
    BEGIN
      // COD 1102
      Initialize;

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      LibraryCostAccounting.CreateCostObject(CostObject);
      LibraryCostAccounting.CreateCostObject(BalCostObject);
      CostJournalLine."Cost Center Code" := CostObject.Code;
      CostJournalLine."Bal. Cost Center Code" := BalCostObject.Code;
      CostJournalLine.MODIFY;
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post Line",CostJournalLine)
    END;

    [Test]
    PROCEDURE TestFirstCostJournalTemplateCreation@102();
    VAR
      CostJournalLine@1002 : Record 1101;
      CostJournalTemplate@1000 : Record 1100;
      CostJnlManagement@1001 : Codeunit 1106;
      JnlSelected@1003 : Boolean;
    BEGIN
      // Test if no cost journal template exist then a default value is inserted and JnlSelected is TRUE with Cost Journal Line remains empty.

      // Setup: Setup Demo Data and make Cost Journal Setup Blank.
      Initialize;
      CostJournalTemplate.DELETEALL;

      // Exercise: Execute TemplateSelection function of CostJnlManagement.
      CostJnlManagement.TemplateSelection(CostJournalLine,JnlSelected);

      // Verify: Verify that if no cost journal template is present in setup then a default setup will be created
      // with Template name as "STANDARD" and Description as "Standard Template".
      VerifyCostJournalTemplate(JnlSelected);
      Assert.IsTrue(CostJournalLine.ISEMPTY,STRSUBSTNO(CostJournlLineError,CostJournalLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE TestSingleCostJournalTemplate@99();
    VAR
      CostJournalLine@1002 : Record 1101;
      CostJournalTemplate@1004 : Record 1100;
      CostJnlManagement@1003 : Codeunit 1106;
      JnlSelected@1001 : Boolean;
    BEGIN
      // Test if single cost journal template exist then JnlSelected is TRUE.

      // Setup: Setup Demo Data.Make Cost Journal Setup Blank and create a single cost journal template.
      Initialize;
      CostJournalTemplate.DELETEALL;
      LibraryCostAccounting.CreateCostJournalTemplate(CostJournalTemplate);

      // Exercise: Execute TemplateSelection function of CostJnlManagement.
      CostJnlManagement.TemplateSelection(CostJournalLine,JnlSelected);

      // Verify: Verify that JnlSelected is TRUE for a single Cost Journal Template.
      Assert.IsTrue(JnlSelected,STRSUBSTNO(TemplateSelectionError,CostJournalTemplate.TABLECAPTION));
    END;

    [Test]
    [HandlerFunctions(CostJournalTemplatePageHandler)]
    PROCEDURE TestMultipleCostJournalTemplate@98();
    VAR
      CostJournalTemplate@1002 : Record 1100;
      CostJournalLine@1000 : Record 1101;
      CostJnlManagement@1001 : Codeunit 1106;
      JnlSelected@1003 : Boolean;
      i@1004 : Integer;
    BEGIN
      // Test if more then one journal template exist then cost journal template page is open up for selection and JnlSelection get TRUE.

      // Setup: Setup Demo Data.Create more then one Cost Journal Template.
      Initialize;
      IF CostJournalTemplate.COUNT < 2 THEN
        FOR i := 0 TO 2 DO  // records to contibute in scenerios of multiple records
          LibraryCostAccounting.CreateCostJournalTemplate(CostJournalTemplate);

      // Exercise: Execute TemplateSelection function of CostJnlManagement.
      CostJnlManagement.TemplateSelection(CostJournalLine,JnlSelected);

      // Verify: Verify that when more then one  cost journal template are there then a page is open for selection of journal template and JnlSelection is TRUE.
      Assert.IsTrue(JnlSelected,STRSUBSTNO(TemplateSelectionError,CostJournalTemplate.TABLECAPTION));
    END;

    [Test]
    [HandlerFunctions(CostJournalPageHandler)]
    PROCEDURE TestCostJournalBatchNameOnCostJournalPage@97();
    VAR
      CostJournalBatch@1000 : Record 1102;
      CostJnlManagement@1001 : Codeunit 1106;
    BEGIN
      // Test Cost Journal Batch name on Cost Journal Batch Page when opened through batch.

      // Setup: Create a new cost journal template and cost journal batch.
      Initialize;
      CreateCostJournalBatch(CostJournalBatch);

      // Exercise: Execute TemplateSelectionFromBatch function of CostJnlManagement.
      CostJnlManagement.TemplateSelectionFromBatch(CostJournalBatch);

      // Verify: Cost Journal Page open with the same value of created batch when open through batches.
      Assert.AreEqual(CostJournalBatch.Name,CostJnlBatchName,STRSUBSTNO(ExpectedBatchError,CostJournalBatch.Name));
    END;

    [Test]
    PROCEDURE TestCostJournalBatchName@114();
    VAR
      CostJournalTemplate@1000 : Record 1100;
      CostJnlManagement@1001 : Codeunit 1106;
      CostJnlBatchName@1002 : Code[10];
    BEGIN
      // Check a DEFAULT Cost journal batch name is created for a new cost journal template if no cost journal batch name exists for it.

      // Setup: Create a new cost journal template.
      Initialize;
      LibraryCostAccounting.CreateCostJournalTemplate(CostJournalTemplate);

      // Exercise: Execute CheckTemplate function of CostJnlManagement.
      CostJnlManagement.CheckTemplateName(CostJournalTemplate.Name,CostJnlBatchName);

      // Verify: Verify that a DEFAULT cost journal batch is created for a new cost journal template.
      VerifyCostJournalBatch(CostJournalTemplate.Name);
    END;

    [Test]
    PROCEDURE TestCalculatedBalance@103();
    VAR
      CostJournalLine@1001 : Record 1101;
      TempCostJournalLine@1000 : TEMPORARY Record 1101;
      CostJournalBatch@1003 : Record 1102;
      Index@1002 : Integer;
      Balance@1005 : Decimal;
      TotalBalance@1006 : Decimal;
      ShowBalance@1007 : Boolean;
      ShowTotalBalance@1008 : Boolean;
      ExpectedBalance@1009 : Decimal;
    BEGIN
      // Test balance and totalbalance on cost journal page when Bal Cost Type No. and Bal. Cost Center Code are blank.

      // Setup: Create a new cost journal batch.
      Initialize;
      CreateCostJournalBatch(CostJournalBatch);

      // Exercise: Create multiple cost Journal line and execute CalcBalance of CostJnlManagement.
      FOR Index := 1 TO LibraryRandom.RandInt(3) DO BEGIN
        CreateCostJnlLineAndxCostJnlLine(
          CostJournalLine,TempCostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);
        ExpectedBalance += CostJournalLine.Balance;
        UpdateCostJournalLineBalance(
          CostJournalLine,TempCostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name,Balance,
          TotalBalance,ShowBalance,ShowTotalBalance);
      END;

      // Verify: Verify that balance and total balance are equal to expected balance and expected total balance.
      Assert.AreEqual(ExpectedBalance,Balance,STRSUBSTNO(ExpectedBalanceError,CostJournalLine.TABLECAPTION));
      Assert.AreEqual(ExpectedBalance,TotalBalance,STRSUBSTNO(ExpectedTotBalanceError,CostJournalLine.TABLECAPTION));
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestTransferGLEntriesToCAWithNoGLEntries@106();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      InitialCostCenterDimension@1006 : Code[20];
      InitialCostObjectDimension@1002 : Code[20];
    BEGIN
      // Test that error will appear if Transfer GL Entries to CA will run without any G/L Entries.

      // Setup: Setting the new cost center and cost object dimension in Cost Accounting setup.
      Initialize;
      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);

      // Exercise: Run Transfer GL Entries to CA.
      ASSERTERROR CODEUNIT.RUN(CODEUNIT::"Transfer GL Entries to CA");

      // Verify: Verify that Expected error. will appear.
      Assert.ExpectedError(NoGLEntriesTransferedError);

      // Tear down.
      CleanCostCenterTestCases(InitialCostCenterDimension);
      CleanCostObjectTestCases(InitialCostObjectDimension);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestTransferGLEntriesToCACheckCAEntriesByCostCenter@113();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      CostCenter@1005 : Record 1112;
      GenJournalLine@1004 : Record 81;
      CostAccountingSetup@1003 : Record 1108;
      TransferGLEntriesToCA@1008 : Codeunit 1105;
      OldAlignmentValue@1021 : Option;
      InitialCostCenterDimension@1002 : Code[20];
    BEGIN
      // Test the Cost register and cost enries after running Transfer GL Entries to CA after G/L entries posted with Cost Center dimension.

      // Setup: Setting the new cost center in cost center dimension in Cost Accounting setup and setting Align G/L Account to Automatic.
      // Creating a new cost center.
      // Run Transfer GL Entries to CA before exercise to avoid local posted data influence
      Initialize;
      CLEAR(TransferGLEntriesToCA);
      TransferGLEntriesToCA.TransferGLtoCA;
      UpdateCostAccountingSetup(OldAlignmentValue);
      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      LibraryCostAccounting.CreateCostCenter(CostCenter);
      CostCenter.RENAME(DimensionValue.Code);

      // Exercise: Creating and posting the General Journal Line with dimension and then run the batch Transfer GL Entries to CA.
      CreateGeneralLineWithDimension(GenJournalLine,DimensionValue."Dimension Code",DimensionValue.Code);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
      CLEAR(TransferGLEntriesToCA);
      TransferGLEntriesToCA.TransferGLtoCA;

      // Verify: Verify the cost register and cost entries with cost center.
      ValidateCreatedEntries(CostCenter.Code,'');

      // Tear down.
      CleanCostCenterTestCases(InitialCostCenterDimension);
      LibraryCostAccounting.SetAlignment(CostAccountingSetup.FIELDNO("Align G/L Account"),OldAlignmentValue);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestTransferGLEntriesToCACheckCAEntriesByCostObject@119();
    VAR
      Dimension@1000 : Record 348;
      DimensionValue@1001 : Record 349;
      CostObject@1005 : Record 1113;
      GenJournalLine@1004 : Record 81;
      CostAccountingSetup@1003 : Record 1108;
      TransferGLEntriesToCA@1008 : Codeunit 1105;
      OldAlignmentValue@1021 : Option;
      InitialCostObjectDimension@1002 : Code[20];
    BEGIN
      // Test the Cost register and cost enries after running Transfer GL Entries to CA after G/L entries posted with Cost Object dimension.

      // Setup: Setting the new dimension in cost object dimension in Cost Accounting setup and setting Align G/L Account to Automatic.
      // Creaing a new cost object.
      Initialize;
      UpdateCostAccountingSetup(OldAlignmentValue);
      SetupCostObjectTestCases(Dimension,DimensionValue,InitialCostObjectDimension);
      LibraryCostAccounting.CreateCostObject(CostObject);
      CostObject.RENAME(DimensionValue.Code);

      // Exercise: Creating and posting the General Journal Line with dimension and then run the batch Transfer GL Entries to CA.
      CreateGeneralLineWithDimension(GenJournalLine,DimensionValue."Dimension Code",DimensionValue.Code);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
      TransferGLEntriesToCA.TransferGLtoCA;

      // Verify: Verify the cost register and cost entries with cost object.
      ValidateCreatedEntries('',CostObject.Code);

      // Tear down.
      CleanCostObjectTestCases(InitialCostObjectDimension);
      LibraryCostAccounting.SetAlignment(CostAccountingSetup.FIELDNO("Align G/L Account"),OldAlignmentValue);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestTransferGLEntriesToCALinkCostTypesToGLAccountsConfirmYes@154();
    VAR
      Dimension@1003 : Record 348;
      DimensionValue@1000 : Record 349;
      CostType@1004 : Record 1103;
      GLAccount@1002 : Record 15;
      CostAccountingSetup@1001 : Record 1108;
      CostCenter@1007 : Record 1112;
      GenJournalLine@1009 : Record 81;
      InitialCostCenterDimension@1006 : Code[20];
      OldAlignmentValue@1011 : Option;
    BEGIN
      // Test that the LinkCostTypesToGLAccounts works correctly if confirm is Yes.

      // Setup: Setting the new dimension in cost center dimension in Cost Accounting setup and setting Align G/L Account to Automatic.
      // Creating the General Journal line with dimension and then posting the line.
      Initialize;
      UpdateCostAccountingSetup(OldAlignmentValue);
      SetupCostCenterTestCases(Dimension,DimensionValue,InitialCostCenterDimension);
      LibraryCostAccounting.CreateCostCenter(CostCenter);
      CostCenter.RENAME(DimensionValue.Code);
      CreateGeneralLineWithDimension(GenJournalLine,DimensionValue."Dimension Code",DimensionValue.Code);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");

      // Exercise: Creating new G/L Account and Cost Type and then run the batch Transfer GL Entries to CA.
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      LibraryCostAccounting.CreateCostTypeNoGLRange(CostType);
      UpdateCostType(CostType,GLAccount."No.",CostType.Type::"Cost Type");
      CODEUNIT.RUN(CODEUNIT::"Transfer GL Entries to CA");

      // Verify: Verify that Cost Type No. should not be blank in G/L Account.
      GLAccount.GET(CostType."G/L Account Range");
      GLAccount.TESTFIELD("Cost Type No.",CostType."No.");

      // Tear down.
      CleanCostCenterTestCases(InitialCostCenterDimension);
      LibraryCostAccounting.SetAlignment(CostAccountingSetup.FIELDNO("Align G/L Account"),OldAlignmentValue);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestTransferGLEntriesToCALinkCostTypesToGLAccountsConfirmYNo@124();
    VAR
      CostType@1004 : Record 1103;
      GLAccount@1002 : Record 15;
    BEGIN
      // Test that the LinkCostTypesToGLAccounts works correctly if confirm is No.

      // Setup: Create G/L Account and Cost Type.
      Initialize;
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      LibraryCostAccounting.CreateCostTypeNoGLRange(CostType);

      // Exercise: Update Cost type and and then run the batch Transfer GL Entries to CA.
      UpdateCostType(CostType,GLAccount."No.",CostType.Type::"Cost Type");
      CODEUNIT.RUN(CODEUNIT::"Transfer GL Entries to CA");

      // Verify: Verify that Cost Type No. should be blank in G/L Account.
      GLAccount.GET(CostType."G/L Account Range");
      GLAccount.TESTFIELD("Cost Type No.",'')
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageWhenPostedSuccessfullyHandler)]
    PROCEDURE TestPostLinesDirectlyFromBatch@125();
    VAR
      CostJournalBatch@1001 : Record 1102;
      CostJournalLine@1000 : Record 1101;
      LineNo@1002 : Integer;
    BEGIN
      // Test to verify that when cost journal lines get posted it shows the appropriate message and line doenot exist on Cost Journal Line.

      // Setup: Find a cost Journal batch.
      Initialize;
      FindCostJnlBatchAndTemplate(CostJournalBatch);

      // Exercise: Create Cost journal line to get posted.
      LibraryCostAccounting.CreateCostJournalLine(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);
      LineNo := CostJournalLine."Line No.";
      COMMIT;
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-B. Post",CostJournalBatch);

      // Verify: Verify that the Cost Journal Line should not exist.
      ASSERTERROR CostJournalLine.GET(CostJournalBatch."Journal Template Name",CostJournalBatch.Name,LineNo);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageWhenPostingFailsHandler)]
    PROCEDURE TestPostDirectlyFromBatchToStopLinePosting@123();
    VAR
      CostJournalBatch@1001 : Record 1102;
      CostJournalLine@1000 : Record 1101;
      LineNo@1002 : Integer;
      JournalBatchName@1003 : Code[10];
    BEGIN
      // Test to verify that when cost journal lines did not get posted it shows the appropriate message and line exist on Cost Journal Line.

      // Setup: Find a cost Journal batch.
      Initialize;
      FindCostJnlBatchAndTemplate(CostJournalBatch);

      // Exercise: Create Cost journal lines with basic conditions so that it did not get posted.
      LibraryCostAccounting.CreateCostJournalLineBasic(
        CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name,WORKDATE,'','');
      LineNo := CostJournalLine."Line No.";
      JournalBatchName := CostJournalLine."Journal Batch Name";
      COMMIT;
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-B. Post",CostJournalBatch);

      // Verify: Verify that the Cost Journal Line should exist.
      CostJournalLine.GET(CostJournalBatch."Journal Template Name",JournalBatchName,LineNo);
    END;

    [Test]
    PROCEDURE TestCostJnlPostBatchValidateCostJnlBatchName@135();
    VAR
      CostJournalLine@1004 : Record 1101;
      CostJournalBatch@1000 : Record 1102;
    BEGIN
      // Unit test - Codeunit 1103-CA Jnl.-Post Batch-Test error is displayed when Cost Journal Batch Name exceed its defined length.

      // Setup: Create Cost Journal Batch Name of maximum length.
      Initialize;
      CreateCostJournalBatch(CostJournalBatch);
      CostJnlBatchName := INSSTR(DELSTR(CostJournalBatch.Name,9,2),'A9',9); // Modified to generate error.
      CostJournalBatch.RENAME(CostJournalBatch."Journal Template Name",CostJnlBatchName);

      // Exercise: Post Cost Journal Line.
      LibraryCostAccounting.CreateCostJournalLine(CostJournalLine,CostJournalBatch."Journal Template Name",CostJnlBatchName);
      ASSERTERROR CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post Batch",CostJournalLine);

      // Verify: Error occurs when Cost Journal Batch Name exceed its defined length.
      Assert.ExpectedError(
        STRSUBSTNO(
          CostJnlBatchNameLengthError,CostJournalBatch.FIELDCAPTION(Name),MAXSTRLEN(CostJournalBatch.Name),
          CostJournalBatch.TABLECAPTION,CostJournalBatch.FIELDCAPTION("Journal Template Name"),
          CostJournalBatch."Journal Template Name",CostJournalBatch.FIELDCAPTION(Name),CostJournalBatch.Name));
    END;

    [Test]
    PROCEDURE TestCostJnlPostBatchValidateCostJnlLinePost@134();
    VAR
      CostJournalLine@1001 : Record 1101;
      CostJournalBatch@1000 : Record 1102;
      CostJournalAmount@1003 : Decimal;
      CostJournalDocumentNo@1004 : Code[20];
    BEGIN
      // Unit test - Codeunit 1103-CA Jnl.-Post Batch-Test Cost Journal Line is posted successfully in Cost Entries.

      // Setup: Create Cost Journal line and store the value of Amount and Document No. Field.
      Initialize;
      CreateCostJournalBatch(CostJournalBatch);
      LibraryCostAccounting.CreateCostJournalLine(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);
      CostJournalAmount := CostJournalLine.Amount;
      CostJournalDocumentNo := CostJournalLine."Document No.";

      // Exercise: Post Cost Journal Line.
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post Batch",CostJournalLine);

      // Verify: To check if amount of respective Cost Journal Line is posted correctly on Cost entries.
      VerifyCostEntry(CostJournalDocumentNo,CostJournalAmount);
    END;

    [Test]
    PROCEDURE TestCostJnlPostBatchCheckBalance@133();
    VAR
      CostJournalLine@1004 : Record 1101;
      CostJournalBatch@1002 : Record 1102;
    BEGIN
      // Unit test - Codeunit 1103-CA Jnl.-Post Batch-Test that error is displayed on posting Cost Journal Line when Balance Cost Type No. Field is blank.

      // Setup: Create Cost Journal Line and set Bal. Cost Type No. to blank.
      Initialize;
      CreateCostJournalBatch(CostJournalBatch);
      LibraryCostAccounting.CreateCostJournalLine(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);
      UpdateCostJournalLine(CostJournalLine);

      // Exercise: Post Cost Journal Line.
      ASSERTERROR CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post Batch",CostJournalLine);

      // Verify: Error occurs on posting Cost Journal Line when Balance Cost Type No. Field is blank.
      Assert.ExpectedError(
        STRSUBSTNO(
          CostJournalLineBalanceError,CostJournalLine.Balance,CostJournalLine.FIELDCAPTION("Posting Date"),
          CostJournalLine.FIELDCAPTION(Amount)));
    END;

    [Test]
    PROCEDURE TestCostJnlPostBatchCostJnlLineAfterPost@132();
    VAR
      CostJournalLine@1003 : Record 1101;
      CostJournalBatch@1001 : Record 1102;
      LineNo@1004 : Integer;
    BEGIN
      // Unit test - Codeunit 1103-CA Jnl.-Post Batch-Test that Cost Journal Line is deleted successfully after posting it.

      // Setup: Create Cost Journal line and store the value of Journal Template Name, Journal Batch Name and Line No.
      Initialize;
      CreateCostJournalBatch(CostJournalBatch);

      // Exercise: Create and Post Cost Journal Line.
      LibraryCostAccounting.CreateCostJournalLine(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);
      LineNo := CostJournalLine."Line No.";
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Post Batch",CostJournalLine);

      // Verify: Check if repective Cost Journal Line is deleted after posting it.
      ASSERTERROR CostJournalLine.GET(CostJournalBatch."Journal Template Name",CostJournalBatch.Name,LineNo);
    END;

    [Test]
    PROCEDURE TestChartOfCostCenterIndent@155();
    VAR
      CostCenter@1000 : ARRAY [4] OF Record 1112;
      CostAccMgt@1001 : Codeunit 1100;
      i@1007 : Integer;
      Totaling@1002 : Text[250];
    BEGIN
      // Test that system indents cost centers correctly with different Line Types.

      // Setup: Create four Cost Centers of different Line Type.
      Initialize;
      FOR i := 1 TO 4 DO
        LibraryCostAccounting.CreateCostCenter(CostCenter[i]);
      Totaling := STRSUBSTNO(CostCenterObjectFilterDefinition,CostCenter[1].Code,CostCenter[2].Code,CostCenter[3].Code);

      UpdateCostCenter(CostCenter[1],CostCenter[1]."Line Type"::"Begin-Total");
      UpdateCostCenter(CostCenter[4],CostCenter[1]."Line Type"::"End-Total");

      // Exercise: Indent cost centers.
      CostAccMgt.IndentCostCenters;

      // Verify: To verify the indentation of created Cost Center after invoking Indent Cost Center Action.
      VerifyChartOfCostCenterIndent(CostCenter[1].Code,CostCenter[4].Code,Totaling);
    END;

    [Test]
    PROCEDURE TestChartOfCostObjectIndent@137();
    VAR
      CostObject@1000 : ARRAY [4] OF Record 1113;
      CostAccMgt@1001 : Codeunit 1100;
      i@1007 : Integer;
      Totaling@1002 : Text[250];
    BEGIN
      // Test that system indents cost objects correctly with different Line Types.

      // Setup: Create four Cost Objects of different Line Type.
      Initialize;
      FOR i := 1 TO 4 DO
        LibraryCostAccounting.CreateCostObject(CostObject[i]);
      Totaling := STRSUBSTNO(CostCenterObjectFilterDefinition,CostObject[1].Code,CostObject[2].Code,CostObject[3].Code);

      UpdateCostObject(CostObject[1],CostObject[1]."Line Type"::"Begin-Total");
      UpdateCostObject(CostObject[4],CostObject[4]."Line Type"::"End-Total");

      // Exercise: Indent cost objects.
      CostAccMgt.IndentCostObjects;

      // Verify: To verify the indentation of created Cost Object after invoking Indent Cost Object Action.
      VerifyChartOfCostObjectIndent(CostObject[1].Code,CostObject[4].Code,Totaling);
    END;

    [Test]
    PROCEDURE TestChartOfCostTypeIndent@136();
    VAR
      CostType@1000 : ARRAY [4] OF Record 1103;
      CostAccMgt@1001 : Codeunit 1100;
      i@1007 : Integer;
      Totaling@1002 : Text[250];
    BEGIN
      // Test that system indents cost objects correctly with different Types.

      // Setup: Create four Cost Type of different Type.
      Initialize;
      FOR i := 1 TO 4 DO
        LibraryCostAccounting.CreateCostTypeNoGLRange(CostType[i]);
      Totaling := STRSUBSTNO(CostTypeFilterDefinition,CostType[1]."No.",CostType[4]."No.");

      UpdateCostType(CostType[1],'',CostType[1].Type::"Begin-Total");
      UpdateCostType(CostType[4],'',CostType[4].Type::"End-Total");

      // Exercise: Indent cost types.
      CostAccMgt.IndentCostTypes(TRUE);

      // Verify: To verify the indentation of created Cost Type after invoking Indent Cost Type Action.
      VerifyChartOfCostTypeIndent(CostType[1]."No.",CostType[4]."No.",Totaling);
    END;

    [Test]
    PROCEDURE TestCostCenterEndTotalError@148();
    VAR
      CostCenter@1000 : Record 1112;
      CostAccountMgt@1001 : Codeunit 1100;
    BEGIN
      // Test that system throws error while running Indent Cost Center when there is no corresponding Begin Total for End Total Cost Center.

      // Setup: Create Cost Center of Line Type End-Total.
      Initialize;
      LibraryCostAccounting.CreateCostCenter(CostCenter);
      UpdateCostCenter(CostCenter,CostCenter."Line Type"::"End-Total");

      // Exercise: Indent cost centers.
      ASSERTERROR CostAccountMgt.IndentCostCenters;

      // Verify: Verify the error message for when there is no corresponding Begin Total for End Total Cost Center.
      Assert.ExpectedError(STRSUBSTNO(EndTotalError,CostCenter.Code));
    END;

    [Test]
    PROCEDURE TestCostObjectEndTotalError@156();
    VAR
      CostObject@1000 : Record 1113;
      CostAccountMgt@1001 : Codeunit 1100;
    BEGIN
      // Test that system throws error while running Indent Cost Object when there is no corresponding Begin Total for End Total Cost Object.

      // Setup: Create Cost Object of Line Type End-Total.
      Initialize;
      LibraryCostAccounting.CreateCostObject(CostObject);
      UpdateCostObject(CostObject,CostObject."Line Type"::"End-Total");

      // Exercise: Indent cost centers.
      ASSERTERROR CostAccountMgt.IndentCostObjects;

      // Verify: Verify the error message for when there is no corresponding Begin Total for End Total Cost Center.
      Assert.ExpectedError(STRSUBSTNO(EndTotalError,CostObject.Code));
    END;

    [Test]
    PROCEDURE PostingDateLessthanAllowPostingFrom@143();
    BEGIN
      // Test that system does not allow to post the entry when Posting Date is less than Allow Posting From in User Setup Table.
      PostingDateNotAllowed(CALCDATE(STRSUBSTNO('<-%1D>',LibraryRandom.RandInt(10)),WORKDATE));
    END;

    [Test]
    PROCEDURE PostingDateGreaterthanAllowPostingTo@160();
    BEGIN
      // Test that system does not allow to post the entry when Posting Date is greater than Allow Posting To in User Setup Table.
      PostingDateNotAllowed(CALCDATE(STRSUBSTNO('<%1D>',LibraryRandom.RandInt(10)),WORKDATE));
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE LinkCostTypeToGLForDuplicateGLAccRange@150();
    VAR
      CostType@1000 : Record 1103;
      CostType2@1004 : Record 1103;
      GLAccount@1001 : Record 15;
      CostAccountingSetup@1002 : Record 1108;
      CostAccountMgt@1003 : Codeunit 1100;
      AlignGLAccount@1005 : Option;
    BEGIN
      // Test that system throws error while running batch LinkCostTypesToGLAccounts when cost type is assigned a G/L Acc. Range which is already linked with another cost type.

      // Setup: Create an Income Stmt GL Account and assigning a G/L Acc. Range to the newly created cost type.
      Initialize;
      CostAccountingSetup.GET;
      AlignGLAccount := CostAccountingSetup."Align G/L Account";
      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::Automatic);
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      CostType.GET(GLAccount."Cost Type No.");
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      CostType2.GET(GLAccount."Cost Type No.");
      CostType."G/L Account Range" := CostType2."No.";
      CostType.MODIFY;

      // Exercise: Running batch LinkCostTypesToGLAccounts.
      ASSERTERROR CostAccountMgt.LinkCostTypesToGLAccounts;

      // Verify: Verify the expected error message is coming after running the batch LinkCostTypesToGLAccounts.
      IF CostType2ExistsInCostType1Range(CostType."No.",CostType2."No.") THEN
        Assert.ExpectedError(STRSUBSTNO(LinkCostTypeError,CostType."No.",CostType2."No."))
      ELSE
        Assert.ExpectedError(STRSUBSTNO(LinkCostTypeError,CostType2."No.",CostType2."No."));

      // TearDown.
      LibraryCostAccounting.SetAlignment(CostAccountingSetup.FIELDNO("Align G/L Account"),AlignGLAccount);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE CancelPostingAction@152();
    VAR
      CostJournalBatch@1000 : Record 1102;
      CostJournalLine@1001 : Record 1101;
      LineNo@1002 : Integer;
    BEGIN
      // Test that while posing the cost journal line by CA Jnl.-B. Post, system is not posting entry when we select option no in confirm handler.

      // Setup: Create a cost journal batch and a cost journal line.
      Initialize;
      CreateCostJournalBatch(CostJournalBatch);
      LibraryCostAccounting.CreateCostJournalLine(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);
      LineNo := CostJournalLine."Line No.";

      // Exercise: Run codeunit CA Jnl.-B. Post.
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-B. Post",CostJournalBatch);

      // Verify: Verify that system is not posting entry when we select option no in confirm handler.
      CostJournalLine.GET(CostJournalBatch."Journal Template Name",CostJournalBatch.Name,LineNo);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageWhenPostingFailsHandler)]
    PROCEDURE EmptyCostJournalBatch@165();
    VAR
      CostJournalBatch@1000 : Record 1102;
    BEGIN
      // Test that system shows the warning message when cost journal batch is empty.

      // Setup: Create a cost journal batch.
      Initialize;
      CreateCostJournalBatch(CostJournalBatch);

      // Exercise: Run codeunit CA Jnl.-B. Post with empty cost journal batch.
      COMMIT;
      CODEUNIT.RUN(CODEUNIT::"CA Jnl.-B. Post",CostJournalBatch);

      // Verify: Verify that warning message comes up while calling the codeunit CA Jnl.-B. Post with empty cost journal batch.
      // Verification has been done in handler MessageWhenPostingFailsHandler.
    END;

    [Test]
    PROCEDURE TestCalcAllocationKeyForDifferentCostCenterFilter@157();
    VAR
      GeneralLedgerSetup@1000 : Record 98;
      DimensionValue@1007 : ARRAY [2] OF Record 349;
      CostCenter@1009 : ARRAY [2] OF Record 1112;
      Item@1008 : Record 27;
      CostAllocationSource@1005 : Record 1106;
      CostAllocationTarget@1004 : Record 1107;
      ID@1001 : Code[10];
      DynamicLineNo@1002 : Integer;
      Count@1006 : Integer;
      i@1010 : Integer;
      Qty@1011 : Integer;
    BEGIN
      // Test the Shares are correct after executing Calculate Alloction Key for two Dynamics Allocation Targets with Base = "Items Sold Qty." and different Cost Center Filters.

      // Setup: Create two Dimensions and two Cost Centers. Create Item.
      UpdateCountryData := TRUE;
      IsInitialized := FALSE;
      Initialize;
      Count := 2;
      Qty := LibraryRandom.RandInt(10);
      DynamicLineNo := LibraryRandom.RandInt(10);
      LibraryInventory.CreateItem(Item);

      GeneralLedgerSetup.GET;
      FOR i := 1 TO Count DO BEGIN
        LibraryDimension.CreateDimensionValue(DimensionValue[i],GeneralLedgerSetup."Global Dimension 1 Code");
        CreateCostCenter(CostCenter[i],DimensionValue[i].Code);
      END;

      // Create and Post Sales Invoice with two lines and dimensions.
      CreateAndPostSalesInvoiceWithMultipleLinesAndDimension(DimensionValue,Item."No.",Qty,Count);

      // Create two Dynamics Allocation Targets with Base = "Items Sold Qty." and Cost Center Filter.
      CostAllocationTarget.DELETEALL;
      CostAllocationSource.DELETEALL;
      ID := CreateMultipleDynAllocTargetItemsSoldQtyWithCostCenterFilter(
          CostAllocationTarget,CostCenter,Item."No.",DynamicLineNo,Count);

      // Exercise: Run Calculate Allocation Key.
      CostAllocationSource.GET(ID);
      CostAccountAllocation.CalcAllocationKey(CostAllocationSource);

      // Verify: Verify the Shares are correct in the two Allocation Target lines.
      VerifyAllocTargetShareWithMultipleLines(Count,ID,DynamicLineNo,Qty);
    END;

    LOCAL PROCEDURE Initialize@45();
    BEGIN
      IF IsInitialized THEN
        EXIT;
      IF UpdateCountryData THEN BEGIN
        LibraryERMCountryData.CreateVATData;
        LibraryERMCountryData.UpdateGenProdPostingGroup;
        LibraryERMCountryData.UpdateGeneralPostingSetup;
        UpdateCountryData := FALSE;
      END;
      IsInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE CleanCostCenterTestCases@84(InitialCostCenterDimension@1000 : Code[20]);
    VAR
      CostAccountingSetup@1001 : Record 1108;
    BEGIN
      CostAccountingSetup.GET;
      CostAccountingSetup.VALIDATE("Align Cost Center Dimension",CostAccountingSetup."Align Cost Center Dimension"::"No Alignment");
      CostAccountingSetup.VALIDATE("Cost Center Dimension",InitialCostCenterDimension);
      CostAccountingSetup.VALIDATE("Check G/L Postings",FALSE);
      CostAccountingSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CleanCostObjectTestCases@86(InitialCostObjectDimension@1000 : Code[20]);
    VAR
      CostAccountingSetup@1001 : Record 1108;
    BEGIN
      CostAccountingSetup.GET;
      CostAccountingSetup.VALIDATE("Align Cost Object Dimension",CostAccountingSetup."Align Cost Object Dimension"::"No Alignment");
      CostAccountingSetup.VALIDATE("Cost Object Dimension",InitialCostObjectDimension);
      CostAccountingSetup.VALIDATE("Check G/L Postings",FALSE);
      CostAccountingSetup.MODIFY(TRUE);
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandlerNo@29(Message@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := FALSE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandlerYes@28(Message@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [PageHandler]
    PROCEDURE CostJournalPageHandler@110(VAR CostJournal@1000 : TestPage 1108);
    BEGIN
      CostJnlBatchName := CostJournal.CostJnlBatchName.VALUE;
      CostJournal.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE CostJournalTemplatePageHandler@111(VAR CostJournalTemplate@1000 : TestPage 1107);
    BEGIN
      CostJournalTemplate.OK.INVOKE;
    END;

    LOCAL PROCEDURE CreateAllocSource@94(VAR CostAllocationSource@1000 : Record 1106);
    BEGIN
      CostAllocationSource.ID :=
        COPYSTR(LibraryUtility.GenerateRandomCode(CostAllocationSource.FIELDNO(ID),DATABASE::"Cost Allocation Source"),
          1,LibraryUtility.GetFieldLength(DATABASE::"Cost Allocation Source",CostAllocationSource.FIELDNO(ID)));
      CostAllocationSource.Level := LibraryRandom.RandInt(99);
      CostAllocationSource.INSERT;
    END;

    LOCAL PROCEDURE CreateAllocTarget@93(VAR CostAllocationTarget@1000 : Record 1107;ID@1001 : Code[10];LineNo@1002 : Integer;Base@1003 : Option);
    BEGIN
      CostAllocationTarget.ID := ID;
      CostAllocationTarget."Line No." := LineNo;
      CostAllocationTarget.Base := Base;
      CostAllocationTarget.INSERT;
    END;

    LOCAL PROCEDURE CreateCostCenter@37(VAR CostCenter@1001 : Record 1112;DimensionValueCode@1000 : Code[20]);
    BEGIN
      CostCenter.INIT;
      CostCenter.VALIDATE(Code,DimensionValueCode);
      CostCenter.INSERT;
    END;

    LOCAL PROCEDURE CreateCostJournalBatch@108(VAR CostJournalBatch@1000 : Record 1102);
    VAR
      CostJournalTemplate@1001 : Record 1100;
    BEGIN
      CostJournalTemplate.Name :=
        COPYSTR(LibraryUtility.GenerateRandomCode(CostJournalTemplate.FIELDNO(Name),DATABASE::"Cost Journal Template"),
          1,LibraryUtility.GetFieldLength(DATABASE::"Cost Journal Template",CostJournalTemplate.FIELDNO(Name)));
      CostJournalTemplate.INSERT;

      CostJournalBatch."Journal Template Name" := CostJournalTemplate.Name;
      CostJournalBatch.Name :=
        COPYSTR(LibraryUtility.GenerateRandomCode(CostJournalBatch.FIELDNO(Name),DATABASE::"Cost Journal Batch"),
          1,LibraryUtility.GetFieldLength(DATABASE::"Cost Journal Batch",CostJournalBatch.FIELDNO(Name)));
      CostJournalBatch.INSERT;
    END;

    LOCAL PROCEDURE CreateCostJnlLineAndxCostJnlLine@105(VAR CostJournalLine@1000 : Record 1101;VAR TempCostJournalLine@1001 : TEMPORARY Record 1101;CostJournalTemplateName@1002 : Code[10];CostJournalBatchName@1003 : Code[10]);
    BEGIN
      // Create Cost Journal line and update its Bal Cost Type No. , Bal Cost Center Code and maintain its previous record
      TempCostJournalLine := CostJournalLine; // to maintain xRec of cost journal line.
      TempCostJournalLine.INSERT;
      LibraryCostAccounting.CreateCostJournalLineBasic(CostJournalLine,CostJournalTemplateName,CostJournalBatchName,WORKDATE,'','');
    END;

    LOCAL PROCEDURE CreateCostJournalLine@4(VAR CostJournalLine@1002 : Record 1101;VAR CostJournalTemplate@1001 : Record 1100;VAR CostJournalBatch@1000 : Record 1102);
    VAR
      CostType@1003 : Record 1103;
      BalCostType@1004 : Record 1103;
    BEGIN
      LibraryCostAccounting.CreateCostTypeNoGLRange(CostType);
      LibraryCostAccounting.CreateCostTypeNoGLRange(BalCostType);
      LibraryCostAccounting.CreateCostJournalTemplate(CostJournalTemplate);
      LibraryCostAccounting.CreateCostJournalBatch(CostJournalBatch,CostJournalTemplate.Name);
      LibraryCostAccounting.CreateCostJournalLineBasic(
        CostJournalLine,CostJournalTemplate.Name,CostJournalBatch.Name,WORKDATE,CostType."No.",BalCostType."No.");
    END;

    LOCAL PROCEDURE CreateGeneralJournalLine@115(VAR GenJournalLine@1005 : Record 81;AccountType@1003 : Option;AccountNo@1004 : Code[20];Amount@1006 : Decimal);
    VAR
      GenJournalBatch@1000 : Record 232;
    BEGIN
      LibraryERM.SelectGenJnlBatch(GenJournalBatch);
      LibraryERM.ClearGenJournalLines(GenJournalBatch);
      LibraryERM.CreateGeneralJnlLine(
        GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,GenJournalLine."Document Type"::" ",AccountType,
        AccountNo,Amount);
    END;

    LOCAL PROCEDURE CreateCostObject@38(VAR CostObject@1001 : Record 1113;DimensionValueCode@1000 : Code[20]);
    BEGIN
      CostObject.INIT;
      CostObject.VALIDATE(Code,DimensionValueCode);
      CostObject.INSERT;
    END;

    LOCAL PROCEDURE CreateDynAllocTargetByAllocSourceID@92(VAR CostAllocationTarget@1000 : Record 1107;ID@1001 : Code[10];LineNo@1002 : Integer;Base@1003 : Option;DateFilterCode@1004 : Option);
    BEGIN
      CreateAllocTarget(CostAllocationTarget,ID,LineNo,Base);
      CostAllocationTarget."Date Filter Code" := DateFilterCode;
      CostAllocationTarget.MODIFY;
    END;

    LOCAL PROCEDURE CreateDynAllocTargetItemsSoldAmount@91(VAR CostAllocationTarget@1000 : Record 1107;LineNo@1001 : Integer);
    VAR
      CostAllocationSource@1002 : Record 1106;
    BEGIN
      CreateAllocSource(CostAllocationSource);
      CreateDynAllocTargetByAllocSourceID(CostAllocationTarget,CostAllocationSource.ID,LineNo,
        CostAllocationTarget.Base::"Items Sold (Amount)",CostAllocationTarget."Date Filter Code"::"Last Year");
    END;

    LOCAL PROCEDURE CreateMultipleDynAllocTargetItemsSoldQtyWithCostCenterFilter@169(VAR CostAllocationTarget@1000 : Record 1107;CostCenter@1005 : ARRAY [2] OF Record 1112;ItemNo@1004 : Code[20];LineNo@1001 : Integer;Count@1006 : Integer) : Code[10];
    VAR
      CostAllocationSource@1002 : Record 1106;
      i@1007 : Integer;
    BEGIN
      CreateAllocSource(CostAllocationSource);
      FOR i := 1 TO Count DO BEGIN
        CreateDynAllocTargetByAllocSourceID(CostAllocationTarget,CostAllocationSource.ID,LineNo,
          CostAllocationTarget.Base::"Items Sold (Qty.)",CostAllocationTarget."Date Filter Code"::Month);
        CostAllocationTarget.VALIDATE("No. Filter",ItemNo);
        CostAllocationTarget.VALIDATE("Cost Center Filter",CostCenter[i].Code);
        CostAllocationTarget.MODIFY(TRUE);
        LineNo := LineNo + 1;
      END;
      EXIT(CostAllocationSource.ID);
    END;

    LOCAL PROCEDURE CreateDynAllocTargetNoOfEmployees@90(VAR CostAllocationTarget@1000 : Record 1107;LineNo@1001 : Integer);
    VAR
      CostAllocationSource@1002 : Record 1106;
    BEGIN
      CreateAllocSource(CostAllocationSource);
      CreateDynAllocTargetByAllocSourceID(CostAllocationTarget,CostAllocationSource.ID,LineNo,
        CostAllocationTarget.Base::"No of Employees",CostAllocationTarget."Date Filter Code"::" ");
    END;

    LOCAL PROCEDURE CreateStaticAllocTarget@89(VAR CostAllocationTarget@1000 : Record 1107;LineNo@1002 : Integer);
    VAR
      CostAllocationSource@1001 : Record 1106;
    BEGIN
      CreateAllocSource(CostAllocationSource);
      CreateAllocTarget(CostAllocationTarget,CostAllocationSource.ID,LineNo,CostAllocationTarget.Base::Static);
    END;

    LOCAL PROCEDURE CreateGeneralLineWithDimension@122(VAR GenJournalLine@1004 : Record 81;DimensionCode@1000 : Code[20];DimensionValueCode@1001 : Code[20]);
    VAR
      GLAccount@1003 : Record 15;
      DimSetID@1002 : Integer;
    BEGIN
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,DimensionCode,DimensionValueCode);
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      CreateGeneralJournalLine(
        GenJournalLine,GenJournalLine."Account Type"::"G/L Account",GLAccount."No.",LibraryRandom.RandDec(100,2));
      UpdateGenJournalLineWithDimension(GenJournalLine,DimSetID);
    END;

    LOCAL PROCEDURE CreateAndPostSalesInvoiceWithMultipleLinesAndDimension@161(DimensionValue@1006 : ARRAY [2] OF Record 349;ItemNo@1004 : Code[20];Qty@1005 : Decimal;LineCount@1008 : Integer);
    VAR
      Customer@1000 : Record 18;
      SalesHeader@1001 : Record 36;
      SalesLine@1002 : Record 37;
      i@1007 : Integer;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Invoice,Customer."No.");

      // Create Multiple Sales Lines with different dimensions.
      FOR i := 1 TO LineCount DO BEGIN
        LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Qty);
        SalesLine.VALIDATE("Shortcut Dimension 1 Code",DimensionValue[i].Code);
        SalesLine.MODIFY(TRUE);
      END;
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE CostType2ExistsInCostType1Range@162(CostTypeNo1@1000 : Code[20];CostTypeNo2@1001 : Code[20]) : Boolean;
    VAR
      CostType@1002 : Record 1103;
    BEGIN
      CostType.SETFILTER("No.",'..%1',CostTypeNo1);
      IF CostType.FINDSET THEN
        REPEAT
          IF CostType."No." = CostTypeNo2 THEN
            EXIT(TRUE);
        UNTIL CostType.NEXT = 0;
      EXIT(FALSE);
    END;

    LOCAL PROCEDURE FindCostJnlBatchAndTemplate@126(VAR CostJournalBatch@1001 : Record 1102);
    VAR
      CostJournalTemplate@1000 : Record 1100;
    BEGIN
      LibraryCostAccounting.FindCostJournalTemplate(CostJournalTemplate);
      LibraryCostAccounting.FindCostJournalBatch(CostJournalBatch,CostJournalTemplate.Name);
      LibraryCostAccounting.ClearCostJournalLines(CostJournalBatch);
    END;

    LOCAL PROCEDURE GetIndentation@223(VAR FirstLevelIndentation@1000 : Integer;VAR SecondLevelIndentation@1001 : Integer;RecordRef@1004 : RecordRef;TypeFieldNo@1003 : Integer;TypeValue@1005 : Option;IndentationFieldNo@1006 : Integer);
    VAR
      FieldRef@1002 : FieldRef;
    BEGIN
      FieldRef := RecordRef.FIELD(TypeFieldNo);
      FieldRef.SETFILTER('<>%1',TypeValue);
      RecordRef.FINDFIRST;
      FieldRef := RecordRef.FIELD(IndentationFieldNo);
      FirstLevelIndentation := FieldRef.VALUE;

      FieldRef := RecordRef.FIELD(TypeFieldNo);
      FieldRef.SETRANGE(TypeValue);
      RecordRef.FINDFIRST;
      FieldRef := RecordRef.FIELD(IndentationFieldNo);
      SecondLevelIndentation := FieldRef.VALUE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@18(Message@1000 : Text[1024]);
    BEGIN
      // Dummy message handler.
    END;

    [MessageHandler]
    PROCEDURE MessageWhenPostingFailsHandler@127(MessageOnNoPost@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(ExpectedNoPostingMsg = MessageOnNoPost,STRSUBSTNO(UnexpectedMessage,MessageOnNoPost,ExpectedNoPostingMsg));
    END;

    [MessageHandler]
    PROCEDURE MessageWhenPostedSuccessfullyHandler@129(MessageOnPost@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(ExpectedPostingMsg = MessageOnPost,STRSUBSTNO(UnexpectedMessage,MessageOnPost,ExpectedPostingMsg));
    END;

    LOCAL PROCEDURE PostingDateNotAllowed@158(PostingDate@1003 : Date);
    VAR
      UserSetup@1000 : Record 91;
      CostJournalBatch@1001 : Record 1102;
      CostJournalLine@1002 : Record 1101;
    BEGIN
      // Setup: Create a User setup with current USERID and creating a cost journal line.
      Initialize;
      LibraryTimeSheet.CreateUserSetup(UserSetup,TRUE);
      UserSetup."Allow Posting From" := WORKDATE;
      UserSetup."Allow Posting To" := WORKDATE;
      UserSetup.MODIFY;
      CreateCostJournalBatch(CostJournalBatch);
      LibraryCostAccounting.CreateCostJournalLine(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);
      CostJournalLine."Posting Date" := PostingDate;
      CostJournalLine.MODIFY;

      // Exercise: Run codeunit CA Jnl.-Check Line.
      ASSERTERROR CODEUNIT.RUN(CODEUNIT::"CA Jnl.-Check Line",CostJournalLine);

      // Verify: Verify that system throws error message when posting date is not within the range.
      Assert.ExpectedError(PostingDateError);
    END;

    [ReportHandler]
    PROCEDURE ReportHandlerCostRegister@109(VAR CostRegister@1000 : Report 1144);
    BEGIN
      // Dummy request page handler.
    END;

    LOCAL PROCEDURE SetupCostCenterTestCases@82(VAR Dimension@1000 : Record 348;VAR DimensionValue@1001 : Record 349;VAR InitialCostCenterDimension@1002 : Code[20]);
    VAR
      CostAccountingSetup@1003 : Record 1108;
    BEGIN
      LibraryDimension.CreateDimension(Dimension);
      LibraryDimension.CreateDimensionValue(DimensionValue,Dimension.Code);

      CostAccountingSetup.GET;
      InitialCostCenterDimension := CostAccountingSetup."Cost Center Dimension";
      CostAccountingSetup.VALIDATE("Align Cost Center Dimension",CostAccountingSetup."Align Cost Center Dimension"::Automatic);
      CostAccountingSetup.VALIDATE("Cost Center Dimension",Dimension.Code);
      CostAccountingSetup.VALIDATE("Check G/L Postings",TRUE);
      CostAccountingSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE SetupCostObjectTestCases@85(VAR Dimension@1002 : Record 348;VAR DimensionValue@1001 : Record 349;VAR InitialCostObjectDimension@1000 : Code[20]);
    VAR
      CostAccountingSetup@1003 : Record 1108;
    BEGIN
      LibraryDimension.CreateDimension(Dimension);
      LibraryDimension.CreateDimensionValue(DimensionValue,Dimension.Code);

      CostAccountingSetup.GET;
      InitialCostObjectDimension := CostAccountingSetup."Cost Object Dimension";
      CostAccountingSetup.VALIDATE("Align Cost Object Dimension",CostAccountingSetup."Align Cost Object Dimension"::Automatic);
      CostAccountingSetup.VALIDATE("Cost Object Dimension",Dimension.Code);
      CostAccountingSetup.VALIDATE("Check G/L Postings",TRUE);
      CostAccountingSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdatePostingReportID@112(Name@1001 : Code[10];PostingReportID@1002 : Integer);
    VAR
      CostJournalTemplate@1000 : Record 1100;
    BEGIN
      CostJournalTemplate.GET(Name);
      CostJournalTemplate."Posting Report ID" := PostingReportID;
      CostJournalTemplate.MODIFY;
    END;

    LOCAL PROCEDURE UpdateGenJournalLineWithDimension@116(VAR GenJournalLine@1000 : Record 81;DimSetID@1001 : Integer);
    BEGIN
      GenJournalLine.VALIDATE("Dimension Set ID",DimSetID);
      GenJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCostCenter@153(VAR CostCenter@1000 : Record 1112;LineType@1001 : Option);
    BEGIN
      CostCenter.VALIDATE("Line Type",LineType);
      CostCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCostJournalLine@130(VAR CostJournalLine@1000 : Record 1101);
    BEGIN
      CostJournalLine.VALIDATE("Bal. Cost Type No.",'');
      CostJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCostJournalLineBalance@107(CostJournalLine@1000 : Record 1101;xCostJournalLine@1007 : Record 1101;CostJournalTemplateName@1001 : Code[10];CostJournalBatchName@1008 : Code[10];VAR Balance@1003 : Decimal;VAR TotalBalance@1004 : Decimal;VAR ShowBalance@1006 : Boolean;VAR ShowTotalBalance@1005 : Boolean);
    VAR
      CostJnlManagement@1002 : Codeunit 1106;
    BEGIN
      // Set filter on Cost Journal line and calculate Balance and Total Balance.
      CostJournalLine.SETFILTER("Journal Template Name",'%1',CostJournalTemplateName);
      CostJournalLine.SETFILTER("Journal Batch Name",'%1',CostJournalBatchName);
      CostJnlManagement.CalcBalance(CostJournalLine,xCostJournalLine,Balance,TotalBalance,ShowBalance,ShowTotalBalance);
    END;

    LOCAL PROCEDURE UpdateCostObject@138(VAR CostObject@1000 : Record 1113;LineType@1001 : Option);
    BEGIN
      CostObject.VALIDATE("Line Type",LineType);
      CostObject.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCostType@118(VAR CostType@1000 : Record 1103;GLAccountNo@1001 : Code[20];Type@1002 : Option);
    BEGIN
      CostType.VALIDATE("G/L Account Range",GLAccountNo);
      CostType.VALIDATE(Type,Type);
      CostType.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCostAccountingSetup@128(VAR OldAlignmentValue@1001 : Option);
    VAR
      CostAccountingSetup@1000 : Record 1108;
    BEGIN
      CostAccountingSetup.GET;
      OldAlignmentValue := CostAccountingSetup."Align G/L Account";
      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::Automatic);
    END;

    LOCAL PROCEDURE ValidateCreatedEntries@121(CostCenterCode@1004 : Code[20];CostObjectCode@1005 : Code[20]);
    VAR
      CostEntry@1001 : Record 1104;
      CostRegister@1002 : Record 1105;
      GLEntry@1003 : Record 17;
      GLRegister@1000 : Record 45;
    BEGIN
      // Validate cost register.
      CostRegister.FINDLAST;
      CostRegister.TESTFIELD(Source,CostRegister.Source::"Transfer from G/L");
      CostRegister.TESTFIELD("No. of Entries",CostRegister."To Cost Entry No." - CostRegister."From Cost Entry No." + 1);

      // To find the GL entry.
      GLRegister.FINDLAST;
      GLEntry.SETRANGE("Entry No.",GLRegister."From Entry No.",GLRegister."To Entry No.");
      GLEntry.FINDSET;

      // Validate First cost entry.
      CostEntry.SETRANGE("Entry No.",CostRegister."From Cost Entry No.",CostRegister."To Cost Entry No.");
      CostEntry.FINDSET;
      VerifyCommonFields(CostEntry,GLEntry,CostCenterCode,CostObjectCode);

      // Validate Second cost entry.
      GLEntry.NEXT;
      CostEntry.NEXT;
      VerifyCommonFields(CostEntry,GLEntry,CostCenterCode,CostObjectCode);
    END;

    LOCAL PROCEDURE VerifyAllocTargetShareIsNonZero@88(ID@1000 : Code[10];LineNo@1001 : Integer);
    VAR
      CostAllocationTarget@1002 : Record 1107;
    BEGIN
      CostAllocationTarget.GET(ID,LineNo);
      Assert.IsTrue(CostAllocationTarget.Share > 0,STRSUBSTNO(AllocTargetShareIsZero,LineNo));
      CostAllocationTarget.TESTFIELD(Percent,100);
    END;

    LOCAL PROCEDURE VerifyAllocTargetShareIsZero@87(ID@1000 : Code[10];LineNo@1001 : Integer);
    VAR
      CostAllocationTarget@1002 : Record 1107;
    BEGIN
      CostAllocationTarget.GET(ID,LineNo);
      CostAllocationTarget.TESTFIELD(Share,0);
      CostAllocationTarget.TESTFIELD(Percent,0);
    END;

    LOCAL PROCEDURE VerifyBlocked@139(RecordRef@1000 : RecordRef;BlockedFieldNo@1001 : Integer;TypeFieldNo@1004 : Integer;TypeValue@1006 : Option);
    VAR
      BlockedFieldRef@1003 : FieldRef;
      TypeFieldRef@1002 : FieldRef;
      Type@1005 : Option;
    BEGIN
      REPEAT
        BlockedFieldRef := RecordRef.FIELD(BlockedFieldNo);
        TypeFieldRef := RecordRef.FIELD(TypeFieldNo);
        Type := TypeFieldRef.VALUE;
        BlockedFieldRef.TESTFIELD(Type <> TypeValue);
      UNTIL RecordRef.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyChartOfCostCenterIndent@140(FromCostCenter@1000 : Code[20];ToCostCenter@1001 : Code[20];Totaling@1002 : Text[250]);
    VAR
      CostCenter@1003 : Record 1112;
      RecordRef@1004 : RecordRef;
      FirstLevelIndentation@1005 : Integer;
      SecondLevelIndentation@1006 : Integer;
    BEGIN
      CostCenter.SETRANGE(Code,FromCostCenter,ToCostCenter);
      CostCenter.FINDFIRST;

      RecordRef.GETTABLE(CostCenter);
      VerifyBlocked(RecordRef,CostCenter.FIELDNO(Blocked),CostCenter.FIELDNO("Line Type"),CostCenter."Line Type"::"Cost Center");

      RecordRef.GETTABLE(CostCenter);
      VerifyTotaling(RecordRef,CostCenter.FIELDNO(Totaling),Totaling);

      RecordRef.GETTABLE(CostCenter);
      GetIndentation(
        FirstLevelIndentation,SecondLevelIndentation,RecordRef,CostCenter.FIELDNO("Line Type"),CostCenter."Line Type"::"Cost Center",
        CostCenter.FIELDNO(Indentation));
      RecordRef.GETTABLE(CostCenter);
      VerifyIndentation(
        RecordRef,CostCenter.FIELDNO(Indentation),CostCenter.FIELDNO("Line Type"),FirstLevelIndentation,SecondLevelIndentation);
    END;

    LOCAL PROCEDURE VerifyChartOfCostObjectIndent@141(FromCostObject@1000 : Code[20];ToCostObject@1001 : Code[20];Totaling@1002 : Text[250]);
    VAR
      CostObject@1003 : Record 1113;
      RecordRef@1004 : RecordRef;
      FirstLevelIndentation@1005 : Integer;
      SecondLevelIndentation@1006 : Integer;
    BEGIN
      CostObject.SETRANGE(Code,FromCostObject,ToCostObject);
      CostObject.FINDFIRST;

      RecordRef.GETTABLE(CostObject);
      VerifyBlocked(RecordRef,CostObject.FIELDNO(Blocked),CostObject.FIELDNO("Line Type"),CostObject."Line Type"::"Cost Object");

      RecordRef.GETTABLE(CostObject);
      VerifyTotaling(RecordRef,CostObject.FIELDNO(Totaling),Totaling);

      RecordRef.GETTABLE(CostObject);
      GetIndentation(
        FirstLevelIndentation,SecondLevelIndentation,RecordRef,CostObject.FIELDNO("Line Type"),CostObject."Line Type"::"Cost Object",
        CostObject.FIELDNO(Indentation));
      RecordRef.GETTABLE(CostObject);
      VerifyIndentation(
        RecordRef,CostObject.FIELDNO(Indentation),CostObject.FIELDNO("Line Type"),FirstLevelIndentation,SecondLevelIndentation);
    END;

    LOCAL PROCEDURE VerifyChartOfCostTypeIndent@142(FromCostType@1000 : Code[20];ToCostType@1001 : Code[20];Totaling@1004 : Text[250]);
    VAR
      CostType@1002 : Record 1103;
      RecordRef@1003 : RecordRef;
      FirstLevelIndentation@1005 : Integer;
      SecondLevelIndentation@1006 : Integer;
    BEGIN
      CostType.SETRANGE("No.",FromCostType,ToCostType);
      CostType.FINDFIRST;

      RecordRef.GETTABLE(CostType);
      VerifyBlocked(RecordRef,CostType.FIELDNO(Blocked),CostType.FIELDNO(Type),CostType.Type::"Cost Type");

      RecordRef.GETTABLE(CostType);
      VerifyTotaling(RecordRef,CostType.FIELDNO(Totaling),Totaling);

      RecordRef.GETTABLE(CostType);
      GetIndentation(
        FirstLevelIndentation,SecondLevelIndentation,RecordRef,CostType.FIELDNO(Type),CostType.Type::"Cost Type",
        CostType.FIELDNO(Indentation));
      RecordRef.GETTABLE(CostType);
      VerifyIndentation(RecordRef,CostType.FIELDNO(Indentation),CostType.FIELDNO(Type),FirstLevelIndentation,SecondLevelIndentation);
    END;

    LOCAL PROCEDURE VerifyCommonFields@120(CostEntry@1001 : Record 1104;GLEntry@1000 : Record 17;CostCenterCode@1002 : Code[20];CostObjectCode@1003 : Code[20]);
    BEGIN
      CostEntry.TESTFIELD(Amount,GLEntry.Amount);
      CostEntry.TESTFIELD("G/L Entry No.",GLEntry."Entry No.");
      CostEntry.TESTFIELD("Document No.",GLEntry."Document No.");
      CostEntry.TESTFIELD("Cost Center Code",CostCenterCode);
      CostEntry.TESTFIELD("Cost Object Code",CostObjectCode);
      CostEntry.TESTFIELD("System-Created Entry",TRUE);
    END;

    LOCAL PROCEDURE VerifyCostBudgetEntry@159(BudgetName@1001 : Code[10];CostCenterCode@1002 : Code[20]);
    VAR
      CostBudgetEntry@1000 : Record 1109;
      Amount@1004 : Decimal;
    BEGIN
      CostBudgetEntry.SETRANGE("Budget Name",BudgetName);
      CostBudgetEntry.SETRANGE("Cost Center Code",CostCenterCode);
      CostBudgetEntry.FINDSET;
      REPEAT
        Amount += CostBudgetEntry.Amount;
      UNTIL CostBudgetEntry.NEXT = 0;
      Assert.AreEqual(0,Amount,STRSUBSTNO(ValuesAreWrong,CostBudgetEntry.TABLECAPTION));
    END;

    LOCAL PROCEDURE VerifyCostBudgetRegister@163(JournalBatchName@1001 : Code[10];CostBudgetName@1002 : Code[10]);
    VAR
      CostBudgetRegister@1000 : Record 1111;
    BEGIN
      CostBudgetRegister.SETRANGE("Journal Batch Name",JournalBatchName);
      CostBudgetRegister.SETRANGE("Cost Budget Name",CostBudgetName);
      CostBudgetRegister.FINDFIRST;
      CostBudgetRegister.TESTFIELD("No. of Entries",2);
    END;

    LOCAL PROCEDURE VerifyCostEntry@131(ExpectedDocumentNo@1000 : Code[20];ExpectedAmount@1001 : Decimal);
    VAR
      CostEntry@1002 : Record 1104;
    BEGIN
      CostEntry.SETRANGE("Document No.",ExpectedDocumentNo);
      CostEntry.FINDFIRST;
      CostEntry.TESTFIELD(Amount,ExpectedAmount);
    END;

    LOCAL PROCEDURE VerifyCostJournalBatch@117(CostJournalTemplateName@1000 : Code[10]);
    VAR
      CostJournalBatch@1001 : Record 1102;
    BEGIN
      // Verify DEFAULT value in Cost Jourbal Batch for a new Cost Journal Template.
      CostJournalBatch.SETRANGE("Journal Template Name",CostJournalTemplateName);
      CostJournalBatch.FINDFIRST;
      CostJournalBatch.TESTFIELD(Name,'DEFAULT');
      CostJournalBatch.TESTFIELD(Description,'Default Batch');
    END;

    LOCAL PROCEDURE VerifyCostJournalTemplate@104(JnlSelected@1001 : Boolean);
    VAR
      CostJournalTemplate@1000 : Record 1100;
    BEGIN
      // Verify that new record has been created or not.
      CostJournalTemplate.FINDFIRST;
      CostJournalTemplate.TESTFIELD(Name,'STANDARD');
      CostJournalTemplate.TESTFIELD(Description,'Standard Template');
      Assert.IsTrue(JnlSelected,STRSUBSTNO(TemplateSelectionError,CostJournalTemplate.TABLECAPTION));
    END;

    LOCAL PROCEDURE VerifyIndentation@147(RecordRef@1000 : RecordRef;IndentationFieldNo@1002 : Integer;TypeFieldNo@1006 : Integer;FirstLevelIndentation@1005 : Integer;SecondLevelIndentation@1004 : Integer);
    VAR
      IndentationFieldRef@1001 : FieldRef;
      TypeFieldRef@1003 : FieldRef;
      Type@1008 : Option;
    BEGIN
      TypeFieldRef := RecordRef.FIELD(TypeFieldNo);
      IndentationFieldRef := RecordRef.FIELD(IndentationFieldNo);

      TypeFieldRef.SETFILTER('<>%1',Type);
      IndentationFieldRef.SETFILTER('<>%1',FirstLevelIndentation);
      Assert.AreEqual(TRUE,RecordRef.ISEMPTY,STRSUBSTNO(ExpectedIndentationForTotaling,SecondLevelIndentation));

      TypeFieldRef.SETRANGE(Type);
      IndentationFieldRef.SETFILTER('<>%1',SecondLevelIndentation);
      Assert.AreEqual(TRUE,RecordRef.ISEMPTY,STRSUBSTNO(ExpectedIndentationForNonTotaling,SecondLevelIndentation));

      Assert.AreEqual(
        1,SecondLevelIndentation - FirstLevelIndentation,
        STRSUBSTNO(ExpectedLevelDifference,FirstLevelIndentation,SecondLevelIndentation));
    END;

    LOCAL PROCEDURE VerifyTotaling@149(RecordRef@1000 : RecordRef;TotalingFieldNo@1001 : Integer;Expected@1002 : Text[250]);
    VAR
      FieldRef@1003 : FieldRef;
    BEGIN
      FieldRef := RecordRef.FIELD(TotalingFieldNo);
      FieldRef.SETRANGE('');
      Assert.AreEqual(3,RecordRef.COUNT,ExpectedTotaling3);
      FieldRef.SETRANGE(Expected);
      Assert.AreEqual(1,RecordRef.COUNT,ExpectedTotaling1);
      FieldRef.SETRANGE;
    END;

    LOCAL PROCEDURE VerifyAllocTargetShareWithMultipleLines@172(Count@1003 : Integer;ID@1000 : Code[10];LineNo@1001 : Integer;ExpectedShare@1005 : Decimal);
    VAR
      CostAllocationTarget@1002 : Record 1107;
      i@1004 : Integer;
    BEGIN
      FOR i := 1 TO Count DO BEGIN
        CostAllocationTarget.GET(ID,LineNo);
        CostAllocationTarget.TESTFIELD(Share,ExpectedShare);
        LineNo := LineNo + 1;
      END;
    END;

    BEGIN
    {
      // [FEATURE] [Cost Accounting]
      Unsupported version tags:
      SE: Unable to Execute

      TFS270021 - Codeunits 1103, 1104
      TFS272799 - Codeunit 1108, 1113
      TFS270023 - Codeunit 1106
      TFS270022 - Codeunit 1105
      TFS270022 - Codeunit 1107

      Test functions of CostJnlManagement.
      1. Test that the standard cost journal template is created when no cost journal template exist.
      2. Test that the first cost journal template is selected when a single cost journal template exist.
      3. Test that a Cost journal template page is open to select template if multiple cost journal template exists.
      4. Test cost journal batch on cost journal page when page is opened through batch.
      5. Test that a DEFAULT batch name is automatically created for a new cost journal template name if no cost journal batch exist for it.
      6. Test that balance and total balance on cost journal page are equal to expected balance and expected total balance.

      Test functions of Transfer GL Entries to CA.
      1. Test that error will appear if Transfer GL Entries to CA will run without any G/L Entries.
      2. Test the Cost register and cost enries after running Transfer GL Entries to CA after G/L entries posted with Cost Center dimension.
      3. Test the Cost register and cost enries after running Transfer GL Entries to CA after G/L entries posted with Cost Object dimension.
      4. Test that the LinkCostTypesToGLAccounts works correctly if confirm is Yes.
      5. Test that the LinkCostTypesToGLAccounts works correctly if confirm is No.

      Test functions of CA Jnl.-B. Post.
      1. Test to verify that when cost journal lines get posted it shows the appropriate message and line doesnot exist on Cost Journal Line.
      2. Test to verify that when cost journal lines did not get posted it shows the appropriate message and line exisit on Cost Journal Line.

      Test Functions of CA Jnl.-Post Batch
      1. Post Batch-Test error is displayed when Cost Journal Batch Name exceed its defined length.
      2. Test Cost Journal Line is posted successfully in Cost Entries.
      3. Test that error is displayed on posting Cost Journal Line when Balance Cost Type No. Field is blank.
      4. Test that Cost Journal Line is deleted successfully after posting it.

      Test functions of Cost Accounting.
      1.Test the Shares are correct after executing Calculate Alloction Key for two Dynamics Allocation Targets with Base = "Items Sold Qty." and different Cost Center Filters.

      Covers Test Cases for WI - 243045
      ----------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                  TFS ID
      ----------------------------------------------------------------------------------------------------------
      TestChartOfCostCenterIndent                                                                         151721
      TestChartOfCostObjectIndent                                                                         151722
      TestChartOfCostTypeIndent                                                                           257396

      Covers Test Cases for WI - 308239
      ----------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                  TFS ID
      ----------------------------------------------------------------------------------------------------------
      TestCostCenterEndTotalError,TestCostObjectEndTotalError                                             308239
      LinkCostTypeToGLForDuplicateGLAccRange,PostingDateLessthanAllowPostingFrom
      PostingDateGreaterthanAllowPostingTo,CancelPostingAction,EmptyCostJournalBatch

      Covers Test Cases for WI - 71888
      ----------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                  TFS ID
      ----------------------------------------------------------------------------------------------------------
      TestCalcAllocationKeyForDifferentCostCenterFilter                                                    71888
    }
    END.
  }
}

