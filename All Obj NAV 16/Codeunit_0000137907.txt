OBJECT Codeunit 137907 SCM Assembly Order Functions
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=VAR
            MfgSetup@1000 : Record 99000765;
          BEGIN
            MfgSetup.GET;
            WorkDate2 := CALCDATE(MfgSetup."Default Safety Lead Time",WORKDATE); // to avoid Due Date Before Work Date message.
          END;

  }
  CODE
  {
    VAR
      Assert@1000 : Codeunit 130000;
      MSGAssertLineCount@1004 : TextConst 'ENU=Bad Line count of Order: %1 expected %2, got %3';
      LibraryAssembly@1010 : Codeunit 132207;
      LibraryInventory@1005 : Codeunit 132201;
      LibraryKitting@1002 : Codeunit 132205;
      LibraryManufacturing@1003 : Codeunit 132202;
      LibraryRandom@1011 : Codeunit 130440;
      LibraryUtility@1012 : Codeunit 131000;
      LibraryDimension@1013 : Codeunit 131001;
      LibrarySales@1014 : Codeunit 130509;
      LibraryPlanning@1015 : Codeunit 132203;
      LibrarySetupStorage@1016 : Codeunit 131009;
      WorkDate2@1006 : Date;
      RefreshingBomCnfm@1007 : TextConst 'ENU=This assembly order may have customized lines. Are you sure that you want to reset the lines according to the assembly BOM?';
      UpdateDimCnfm@1008 : TextConst 'ENU=Do you want to update the Dimensions on the lines?';
      Initialized@1001 : Boolean;
      MSGDueDateBeforeWorkDate@1009 : TextConst 'ENU=is before work date';
      DimErr@1017 : TextConst 'ENU=Incorrect Dimension Set ID';
      ShortcutDimErr@1018 : TextConst 'ENU=Incorrect Shortcut Dimension';
      Description2AssemblyLineResourceNotBlankErr@1019 : TextConst 'ENU=Description 2 field of Assembly Line table must be blank for Type Resource.';
      Description2AssemblyLineItemDoesntMatchErr@1020 : TextConst 'ENU=Description 2 field of Assembly Line table must match to related component item Description 2 for Type Item.';

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ExplodeBomOneItem@10();
    VAR
      AssemblyHeader@1001 : Record 900;
      AssemblyLine@1004 : Record 901;
      BOMComp@1002 : Record 90;
      parentItem@1000 : Record 27;
      childItem@1003 : Record 27;
      childItem2@1006 : Record 27;
    BEGIN
      Initialize;
      parentItem.GET(LibraryKitting.CreateItemWithLotAndNewUOM(500,700,1));
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,LibraryKitting.CreateOrder(WorkDate2,parentItem."No.",1));
      childItem.GET(LibraryKitting.CreateItemWithNewUOM(500,700));
      LibraryManufacturing.CreateBOMComponent(
        BOMComp,parentItem."No.",BOMComp.Type::Item,childItem."No.",1,childItem."Base Unit of Measure");

      AssemblyHeader.RefreshBOM;
      ValidateCount(AssemblyHeader."No.",1);
      childItem2.GET(LibraryKitting.CreateItemWithNewUOM(500,700));
      LibraryManufacturing.CreateBOMComponent(
        BOMComp,childItem."No.",BOMComp.Type::Item,childItem2."No.",1,childItem2."Base Unit of Measure");

      FindAssemblyLine(AssemblyLine,AssemblyHeader);

      AssemblyLine.ExplodeAssemblyList;
      ValidateCount(AssemblyHeader."No.",2);
      ASSERTERROR ERROR('') // roll back
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ExplodeBomTwoItem@5();
    VAR
      AssemblyHeader@1001 : Record 900;
      AssemblyLine@1004 : Record 901;
      BOMComp@1002 : Record 90;
      parentItem@1000 : Record 27;
      childItem@1003 : Record 27;
      childItem2@1005 : Record 27;
    BEGIN
      Initialize;
      parentItem.GET(LibraryKitting.CreateItemWithLotAndNewUOM(500,700,1));
      parentItem.VALIDATE("Costing Method",parentItem."Costing Method"::Average);
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,LibraryKitting.CreateOrder(WorkDate2,parentItem."No.",1));
      childItem.GET(LibraryKitting.CreateItemWithNewUOM(500,700));
      LibraryManufacturing.CreateBOMComponent(
        BOMComp,parentItem."No.",BOMComp.Type::Item,childItem."No.",1,childItem."Base Unit of Measure");

      AssemblyHeader.RefreshBOM;
      ValidateCount(AssemblyHeader."No.",1);
      childItem2.GET(LibraryKitting.CreateItemWithNewUOM(500,700));
      LibraryManufacturing.CreateBOMComponent(
        BOMComp,childItem."No.",BOMComp.Type::Item,childItem2."No.",1,childItem2."Base Unit of Measure");
      childItem2.GET(LibraryKitting.CreateItemWithNewUOM(100,200));
      LibraryManufacturing.CreateBOMComponent(
        BOMComp,childItem."No.",BOMComp.Type::Item,childItem2."No.",2,childItem2."Base Unit of Measure");

      FindAssemblyLine(AssemblyLine,AssemblyHeader);

      AssemblyLine.ExplodeAssemblyList;
      ValidateCount(AssemblyHeader."No.",3);
      ValidateQuantityonLines(AssemblyHeader."No.",3);
      AssemblyHeader.UpdateUnitCost;
      ValidateOrderUnitCost(AssemblyHeader,1 * (1 * 500 + 2 * 100));
      ASSERTERROR ERROR('') // roll back
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ExplodeBomSkip@4();
    VAR
      AssemblyHeader@1001 : Record 900;
      AssemblyLine@1004 : Record 901;
      BOMComp@1002 : Record 90;
      parentItem@1000 : Record 27;
      childItem@1003 : Record 27;
      childItem2@1005 : Record 27;
    BEGIN
      Initialize;
      parentItem.GET(LibraryKitting.CreateItemWithLotAndNewUOM(500,700,1));
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,LibraryKitting.CreateOrder(WorkDate2,parentItem."No.",1));
      childItem.GET(LibraryKitting.CreateItemWithNewUOM(500,700));
      LibraryManufacturing.CreateBOMComponent(
        BOMComp,parentItem."No.",BOMComp.Type::Item,childItem."No.",1,childItem."Base Unit of Measure");

      AssemblyHeader.RefreshBOM;
      ValidateCount(AssemblyHeader."No.",1);
      childItem2.GET(LibraryKitting.CreateItemWithNewUOM(500,700));
      LibraryManufacturing.CreateBOMComponent(
        BOMComp,childItem."No.",BOMComp.Type::Item,childItem2."No.",1,childItem2."Base Unit of Measure");

      FindAssemblyLine(AssemblyLine,AssemblyHeader);

      AssemblyLine.ExplodeAssemblyList;  // Can't be esscaped anymore as dimension is not asked anymore
      ValidateCount(AssemblyHeader."No.",2); // was 1 before we removed the question
      ASSERTERROR ERROR('') // roll back
    END;

    [Test]
    [HandlerFunctions(DimensionSetupRefreshConfirmHandler,AvailabilityWindowHandler)]
    PROCEDURE DimensionSetup@16();
    VAR
      AssemblyHeader@1002 : Record 900;
      AssemblyLine@1001 : Record 901;
      BOMComp@1000 : Record 90;
      ParentItem@1013 : Record 27;
      ChildItem@1005 : Record 27;
      Dimension1@1026 : Record 348;
      Dimension2@1025 : Record 348;
      Dimension3@1024 : Record 348;
      DimValue1@1023 : Record 349;
      DimValue2@1022 : Record 349;
      DimValue21@1021 : Record 349;
      DimValue22@1020 : Record 349;
      DimValue3@1019 : Record 349;
      AsmSetup@1011 : Record 905;
      DefaultDim@1016 : Record 352;
      TempDimSetEntry@1017 : TEMPORARY Record 480;
      TempDimSetEntryLinePost@1007 : TEMPORARY Record 480;
      DimMgt@1012 : Codeunit 408;
      LibraryDimension@1027 : Codeunit 131001;
      LibraryAssembly@1028 : Codeunit 132207;
      DimSetID1@1006 : Integer;
      DimSetID2@1008 : Integer;
      parent@1004 : Code[20];
      child@1003 : Code[20];
    BEGIN
      Initialize;
      LibraryKitting.SetCopyFrom(0); // Header

      // Setup dimensions
      LibraryDimension.CreateDimension(Dimension1);
      LibraryDimension.CreateDimensionValue(DimValue1,Dimension1.Code);
      LibraryDimension.CreateDimensionValue(DimValue2,Dimension1.Code);

      LibraryDimension.CreateDimension(Dimension2);
      LibraryDimension.CreateDimensionValue(DimValue21,Dimension2.Code);
      LibraryDimension.CreateDimensionValue(DimValue22,Dimension2.Code);
      LibraryDimension.CreateDimension(Dimension3);
      LibraryDimension.CreateDimensionValue(DimValue3,Dimension3.Code);

      // Add dimension to Dim Set
      TempDimSetEntry."Dimension Code" := Dimension1.Code;
      TempDimSetEntry."Dimension Value Code" := DimValue1.Code;
      TempDimSetEntry."Dimension Value ID" := DimValue1."Dimension Value ID";
      TempDimSetEntry.INSERT;
      TempDimSetEntry."Dimension Code" := Dimension2.Code;
      TempDimSetEntry."Dimension Value Code" := DimValue21.Code;
      TempDimSetEntry."Dimension Value ID" := DimValue21."Dimension Value ID";
      TempDimSetEntry.INSERT;

      DimSetID1 := DimMgt.GetDimensionSetID(TempDimSetEntry);

      TempDimSetEntry.DELETEALL;
      TempDimSetEntry."Dimension Code" := Dimension1.Code;
      TempDimSetEntry."Dimension Value Code" := DimValue2.Code;
      TempDimSetEntry."Dimension Value ID" := DimValue2."Dimension Value ID";
      TempDimSetEntry.INSERT;
      TempDimSetEntry."Dimension Code" := Dimension2.Code;
      TempDimSetEntry."Dimension Value Code" := DimValue22.Code;
      TempDimSetEntry."Dimension Value ID" := DimValue22."Dimension Value ID";
      TempDimSetEntry.INSERT;
      TempDimSetEntry."Dimension Code" := Dimension3.Code;
      TempDimSetEntry."Dimension Value Code" := DimValue3.Code;
      TempDimSetEntry."Dimension Value ID" := DimValue3."Dimension Value ID";
      TempDimSetEntry.INSERT;

      DimSetID2 := DimMgt.GetDimensionSetID(TempDimSetEntry);
      parent := LibraryKitting.CreateItemWithLotAndNewUOM(500,700,1);
      child := LibraryKitting.CreateItemWithNewUOM(500,700);
      ParentItem.GET(parent);
      ChildItem.GET(child);

      DefaultDim.INIT;
      DefaultDim.VALIDATE("Table ID",DATABASE::Item);
      DefaultDim.VALIDATE("No.",ParentItem."No.");
      DefaultDim.VALIDATE("Dimension Code",Dimension1.Code);
      DefaultDim.VALIDATE("Dimension Value Code",DimValue1.Code);
      DefaultDim.INSERT;
      DefaultDim.VALIDATE("Table ID",DATABASE::Item);
      DefaultDim.VALIDATE("No.",ParentItem."No.");
      DefaultDim.VALIDATE("Dimension Code",Dimension2.Code);
      DefaultDim.VALIDATE("Dimension Value Code",DimValue21.Code);
      DefaultDim.INSERT;

      DefaultDim.INIT;
      DefaultDim.VALIDATE("Table ID",DATABASE::Item);
      DefaultDim.VALIDATE("No.",ChildItem."No.");
      DefaultDim.VALIDATE("Dimension Code",Dimension1.Code);
      DefaultDim.VALIDATE("Dimension Value Code",DimValue2.Code);
      DefaultDim.INSERT;
      DefaultDim.VALIDATE("Table ID",DATABASE::Item);
      DefaultDim.VALIDATE("No.",ChildItem."No.");
      DefaultDim.VALIDATE("Dimension Code",Dimension2.Code);
      DefaultDim.VALIDATE("Dimension Value Code",DimValue22.Code);
      DefaultDim.INSERT;
      DefaultDim.VALIDATE("Table ID",DATABASE::Item);
      DefaultDim.VALIDATE("No.",ChildItem."No.");
      DefaultDim.VALIDATE("Dimension Code",Dimension3.Code);
      DefaultDim.VALIDATE("Dimension Value Code",DimValue3.Code);
      DefaultDim.INSERT;

      LibraryManufacturing.CreateBOMComponent(
        BOMComp,parent,BOMComp.Type::Item,child,1,ChildItem."Base Unit of Measure");
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,LibraryKitting.CreateOrder(WorkDate2,parent,1));

      // Set the refreshBom Method
      // TEST WITH THE ASM setup option Copy Component Dimensions from := Order Header
      AsmSetup.FINDFIRST;
      AsmSetup.VALIDATE("Copy Component Dimensions from",AsmSetup."Copy Component Dimensions from"::"Order Header");
      AsmSetup.MODIFY;

      AssemblyHeader.VALIDATE("Dimension Set ID",DimSetID1);
      AssemblyHeader.MODIFY(TRUE);

      LibraryAssembly.SetLinkToLines(AssemblyHeader,AssemblyLine);

      AssemblyLine.FINDFIRST;
      AssemblyLine.VALIDATE("Dimension Set ID",DimSetID2);
      AssemblyHeader.RefreshBOM;
      // find children lines and verify dimensions
      LibraryAssembly.SetLinkToLines(AssemblyHeader,AssemblyLine);
      AssemblyLine.FINDFIRST;
      Assert.AreNotEqual(AssemblyLine."Dimension Set ID",0,'AssemblyLine.Dimension Set ID must not be Zero');

      // Test the refreshBOM using AsmSetup."Copy Component Dimensions from"::"Order Header"
      DimMgt.GetDimensionSet(TempDimSetEntryLinePost,AssemblyLine."Dimension Set ID");

      // VERIFY
      Assert.AreEqual(AssemblyHeader."Dimension Set ID",DimSetID1,'Asm Header.Dimension Set ID changed');
      Assert.AreNotEqual(AssemblyLine."Dimension Set ID",DimSetID2,
        STRSUBSTNO(
          'AssemblyLine.Dimension Set ID did NOT change, which it is expected to Initital %1 after update %2',DimSetID2,
          AssemblyLine."Dimension Set ID"));

      TempDimSetEntryLinePost.SETFILTER("Dimension Code",Dimension1.Code);
      TempDimSetEntryLinePost.FINDFIRST;
      Assert.AreEqual(TempDimSetEntryLinePost."Dimension Value Code",DimValue1.Code,
        STRSUBSTNO('Wrong Dimension Value in Line, expected %1, got %2',DimValue1.Code,TempDimSetEntryLinePost."Dimension Value Code"));

      // TEST WITH THE OTHER ASM setup option Copy Component Dimensions from := Item/Resource Card
      AsmSetup.VALIDATE("Copy Component Dimensions from",AsmSetup."Copy Component Dimensions from"::"Item/Resource Card");
      AsmSetup.MODIFY;

      DimSetID2 := AssemblyLine."Dimension Set ID";
      AssemblyHeader.RefreshBOM;
      LibraryAssembly.SetLinkToLines(AssemblyHeader,AssemblyLine);
      AssemblyLine.FINDFIRST;
      // VERIFY
      Assert.AreEqual(AssemblyHeader."Dimension Set ID",DimSetID1,'Asm Header.Dimension Set ID changed');
      Assert.AreNotEqual(AssemblyLine."Dimension Set ID",DimSetID2,
        STRSUBSTNO(
          'AssemblyLine.Dimension Set ID did NOT change, which it is expected to Initital %1 after update %2',DimSetID2,
          AssemblyLine."Dimension Set ID"));

      DimMgt.GetDimensionSet(TempDimSetEntryLinePost,AssemblyLine."Dimension Set ID");
      TempDimSetEntryLinePost.SETFILTER("Dimension Code",Dimension1.Code);
      TempDimSetEntryLinePost.FINDFIRST;
      Assert.AreEqual(TempDimSetEntryLinePost."Dimension Value Code",DimValue2.Code,
        STRSUBSTNO('Wrong Dimension Value in Line, expected %1, got %2',DimValue2.Code,TempDimSetEntryLinePost."Dimension Value Code"));
      ASSERTERROR ERROR('') // roll back
    END;

    [Test]
    [HandlerFunctions(ItemSubstitutionPageHandler,AvailabilityWindowHandler,AvailabilityWarningHandler)]
    PROCEDURE Substitude@8();
    VAR
      AssemblyHeader@1002 : Record 900;
      AssemblyLine@1001 : Record 901;
      BOMComp@1000 : Record 90;
      ItemSubstitution@1005 : Record 5715;
      childItem@1007 : Record 27;
      subst@1006 : Code[20];
      parent@1004 : Code[20];
    BEGIN
      Initialize;
      parent := LibraryKitting.CreateItemWithLotAndNewUOM(500,700,1);
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,LibraryKitting.CreateOrder(WorkDate2,parent,1));
      childItem.GET(LibraryKitting.CreateItemWithNewUOM(500,700));
      LibraryManufacturing.CreateBOMComponent(
        BOMComp,parent,BOMComp.Type::Item,childItem."No.",1,childItem."Base Unit of Measure");

      AssemblyHeader.RefreshBOM;
      ValidateCount(AssemblyHeader."No.",1);

      FindAssemblyLine(AssemblyLine,AssemblyHeader);

      subst := LibraryKitting.CreateItem(500,700,childItem."Base Unit of Measure");
      ItemSubstitution.CreateSubstitutionItem2Item(childItem."No.",'',subst,'',FALSE);
      AssemblyLine.ShowItemSub;
      ValidateNo(AssemblyLine,subst);

      ASSERTERROR ERROR('') // roll back
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE VSTF295357@3();
    VAR
      DueDate@1000 : Date;
    BEGIN
      DueDate := CALCDATE('<1Y>',WORKDATE);
      TestAsmOrderExplodeBOM(FALSE,DueDate);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE VSTF295357DueDateBeforeWorkDate@17();
    VAR
      DueDate@1000 : Date;
    BEGIN
      DueDate := CALCDATE('<-1Y>',WORKDATE);
      TestAsmOrderExplodeBOM(FALSE,DueDate);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE VSTF333588@13();
    VAR
      DueDate@1000 : Date;
    BEGIN
      DueDate := CALCDATE('<1Y>',WORKDATE);
      TestAsmOrderExplodeBOM(TRUE,DueDate);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler,DueDateBeforeWorkDateMsgHandler)]
    PROCEDURE VSTF333588DueDateBeforeWorkDate@14();
    VAR
      DueDate@1000 : Date;
    BEGIN
      DueDate := CALCDATE('<-1Y>',WORKDATE);
      TestAsmOrderExplodeBOM(TRUE,DueDate);
    END;

    [Test]
    PROCEDURE DimOnPlanningCompWithAssembly@24();
    VAR
      PlanningComponent@1003 : Record 99000829;
      Item@1001 : ARRAY [2] OF Record 27;
      DimSetID@1000 : ARRAY [2] OF Integer;
      DimValueCode@1002 : Code[20];
    BEGIN
      // [FEATURE] [Dimension] [Planning Worksheet]
      // [SCENARIO 377510] Planning Components should inherit Dimension from Requisition Line while planning through Planning Worksheet
      Initialize;

      // [GIVEN] Component Item with Default Dimension = "X"
      // [GIVEN] Parent Item with Default Dimension = "Y"
      // [GIVEN] Sales Order for Parent Item with "Shortcut Dimension Code 1" = "Z"
      DimValueCode := CreateSalesOrderForAssemblyItemWithDim(DimSetID,Item);

      // [WHEN] Calculate Regenerative Plan
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item[1],WORKDATE,WORKDATE);

      // [THEN] Planning Component is created with Dimension = "Y" and "Shortcut Dimension Code 1" = "Z"
      PlanningComponent.SETRANGE("Item No.",Item[2]."No.");
      PlanningComponent.FINDFIRST;
      Assert.AreEqual(DimSetID[1],PlanningComponent."Dimension Set ID",DimErr);
      Assert.AreEqual(DimValueCode,PlanningComponent."Shortcut Dimension 1 Code",ShortcutDimErr);
    END;

    [Test]
    PROCEDURE DimOnAssemblyLineCopiedFromHeader@15();
    VAR
      RequisitionLine@1002 : Record 246;
      AssemblySetup@1001 : Record 905;
      Item@1003 : ARRAY [2] OF Record 27;
      DimSetID@1000 : ARRAY [2] OF Integer;
    BEGIN
      // [FEATURE] [Dimension] [Planning Worksheet] [Copy Components Dimensions from]
      // [SCENARIO 377510] Default Dimension of Component should be taken from Assembly Header when "Copy Components Dimensions from" is "Order Header" in Assembly Setup
      Initialize;

      // [GIVEN] Assembly Setup where "Copy Components Dimensions from" is "Order Header"
      SetCopyCompDimOnAsmSetup(AssemblySetup."Copy Component Dimensions from"::"Order Header");

      // [GIVEN] Component Item with Default Dimension = "X"
      // [GIVEN] Parent Item with Default Dimension = "Y"
      // [GIVEN] Sales Order for Parent Item
      CreateSalesOrderForAssemblyItemWithDim(DimSetID,Item);

      // [GIVEN] Calculate Regenerative Plan for Parent Item
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item[1],WORKDATE,WORKDATE);
      AcceptActionMessageOnReqLines(RequisitionLine,Item[1]."No.");

      // [WHEN] Carry Out Action Message
      LibraryPlanning.CarryOutActionMsgPlanWksh(RequisitionLine);

      // [THEN] Assembly Line has Dimension equal to "Y"
      VerifyDimOnAssemblyLine(Item[1]."No.",DimSetID[1]);
    END;

    [Test]
    PROCEDURE DimOnAssemblyLineCopiedFromItem@20();
    VAR
      RequisitionLine@1013 : Record 246;
      AssemblySetup@1005 : Record 905;
      Item@1001 : ARRAY [2] OF Record 27;
      DimSetID@1000 : ARRAY [2] OF Integer;
    BEGIN
      // [FEATURE] [Dimension] [Planning Worksheet] [Copy Components Dimensions from]
      // [SCENARIO 377510] Default Dimension of Component should be taken from Component Item when "Copy Components Dimensions from" is "Item/Resource Card" in Assembly Setup
      Initialize;

      // [GIVEN] Assembly Setup where "Copy Components Dimensions from" is "Item/Resource Card"
      SetCopyCompDimOnAsmSetup(AssemblySetup."Copy Component Dimensions from"::"Item/Resource Card");

      // [GIVEN] Component Item with Default Dimension = "X"
      // [GIVEN] Parent Item with Default Dimension = "Y"
      // [GIVEN] Sales Order for Parent Item
      CreateSalesOrderForAssemblyItemWithDim(DimSetID,Item);

      // [GIVEN] Calculate Regenerative Plan for Parent Item
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item[1],WORKDATE,WORKDATE);
      AcceptActionMessageOnReqLines(RequisitionLine,Item[1]."No.");

      // [WHEN] Carry Out Action Message
      LibraryPlanning.CarryOutActionMsgPlanWksh(RequisitionLine);

      // [THEN] Assembly Line has Dimension equal to "X"
      VerifyDimOnAssemblyLine(Item[1]."No.",DimSetID[2]);
    END;

    [Test]
    [HandlerFunctions(AssemblyAvailabilityYesModalPageHandler,StubMessageHandler)]
    PROCEDURE Description2InAssemblyLineMatching@19();
    VAR
      ParentItem@1003 : Record 27;
      ChildItem@1005 : Record 27;
      BOMComponent@1002 : Record 90;
      AssemblyHeader@1001 : Record 900;
      AssemblyLine@1000 : Record 901;
      Resource@1004 : Record 156;
    BEGIN
      // [FEATURE] [Assembly BOM]
      // [SCENARIO 381865] Field "Description 2" should not be populated in assembly line with Type = "Resource". For a line with Type = "Item", it should be copied from the component item.
      Initialize;

      // [GIVEN] Parent Assembly Item PAI with populated Description 2.
      LibraryInventory.CreateItem(ParentItem);
      WITH ParentItem DO BEGIN
        VALIDATE("Replenishment System","Replenishment System"::Assembly);
        VALIDATE("Description 2",LibraryUtility.GenerateRandomCode(FIELDNO("Description 2"),DATABASE::Item));
        MODIFY(TRUE);
      END;

      // [GIVEN] Child Item CI with populated Description 2 as a BOM Component of type Item for PAI.
      LibraryInventory.CreateItem(ChildItem);
      WITH ChildItem DO BEGIN
        VALIDATE("Description 2",LibraryUtility.GenerateRandomCode(FIELDNO("Description 2"),DATABASE::Item));
        MODIFY(TRUE);
      END;
      LibraryManufacturing.CreateBOMComponent(
        BOMComponent,ParentItem."No.",BOMComponent.Type::Item,ChildItem."No.",1,'');

      // [GIVEN] A BOM Component of type Resource for PAI.
      LibraryManufacturing.CreateBOMComponent(
        BOMComponent,ParentItem."No.",BOMComponent.Type::Resource,LibraryAssembly.CreateResource(Resource,TRUE,''),1,'');

      // [WHEN] Create Assembly Header for PAI and populate Quantity
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WORKDATE,ParentItem."No.",'',LibraryRandom.RandInt(10),'');

      WITH AssemblyLine DO BEGIN
        SETRANGE("Document Type",AssemblyHeader."Document Type");
        SETRANGE("Document No.",AssemblyHeader."No.");
        SETRANGE(Type,Type::Resource);
        FINDFIRST;

        // [THEN] the field "Description 2" of related Assembly Line of Type Resource is blank.
        Assert.AreEqual('',"Description 2",Description2AssemblyLineResourceNotBlankErr);

        SETRANGE(Type,Type::Item);
        FINDFIRST;

        // [THEN] the field "Description 2" of related Assembly Line of Type Item is equal to CI."Description 2".
        Assert.AreEqual(ChildItem."Description 2","Description 2",Description2AssemblyLineItemDoesntMatchErr);
      END;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ExplodeBOMDiffUnitOfMeasure@25();
    VAR
      Item@1000 : ARRAY [3] OF Record 27;
      ItemUnitOfMeasure@1001 : ARRAY [3] OF Record 5404;
      BOMComponent@1002 : Record 90;
      AssemblyHeader@1004 : Record 900;
      AssemblyLine@1005 : Record 901;
      ExpectedQty@1003 : Decimal;
      ExpectedQtyBase@1006 : Decimal;
    BEGIN
      // [FEATURE] [Explode BOM] [Item Unit of Measure]
      // [SCENARIO 211722] Function "Explode BOM" of the assembly order should consider the order unit of measure when calculating the quantity of a component item
      Initialize;

      // [GIVEN] Item "A" with an additional unit of measure "UoM1", "Qty. per Unit of Measure" = 2
      LibraryInventory.CreateItem(Item[1]);
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure[1],Item[1]."No.",LibraryRandom.RandIntInRange(2,10));

      // [GIVEN] Item "B" with an additional unit of measure "UoM2", "Qty. per Unit of Measure" = 3
      // [GIVEN] Item "B" is an assembly component of "A", unit of measure of the component is "UoM2"
      LibraryInventory.CreateItem(Item[2]);
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure[2],Item[2]."No.",LibraryRandom.RandIntInRange(2,10));
      LibraryManufacturing.CreateBOMComponent(
        BOMComponent,Item[1]."No.",BOMComponent.Type::Item,Item[2]."No.",1,ItemUnitOfMeasure[2].Code);

      // [GIVEN] Item "C" with an additional unit of measure "UoM3", "Qty. per Unit of Measure" = 4
      // [GIVEN] Item "C" is an assembly component of "B", unit of measure of the component is "UoM3"
      LibraryInventory.CreateItem(Item[3]);
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure[3],Item[3]."No.",LibraryRandom.RandIntInRange(2,10));
      LibraryManufacturing.CreateBOMComponent(
        BOMComponent,Item[2]."No.",BOMComponent.Type::Item,Item[3]."No.",1,ItemUnitOfMeasure[3].Code);

      // [GIVEN] Create an assembly order for te top-level item "A", unit of measure = "UOM1"
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,LibraryKitting.CreateOrder(WorkDate2,Item[1]."No.",1));
      AssemblyHeader.VALIDATE("Unit of Measure Code",ItemUnitOfMeasure[1].Code);
      AssemblyHeader.MODIFY(TRUE);

      FindAssemblyLine(AssemblyLine,AssemblyHeader);

      // [WHEN] Run "Explode BOM" function on the item "B"
      AssemblyLine.ExplodeAssemblyList;

      // [THEN] Quantity of the low-level item "C" in the order line is 2 * 3 = 6
      // [THEN] "Quantity (Base)" of the item "C" in the order line is 2 * 3 * 4 = 24
      ExpectedQty := ItemUnitOfMeasure[1]."Qty. per Unit of Measure" * ItemUnitOfMeasure[2]."Qty. per Unit of Measure";
      ExpectedQtyBase := ExpectedQty * ItemUnitOfMeasure[3]."Qty. per Unit of Measure";
      VerifyAssemblyLineQty(Item[3]."No.",ExpectedQty,ExpectedQtyBase);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ExplodeBOMQuantityPerLine@51();
    VAR
      Item@1000 : ARRAY [3] OF Record 27;
      BOMComponent@1002 : Record 90;
      AssemblyHeader@1004 : Record 900;
      AssemblyLine@1005 : Record 901;
      QtyPerLine@1001 : ARRAY [2] OF Decimal;
    BEGIN
      // [FEATURE] [Explode BOM]
      // [SCENARIO 211722] Function "Explode BOM" of the assembly order should calculate the quantity of a component item based on "Quantity per" in the order line

      Initialize;

      // [GIVEN] 3 items "A", "B" and "C"
      QtyPerLine[1] := LibraryRandom.RandIntInRange(2,10);
      QtyPerLine[2] := LibraryRandom.RandIntInRange(2,10);

      // [GIVEN] Item "B" is an assembly component of "A", "Quantity per" = 2
      LibraryInventory.CreateItem(Item[1]);
      LibraryInventory.CreateItem(Item[2]);
      LibraryManufacturing.CreateBOMComponent(
        BOMComponent,Item[1]."No.",BOMComponent.Type::Item,Item[2]."No.",QtyPerLine[1],Item[2]."Base Unit of Measure");

      // [GIVEN] Item "C" is a component of "B", "Quantity per" = 3
      LibraryInventory.CreateItem(Item[3]);
      LibraryManufacturing.CreateBOMComponent(
        BOMComponent,Item[2]."No.",BOMComponent.Type::Item,Item[3]."No.",QtyPerLine[2],Item[3]."Base Unit of Measure");

      // [GIVEN] Create an assembly order for te top-level item "A"
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,LibraryKitting.CreateOrder(WorkDate2,Item[1]."No.",1));
      FindAssemblyLine(AssemblyLine,AssemblyHeader);

      // [WHEN] Run "Explode BOM" function on the item "B"
      AssemblyLine.ExplodeAssemblyList;

      // [THEN] Quantity of the low-level item "C" in the order line is 2 * 3 = 6
      VerifyAssemblyLineQty(Item[3]."No.",QtyPerLine[1] * QtyPerLine[2],QtyPerLine[1] * QtyPerLine[2]);
    END;

    LOCAL PROCEDURE Initialize@31();
    VAR
      LibraryERMCountryData@1000 : Codeunit 131305;
    BEGIN
      LibrarySetupStorage.Restore;

      IF Initialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;

      LibrarySetupStorage.Save(DATABASE::"Assembly Setup");

      Initialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE SetCopyCompDimOnAsmSetup@33(CopyComponentDimensionsFrom@1001 : Option);
    VAR
      AssemblySetup@1000 : Record 905;
    BEGIN
      WITH AssemblySetup DO BEGIN
        GET;
        VALIDATE("Copy Component Dimensions from",CopyComponentDimensionsFrom);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateItemWithDefaultDimension@22(VAR Item@1000 : Record 27;DimensionValue@1001 : Record 349) : Integer;
    VAR
      DefaultDimension@1002 : Record 352;
    BEGIN
      LibraryInventory.CreateItem(Item);
      WITH Item DO BEGIN
        VALIDATE("Replenishment System","Replenishment System"::Assembly);
        VALIDATE("Reordering Policy","Reordering Policy"::Order);
        MODIFY(TRUE);
      END;
      LibraryDimension.CreateDefaultDimensionItem(DefaultDimension,Item."No.",DimensionValue."Dimension Code",DimensionValue.Code);
      EXIT(MockDimSetEntry(DimensionValue));
    END;

    LOCAL PROCEDURE MockDimSetEntry@32(DimensionValue@1001 : Record 349) : Integer;
    VAR
      TempDimSetEntry@1000 : TEMPORARY Record 480;
      DimMgt@1002 : Codeunit 408;
    BEGIN
      WITH TempDimSetEntry DO BEGIN
        INIT;
        "Dimension Code" := DimensionValue."Dimension Code";
        "Dimension Value Code" := DimensionValue.Code;
        "Dimension Value ID" := DimensionValue."Dimension Value ID";
        INSERT;
      END;
      EXIT(DimMgt.GetDimensionSetID(TempDimSetEntry));
    END;

    LOCAL PROCEDURE AcceptActionMessageOnReqLines@26(VAR RequisitionLine@1000 : Record 246;ItemNo@1001 : Code[20]);
    BEGIN
      WITH RequisitionLine DO BEGIN
        SETRANGE("No.",ItemNo);
        FINDSET;
        MODIFYALL("Accept Action Message",TRUE,TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateSalesOrderForAssemblyItemWithDim@36(VAR DimSetID@1000 : ARRAY [2] OF Integer;VAR Item@1001 : ARRAY [2] OF Record 27) : Code[20];
    VAR
      BOMComponent@1002 : Record 90;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      DimensionValue@1007 : Record 349;
      GeneralLedgerSetup@1003 : Record 98;
    BEGIN
      GeneralLedgerSetup.GET;
      LibraryDimension.CreateDimensionValue(DimensionValue,GeneralLedgerSetup."Shortcut Dimension 1 Code");
      DimSetID[1] := CreateItemWithDefaultDimension(Item[1],DimensionValue);
      DimSetID[2] := CreateItemWithDefaultDimension(Item[2],DimensionValue);
      LibraryAssembly.CreateAssemblyListComponent(
        BOMComponent.Type::Item,Item[2]."No.",Item[1]."No.",'',BOMComponent."Resource Usage Type",LibraryRandom.RandInt(10),TRUE);

      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,'');
      LibrarySales.CreateSalesLine(
        SalesLine,SalesHeader,SalesLine.Type::Item,Item[1]."No.",LibraryRandom.RandInt(10));

      EXIT(DimensionValue.Code);
    END;

    LOCAL PROCEDURE FindAssemblyLine@37(VAR AssemblyLine@1000 : Record 901;AssemblyHeader@1001 : Record 900);
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.FINDFIRST;
    END;

    LOCAL PROCEDURE TestAsmOrderExplodeBOM@12(ExplodeBOMFromPage@1013 : Boolean;DueDate@1014 : Date);
    VAR
      ChildChildItem@1000 : Record 27;
      ChildItem@1001 : Record 27;
      ParentItem@1002 : Record 27;
      BOMComponent@1003 : Record 90;
      AsmHeader@1004 : Record 900;
      AsmLine@1005 : Record 901;
      AsmLineMgt@1006 : Codeunit 905;
      AsmOrderTestPage@1012 : TestPage 900;
      ChildItemDesc1@1007 : Code[20];
      ChildItemDesc2@1008 : Code[20];
      ParentItemDesc1@1009 : Code[20];
      ParentItemDesc2@1010 : Code[20];
      ResourceNo@1015 : Code[20];
      LineCount@1011 : Integer;
      ExpectedNoLines@1016 : Integer;
    BEGIN
      // SETUP
      // Make the BOM tree
      Initialize;
      LibraryInventory.CreateItem(ChildChildItem);

      // Create child assembly item
      LibraryInventory.CreateItem(ChildItem);
      ChildItem."Replenishment System" := ChildItem."Replenishment System"::Assembly;
      ChildItem.MODIFY;
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ChildItem."No.",BOMComponent.Type::" ",'',1,'');
      ChildItemDesc1 := LibraryUtility.GenerateRandomCode(BOMComponent.FIELDNO(Description),DATABASE::"BOM Component");
      BOMComponent.VALIDATE(Description,ChildItemDesc1);
      BOMComponent.MODIFY;
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ChildItem."No.",BOMComponent.Type::Item,ChildChildItem."No.",1,'');
      ResourceNo := LibraryKitting.CreateResourceWithNewUOM(1,1); // Any resource price/cost
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ChildItem."No.",BOMComponent.Type::Resource,ResourceNo,1,'');
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ChildItem."No.",BOMComponent.Type::" ",'',1,'');
      ChildItemDesc2 := LibraryUtility.GenerateRandomCode(BOMComponent.FIELDNO(Description),DATABASE::"BOM Component");
      BOMComponent.VALIDATE(Description,ChildItemDesc2);
      BOMComponent.MODIFY;

      // Create parent assembly item
      LibraryInventory.CreateItem(ParentItem);
      ParentItem."Replenishment System" := ParentItem."Replenishment System"::Assembly;
      ParentItem.MODIFY;
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentItem."No.",BOMComponent.Type::" ",'',1,'');
      ParentItemDesc1 := LibraryUtility.GenerateRandomCode(BOMComponent.FIELDNO(Description),DATABASE::"BOM Component");
      BOMComponent.VALIDATE(Description,ParentItemDesc1);
      BOMComponent.MODIFY;
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentItem."No.",BOMComponent.Type::Item,ChildItem."No.",1,'');
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentItem."No.",BOMComponent.Type::" ",'',1,'');
      ParentItemDesc2 := LibraryUtility.GenerateRandomCode(BOMComponent.FIELDNO(Description),DATABASE::"BOM Component");
      BOMComponent.VALIDATE(Description,ParentItemDesc2);
      BOMComponent.MODIFY;

      // Make Asm header and lines
      LibraryAssembly.CreateAssemblyHeader(AsmHeader,DueDate,ParentItem."No.",'',LibraryRandom.RandInt(10),'');

      // EXERCISE
      // Call the explode BOM function
      IF ExplodeBOMFromPage THEN BEGIN
        AsmOrderTestPage.OPENEDIT;
        AsmOrderTestPage.FILTER.SETFILTER("Document Type",FORMAT(AsmHeader."Document Type"::Order));
        AsmOrderTestPage.FILTER.SETFILTER("No.",AsmHeader."No.");
        AsmOrderTestPage.Lines.FILTER.SETFILTER(Type,FORMAT(AsmLine.Type::Item));
        AsmOrderTestPage.Lines.FILTER.SETFILTER("No.",ChildItem."No.");
        AsmOrderTestPage.FIRST;
        AsmOrderTestPage.Lines.ExplodeBOM.INVOKE
      END ELSE BEGIN
        AsmLine.SETRANGE("Document Type",AsmHeader."Document Type");
        AsmLine.SETRANGE("Document No.",AsmHeader."No.");
        AsmLine.SETRANGE(Type,AsmLine.Type::Item);
        AsmLine.SETRANGE("No.",ChildItem."No.");
        AsmLine.FINDSET;
        AsmLineMgt.ExplodeAsmList(AsmLine);
      END;

      // VERIFY
      AsmLine.RESET;
      FindAssemblyLine(AsmLine,AsmHeader);
      LineCount := 0;
      ExpectedNoLines := 7;
      REPEAT
        LineCount += 1;
        CASE LineCount OF
          1: // line 1
            BEGIN
              AsmLine.TESTFIELD(Type,AsmLine.Type::" ");
              AsmLine.TESTFIELD("No.",'');
              AsmLine.TESTFIELD(Description,ParentItemDesc1);
            END;
          2: // line 2
            BEGIN
              AsmLine.TESTFIELD(Type,AsmLine.Type::" ");
              AsmLine.TESTFIELD("No.",ChildItem."No.");
            END;
          3: // line 3
            BEGIN
              AsmLine.TESTFIELD(Type,AsmLine.Type::" ");
              AsmLine.TESTFIELD("No.",'');
              AsmLine.TESTFIELD(Description,ChildItemDesc1);
            END;
          4: // line 4
            BEGIN
              AsmLine.TESTFIELD(Type,AsmLine.Type::Item);
              AsmLine.TESTFIELD("No.",ChildChildItem."No.");
              AsmLine.TESTFIELD("Avail. Warning",TRUE); // Availability warning after explosion
            END;
          5: // line 5 - VSTF333535
            BEGIN
              AsmLine.TESTFIELD(Type,AsmLine.Type::Resource);
              AsmLine.TESTFIELD("No.",ResourceNo);
            END;
          6: // line 6
            BEGIN
              AsmLine.TESTFIELD(Type,AsmLine.Type::" ");
              AsmLine.TESTFIELD("No.",'');
              AsmLine.TESTFIELD(Description,ChildItemDesc2);
            END;
          7: // line 7
            BEGIN
              AsmLine.TESTFIELD(Type,AsmLine.Type::" ");
              AsmLine.TESTFIELD("No.",'');
              AsmLine.TESTFIELD(Description,ParentItemDesc2);
            END;
        END;
      UNTIL AsmLine.NEXT = 0;

      Assert.AreEqual(
        ExpectedNoLines,
        LineCount,
        STRSUBSTNO(MSGAssertLineCount,AsmHeader."No.",ExpectedNoLines,LineCount));
    END;

    LOCAL PROCEDURE ValidateOrderUnitCost@6(AssemblyHeader@1000 : Record 900;ExpectedCost@1001 : Decimal);
    BEGIN
      Assert.AreEqual(AssemblyHeader."Unit Cost",ExpectedCost,
        STRSUBSTNO('Bad Unit Cost of Assembly Order %1 Expected %2, got %3',
          AssemblyHeader."No.",
          ExpectedCost,
          AssemblyHeader."Unit Cost"));
    END;

    LOCAL PROCEDURE ValidateCount@7(OrderNo@1000 : Code[20];Count@1001 : Integer);
    VAR
      AssemblyHeader@1002 : Record 900;
      LibraryAssembly@1004 : Codeunit 132207;
    BEGIN
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,OrderNo);
      Assert.AreEqual(Count,LibraryAssembly.LineCount(AssemblyHeader),
        STRSUBSTNO(MSGAssertLineCount,OrderNo,Count,LibraryAssembly.LineCount(AssemblyHeader)));
    END;

    LOCAL PROCEDURE ValidateQuantityonLines@23(OrderNo@1000 : Code[20];Count@1001 : Integer);
    VAR
      AssemblyHeader@1002 : Record 900;
    BEGIN
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,OrderNo);
      Assert.AreEqual(Count,LibraryKitting.TotalQuantity(AssemblyHeader),
        STRSUBSTNO('Bad Line Quantity of Order: %1 expected %2, got %3',OrderNo,Count,LibraryKitting.TotalQuantity(AssemblyHeader)));
    END;

    LOCAL PROCEDURE ValidateNo@9(AsmLine@1000 : Record 901;Number@1001 : Code[20]);
    BEGIN
      Assert.IsFalse((AsmLine.Type <> AsmLine.Type::Item) OR (AsmLine."No." <> Number),
        STRSUBSTNO('Bad Item substitution in Line %1 Expected %2 got %3',
          AsmLine."Document No.",
          Number,
          AsmLine."No."));
    END;

    LOCAL PROCEDURE VerifyAssemblyLineQty@28(ItemNo@1001 : Code[20];ExpectedQty@1002 : Decimal;ExpectedQtyBase@1003 : Decimal);
    VAR
      AssemblyLine@1000 : Record 901;
    BEGIN
      WITH AssemblyLine DO BEGIN
        SETRANGE(Type,Type::Item);
        SETRANGE("No.",ItemNo);
        FINDFIRST;

        TESTFIELD(Quantity,ExpectedQty);
        TESTFIELD("Quantity (Base)",ExpectedQtyBase);
        TESTFIELD("Quantity per",ExpectedQty);
        TESTFIELD("Remaining Quantity",ExpectedQty);
        TESTFIELD("Remaining Quantity (Base)",ExpectedQtyBase);
        TESTFIELD("Quantity to Consume",ExpectedQty);
        TESTFIELD("Quantity to Consume (Base)",ExpectedQtyBase);
      END;
    END;

    LOCAL PROCEDURE VerifyDimOnAssemblyLine@21(ItemNo@1002 : Code[20];DimSetID@1003 : Integer);
    VAR
      AssemblyHeader@1001 : Record 900;
      AssemblyLine@1000 : Record 901;
    BEGIN
      AssemblyHeader.SETRANGE("Item No.",ItemNo);
      AssemblyHeader.FINDFIRST;
      WITH AssemblyLine DO BEGIN
        SETRANGE("Document Type","Document Type"::Order);
        SETRANGE("Document No.",AssemblyHeader."No.");
        FINDFIRST;
        Assert.AreEqual(DimSetID,"Dimension Set ID",DimErr);
      END;
    END;

    [ModalPageHandler]
    PROCEDURE AssemblyAvailabilityYesModalPageHandler@39(VAR AssemblyAvailability@1000 : TestPage 908);
    BEGIN
      AssemblyAvailability.Yes.INVOKE;
    END;

    [MessageHandler]
    PROCEDURE StubMessageHandler@46(MessageText@1000 : Text);
    BEGIN
    END;

    [ModalPageHandler]
    PROCEDURE ItemSubstitutionPageHandler@18(VAR ItemSubstitutionEntries@1000 : Page 5718;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::LookupOK;
    END;

    [ModalPageHandler]
    PROCEDURE AvailabilityWindowHandler@43(VAR AsmAvailability@1000 : Page 908;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::Yes; // always confirm
    END;

    [ModalPageHandler]
    PROCEDURE AvailabilityWarningHandler@2(VAR CheckAvailability@1002 : Page 342;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::Yes;
    END;

    [MessageHandler]
    PROCEDURE DueDateBeforeWorkDateMsgHandler@11(Message@1000 : Text);
    BEGIN
      Assert.IsTrue(STRPOS(Message,MSGDueDateBeforeWorkDate) > 0,MSGDueDateBeforeWorkDate);
    END;

    [ConfirmHandler]
    PROCEDURE DimensionSetupRefreshConfirmHandler@1(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Assert.IsTrue((STRPOS(Question,RefreshingBomCnfm) > 0) OR (STRPOS(Question,UpdateDimCnfm) > 0),
        STRSUBSTNO('Wrong question: %1',Question));
      Reply := TRUE;
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [SCM]
    }
    END.
  }
}

