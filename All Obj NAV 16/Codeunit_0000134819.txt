OBJECT Codeunit 134819 ERM Cost Accounting - Tables
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Permissions=TableData 17=rimd;
    Subtype=Test;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      Assert@1003 : Codeunit 130000;
      LibraryCostAccounting@1000 : Codeunit 131340;
      LibraryDimension@1015 : Codeunit 131001;
      LibraryERM@1042 : Codeunit 131300;
      LibraryUtility@1002 : Codeunit 131000;
      LibraryInventory@1045 : Codeunit 132201;
      LibraryFiscalYear@1037 : Codeunit 131302;
      LibraryRandom@1016 : Codeunit 130440;
      ExpectedValueIsDifferentError@1004 : TextConst 'ENU=Expected value of %1 field is different than the actual one.';
      CostAllocTargetCountError@1005 : TextConst 'ENU=The number of cost allocation targets is incorrect.';
      SelectionFilterManagement@1044 : Codeunit 46;
      GLAccFilter@1006 : Text;
      GLBudgetNameFilter@1009 : Text;
      CostBudgetNameFilter@1010 : Text;
      CostCenterFilter@1012 : Text;
      CostObjectFilter@1013 : Text;
      CostTypeFilter@1007 : Text;
      InvtPostingGroupFilter@1011 : Text;
      ItemFilter@1008 : Text;
      CostEntriesCountError@1014 : TextConst 'ENU=The number of cost entries is incorrect.';
      BalanceEqualToZero@1019 : TextConst 'ENU=Balance must be equal to ''0''';
      CostTypeNotDeleted@1001 : TextConst 'ENU=The Cost Type number %1 was not deleted.';
      CostRegisterEntriesNotClosed@1022 : TextConst 'ENU=The Cost Register entries were not closed.';
      EntriesWithinOpenFiscalYear@1023 : TextConst 'ENU=You cannot delete a cost type with entries in an open fiscal year.';
      IncorrectAddReportingCurrency@1020 : TextConst 'ENU=An incorrect value for the Additional Reporting Currency is retrieved.';
      UnexpectedErr@1021 : TextConst 'ENU=An unexpected error was thrown.';
      Text000@1024 : TextConst '@@@="%1=fieldcaption Entry No.;%2=tablecaption Cost Budget Entry;%3=integer or decimal";ENU=Field %1 on Table %2 is not %3 as expected.';
      Text001@1025 : TextConst '@@@="%1=tablecaption Cost Budget Register";ENU=A new record was not inserted in Table %1.';
      Text002@1026 : TextConst '@@@="%1=fieldcaption Last Modified By User or fieldcaption Last Date Modified;%2=USERID or DATE";ENU=The Field %1 was not updated to %2.';
      Text003@1027 : TextConst 'ENU=GetCostBudgetRegNo did not return the value set.';
      Text005@1029 : TextConst '@@@=error message from CompressBudgetEntries in Table Cost Budget Entry;ENU=This function must be started with a budget name.';
      Text007@1031 : TextConst '@@@="%1=tablecaption Cost Budget Entry";ENU=The compressed records in Table %1 were not deleted.';
      Text008@1032 : TextConst 'ENU=The compressed entry does not have the correct sum.';
      Text009@1033 : TextConst '@@@="%1=tablecaption Cost Budget Entry";ENU=The compressed %1 does not exist.';
      Text010@1034 : TextConst '@@@="%1=tablecaption Cost Budget Entry";ENU=The amount on the compressed %1 does not match the sum of the entries.';
      Text011@1035 : TextConst '@@@="%1=tablecaption Cost Budget Entry";ENU=The %1 to be compressed still exists.';
      Text012@1036 : TextConst '@@@="%1=tablecaption Cost Budget Register";ENU=The %1 does not exist.';
      Text014@1038 : TextConst 'ENU=A closed register cannot be reactivated.';
      Text015@1039 : TextConst '@@@="%1=tablecaption Cost Budget Register";ENU=A %1 was not closed.';
      Text016@1041 : TextConst '@@@="%1=fieldcaption Line Type;%2=tablecaption Cost Center;@3= fieldvalue Line Type;@4=fieldvalue Line Type;@5=Line Type";ENU=%1 must be %2 or %3 in %4 %5.';
      Text017@1040 : TextConst '@@@="%1=fieldcaption Blocked;%2=format(boolean);@3= fieldcaption No.;@4=format(boolean)";ENU="%1 must be equal to ''%2''  in Cost Type: No.=%3. Current value is ''%4''."';
      UnexpectedMessageError@1030 : TextConst 'ENU=The raised message is not the expected one. The actual message is: [%1], while the expected message is: [%2].';
      IncorrectLineTypeError@1043 : TextConst '@@@="%1:Field Value;%2:Table Caption;%3:Field Caption;%4:Field Value;";ENU="Line Type must not be %1 in %2 %3=''%4''."';
      CostEntryErr@1017 : TextConst 'ENU="There is no Cost Entry within the filter: ""G/L Entry No."" = ''%1''"';

    [Test]
    PROCEDURE AllocSourceCreateWhenLastAllocIDEmpty@3();
    VAR
      CostAccSetup@1000 : Record 1108;
      PrevLastAllocID@1002 : Code[10];
    BEGIN
      // Setup:
      CostAccSetup.GET;
      PrevLastAllocID := CostAccSetup."Last Allocation ID";
      CostAccSetup.VALIDATE("Last Allocation ID",'');
      CostAccSetup.MODIFY(TRUE);

      // Exercise & Verify:
      ASSERTERROR CreateAllocationSource(TRUE);

      // Clean-up:
      CostAccSetup."Last Allocation ID" := PrevLastAllocID;
      CostAccSetup.MODIFY;
    END;

    [Test]
    PROCEDURE AllocSourceCreateWithAutogeneratedID@2();
    VAR
      CostAccSetup@1000 : Record 1108;
      AllocationID@1002 : Code[10];
    BEGIN
      // Setup & Exercise:
      AllocationID := CreateAllocationSource(TRUE);

      // Verify:
      CostAccSetup.GET;
      CostAccSetup.TESTFIELD("Last Allocation ID",AllocationID);
    END;

    [Test]
    PROCEDURE AllocSourceCreateWithCustomID@4();
    VAR
      CostAccSetup@1000 : Record 1108;
      AllocationID@1002 : Code[10];
    BEGIN
      // Setup & Exercise:
      AllocationID := CreateAllocationSource(FALSE);

      CostAccSetup.GET;
      Assert.AreNotEqual(
        CostAccSetup."Last Allocation ID",AllocationID,
        STRSUBSTNO(ExpectedValueIsDifferentError,CostAccSetup.FIELDNAME("Last Allocation ID")));
    END;

    [Test]
    PROCEDURE AllocSourceCreateWithCustomIDWhenLastAllocIDEmpty@18();
    VAR
      CostAccSetup@1001 : Record 1108;
      PrevLastAllocID@1000 : Code[10];
    BEGIN
      // Setup:
      CostAccSetup.GET;
      PrevLastAllocID := CostAccSetup."Last Allocation ID";
      CostAccSetup.VALIDATE("Last Allocation ID",'');
      CostAccSetup.MODIFY(TRUE);

      // Exercise:
      CreateAllocationSource(FALSE);

      // Verify:
      CostAccSetup.GET;
      CostAccSetup.TESTFIELD("Last Allocation ID",'');

      // Clean-up:
      CostAccSetup."Last Allocation ID" := PrevLastAllocID;
      CostAccSetup.MODIFY;
    END;

    [Test]
    PROCEDURE AllocSourceDelete@6();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1002 : Record 1107;
      AllocationID@1003 : Code[10];
      I@1001 : Integer;
    BEGIN
      // Setup:
      AllocationID := CreateAllocationSource(TRUE);
      FOR I := 1 TO LibraryRandom.RandInt(10) DO
        CreateAllocationTarget(CostAllocationTarget,AllocationID);

      // Exercise:
      CostAllocationSource.GET(AllocationID);
      CostAllocationSource.DELETE(TRUE);

      // Verify:
      CostAllocationTarget.SETFILTER(ID,AllocationID);
      Assert.IsTrue(CostAllocationTarget.ISEMPTY,CostAllocTargetCountError);
    END;

    [Test]
    PROCEDURE AllocSourceUpdate@5();
    VAR
      CostAllocationSource@1000 : Record 1106;
      AllocationID@1001 : Code[10];
    BEGIN
      // Setup:
      AllocationID := CreateAllocationSource(TRUE);

      // Exercise:
      CostAllocationSource.GET(AllocationID);
      CostAllocationSource.VALIDATE("User ID",'');
      CostAllocationSource.VALIDATE("Last Date Modified",0D);
      CostAllocationSource.MODIFY(TRUE);

      // Verify:
      CostAllocationSource.TESTFIELD("User ID",UPPERCASE(USERID));
      CostAllocationSource.TESTFIELD("Last Date Modified",TODAY);
    END;

    [Test]
    PROCEDURE AllocSourceValidateCostCenterField@7();
    VAR
      CostAllocationSource@1000 : Record 1106;
    BEGIN
      // Setup:
      CostAllocationSource.GET(CreateAllocationSource(TRUE));
      CostAllocationSource.VALIDATE("Cost Object Code",CreateCostObject);
      CostAllocationSource.MODIFY(TRUE);

      // Exercise & Verify:
      ASSERTERROR CostAllocationSource.VALIDATE("Cost Center Code",CreateCostCenter);
    END;

    [Test]
    PROCEDURE AllocSourceValidateCostObjectField@8();
    VAR
      CostAllocationSource@1000 : Record 1106;
    BEGIN
      // Setup:
      CostAllocationSource.GET(CreateAllocationSource(TRUE));
      CostAllocationSource.VALIDATE("Cost Center Code",CreateCostCenter);
      CostAllocationSource.MODIFY(TRUE);

      // Exercise & Verify:
      ASSERTERROR CostAllocationSource.VALIDATE("Cost Object Code",CreateCostObject);
    END;

    [Test]
    PROCEDURE AllocTargetCalcPercentWhenTotalShareNonZero@20();
    VAR
      CostAllocationSource@1002 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
      AllocationID@1003 : Code[10];
      I@1000 : Integer;
    BEGIN
      // Setup:
      AllocationID := CreateAllocationSource(TRUE);
      FOR I := 1 TO LibraryRandom.RandInt(10) DO BEGIN
        CreateAllocationTarget(CostAllocationTarget,AllocationID);
        // Exercise:
        CostAllocationTarget.VALIDATE(Share,LibraryRandom.RandDec(100,2));
        CostAllocationTarget.MODIFY;
      END;

      // Verify:
      CostAllocationSource.GET(AllocationID);
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);
    END;

    [Test]
    PROCEDURE AllocTargetCalcPercentWhenTotalShareZero@17();
    VAR
      CostAllocationTarget@1001 : Record 1107;
      AllocationID@1003 : Code[10];
      I@1000 : Integer;
    BEGIN
      // Setup:
      AllocationID := CreateAllocationSource(TRUE);
      FOR I := 1 TO LibraryRandom.RandInt(10) DO
        CreateAllocationTarget(CostAllocationTarget,AllocationID);

      // Exercise:
      CostAllocationTarget.VALIDATE(Share,0);
      CostAllocationTarget.MODIFY;

      // Verify:
      CostAllocationTarget.RESET;
      CostAllocationTarget.SETRANGE(ID,AllocationID);
      CostAllocationTarget.FINDSET;
      REPEAT
        CostAllocationTarget.TESTFIELD(Percent,0);
        CostAllocationTarget.TESTFIELD("Share Updated on",TODAY);
      UNTIL CostAllocationTarget.NEXT = 0;
    END;

    [Test]
    [HandlerFunctions(RPHandlerChartOfCostCenters)]
    PROCEDURE AllocTargetLookupCostCenterFilterField@40();
    VAR
      CostCenter@1000 : Record 1112;
      CostAllocTargetListPage@1001 : TestPage 1114;
    BEGIN
      // Setup:
      CostCenter.FINDFIRST;
      CostCenterFilter := SelectionFilterManagement.AddQuotes(CostCenter.Code);
      CostAllocTargetListPage.OPENEDIT;

      // Exercise:
      CostAllocTargetListPage."Cost Center Filter".LOOKUP;

      // Verify:
      CostAllocTargetListPage."Cost Center Filter".ASSERTEQUALS(CostCenterFilter);
    END;

    [Test]
    [HandlerFunctions(RPHandlerChartOfCostObjects)]
    PROCEDURE AllocTargetLookupCostObjectFilterField@41();
    VAR
      CostObject@1000 : Record 1113;
      CostAllocTargetListPage@1001 : TestPage 1114;
    BEGIN
      // Setup:
      CostObject.FINDFIRST;
      CostObjectFilter := SelectionFilterManagement.AddQuotes(CostObject.Code);
      CostAllocTargetListPage.OPENEDIT;

      // Exercise:
      CostAllocTargetListPage."Cost Object Filter".LOOKUP;

      // Verify:
      CostAllocTargetListPage."Cost Object Filter".ASSERTEQUALS(CostObjectFilter);
    END;

    [Test]
    [HandlerFunctions(RPHandlerCostBudgetNames)]
    PROCEDURE AllocTargetLookupGroupFilterFieldForCostBudgetEntryBase@58();
    VAR
      CostAllocTarget@1000 : Record 1107;
      CostBudgetName@1001 : Record 1110;
    BEGIN
      CostBudgetName.FINDFIRST;
      CostBudgetNameFilter := SelectionFilterManagement.AddQuotes(CostBudgetName.Name);

      LookupGroupFilter(CostAllocTarget.Base::"Cost Budget Entries",CostBudgetNameFilter)
    END;

    [Test]
    [HandlerFunctions(RPHandlerGLBudgetNames)]
    PROCEDURE AllocTargetLookupGroupFilterFieldForGLBudgetEntryBase@57();
    VAR
      CostAllocTarget@1000 : Record 1107;
      GLBudgetName@1001 : Record 95;
    BEGIN
      GLBudgetName.FINDFIRST;
      GLBudgetNameFilter := SelectionFilterManagement.AddQuotes(GLBudgetName.Name);

      LookupGroupFilter(CostAllocTarget.Base::"G/L Budget Entries",GLBudgetNameFilter)
    END;

    [Test]
    [HandlerFunctions(RPHandlerInvtPostingGroups)]
    PROCEDURE AllocTargetLookupGroupFilterFieldForItemsPurchasedAmountBase@62();
    VAR
      CostAllocTarget@1000 : Record 1107;
      InvtPostingGroup@1001 : Record 94;
    BEGIN
      InvtPostingGroup.FINDFIRST;
      InvtPostingGroupFilter := SelectionFilterManagement.AddQuotes(InvtPostingGroup.Code);

      LookupGroupFilter(CostAllocTarget.Base::"Items Purchased (Amount)",InvtPostingGroupFilter)
    END;

    [Test]
    [HandlerFunctions(RPHandlerInvtPostingGroups)]
    PROCEDURE AllocTargetLookupGroupFilterFieldForItemsPurchasedQtyBase@60();
    VAR
      CostAllocTarget@1000 : Record 1107;
      InvtPostingGroup@1001 : Record 94;
    BEGIN
      InvtPostingGroup.FINDFIRST;
      InvtPostingGroupFilter := SelectionFilterManagement.AddQuotes(InvtPostingGroup.Code);

      LookupGroupFilter(CostAllocTarget.Base::"Items Purchased (Qty.)",COPYSTR(InvtPostingGroupFilter,1,30))
    END;

    [Test]
    [HandlerFunctions(RPHandlerInvtPostingGroups)]
    PROCEDURE AllocTargetLookupGroupFilterFieldForItemsSoldAmountBase@61();
    VAR
      CostAllocTarget@1000 : Record 1107;
      InvtPostingGroup@1001 : Record 94;
    BEGIN
      InvtPostingGroup.FINDFIRST;
      InvtPostingGroupFilter := SelectionFilterManagement.AddQuotes(InvtPostingGroup.Code);

      LookupGroupFilter(CostAllocTarget.Base::"Items Sold (Amount)",InvtPostingGroupFilter)
    END;

    [Test]
    [HandlerFunctions(RPHandlerInvtPostingGroups)]
    PROCEDURE AllocTargetLookupGroupFilterFieldForItemsSoldQtyBase@59();
    VAR
      CostAllocTarget@1000 : Record 1107;
      InvtPostingGroup@1001 : Record 94;
    BEGIN
      InvtPostingGroup.FINDFIRST;
      InvtPostingGroupFilter := SelectionFilterManagement.AddQuotes(InvtPostingGroup.Code);

      LookupGroupFilter(CostAllocTarget.Base::"Items Sold (Qty.)",COPYSTR(InvtPostingGroupFilter,1,30))
    END;

    [Test]
    [HandlerFunctions(RPHandlerCostTypeList)]
    PROCEDURE AllocTargetLookupNoFilterFieldForCostBudgetEntryBase@48();
    VAR
      CostAllocTarget@1000 : Record 1107;
      CostType@1001 : Record 1103;
    BEGIN
      CostType.FINDFIRST;
      CostTypeFilter := SelectionFilterManagement.AddQuotes(CostType."No.");

      LookupNoFilter(CostAllocTarget.Base::"Cost Budget Entries",CostTypeFilter)
    END;

    [Test]
    [HandlerFunctions(RPHandlerCostTypeList)]
    PROCEDURE AllocTargetLookupNoFilterFieldForCostEntryBase@1();
    VAR
      CostAllocTarget@1000 : Record 1107;
      CostType@1001 : Record 1103;
    BEGIN
      CostType.FINDFIRST;
      CostTypeFilter := SelectionFilterManagement.AddQuotes(CostType."No.");

      LookupNoFilter(CostAllocTarget.Base::"Cost Type Entries",CostTypeFilter)
    END;

    [Test]
    [HandlerFunctions(RPHandlerGLAccList)]
    PROCEDURE AllocTargetLookupNoFilterFieldForGLBudgetEntryBase@47();
    VAR
      CostAllocTarget@1000 : Record 1107;
      GLAccount@1001 : Record 15;
    BEGIN
      // Setup:
      GLAccount.FINDFIRST;
      GLAccFilter := SelectionFilterManagement.AddQuotes(GLAccount."No.");

      // Exercise & Verify:
      LookupNoFilter(CostAllocTarget.Base::"G/L Budget Entries",GLAccFilter)
    END;

    [Test]
    [HandlerFunctions(RPHandlerGLAccList)]
    PROCEDURE AllocTargetLookupNoFilterFieldForGLEntryBase@45();
    VAR
      CostAllocTarget@1000 : Record 1107;
      GLAccount@1001 : Record 15;
    BEGIN
      // Setup:
      GLAccount.FINDFIRST;
      GLAccFilter := SelectionFilterManagement.AddQuotes(GLAccount."No.");

      // Exercise & Verify:
      LookupNoFilter(CostAllocTarget.Base::"G/L Entries",GLAccFilter)
    END;

    [Test]
    [HandlerFunctions(RPHandlerItemList)]
    PROCEDURE AllocTargetLookupNoFilterFieldForItemsPurchasedAmountBase@51();
    VAR
      CostAllocTarget@1000 : Record 1107;
    BEGIN
      ItemFilter := SelectionFilterManagement.AddQuotes(LibraryInventory.CreateItemNo);

      LookupNoFilter(CostAllocTarget.Base::"Items Purchased (Amount)",ItemFilter)
    END;

    [Test]
    [HandlerFunctions(RPHandlerItemList)]
    PROCEDURE AllocTargetLookupNoFilterFieldForItemsPurchasedQtyBase@49();
    VAR
      CostAllocTarget@1000 : Record 1107;
    BEGIN
      ItemFilter := SelectionFilterManagement.AddQuotes(LibraryInventory.CreateItemNo);

      LookupNoFilter(CostAllocTarget.Base::"Items Purchased (Qty.)",COPYSTR(ItemFilter,1,30))
    END;

    [Test]
    [HandlerFunctions(RPHandlerItemList)]
    PROCEDURE AllocTargetLookupNoFilterFieldForItemsSoldAmountBase@50();
    VAR
      CostAllocTarget@1000 : Record 1107;
    BEGIN
      ItemFilter := SelectionFilterManagement.AddQuotes(LibraryInventory.CreateItemNo);

      LookupNoFilter(CostAllocTarget.Base::"Items Sold (Amount)",ItemFilter)
    END;

    [Test]
    [HandlerFunctions(RPHandlerItemList)]
    PROCEDURE AllocTargetLookupNoFilterFieldForItemsSoldQtyBase@9();
    VAR
      CostAllocTarget@1000 : Record 1107;
    BEGIN
      ItemFilter := SelectionFilterManagement.AddQuotes(LibraryInventory.CreateItemNo);

      LookupNoFilter(CostAllocTarget.Base::"Items Sold (Qty.)",COPYSTR(ItemFilter,1,30))
    END;

    [Test]
    PROCEDURE AllocTargetUpdate@11();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup:
      CreateAllocationTarget(CostAllocationTarget,CreateAllocationSource(TRUE));

      // Exercise:
      CostAllocationTarget."Last Date Modified" := 0D;
      CostAllocationTarget."User ID" := '';
      CostAllocationTarget.MODIFY(TRUE);

      // Verify:
      CostAllocationTarget.TESTFIELD("Last Date Modified",TODAY);
      CostAllocationTarget.TESTFIELD("User ID",USERID);
    END;

    [Test]
    PROCEDURE AllocTargetValidateAmountPerShareNonZero@28();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup & Exercise:
      CostAllocationTarget."Percent per Share" := LibraryRandom.RandInt(10);
      CostAllocationTarget.VALIDATE("Amount per Share",LibraryRandom.RandInt(10));
      CostAllocationTarget.INSERT;

      // Verify:
      CostAllocationTarget.TESTFIELD("Allocation Target Type",CostAllocationTarget."Allocation Target Type"::"Amount per Share");
      CostAllocationTarget.TESTFIELD("Percent per Share",0);

      // Clean-up:
      CostAllocationTarget.DELETE;
    END;

    [Test]
    PROCEDURE AllocTargetValidateAmountPerShareZero@27();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup & Exercise:
      CostAllocationTarget."Amount per Share" := LibraryRandom.RandInt(10);
      CostAllocationTarget.VALIDATE("Amount per Share",0);
      CostAllocationTarget.INSERT;

      // Verify:
      CostAllocationTarget.TESTFIELD("Allocation Target Type",CostAllocationTarget."Allocation Target Type"::"All Costs");

      // Clean-up:
      CostAllocationTarget.DELETE;
    END;

    [Test]
    PROCEDURE AllocTargetValidateCostCenterField@12();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup:
      CreateAllocationTarget(CostAllocationTarget,CreateAllocationSource(TRUE));
      CostAllocationTarget.VALIDATE("Target Cost Object",CreateCostObject);
      CostAllocationTarget.MODIFY(TRUE);

      // Exercise & Verify:
      ASSERTERROR CostAllocationTarget.VALIDATE("Target Cost Center",CreateCostCenter);
    END;

    [Test]
    PROCEDURE AllocTargetValidateCostObjectField@13();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup:
      CreateAllocationTarget(CostAllocationTarget,CreateAllocationSource(TRUE));
      CostAllocationTarget.VALIDATE("Target Cost Center",CreateCostCenter);
      CostAllocationTarget.MODIFY(TRUE);

      // Exercise & Verify:
      ASSERTERROR CostAllocationTarget.VALIDATE("Target Cost Object",CreateCostObject);
    END;

    [Test]
    PROCEDURE AllocTargetValidatePercentPerShareNonZero@26();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup & Exercise:
      CostAllocationTarget.VALIDATE("Percent per Share",LibraryRandom.RandInt(10));
      CostAllocationTarget.INSERT;

      // Verify:
      CostAllocationTarget.TESTFIELD("Allocation Target Type",CostAllocationTarget."Allocation Target Type"::"Percent per Share");
      CostAllocationTarget.TESTFIELD("Amount per Share",0);

      // Clean-up:
      CostAllocationTarget.DELETE;
    END;

    [Test]
    PROCEDURE AllocTargetValidatePercentPerShareZero@25();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup & Exercise:
      CostAllocationTarget.VALIDATE("Percent per Share",0);
      CostAllocationTarget.INSERT;

      // Verify:
      CostAllocationTarget.TESTFIELD("Allocation Target Type",CostAllocationTarget."Allocation Target Type"::"All Costs");

      // Clean-up:
      CostAllocationTarget.DELETE;
    END;

    [Test]
    PROCEDURE AllocTargetValidateStaticBaseGreaterThanZeroForDynamicBase@16();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup:
      CostAllocationTarget.Base := CostAllocationTarget.Base::"G/L Entries";
      CostAllocationTarget.INSERT;

      // Exercise & Verify:
      ASSERTERROR CostAllocationTarget.VALIDATE("Static Base",LibraryRandom.RandInt(10));
    END;

    [Test]
    PROCEDURE AllocTargetValidateStaticBaseZeroForDynamicBase@37();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup:
      CostAllocationTarget.Base := CostAllocationTarget.Base::"G/L Entries";
      CostAllocationTarget.INSERT;

      // Exercise & Verify:
      CostAllocationTarget.VALIDATE("Static Base",0);

      // Clean-up:
      CostAllocationTarget.DELETE;
    END;

    [Test]
    PROCEDURE AllocTargetValidateStaticWeightingGreaterThanZeroForDynamicBase@15();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup:
      CostAllocationTarget.Base := CostAllocationTarget.Base::"G/L Entries";
      CostAllocationTarget.INSERT;

      // Exercise & Verify:
      ASSERTERROR CostAllocationTarget.VALIDATE("Static Weighting",LibraryRandom.RandInt(10));
    END;

    [Test]
    PROCEDURE AllocTargetValidateStaticWeightingZeroForDynamicBase@36();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup:
      CostAllocationTarget.Base := CostAllocationTarget.Base::"G/L Entries";
      CostAllocationTarget.INSERT;

      // Exercise & Verify:
      CostAllocationTarget.VALIDATE("Static Weighting",0);

      // Clean-up:
      CostAllocationTarget.DELETE;
    END;

    [Test]
    PROCEDURE AllocTargetValidateStaticWeighttingForStaticBase@67();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup:
      CostAllocationTarget.Base := CostAllocationTarget.Base::Static;
      CostAllocationTarget.INSERT;

      // Exercise:
      CostAllocationTarget.VALIDATE("Static Weighting",LibraryRandom.RandInt(100));
      CostAllocationTarget.MODIFY;

      // Verify:
      CostAllocationTarget.TESTFIELD(Share,CostAllocationTarget."Static Base" * CostAllocationTarget."Static Weighting");

      // Clean-up:
      CostAllocationTarget.DELETE;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo,MessageHandler)]
    PROCEDURE CostAccSetupValidateAutotransferFromGLConfirmNo@38();
    VAR
      CostEntry@1004 : Record 1104;
      GLEntryNo@1003 : Integer;
    BEGIN
      // Setup:
      GLEntryNo := CreateGLEntryWithCostCenterDim;

      // Exercise:
      ASSERTERROR UpdateCostAccSetupAutoTransferFromGL(TRUE);

      // Verify:
      CostEntry.SETRANGE("G/L Entry No.",GLEntryNo);
      Assert.IsTrue(CostEntry.ISEMPTY,CostEntriesCountError);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE CostAccSetupValidateAutotransferFromGLConfirmYes@30();
    VAR
      CostEntry@1002 : Record 1104;
      GLEntryNo@1001 : Integer;
    BEGIN
      // Setup:
      GLEntryNo := CreateGLEntryWithCostCenterDim;

      // Exercise:
      UpdateCostAccSetupAutoTransferFromGL(TRUE);

      // Verify:
      CostEntry.SETRANGE("G/L Entry No.",GLEntryNo);
      Assert.AreEqual(1,CostEntry.COUNT,CostEntriesCountError);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE CostAccSetupValidateStartingDateAfterFirstGLTransfer@90();
    VAR
      CostAccSetup@1001 : Record 1108;
      TransferGLEntriesToCA@1000 : Codeunit 1105;
    BEGIN
      // Setup:
      CreateGLEntryWithCostCenterDim;
      TransferGLEntriesToCA.TransferGLtoCA;

      // Exercise & Verify:
      CostAccSetup.GET;
      ASSERTERROR CostAccSetup.VALIDATE("Starting Date for G/L Transfer",WORKDATE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE CostAccSetupValidateStartingDateConfirmYes@31();
    VAR
      CostRegister@1000 : Record 1105;
      CostAccSetup@1001 : Record 1108;
      PrevStartingDate@1002 : Date;
      NewStartingDate@1003 : Date;
    BEGIN
      // Setup: delete existing cost register corresponding to prev transfers
      CostRegister.SETRANGE(Source,CostRegister.Source::"Transfer from G/L");
      CostRegister.DELETEALL;

      CostAccSetup.GET;
      PrevStartingDate := CostAccSetup."Starting Date for G/L Transfer";
      NewStartingDate := CALCDATE('<+1D>',WORKDATE);

      // Exercise:
      UpdateCostAccSetupStartingDateForGLTransfer(NewStartingDate);

      // Verify:
      CostAccSetup.GET;
      CostAccSetup.TESTFIELD("Starting Date for G/L Transfer",NewStartingDate);

      // Clean-up:
      CostAccSetup."Starting Date for G/L Transfer" := PrevStartingDate;
      CostAccSetup.MODIFY;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE CostAccSetupValidateStartingDateConfirmNo@192();
    VAR
      CostRegister@1000 : Record 1105;
      CostAccSetup@1001 : Record 1108;
      PrevStartingDate@1002 : Date;
      NewStartingDate@1003 : Date;
    BEGIN
      // Setup: delete existing cost register corresponding to prev transfers
      CostRegister.SETRANGE(Source,CostRegister.Source::"Transfer from G/L");
      CostRegister.DELETEALL;

      CostAccSetup.GET;
      PrevStartingDate := CostAccSetup."Starting Date for G/L Transfer";
      NewStartingDate := CALCDATE('<+1D>',WORKDATE);

      // Exercise:
      ASSERTERROR UpdateCostAccSetupStartingDateForGLTransfer(NewStartingDate);

      // Verify:
      CostAccSetup.GET;
      CostAccSetup.TESTFIELD("Starting Date for G/L Transfer",PrevStartingDate);
    END;

    [Test]
    PROCEDURE CostEntryGetCurrencyCode@83();
    VAR
      CostEntry@1001 : Record 1104;
      GeneralLedgerSetup@1000 : Record 98;
    BEGIN
      GeneralLedgerSetup.GET;
      Assert.AreEqual(GeneralLedgerSetup."Additional Reporting Currency",CostEntry.GetCurrencyCode,IncorrectAddReportingCurrency);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE CostRegisterClosedMutlipleEntriesClosed@89();
    VAR
      CostRegister@1001 : Record 1105;
      Index@1000 : Integer;
    BEGIN
      // Setup
      CostRegister.DELETEALL;

      // Exercise
      FOR Index := 1 TO 2 DO BEGIN
        CreateCostRegister(CostRegister,Index);
        UpdateCostRegisterClosed(CostRegister,TRUE);
      END;

      // Verify
      CLEAR(CostRegister);
      CostRegister.SETFILTER(Closed,'%1',FALSE);
      Assert.IsTrue(CostRegister.ISEMPTY,CostRegisterEntriesNotClosed);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE CostRegisterClosedMutlipleEntriesNotClosed@91();
    VAR
      CostRegister@1001 : Record 1105;
      Index@1002 : Integer;
    BEGIN
      // Setup
      CostRegister.DELETEALL;

      FOR Index := 1 TO 2 DO
        CreateCostRegister(CostRegister,Index);

      // Exercise
      CostRegister.FINDLAST;
      UpdateCostRegisterClosed(CostRegister,TRUE);

      // Verify
      CostRegister.FINDFIRST;
      REPEAT
        CostRegister.TESTFIELD(Closed,TRUE);
      UNTIL CostRegister.NEXT = 0;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE CostRegisterClosedSingleEntry@76();
    VAR
      CostRegister@1000 : Record 1105;
    BEGIN
      // Setup
      CostRegister.DELETEALL;
      CreateCostRegister(CostRegister,1);

      // Exercise
      UpdateCostRegisterClosed(CostRegister,TRUE);

      // Verify
      CostRegister.GET(1);
      CostRegister.TESTFIELD(Closed,TRUE);
    END;

    [Test]
    PROCEDURE CostTypeDeleteBalanceNonZero@21();
    VAR
      CostEntry@1003 : Record 1104;
      CostType@1002 : Record 1103;
      CostTypeNo@1000 : Code[20];
    BEGIN
      // Setup
      CostTypeInsert(CostTypeNo,FALSE);
      CostEntryInsert(CostEntry,CostTypeNo,LibraryRandom.RandInt(1000));

      // Exercise
      CostType.GET(CostTypeNo);
      ASSERTERROR CostType.DELETE(TRUE);

      // Verify
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,BalanceEqualToZero) > 0,UnexpectedErr);
    END;

    [Test]
    PROCEDURE CostTypeDeleteBalanceZero@82();
    VAR
      CostEntry@1000 : Record 1104;
      CostType@1003 : Record 1103;
      CostTypeNo@1002 : Code[20];
    BEGIN
      // Setup
      CostTypeInsert(CostTypeNo,FALSE);
      CostEntryInsert(CostEntry,CostTypeNo,0);

      // Exercise
      CostType.GET(CostTypeNo);
      CostType.DELETE(TRUE);

      // Verify
      ASSERTERROR CostType.GET(CostTypeNo);
    END;

    [Test]
    PROCEDURE CostTypeDeleteCostEntryPostingDateAfter@84();
    VAR
      CostEntry@1004 : Record 1104;
      CostType@1003 : Record 1103;
      CostTypeNo@1000 : Code[20];
    BEGIN
      // Setup
      CostTypeInsert(CostTypeNo,FALSE);
      CostEntryInsert(CostEntry,CostTypeNo,0);
      CostEntry.VALIDATE("Posting Date",CALCDATE('<+1D>',LibraryFiscalYear.IdentifyOpenAccountingPeriod));
      CostEntry.MODIFY(TRUE);

      // Exercise
      CostType.GET(CostTypeNo);
      ASSERTERROR CostType.DELETE(TRUE);

      // Verify
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,EntriesWithinOpenFiscalYear) > 0,UnexpectedErr);
    END;

    [Test]
    PROCEDURE CostTypeDeleteCostEntryPostingDateBefore@92();
    VAR
      CostEntry@1004 : Record 1104;
      CostType@1003 : Record 1103;
      CostTypeNo@1000 : Code[20];
    BEGIN
      // Setup
      CostTypeInsert(CostTypeNo,FALSE);
      CostEntryInsert(CostEntry,CostTypeNo,0);
      CostEntry.VALIDATE("Posting Date",CALCDATE('<-1D>',LibraryFiscalYear.IdentifyOpenAccountingPeriod));
      CostEntry.MODIFY(TRUE);

      // Exercise
      CostType.GET(CostTypeNo);
      CostType.DELETE(TRUE);

      // Verify
      IF CostType.GET(CostTypeNo) THEN
        ERROR(CostTypeNotDeleted,CostTypeNo);
    END;

    [Test]
    PROCEDURE CostTypeDeleteHeadingType@93();
    VAR
      CostType@1000 : Record 1103;
      CostTypeNo@1002 : Code[20];
    BEGIN
      // Setup
      CostTypeInsert(CostTypeNo,FALSE);
      CostType.GET(CostTypeNo);
      CostType.VALIDATE(Type,CostType.Type::Heading);
      CostType.MODIFY;

      // Exercise
      CostType.DELETE(TRUE);

      // Verify
      ASSERTERROR CostType.GET(CostTypeNo);
    END;

    [Test]
    PROCEDURE CostTypeDeleteNoOpenAccountingPeriods@81();
    VAR
      CostEntry@1001 : Record 1104;
      CostType@1002 : Record 1103;
      CostTypeNo@1004 : Code[20];
    BEGIN
      // Setup
      LibraryFiscalYear.CloseAccountingPeriod;
      CostTypeInsert(CostTypeNo,FALSE);
      CostEntryInsert(CostEntry,CostTypeNo,0);

      // Exercise
      CostType.GET(CostTypeNo);
      ASSERTERROR CostType.DELETE(TRUE);

      // Verify
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,EntriesWithinOpenFiscalYear) > 0,UnexpectedErr);
    END;

    [Test]
    PROCEDURE CostTypeInsertNoValidation@72();
    BEGIN
      ValidateCostTypeInsert(FALSE);
    END;

    [Test]
    PROCEDURE CostTypeInsertWithValidation@94();
    BEGIN
      ValidateCostTypeInsert(TRUE);
    END;

    [Test]
    PROCEDURE CostTypeModifyNoValidation@73();
    BEGIN
      ValidateCostTypeModify(FALSE);
    END;

    [Test]
    PROCEDURE CostTypeModifyWithValidation@70();
    BEGIN
      ValidateCostTypeModify(TRUE);
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryCheckEntriesCostCenterAndCostObject@119();
    VAR
      CostBudgetEntry@1000 : Record 1109;
    BEGIN
      CreateCostBudgetEntry(CostBudgetEntry,0,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Budget Name"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Budget Name")),
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Type No."),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Type No.")),WORKDATE,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Center Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Center Code")),
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Object Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Object Code")),0,FALSE);
      ASSERTERROR
        CostBudgetEntry.CheckEntries
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryCheckEntriesMissingBudgetName@116();
    VAR
      CostBudgetEntry@1000 : Record 1109;
    BEGIN
      CreateCostBudgetEntry(CostBudgetEntry,0,'',
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Type No."),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Type No.")),WORKDATE,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Center Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Center Code")),'',0,FALSE);
      ASSERTERROR
        CostBudgetEntry.CheckEntries
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryCheckEntriesMissingCostCenterAndCostObject@118();
    VAR
      CostBudgetEntry@1000 : Record 1109;
    BEGIN
      CreateCostBudgetEntry(
        CostBudgetEntry,0,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Budget Name"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Budget Name")),
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Type No."),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Type No.")),WORKDATE,
        '','',0,FALSE);
      ASSERTERROR
        CostBudgetEntry.CheckEntries
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryCheckEntriesMissingCostTypeNo@117();
    VAR
      CostBudgetEntry@1000 : Record 1109;
    BEGIN
      CreateCostBudgetEntry(
        CostBudgetEntry,0,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Budget Name"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Budget Name")),
        '',WORKDATE,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Center Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Center Code")),'',0,FALSE);
      ASSERTERROR
        CostBudgetEntry.CheckEntries
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryCheckEntriesMissingDate@115();
    VAR
      CostBudgetEntry@1000 : Record 1109;
    BEGIN
      CreateCostBudgetEntry(
        CostBudgetEntry,0,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Budget Name"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Budget Name")),
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Type No."),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Type No.")),0D,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Center Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Center Code")),'',0,FALSE);
      ASSERTERROR
        CostBudgetEntry.CheckEntries
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryCheckEntriesOKCostCenter@120();
    VAR
      CostBudgetEntry@1000 : Record 1109;
    BEGIN
      CreateCostBudgetEntry(CostBudgetEntry,0,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Budget Name"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Budget Name")),
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Type No."),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Type No.")),WORKDATE,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Center Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Center Code")),'',0,FALSE);
      ASSERTERROR BEGIN
        CostBudgetEntry.CheckEntries;
        ERROR('')
      END;
      Assert.AreEqual('',GETLASTERRORTEXT,UnexpectedErr);
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryCheckEntriesOKCostObject@121();
    VAR
      CostBudgetEntry@1001 : Record 1109;
    BEGIN
      CreateCostBudgetEntry(CostBudgetEntry,0,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Budget Name"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Budget Name")),
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Type No."),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Type No.")),WORKDATE,
        '',
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Object Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Object Code")),0,FALSE);
      ASSERTERROR BEGIN
        CostBudgetEntry.CheckEntries;
        ERROR('')
      END;
      Assert.AreEqual('',GETLASTERRORTEXT,UnexpectedErr);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostBudgetEntryCompressBudgetEntries@107();
    VAR
      CostBudgetEntry@1000 : Record 1109;
      FromEntryNo@1002 : Integer;
      ToEntryNo@1004 : Integer;
      TotalAmount@1005 : Decimal;
      j@1003 : Integer;
    BEGIN
      // create budget entries
      InsertCostBudgetEntriesToCompress(CostBudgetEntry,FromEntryNo,ToEntryNo,TRUE,TotalAmount);
      // compress budget entries
      CostBudgetEntry.CompressBudgetEntries(CostBudgetEntry."Budget Name");
      // verify entries were deleted
      FOR j := (FromEntryNo + 1) TO ToEntryNo DO BEGIN
        IF CostBudgetEntry.GET(j) THEN
          ERROR(Text007,CostBudgetEntry.TABLECAPTION)
      END;
      // verify the sum matches expected.
      CostBudgetEntry.GET(FromEntryNo);
      Assert.AreEqual(TotalAmount,CostBudgetEntry.Amount,Text008);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostBudgetEntryCompressBudgetEntriesAmountZeroOneGroup@108();
    VAR
      CostBudgetEntry@1004 : Record 1109;
      FromEntryNo@1003 : Integer;
      ToEntryNo@1002 : Integer;
      TotalAmount@1001 : Decimal;
      j@1000 : Integer;
    BEGIN
      // create budget entries
      InsertCostBudgetEntriesToCompress(CostBudgetEntry,FromEntryNo,ToEntryNo,FALSE,TotalAmount);
      // compress budget entries
      CostBudgetEntry.CompressBudgetEntries(CostBudgetEntry."Budget Name");
      // verify entries were deleted
      FOR j := (FromEntryNo + 1) TO ToEntryNo DO BEGIN
        IF CostBudgetEntry.GET(j) THEN
          ERROR(Text007,CostBudgetEntry.TABLECAPTION)
      END;
      // verify the sum matches expected.
      CostBudgetEntry.GET(FromEntryNo);
      Assert.AreEqual(TotalAmount,CostBudgetEntry.Amount,Text008);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostBudgetEntryCompressBudgetEntriesAmountZeroTwoGroups@109();
    VAR
      CostBudgetEntry@1006 : Record 1109;
      BudgetName@1007 : Code[10];
      FromEntryNo@1005 : Integer;
      FirstEntryNo@1000 : Integer;
      ToEntryNo@1004 : Integer;
      TotalAmount@1003 : Decimal;
      i@1001 : Integer;
    BEGIN
      InsertCostBudgetEntriesToCompress(CostBudgetEntry,FromEntryNo,ToEntryNo,FALSE,TotalAmount);
      BudgetName := CostBudgetEntry."Budget Name";
      FirstEntryNo := CostBudgetEntry."Entry No.";
      InsertCostBudgetEntriesToCompress(CostBudgetEntry,FromEntryNo,ToEntryNo,FALSE,TotalAmount);
      CostBudgetEntry.SETRANGE("Entry No.",FromEntryNo,ToEntryNo);
      CostBudgetEntry.MODIFYALL("Budget Name",BudgetName);

      CostBudgetEntry.CompressBudgetEntries(BudgetName);

      FOR i := FirstEntryNo TO ToEntryNo DO BEGIN
        IF i <> FromEntryNo THEN
          IF CostBudgetEntry.GET(i) THEN
            ERROR(Text007,CostBudgetEntry.TABLECAPTION)
      END;
      // verify the sum matches expected.
      CostBudgetEntry.GET(FromEntryNo);
      Assert.AreEqual(TotalAmount,CostBudgetEntry.Amount,Text008);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostBudgetEntryCompressBudgetEntriesConfirmNo@106();
    VAR
      CostBudgetEntry@1001 : Record 1109;
    BEGIN
      ASSERTERROR CostBudgetEntry.CompressBudgetEntries(
          COPYSTR(
            LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Budget Name"),DATABASE::"Cost Budget Entry"),1,
            MAXSTRLEN(CostBudgetEntry."Budget Name")));
      Assert.AreEqual('',GETLASTERRORTEXT,UnexpectedErr);
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryCompressBudgetEntriesMissingBudgetName@105();
    VAR
      CostBudgetEntry@1000 : Record 1109;
    BEGIN
      ASSERTERROR CostBudgetEntry.CompressBudgetEntries('');
      Assert.IsTrue(Text005 = GETLASTERRORTEXT,UnexpectedErr);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostBudgetEntryCompressBudgetEntriesWithDiffCostCenter@111();
    VAR
      CostBudgetEntry@1003 : Record 1109;
      EntryNos@1002 : ARRAY [2] OF Integer;
      Amounts@1001 : ARRAY [2] OF Integer;
      i@1000 : Integer;
    BEGIN
      CreateRandomCostBudgetEntryWithCostCenter(CostBudgetEntry,FALSE);
      EntryNos[1] := CostBudgetEntry."Entry No.";
      Amounts[1] := CostBudgetEntry.Amount;
      CreateCostBudgetEntryCopy(CostBudgetEntry);
      Amounts[1] += CostBudgetEntry.Amount;
      CreateCostBudgetEntry(CostBudgetEntry,0,CostBudgetEntry."Budget Name",CostBudgetEntry."Cost Type No.",
        CostBudgetEntry.Date,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Center Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Center Code")),
        CostBudgetEntry."Cost Object Code",0,FALSE);
      EntryNos[2] := CostBudgetEntry."Entry No.";
      Amounts[2] := CostBudgetEntry.Amount;
      CreateCostBudgetEntryCopy(CostBudgetEntry);
      Amounts[1] += CostBudgetEntry.Amount;

      CostBudgetEntry.CompressBudgetEntries(CostBudgetEntry."Budget Name");
      FOR i := 1 TO ARRAYLEN(EntryNos) DO BEGIN
        Assert.IsTrue(CostBudgetEntry.GET(EntryNos[i]),STRSUBSTNO(Text009,CostBudgetEntry.TABLECAPTION));
        Assert.AreEqual(Amounts[i],CostBudgetEntry.Amount,STRSUBSTNO(Text010,CostBudgetEntry.TABLECAPTION));
        Assert.IsFalse(CostBudgetEntry.GET(EntryNos[i] + 1),STRSUBSTNO(Text011,CostBudgetEntry.TABLECAPTION));
      END;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostBudgetEntryCompressBudgetEntriesWithDiffCostObject@112();
    VAR
      CostBudgetEntry@1003 : Record 1109;
      EntryNos@1002 : ARRAY [2] OF Integer;
      Amounts@1001 : ARRAY [2] OF Integer;
      i@1000 : Integer;
    BEGIN
      CreateRandomCostBudgetEntryWithCostObject(CostBudgetEntry,FALSE);
      EntryNos[1] := CostBudgetEntry."Entry No.";
      Amounts[1] := CostBudgetEntry.Amount;
      CreateCostBudgetEntryCopy(CostBudgetEntry);
      Amounts[1] += CostBudgetEntry.Amount;
      CreateCostBudgetEntry(CostBudgetEntry,0,CostBudgetEntry."Budget Name",CostBudgetEntry."Cost Type No.",
        CostBudgetEntry.Date,CostBudgetEntry."Cost Center Code",
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Object Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Object Code")),0,FALSE);
      EntryNos[2] := CostBudgetEntry."Entry No.";
      Amounts[2] := CostBudgetEntry.Amount;
      CreateCostBudgetEntryCopy(CostBudgetEntry);
      Amounts[1] += CostBudgetEntry.Amount;

      CostBudgetEntry.CompressBudgetEntries(CostBudgetEntry."Budget Name");
      FOR i := 1 TO ARRAYLEN(EntryNos) DO BEGIN
        Assert.IsTrue(CostBudgetEntry.GET(EntryNos[i]),STRSUBSTNO(Text009,CostBudgetEntry.TABLECAPTION));
        Assert.AreEqual(Amounts[i],CostBudgetEntry.Amount,STRSUBSTNO(Text010,CostBudgetEntry.TABLECAPTION));
        Assert.IsFalse(CostBudgetEntry.GET(EntryNos[i] + 1),STRSUBSTNO(Text011,CostBudgetEntry.TABLECAPTION));
      END;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostBudgetEntryCompressBudgetEntriesWithDiffCostType@110();
    VAR
      CostBudgetEntry@1000 : Record 1109;
      EntryNos@1001 : ARRAY [2] OF Integer;
      Amounts@1002 : ARRAY [2] OF Integer;
      i@1003 : Integer;
    BEGIN
      CreateRandomCostBudgetEntryWithCostCenter(CostBudgetEntry,FALSE);
      EntryNos[1] := CostBudgetEntry."Entry No.";
      Amounts[1] := CostBudgetEntry.Amount;
      CreateCostBudgetEntryCopy(CostBudgetEntry);
      Amounts[1] += CostBudgetEntry.Amount;
      CreateCostBudgetEntry(
        CostBudgetEntry,0,CostBudgetEntry."Budget Name",
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Type No."),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Type No.")),
        CostBudgetEntry.Date,CostBudgetEntry."Cost Center Code",CostBudgetEntry."Cost Object Code",0,FALSE);
      EntryNos[2] := CostBudgetEntry."Entry No.";
      Amounts[2] := CostBudgetEntry.Amount;
      CreateCostBudgetEntryCopy(CostBudgetEntry);
      Amounts[1] += CostBudgetEntry.Amount;

      CostBudgetEntry.CompressBudgetEntries(CostBudgetEntry."Budget Name");
      FOR i := 1 TO ARRAYLEN(EntryNos) DO BEGIN
        Assert.IsTrue(CostBudgetEntry.GET(EntryNos[i]),STRSUBSTNO(Text009,CostBudgetEntry.TABLECAPTION));
        Assert.AreEqual(Amounts[i],CostBudgetEntry.Amount,'The amount on the compressed entry does not match the sum of the entries');
        Assert.IsFalse(CostBudgetEntry.GET(EntryNos[i] + 1),'The entry to be compressed still exists');
      END;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestCostBudgetEntryCompressBudgetEntriesWithDiffDate@113();
    VAR
      CostBudgetEntry@1003 : Record 1109;
      EntryNos@1002 : ARRAY [2] OF Integer;
      Amounts@1001 : ARRAY [2] OF Integer;
      i@1000 : Integer;
    BEGIN
      CreateRandomCostBudgetEntryWithCostCenter(CostBudgetEntry,FALSE);
      EntryNos[1] := CostBudgetEntry."Entry No.";
      Amounts[1] := CostBudgetEntry.Amount;
      CreateCostBudgetEntryCopy(CostBudgetEntry);
      Amounts[1] += CostBudgetEntry.Amount;
      CreateCostBudgetEntry(CostBudgetEntry,0,CostBudgetEntry."Budget Name",CostBudgetEntry."Cost Type No.",
        CALCDATE('<+1M>',CostBudgetEntry.Date),CostBudgetEntry."Cost Center Code",CostBudgetEntry."Cost Object Code",0,FALSE);
      EntryNos[2] := CostBudgetEntry."Entry No.";
      Amounts[2] := CostBudgetEntry.Amount;
      CreateCostBudgetEntryCopy(CostBudgetEntry);
      Amounts[1] += CostBudgetEntry.Amount;

      CostBudgetEntry.CompressBudgetEntries(CostBudgetEntry."Budget Name");
      FOR i := 1 TO ARRAYLEN(EntryNos) DO BEGIN
        Assert.IsTrue(CostBudgetEntry.GET(EntryNos[i]),STRSUBSTNO(Text009,CostBudgetEntry.TABLECAPTION));
        Assert.AreEqual(Amounts[i],CostBudgetEntry.Amount,STRSUBSTNO(Text010,CostBudgetEntry.TABLECAPTION));
        Assert.IsFalse(CostBudgetEntry.GET(EntryNos[i] + 1),STRSUBSTNO(Text011,CostBudgetEntry.TABLECAPTION));
      END;
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryGetFirstCostCenter@78();
    VAR
      CostBudgetEntry@1001 : Record 1109;
      CostCenter@1000 : Record 1112;
      CostCenter2@1002 : Record 1112;
    BEGIN
      LibraryCostAccounting.CreateCostCenter(CostCenter);
      LibraryCostAccounting.CreateCostCenter(CostCenter2);
      CostCenter.TESTFIELD(Code,CostBudgetEntry.GetFirstCostCenter(CostCenter.Code + '|' + CostCenter2.Code));
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryGetFirstCostCenterInvalidFilter@74();
    VAR
      CostBudgetEntry@1001 : Record 1109;
      CostCenter@1000 : Record 1112;
    BEGIN
      Assert.AreEqual(
        '',CostBudgetEntry.GetFirstCostCenter(LibraryUtility.GenerateRandomCode(CostCenter.FIELDNO(Code),DATABASE::"Cost Center")),
        STRSUBSTNO(ExpectedValueIsDifferentError,CostCenter.FIELDNAME(Code)));
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryGetFirstCostObject@32();
    VAR
      CostBudgetEntry@1001 : Record 1109;
      CostObject@1000 : Record 1113;
      CostObject2@1002 : Record 1113;
    BEGIN
      LibraryCostAccounting.CreateCostObject(CostObject);
      LibraryCostAccounting.CreateCostObject(CostObject2);
      CostObject.TESTFIELD(Code,CostBudgetEntry.GetFirstCostObject(CostObject.Code + '|' + CostObject2.Code));
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryGetFirstCostObjectInvalidFilter@69();
    VAR
      CostBudgetEntry@1001 : Record 1109;
      CostObject@1000 : Record 1113;
    BEGIN
      Assert.AreEqual(
        '',CostBudgetEntry.GetFirstCostObject(LibraryUtility.GenerateRandomCode(CostObject.FIELDNO(Code),DATABASE::"Cost Object")),
        STRSUBSTNO(ExpectedValueIsDifferentError,CostObject.FIELDNAME(Code)));
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestCostBudgetEntryGetFirstCostType@19();
    VAR
      CostBudgetEntry@1001 : Record 1109;
      CostType@1000 : Record 1103;
      CostType2@1002 : Record 1103;
      CostAccountingSetup@1004 : Record 1108;
    BEGIN
      LibraryCostAccounting.CreateCostType(CostType);
      LibraryCostAccounting.CreateCostType(CostType2);
      CostType.TESTFIELD("No.",CostBudgetEntry.GetFirstCostType(CostType."No." + '|' + CostType2."No."));

      // Tear Down: Reset the value of Align G/L Account in Cost Accounting Setup.
      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::"No Alignment");
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryGetFirstCostTypeInvalidFilter@96();
    VAR
      CostBudgetEntry@1001 : Record 1109;
      CostType@1000 : Record 1103;
    BEGIN
      Assert.AreEqual(
        '',CostBudgetEntry.GetFirstCostType(LibraryUtility.GenerateRandomCode(CostType.FIELDNO("No."),DATABASE::"Cost Type")),
        STRSUBSTNO(ExpectedValueIsDifferentError,CostType.FIELDNAME("No.")));
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryGetFirstDateHiddenDate@24();
    VAR
      CostBudgetEntry@1001 : Record 1109;
      CostBudgetName@1002 : Record 1110;
      RandomDate@1000 : Date;
      RandomDate2@1003 : Date;
      RandomDate3@1004 : Date;
      DateFormulaMonth@1005 : DateFormula;
    BEGIN
      LibraryCostAccounting.CreateCostBudgetName(CostBudgetName);
      LibraryCostAccounting.CreateCostBudgetEntry(CostBudgetEntry,CostBudgetName.Name);

      EVALUATE(DateFormulaMonth,'<1M>');
      RandomDate := LibraryUtility.GenerateRandomDate(WORKDATE,CALCDATE(DateFormulaMonth,WORKDATE));
      RandomDate2 := LibraryUtility.GenerateRandomDate(RandomDate,CALCDATE(DateFormulaMonth,RandomDate));
      RandomDate3 := LibraryUtility.GenerateRandomDate(RandomDate2,CALCDATE(DateFormulaMonth,RandomDate2));
      CostBudgetEntry.FILTERGROUP := 26;
      CostBudgetEntry.SETFILTER(Date,'..' + FORMAT(RandomDate) + '|' + FORMAT(RandomDate2) + '..');
      Assert.AreEqual(
        RandomDate,CostBudgetEntry.GetFirstDate(FORMAT(RandomDate3)),
        STRSUBSTNO(ExpectedValueIsDifferentError,CostBudgetEntry.FIELDNAME(Date)));
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryGetFirstDatePeriodDate@23();
    VAR
      CostBudgetEntry@1001 : Record 1109;
      CostBudgetName@1002 : Record 1110;
      RandomDate@1000 : Date;
      DateFormulaYear@1003 : DateFormula;
    BEGIN
      LibraryCostAccounting.CreateCostBudgetName(CostBudgetName);
      LibraryCostAccounting.CreateCostBudgetEntry(CostBudgetEntry,CostBudgetName.Name);
      EVALUATE(DateFormulaYear,'<1Y>');
      RandomDate := LibraryUtility.GenerateRandomDate(WORKDATE,CALCDATE(DateFormulaYear,WORKDATE));
      Assert.AreEqual(
        RandomDate,CostBudgetEntry.GetFirstDate(FORMAT(RandomDate)),
        STRSUBSTNO(ExpectedValueIsDifferentError,CostBudgetEntry.FIELDNAME(Date)));
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryGetFirstDateWorkDate@68();
    VAR
      CostBudgetEntry@1001 : Record 1109;
    BEGIN
      Assert.AreEqual(
        WORKDATE,CostBudgetEntry.GetFirstDate(''),STRSUBSTNO(ExpectedValueIsDifferentError,CostBudgetEntry.FIELDNAME(Date)));
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryHandleCostBudgetRegisterInsert@103();
    VAR
      CostBudgetEntry@1000 : Record 1109;
      CostBudgetRegister@1001 : Record 1111;
    BEGIN
      CostBudgetEntry.SetCostBudgetRegNo(0);
      CreateRandomCostBudgetEntryWithCostCenter(CostBudgetEntry,TRUE);
      CostBudgetRegister.FINDLAST;

      Assert.AreEqual(CostBudgetRegister."No.",CostBudgetEntry.GetCostBudgetRegNo,STRSUBSTNO(Text001,CostBudgetRegister.TABLECAPTION))
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryHandleCostBudgetRegisterUpdate@104();
    VAR
      CostBudgetEntry@1000 : Record 1109;
      CostBudgetRegister@1001 : Record 1111;
      OldBudgetRegisterNo@1003 : Integer;
    BEGIN
      // set the current RegNo and set "To Budget Entry No." to a newer entry so a new register entry will be created
      IF CostBudgetEntry.FINDLAST THEN;
      IF CostBudgetRegister.FINDLAST THEN;
      CostBudgetRegister."To Cost Budget Entry No." := CostBudgetEntry."Entry No." + 1 + RANDOM(100);
      CostBudgetRegister.MODIFY;
      OldBudgetRegisterNo := CostBudgetRegister."No.";
      CostBudgetEntry.SetCostBudgetRegNo(OldBudgetRegisterNo);
      CreateRandomCostBudgetEntryWithCostCenter(CostBudgetEntry,TRUE);
      CostBudgetRegister.FINDLAST;

      Assert.AreEqual(CostBudgetRegister."No.",CostBudgetEntry.GetCostBudgetRegNo,STRSUBSTNO(Text001,CostBudgetRegister.TABLECAPTION));
      Assert.AreNotEqual(OldBudgetRegisterNo,CostBudgetEntry.GetCostBudgetRegNo,STRSUBSTNO(Text001,CostBudgetRegister.TABLECAPTION))
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryOnInsertEntryNo@100();
    VAR
      CostBudgetEntry@1000 : Record 1109;
      i@1002 : Integer;
    BEGIN
      CostBudgetEntry.DELETEALL;
      FOR i := 1 TO 1 + RANDOM(9) DO BEGIN
        FillRandomCostBudgetEntryWithCostCenter(CostBudgetEntry);
        CostBudgetEntry."Entry No." := 0;
        CostBudgetEntry.INSERT(TRUE);
        Assert.AreEqual(
          i,CostBudgetEntry."Entry No.",STRSUBSTNO(Text000,CostBudgetEntry.FIELDCAPTION("Entry No."),CostBudgetEntry.TABLECAPTION,i))
      END
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryOnModify@101();
    VAR
      CostBudgetEntry@1000 : Record 1109;
    BEGIN
      CreateRandomCostBudgetEntryWithCostCenter(CostBudgetEntry,FALSE);
      CostBudgetEntry."Last Modified By User" := '';
      CostBudgetEntry."Last Date Modified" := 0D;
      CostBudgetEntry.MODIFY(TRUE);
      Assert.AreEqual(
        UPPERCASE(USERID),CostBudgetEntry."Last Modified By User",
        STRSUBSTNO(Text002,CostBudgetEntry.FIELDCAPTION("Last Modified By User"),UPPERCASE(USERID)));
      Assert.AreEqual(
        TODAY,CostBudgetEntry."Last Date Modified",STRSUBSTNO(Text002,CostBudgetEntry.FIELDCAPTION("Last Date Modified"),TODAY))
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryOnModifyAmount@97();
    VAR
      CostBudgetEntry@1000 : Record 1109;
      CostBudgetRegister@1001 : Record 1111;
      PrevBudgetRegisterTotal@1002 : Decimal;
      NewEntryAmount@1004 : Decimal;
    BEGIN
      CreateRandomCostBudgetEntryWithCostCenter(CostBudgetEntry,TRUE);
      CostBudgetRegister.GET(CostBudgetEntry.GetCostBudgetRegNo);
      PrevBudgetRegisterTotal := CostBudgetRegister.Amount;

      NewEntryAmount := RANDOM(CostBudgetEntry.Amount);
      CostBudgetEntry.VALIDATE(Amount,NewEntryAmount);
      CostBudgetEntry.MODIFY(TRUE);

      CostBudgetRegister.GET(CostBudgetRegister."No.");
      Assert.AreEqual(
        NewEntryAmount,CostBudgetRegister.Amount,
        STRSUBSTNO(
          Text000,CostBudgetRegister.FIELDCAPTION(Amount),CostBudgetRegister.TABLECAPTION,PrevBudgetRegisterTotal + NewEntryAmount));
    END;

    [Test]
    PROCEDURE TestCostBudgetEntryOnModifyNegativeAmount@154();
    VAR
      CostBudgetEntry@1005 : Record 1109;
      CostBudgetRegister@1004 : Record 1111;
      PrevBudgetRegisterTotal@1007 : Decimal;
      NewEntryAmount@1006 : Decimal;
    BEGIN
      CreateRandomCostBudgetEntryWithCostCenter(CostBudgetEntry,TRUE);
      CostBudgetRegister.GET(CostBudgetEntry.GetCostBudgetRegNo);
      PrevBudgetRegisterTotal := CostBudgetRegister.Amount;

      NewEntryAmount := LibraryRandom.RandIntInRange(CostBudgetEntry.Amount,2 * CostBudgetEntry.Amount);
      CostBudgetEntry.VALIDATE(Amount,-NewEntryAmount);
      CostBudgetEntry.MODIFY(TRUE);

      CostBudgetRegister.GET(CostBudgetRegister."No.");
      Assert.AreEqual(
        -NewEntryAmount,CostBudgetRegister.Amount,
        STRSUBSTNO(
          Text000,CostBudgetRegister.FIELDCAPTION(Amount),CostBudgetRegister.TABLECAPTION,PrevBudgetRegisterTotal + NewEntryAmount));
    END;

    [Test]
    PROCEDURE TestCostBudgetEntrySetCostBudgetRegNo@114();
    VAR
      CostBudgetEntry@1001 : Record 1109;
      BudgetRegNo@1000 : Integer;
    BEGIN
      BudgetRegNo := RANDOM(100);
      CostBudgetEntry.SetCostBudgetRegNo(BudgetRegNo);
      Assert.AreEqual(BudgetRegNo,CostBudgetEntry.GetCostBudgetRegNo,Text003)
    END;

    [Test]
    PROCEDURE TestCostBudgetNameOnDeleteCostBudgetEntry@122();
    VAR
      CostBudgetEntry@1000 : Record 1109;
      CostBudgetRegister@1001 : Record 1111;
      CostBudgetName@1002 : Record 1110;
    BEGIN
      CostBudgetName.Name :=
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetName.FIELDNO(Name),DATABASE::"Cost Budget Name"),1,
          MAXSTRLEN(CostBudgetEntry."Budget Name"));
      CostBudgetName.INSERT;
      CreateCostBudgetEntry(
        CostBudgetEntry,0,CostBudgetName.Name,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Type No."),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Type No.")),WORKDATE,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Center Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Center Code")),'',0,TRUE);
      Assert.IsTrue(CostBudgetRegister.GET(CostBudgetEntry.GetCostBudgetRegNo),STRSUBSTNO(Text012,CostBudgetRegister.TABLECAPTION));
      CostBudgetName.DELETE(TRUE);
      ASSERTERROR CostBudgetEntry.GET(CostBudgetEntry."Entry No.");
      Assert.ExpectedError(STRSUBSTNO(Text012,CostBudgetEntry.TABLECAPTION));
      ASSERTERROR CostBudgetRegister.GET(CostBudgetRegister."No.");
      Assert.ExpectedError(STRSUBSTNO(Text012,CostBudgetRegister.TABLECAPTION));
      ASSERTERROR CostBudgetName.GET(CostBudgetName.Name);
      Assert.ExpectedError(STRSUBSTNO(Text012,CostBudgetName.TABLECAPTION));
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestCostBudgetRegisterOnValidateClosed@125();
    VAR
      CostBudgetRegister@1000 : Record 1111;
      i@1002 : Integer;
    BEGIN
      // create at least 3 registers. Close the last one -2 and verify all preceding ones are now closed.
      IF CostBudgetRegister.FIND('+') THEN;
      FOR i := 1 TO 3 + RANDOM(7) DO BEGIN
        CostBudgetRegister.INIT;
        CostBudgetRegister."No." += 1;
        CostBudgetRegister.INSERT;
      END;
      CostBudgetRegister.NEXT(-2);
      CostBudgetRegister.VALIDATE(Closed,TRUE);
      REPEAT
        Assert.IsTrue(CostBudgetRegister.Closed,STRSUBSTNO(Text015,CostBudgetRegister.TABLECAPTION))
      UNTIL CostBudgetRegister.NEXT(-1) = 0
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostBudgetRegisterOnValidateClosedErrorOnConfirmNo@124();
    VAR
      CostBudgetRegister@1000 : Record 1111;
    BEGIN
      IF CostBudgetRegister.FINDLAST THEN;
      CostBudgetRegister.Closed := FALSE;
      ASSERTERROR CostBudgetRegister.VALIDATE(Closed,TRUE);
      Assert.AreEqual('',GETLASTERRORTEXT,UnexpectedErr);
    END;

    [Test]
    PROCEDURE TestCostBudgetRegisterOnValidateClosedErrorOnReOpen@123();
    VAR
      CostBudgetRegister@1000 : Record 1111;
    BEGIN
      IF CostBudgetRegister.FINDLAST THEN;
      CostBudgetRegister.Closed := TRUE;
      ASSERTERROR CostBudgetRegister.VALIDATE(Closed,FALSE);
      Assert.IsTrue(Text014 = GETLASTERRORTEXT,UnexpectedErr)
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostCenterValidateDeleteCostCenterOnConfirmNo@161();
    VAR
      CostCenter@1000 : Record 1112;
      CostCenterCode@1001 : Code[20];
    BEGIN
      // Unit test - Table 1112-Cost Center-Test Cost Center is not deleted when Confirm is set False.

      // Setup: Create a Cost Center.
      CostCenterCode := CreateCostCenter;
      CreateCostEntriesWithCostCenter(CostCenterCode);

      // Exercise: Delete created Cost Center and Confirm is set to No.
      CostCenter.GET(CostCenterCode);
      ASSERTERROR CostCenter.DELETE(TRUE); // In the code a blank error is written for confirm No so to handle that error ASSERTERROR has been used.

      // Verify: To check if the created Cost Center is not deleted.
      CostCenter.GET(CostCenterCode);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestCostCenterValidateDeleteCostCenterOnConfirmYes@162();
    VAR
      CostCenter@1000 : Record 1112;
      CostCenterCode@1001 : Code[20];
    BEGIN
      // Unit test - Table 1112-Cost Center-Test Cost Center is deleted successfully when Confirm is set True.

      // Setup: Create a Cost Center.
      CostCenterCode := CreateCostCenter;
      CreateCostEntriesWithCostCenter(CostCenterCode);

      // Exercise: Delete created Cost Center and Confirm is set to Yes.
      CostCenter.GET(CostCenterCode);
      CostCenter.DELETE(TRUE);

      // Verify: To check if the created Cost Center is deleted successfully.
      ASSERTERROR CostCenter.GET(CostCenterCode);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostCenterValidateLineTypeConfirmationNo@158();
    VAR
      CostCenter@1000 : Record 1112;
      CostCenterCode@1001 : Code[20];
    BEGIN
      // Unit test - Table 1112-Cost Center-Test that Line Type of Cost Center is not modified when Confirm is No.

      // Setup: Create a Cost center with Cost Entries.
      CostCenterCode := CreateCostCenter;
      CreateCostEntriesWithCostCenter(CostCenterCode);

      // Exercise: Modify the Line Type of Created Cost Center.
      CostCenter.GET(CostCenterCode);
      ASSERTERROR UpdateCostCenter(CostCenter); // In the code a blank error is written for confirm No so to handle that error ASSERTERROR has been used.

      // Verify: Check that Line Type and Totaling fields of Cost Center is not modified .
      CostCenter.TESTFIELD("Line Type",CostCenter."Line Type"::"Cost Center");
      CostCenter.TESTFIELD(Totaling,'');
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestCostCenterValidateLineTypeConfirmationYes@159();
    VAR
      CostCenter@1000 : Record 1112;
      CostCenterCode@1001 : Code[20];
    BEGIN
      // Unit test - Table 1112-Cost Center-Test that Line Type of Cost Center is Modified when Confirm is set Yes.

      // Setup: Create a Cost Center.
      CostCenterCode := CreateCostCenter;
      CreateCostEntriesWithCostCenter(CostCenterCode);

      // Exercise: Modify the Line Type of created Cost Center.
      CostCenter.GET(CostCenterCode);
      UpdateCostCenter(CostCenter);

      // Verify: To check that Line Type, Blocked and Cost Subtype Fields are Modified when Confirm is Yes.
      CostCenter.TESTFIELD("Line Type",CostCenter."Line Type"::Heading);
      CostCenter.TESTFIELD("Cost Subtype",0);
      CostCenter.TESTFIELD(Blocked,TRUE);
    END;

    [Test]
    PROCEDURE TestCostCenterValidateTotaling@157();
    VAR
      CostCenter@1000 : Record 1112;
      CostCenterCode@1001 : Code[20];
    BEGIN
      // Unit test - Table 1112-Cost Center-Test that error occur when Totaling field value is modified for a Cost Center.

      // Setup: Create a Cost Center with Cost Entries.
      CostCenterCode := CreateCostCenter;
      CreateCostEntriesWithCostCenter(CostCenterCode);

      // Exercise: To get the occured error.
      CostCenter.GET(CostCenterCode);
      ASSERTERROR CostCenter.VALIDATE(Totaling,LibraryUtility.GenerateRandomCode(CostCenter.FIELDNO(Code),DATABASE::"Cost Center"));

      // Verify: To check that expected error occur when Totaling field value is modified for Cost Center.
      Assert.ExpectedError(
        STRSUBSTNO(IncorrectLineTypeError,CostCenter."Line Type",CostCenter.TABLECAPTION,CostCenter.FIELDCAPTION(Code),CostCenter.Code));
    END;

    [Test]
    PROCEDURE TestCostJournalBatchOnDelete@146();
    VAR
      CostJournalTemplate@1002 : Record 1100;
      CostJournalBatch@1001 : Record 1102;
      CostJournalLine@1004 : Record 1101;
      CostJournalBatchName@1000 : Code[10];
    BEGIN
      // Unit test - Table 1102 Cost Journal Batch - Verify a Cost Journal Batch deletion
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      CostJournalBatchName := CostJournalBatch.Name;

      CostJournalBatch.DELETE(TRUE);
      CostJournalLine.SETRANGE("Journal Batch Name",CostJournalBatchName);

      Assert.IsTrue(CostJournalLine.ISEMPTY,STRSUBSTNO(ExpectedValueIsDifferentError,CostJournalBatch.TABLECAPTION));

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalBatchOnValidateBalCostTypeNo@145();
    VAR
      CostJournalTemplate@1005 : Record 1100;
      CostJournalBatch@1004 : Record 1102;
      CostType@1000 : Record 1103;
    BEGIN
      // Unit test - Table 1102 Cost Journal Batch - Verify a Bal.Cost Type No. modification
      LibraryCostAccounting.CreateCostJournalTemplate(CostJournalTemplate);
      LibraryCostAccounting.CreateCostJournalBatch(CostJournalBatch,CostJournalTemplate.Name);

      CreateCostType(CostType);

      CostJournalBatch.VALIDATE("Bal. Cost Type No.",CostType."No.");
      CostJournalBatch.MODIFY;

      CostJournalBatch.TESTFIELD("Bal. Cost Center Code",CostType."Cost Center Code");
      CostJournalBatch.TESTFIELD("Bal. Cost Object Code",CostType."Cost Object Code");

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalBatchOnValidateBlockedBalCostTypeNo@163();
    VAR
      CostJournalTemplate@1009 : Record 1100;
      CostJournalBatch@1008 : Record 1102;
      CostType@1007 : Record 1103;
    BEGIN
      // Unit test - Table 1102 Cost Journal Batch - Verify a blocked Cost Type entry as a Bal.Cost Type No. in Cost Journal Batch
      LibraryCostAccounting.CreateCostJournalTemplate(CostJournalTemplate);
      LibraryCostAccounting.CreateCostJournalBatch(CostJournalBatch,CostJournalTemplate.Name);

      CreateCostType(CostType);
      CostType.VALIDATE(Blocked,TRUE);
      CostType.MODIFY;

      ASSERTERROR CostJournalBatch.VALIDATE("Bal. Cost Type No.",CostType."No.");

      Assert.AreNotEqual(
        STRPOS(GETLASTERRORTEXT,STRSUBSTNO(Text017,CostType.FIELDCAPTION(Blocked),FALSE,CostType."No.",CostType.Blocked)),0,
        GETLASTERRORTEXT);
    END;

    [Test]
    PROCEDURE TestCostJournalLineCalculateBalanceWithEmptyBalCostTypeNo@143();
    VAR
      CostJournalLine@1007 : Record 1101;
      CostType@1001 : Record 1103;
      CostJournalTemplate@1005 : Record 1100;
      CostJournalBatch@1004 : Record 1102;
      AmountValue@1006 : Decimal;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that CostTypeNo modification will affect the Bal.Cost Center Code and Bal.Cost Object Code fields. Testcase ("Cost Type No." <> '') AND ("Bal. Cost Type No." = ''):
      CreateCostType(CostType);

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      CostJournalLine.VALIDATE("Bal. Cost Type No.",'');
      CostJournalLine.VALIDATE("Cost Type No.",CostType."No.");
      AmountValue := LibraryRandom.RandDec(100,2);
      CostJournalLine.VALIDATE(Amount,AmountValue);
      CostJournalLine.MODIFY(TRUE);

      CostJournalLine.TESTFIELD(Balance,AmountValue);
    END;

    [Test]
    PROCEDURE TestCostJournalLineCalculateBalanceWithEmptyCostTypeNo@144();
    VAR
      CostJournalTemplate@1008 : Record 1100;
      CostJournalBatch@1007 : Record 1102;
      CostJournalLine@1006 : Record 1101;
      CostType@1000 : Record 1103;
      AmountValue@1009 : Decimal;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that CostTypeNo modification will affect the Bal.Cost Center Code and Bal.Cost Object Code fields. Testcase ("Cost Type No." = '') AND ("Bal. Cost Type No." <> ''):
      CreateCostType(CostType);

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      CostJournalLine.VALIDATE("Cost Type No.",'');
      CostJournalLine.VALIDATE("Bal. Cost Type No.",CostType."No.");
      AmountValue := LibraryRandom.RandDec(100,2);
      CostJournalLine.VALIDATE(Amount,AmountValue);
      CostJournalLine.MODIFY(TRUE);

      CostJournalLine.TESTFIELD(Balance,-AmountValue);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnModify@141();
    VAR
      CostJournalLine@1002 : Record 1101;
      CostJournalTemplate@1001 : Record 1100;
      CostJournalBatch@1000 : Record 1102;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that any Cost Journal modification will change "System-Created Entry" property to FALSE
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);

      CostJournalLine.VALIDATE(Amount,LibraryRandom.RandDec(100,2));
      CostJournalLine.MODIFY(TRUE);

      Assert.IsFalse(
        CostJournalLine."System-Created Entry",
        STRSUBSTNO(ExpectedValueIsDifferentError,CostJournalLine.FIELDCAPTION("System-Created Entry")));

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateBalCostTypeNo@138();
    VAR
      CostJournalLine@1006 : Record 1101;
      CostType@1000 : Record 1103;
      CostJournalTemplate@1004 : Record 1100;
      CostJournalBatch@1003 : Record 1102;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that Bal CostTypeNo modification will affect the Bal.Cost Center Code and Bal.Cost Object Code fields
      CreateCostType(CostType);

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      CostJournalLine.VALIDATE("Bal. Cost Type No.",CostType."No.");
      CostJournalLine.MODIFY(TRUE);

      CostJournalLine.TESTFIELD("Bal. Cost Center Code",CostType."Cost Center Code");
      CostJournalLine.TESTFIELD("Bal. Cost Object Code",CostType."Cost Object Code");

      CostJournalTemplate.DELETE(TRUE);
      CostType.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateCostCenter@135();
    VAR
      CostJournalLine@1000 : Record 1101;
      CostCenter@1001 : Record 1112;
      CostJournalTemplate@1004 : Record 1100;
      CostJournalBatch@1003 : Record 1102;
      RecRef@1005 : RecordRef;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify object behavior in case that Cost Center Code is equal to "Begin-Total" or "Cost Center"
      SetUpCostJournalLineTestCases;

      CostCenter.INIT;
      CostCenter.SETFILTER("Line Type",'<>%1&<>%2',CostCenter."Line Type"::"Begin-Total",CostCenter."Line Type"::"Cost Center");
      RecRef.GETTABLE(CostCenter);
      LibraryUtility.FindRecord(RecRef);
      RecRef.SETTABLE(CostCenter);

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      ASSERTERROR CostJournalLine.VALIDATE("Cost Center Code",CostCenter.Code);

      Assert.AreNotEqual(
        STRPOS(
          GETLASTERRORTEXT,
          STRSUBSTNO(
            Text016,CostCenter.FIELDCAPTION("Line Type"),CostCenter."Line Type"::"Cost Center",CostCenter."Line Type"::"Begin-Total",
            CostCenter.TABLECAPTION,CostCenter.Code)),0,GETLASTERRORTEXT);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateCostObject@126();
    VAR
      CostJournalLine@1002 : Record 1101;
      CostObject@1001 : Record 1113;
      CostJournalTemplate@1004 : Record 1100;
      CostJournalBatch@1003 : Record 1102;
      RecRef@1005 : RecordRef;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify object behavior in case that Cost Object Code is equal to "Begin-Total" or "Cost Object"
      SetUpCostJournalLineTestCases;

      CostObject.INIT;
      CostObject.SETFILTER("Line Type",'<>%1&<>%2',CostObject."Line Type"::"Begin-Total",CostObject."Line Type"::"Cost Object");
      RecRef.GETTABLE(CostObject);
      LibraryUtility.FindRecord(RecRef);
      RecRef.SETTABLE(CostObject);

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      ASSERTERROR CostJournalLine.VALIDATE("Cost Object Code",CostObject.Code);

      Assert.AreNotEqual(
        STRPOS(
          GETLASTERRORTEXT,
          STRSUBSTNO(
            Text016,CostObject.FIELDCAPTION("Line Type"),CostObject."Line Type"::"Cost Object",CostObject."Line Type"::"Begin-Total",
            CostObject.TABLECAPTION,CostObject.Code)),0,GETLASTERRORTEXT);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateCostTypeNo@139();
    VAR
      CostJournalLine@1001 : Record 1101;
      CostType@1000 : Record 1103;
      CostJournalTemplate@1003 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that CostTypeNo modification will affect the Cost Center Code, Description and Cost Object Code fields
      CreateCostType(CostType);

      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      CostJournalLine.VALIDATE("Cost Type No.",CostType."No.");
      CostJournalLine.MODIFY(TRUE);

      CostJournalLine.TESTFIELD("Cost Center Code",CostType."Cost Center Code");
      CostJournalLine.TESTFIELD("Cost Object Code",CostType."Cost Object Code");
      CostJournalLine.TESTFIELD(Description,CostType.Name);

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateCreditAmount@136();
    VAR
      CostJournalLine@1001 : Record 1101;
      CostJournalTemplate@1003 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      RandomAmountValue@1004 : Decimal;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that debit amount modification will affect amount field
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);

      RandomAmountValue := LibraryRandom.RandDec(10,2);
      CostJournalLine.VALIDATE("Credit Amount",RandomAmountValue);

      CostJournalLine.TESTFIELD(Amount,-RandomAmountValue);
      CostJournalLine.TESTFIELD("Debit Amount",0);

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateCreditAmountWithDebitAmountEntered@152();
    VAR
      CostJournalLine@1004 : Record 1101;
      CostJournalTemplate@1003 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      CreditAmountValue@1001 : Decimal;
      DebitAmountValue@1000 : Decimal;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that Credit amount modification will affect Debit Amount and Amount fields
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);

      DebitAmountValue := LibraryRandom.RandDec(10,2);
      CostJournalLine.VALIDATE("Debit Amount",DebitAmountValue);

      CreditAmountValue := LibraryRandom.RandDec(10,2);
      CostJournalLine.VALIDATE("Credit Amount",CreditAmountValue);

      CostJournalLine.TESTFIELD(Amount,-CreditAmountValue);
      CostJournalLine.TESTFIELD("Debit Amount",0);
      CostJournalLine.TESTFIELD("Credit Amount",CreditAmountValue);

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateDebitAmount@137();
    VAR
      CostJournalLine@1001 : Record 1101;
      CostJournalTemplate@1003 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      RandomAmountValue@1004 : Decimal;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that debit amount modification will affect amount field
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);

      RandomAmountValue := LibraryRandom.RandDec(10,2);
      CostJournalLine.VALIDATE("Debit Amount",RandomAmountValue);

      CostJournalLine.TESTFIELD(Amount,RandomAmountValue);
      CostJournalLine.TESTFIELD("Credit Amount",0);

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateDebitAmountWithCreditAmountEntered@149();
    VAR
      CostJournalLine@1003 : Record 1101;
      CostJournalTemplate@1002 : Record 1100;
      CostJournalBatch@1001 : Record 1102;
      CreditAmountValue@1000 : Decimal;
      DebitAmountValue@1004 : Decimal;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that debit amount modification will affect the Credit Amount and Amount fields
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);

      CreditAmountValue := LibraryRandom.RandDec(10,2);
      CostJournalLine.VALIDATE("Credit Amount",CreditAmountValue);

      DebitAmountValue := LibraryRandom.RandDec(10,2);
      CostJournalLine.VALIDATE("Debit Amount",DebitAmountValue);

      CostJournalLine.TESTFIELD(Amount,DebitAmountValue);
      CostJournalLine.TESTFIELD("Debit Amount",DebitAmountValue);
      CostJournalLine.TESTFIELD("Credit Amount",0);

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateEmptySourceCode@142();
    VAR
      CostJournalLine@1008 : Record 1101;
      SourceCodeSetup@1000 : Record 242;
      CostJournalTemplate@1002 : Record 1100;
      CostJournalBatch@1001 : Record 1102;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify Cost Journal Line with no Source Code entered
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      SourceCodeSetup.GET;

      CostJournalLine.TESTFIELD("Source Code",SourceCodeSetup."Cost Journal");

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateNegativeCreditAmount@156();
    VAR
      CostJournalLine@1004 : Record 1101;
      CostJournalTemplate@1003 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
      CreditAmountValue@1001 : Decimal;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that negative Credit amount will affect Debit amount field
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);

      CreditAmountValue := LibraryRandom.RandDec(10,2);
      CostJournalLine.VALIDATE("Credit Amount",-CreditAmountValue);

      CostJournalLine.TESTFIELD(Amount,CreditAmountValue);
      CostJournalLine.TESTFIELD("Debit Amount",CreditAmountValue);
      CostJournalLine.TESTFIELD("Credit Amount",0);

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalLineOnValidateReasonCode@140();
    VAR
      CostJournalTemplate@1009 : Record 1100;
      CostJournalBatch@1008 : Record 1102;
      CostJournalLine@1007 : Record 1101;
      ReasonCode@1001 : Record 231;
      CostType@1003 : Record 1103;
      BalCostType@1000 : Record 1103;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify that in case of an empty Reason Code, this property will be set to Journal Batch's Reason Code value
      LibraryCostAccounting.CreateCostTypeNoGLRange(CostType);
      LibraryCostAccounting.CreateCostTypeNoGLRange(BalCostType);
      LibraryCostAccounting.CreateCostJournalTemplate(CostJournalTemplate);
      LibraryCostAccounting.CreateCostJournalBatch(CostJournalBatch,CostJournalTemplate.Name);
      LibraryERM.CreateReasonCode(ReasonCode);
      CostJournalBatch.VALIDATE("Reason Code",ReasonCode.Code);
      CostJournalBatch.MODIFY(TRUE);

      LibraryCostAccounting.CreateCostJournalLineBasic(
        CostJournalLine,CostJournalTemplate.Name,CostJournalBatch.Name,WORKDATE,CostType."No.",BalCostType."No.");

      CostJournalLine.TESTFIELD("Reason Code",CostJournalBatch."Reason Code");

      CostJournalTemplate.DELETE(TRUE)
    END;

    [Test]
    PROCEDURE TestCostJournalTemplateOnCreate@102();
    VAR
      CostJournalTemplate@1000 : Record 1100;
    BEGIN
      // Unit test Table 1100 - verify a Cost Journal Template creation
      LibraryCostAccounting.CreateCostJournalTemplate(CostJournalTemplate);

      Assert.AreEqual(
        REPORT::"Cost Register",CostJournalTemplate."Posting Report ID",
        STRSUBSTNO(UnexpectedMessageError,CostJournalTemplate.FIELDCAPTION("Posting Report ID"),REPORT::"Cost Register"));

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    PROCEDURE TestCostJournalTemplateOnDelete@99();
    VAR
      CostJournalTemplate@1000 : Record 1100;
      CostJournalBatch@1001 : Record 1102;
      Counter@1008 : Integer;
    BEGIN
      // Unit test Table 1100 - verify deleting a Cost Journal template (should delete Cost Journal Batch also)
      LibraryCostAccounting.CreateCostJournalTemplate(CostJournalTemplate);
      FOR Counter := 1 TO LibraryRandom.RandInt(10) DO
        LibraryCostAccounting.CreateCostJournalBatch(CostJournalBatch,CostJournalTemplate.Name);

      CostJournalTemplate.GET(CostJournalTemplate.Name);
      CostJournalTemplate.DELETE(TRUE);
      CostJournalBatch.SETRANGE("Journal Template Name",CostJournalTemplate.Name);

      Assert.IsTrue(CostJournalBatch.ISEMPTY,STRSUBSTNO(ExpectedValueIsDifferentError,CostJournalBatch.TABLECAPTION));
    END;

    [Test]
    PROCEDURE TestCostJournalTemplateOnValidateAmountZero@98();
    VAR
      CostJournalTemplate@1004 : Record 1100;
      CostJournalBatch@1003 : Record 1102;
      CostJournalLine@1002 : Record 1101;
    BEGIN
      // Unit test - Table 1101 Cost Journal Line - Verify Cost Journal Line with zero amount
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);

      CostJournalLine.VALIDATE(Amount,0);
      CostJournalLine.MODIFY(TRUE);

      CostJournalLine.TESTFIELD("Debit Amount",0);
      CostJournalLine.TESTFIELD("Credit Amount",0);

      CostJournalTemplate.DELETE(TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostObjectValidateDeleteCostCenterOnConfirmNo@169();
    VAR
      CostObject@1000 : Record 1113;
      CostObjectCode@1002 : Code[20];
    BEGIN
      // Unit test - Table 1113-Cost Object-Test Cost Object is not deleted when Confirm is set to False.

      // Setup: Create a Cost Object.
      CostObjectCode := CreateCostObject;
      CreateCostEntriesWithCostObject(CostObjectCode);

      // Exercise: Delete created Cost Object and set Confirm to No.
      CostObject.GET(CostObjectCode);
      ASSERTERROR CostObject.DELETE(TRUE); // In the code a blank error is written for confirm No so to handle that error ASSERTERROR has been used.

      // Verify: To check if the created Cost Object is not deleted.
      CostObject.GET(CostObjectCode);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestCostObjectValidateDeleteCostCenterOnConfirmYes@170();
    VAR
      CostObject@1000 : Record 1113;
      CostObjectCode@1001 : Code[20];
    BEGIN
      // Unit test - Table 1113-Cost Object-Test Cost Object is deleted successfully when Confirm is set to True.

      // Setup: Create a Cost Object.
      CostObjectCode := CreateCostObject;
      CreateCostEntriesWithCostObject(CostObjectCode);

      // Exercise: Delete created Cost Object and set Confirm to Yes.
      CostObject.GET(CostObjectCode);
      CostObject.DELETE(TRUE);

      // Verify: To check if the created Cost Object is deleted successfully.
      ASSERTERROR CostObject.GET(CostObjectCode);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerNo)]
    PROCEDURE TestCostObjectValidateLineTypeConfirmationNo@167();
    VAR
      CostObject@1000 : Record 1113;
      CostObjectCode@1001 : Code[20];
    BEGIN
      // Unit test - Table 1113-Cost Object-Test that Line Type of Cost Object is not modified when Confirm is No.

      // Setup: Create a Cost Object with Cost Entries.
      CostObjectCode := CreateCostObject;
      CreateCostEntriesWithCostObject(CostObjectCode);

      // Exercise: Modify the Line Type of Created Cost Object.
      CostObject.GET(CostObjectCode);
      ASSERTERROR UpdateCostObject(CostObject); // In the code a blank error is written for confirm No so to handle that error ASSERTERROR has been used.

      // Verify: Check that Line Type and Totaling fields of Cost Object is not modified.
      CostObject.TESTFIELD("Line Type",CostObject."Line Type"::"Cost Object");
      CostObject.TESTFIELD(Totaling,'');
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes)]
    PROCEDURE TestCostObjectValidateLineTypeConfirmationYes@168();
    VAR
      CostObject@1000 : Record 1113;
      CostObjectCode@1001 : Code[20];
    BEGIN
      // Unit test - Table 1113-Cost Object-Test that Line Type of Cost Object is Modified when Confirm is set Yes.

      // Setup: Create a Cost Object.
      CostObjectCode := CreateCostObject;
      CreateCostEntriesWithCostObject(CostObjectCode);

      // Exercise: Modify the Line Type of created Cost Object.
      CostObject.GET(CostObjectCode);
      UpdateCostObject(CostObject);

      // Verify: To check that Line Type, Blocked and Cost Subtype Fields are Modified when Confirm is Yes.
      CostObject.TESTFIELD("Line Type",CostObject."Line Type"::Heading);
      CostObject.TESTFIELD(Blocked,TRUE);
    END;

    [Test]
    PROCEDURE TestCostObjectValidateTotaling@166();
    VAR
      CostObject@1000 : Record 1113;
      CostObjectCode@1001 : Code[20];
    BEGIN
      // Unit test - Table 1113-Cost Object-Test that error occur when Totaling field value is modified for a Cost Object.

      // Setup: Create a Cost Object with Cost Entries.
      CostObjectCode := CreateCostObject;
      CreateCostEntriesWithCostObject(CostObjectCode);

      // Exercise: To get the occured error.
      CostObject.GET(CostObjectCode);
      ASSERTERROR CostObject.VALIDATE(Totaling,LibraryUtility.GenerateRandomCode(CostObject.FIELDNO(Code),DATABASE::"Cost Object"));

      // Verify: To check that expected error occur when Totaling field value is modified for Cost Object.
      Assert.ExpectedError(
        STRSUBSTNO(IncorrectLineTypeError,CostObject."Line Type",CostObject.TABLECAPTION,CostObject.FIELDCAPTION(Code),CostObject.Code));
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestGLAccLinkToCostTypeWhenAlignGLAccIsPrompt@155();
    VAR
      GLAccount@1001 : Record 15;
      CostAccountingSetup@1002 : Record 1108;
      CostType@1005 : Record 1103;
      OldGLAccountNo@1000 : Code[20];
    BEGIN
      // Unit Test Case: Test that on renaming G/L Account No., its Cost Type No. also get renamed successfully(when Align G/L Account on Cost Accounting Setup is set to Prompt).

      // Setup: Set Align G/L Account to Prompt on Cost Accounting Setup.
      CostAccountingSetup.GET;
      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::Prompt);

      // Exercise: Find a G/L Account Linked to Cost Type and rename it.
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      OldGLAccountNo := GLAccount."No.";
      GLAccount.RENAME(
        COPYSTR(
          LibraryUtility.GenerateRandomCode(GLAccount.FIELDNO("No."),DATABASE::"G/L Account"),1,
          LibraryUtility.GetFieldLength(DATABASE::"G/L Account",GLAccount.FIELDNO("No."))));

      // Verify: To check that corresponding Cost Type No. of G/L Account is renamed.
      CostType.GET(GLAccount."No.");
      ASSERTERROR CostType.GET(OldGLAccountNo);

      // Tear Down: Reset the value of Align G/L Account on Cost Accounting Setup.
      LibraryCostAccounting.SetAlignment(CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TestGLAccLinkToCostTypeWhenAlignGLAccIsAutomatic@165();
    VAR
      GLAccount@1001 : Record 15;
      CostAccountingSetup@1002 : Record 1108;
      CostType@1005 : Record 1103;
      OldGLAccountNo@1004 : Code[20];
      NewGLAccountNo@1000 : Code[20];
    BEGIN
      // Unit Test Case: Test that on reverse renaming G/L Account No., its Cost Type No. also get reverse renamed successfully(when Align G/L Account on Cost Accounting Setup is set to Automatic).

      // Setup: Rename G/L Account No. to update its corresponding Cost Type No.
      CostAccountingSetup.GET;
      LibraryCostAccounting.SetAlignment(
        CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account"::Automatic);
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      OldGLAccountNo := GLAccount."No.";
      GLAccount.RENAME(
        COPYSTR(
          LibraryUtility.GenerateRandomCode(GLAccount.FIELDNO("No."),DATABASE::"G/L Account"),1,
          LibraryUtility.GetFieldLength(DATABASE::"G/L Account",GLAccount.FIELDNO("No."))));
      NewGLAccountNo := GLAccount."No.";

      // Exercise: Reverse Rename the G/L Account Linked to Cost Type.
      GLAccount.RENAME(OldGLAccountNo);

      // Verify: CostType No. of Corresponding G/L Account is reverse renamed successfully.
      CostType.GET(OldGLAccountNo);
      ASSERTERROR CostType.GET(NewGLAccountNo);

      // Tear Down: Reset the value of Align G/L Account on Cost Accounting Setup.
      LibraryCostAccounting.SetAlignment(CostAccountingSetup.FIELDNO("Align G/L Account"),CostAccountingSetup."Align G/L Account");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TransferGLEntriesToCAWithCombinedCostCenterAndCostObjectDimensions@65();
    VAR
      TransferGLEntriesToCA@1000 : Codeunit 1105;
      CostCenterDimGLEntryNo@1004 : Integer;
      CostObjectDimGLEntryNo@1005 : Integer;
    BEGIN
      // Validate GL entries are inserted to CA in case of combined entry's dimensions
      CostObjectDimGLEntryNo := CreateGLEntryWithCostObjectDim;
      CostCenterDimGLEntryNo := CreateGLEntryWithCostCenterDim;
      TransferGLEntriesToCA.TransferGLtoCA;

      VerifyCostEntry(CostCenterDimGLEntryNo);
      VerifyCostEntry(CostObjectDimGLEntryNo);
    END;

    LOCAL PROCEDURE CostEntryInsert@22(VAR CostEntry@1002 : Record 1104;CostTypeNo@1000 : Code[20];Amount@1001 : Decimal);
    BEGIN
      CostEntry.VALIDATE("Entry No.",CostEntry.COUNT + 1);
      CostEntry.VALIDATE("Cost Type No.",CostTypeNo);
      CostEntry.VALIDATE(Amount,Amount);
      CostEntry.INSERT;
    END;

    LOCAL PROCEDURE CostTypeInsert@85(VAR CostTypeNo@1004 : Code[20];ValidationStatus@1000 : Boolean);
    VAR
      CostType@1003 : Record 1103;
    BEGIN
      CostType.VALIDATE("No.",LibraryUtility.GenerateRandomCode(CostType.FIELDNO("No."),DATABASE::"Cost Type"));
      CostType.VALIDATE(Name,LibraryUtility.GenerateRandomCode(CostType.FIELDNO(Name),DATABASE::"Cost Type"));
      CostType.INSERT(ValidationStatus);
      CostTypeNo := CostType."No.";
    END;

    LOCAL PROCEDURE CostTypeModifySetup@87(VAR CostType@1002 : Record 1103;VAR ModifiedDate@1000 : Date;VAR ModifiedBy@1001 : Code[50];InvokeOnModify@1003 : Boolean);
    VAR
      CostTypeNo@1005 : Code[20];
    BEGIN
      CostTypeInsert(CostTypeNo,FALSE);
      CostType.GET(CostTypeNo);

      IF InvokeOnModify THEN BEGIN
        ModifiedDate := TODAY;
        ModifiedBy := UPPERCASE(USERID);
      END ELSE BEGIN
        ModifiedDate := CostType."Modified Date";
        ModifiedBy := CostType."Modified By";
      END;
    END;

    LOCAL PROCEDURE CreateAllocationSource@14(AutogeneratedID@1000 : Boolean) : Code[10];
    VAR
      CostAllocationSource@1001 : Record 1106;
    BEGIN
      CostAllocationSource.INIT;
      IF AutogeneratedID THEN
        CostAllocationSource.VALIDATE(ID,'')
      ELSE
        CostAllocationSource.VALIDATE(
          ID,LibraryUtility.GenerateRandomCode(CostAllocationSource.FIELDNO(ID),DATABASE::"Cost Allocation Source"));
      CostAllocationSource.INSERT(TRUE);

      EXIT(CostAllocationSource.ID);
    END;

    LOCAL PROCEDURE CreateAllocationTarget@10(VAR CostAllocationTarget@1002 : Record 1107;AllocSourceID@1000 : Code[10]);
    BEGIN
      CostAllocationTarget.INIT;
      CostAllocationTarget.ID := AllocSourceID;
      CostAllocationTarget."Line No." := NextAllocTargetLineNo(AllocSourceID);
      CostAllocationTarget.INSERT(TRUE);
    END;

    LOCAL PROCEDURE CreateCostBudgetEntry@131(VAR CostBudgetEntry@1006 : Record 1109;EntryNo@1000 : Integer;BudgetName@1001 : Code[10];CostTypeNo@1002 : Code[20];NewDate@1003 : Date;CostCenterCode@1004 : Code[20];CostObjectCode@1005 : Code[20];NewAmount@1008 : Decimal;OnInsert@1007 : Boolean);
    BEGIN
      FillCostBudgetEntry(CostBudgetEntry,EntryNo,BudgetName,CostTypeNo,NewDate,CostCenterCode,CostObjectCode,NewAmount);
      CostBudgetEntry.INSERT(OnInsert)
    END;

    LOCAL PROCEDURE CreateCostBudgetEntryCopy@128(VAR CostBudgetEntry@1000 : Record 1109);
    VAR
      CostBudgetEntry2@1001 : Record 1109;
    BEGIN
      IF CostBudgetEntry2.FINDLAST THEN;
      CostBudgetEntry."Entry No." := CostBudgetEntry2."Entry No." + 1;
      CostBudgetEntry.INSERT;
    END;

    LOCAL PROCEDURE CreateCostCenter@33() : Code[20];
    VAR
      CostCenter@1000 : Record 1112;
    BEGIN
      CostCenter.VALIDATE(Code,LibraryUtility.GenerateRandomCode(CostCenter.FIELDNO(Code),DATABASE::"Cost Center"));
      CostCenter.INSERT(TRUE);

      EXIT(CostCenter.Code);
    END;

    LOCAL PROCEDURE CreateCostEntriesWithCostCenter@153(CostCenterCode@1005 : Code[20]);
    VAR
      CostJournalLine@1002 : Record 1101;
      CostJournalTemplate@1003 : Record 1100;
      CostJournalBatch@1004 : Record 1102;
    BEGIN
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      UpdateCostJournalLine(CostJournalLine,CostCenterCode,'');
      LibraryCostAccounting.PostCostJournalLine(CostJournalLine);
    END;

    LOCAL PROCEDURE CreateCostEntriesWithCostObject@171(CostObjectCode@1000 : Code[20]);
    VAR
      CostJournalLine@1004 : Record 1101;
      CostJournalTemplate@1003 : Record 1100;
      CostJournalBatch@1002 : Record 1102;
    BEGIN
      CreateCostJournalLine(CostJournalLine,CostJournalTemplate,CostJournalBatch);
      UpdateCostJournalLine(CostJournalLine,'',CostObjectCode);
      LibraryCostAccounting.PostCostJournalLine(CostJournalLine);
    END;

    LOCAL PROCEDURE CreateCostJournalLine@147(VAR CostJournalLine@1002 : Record 1101;VAR CostJournalTemplate@1001 : Record 1100;VAR CostJournalBatch@1000 : Record 1102);
    VAR
      CostType@1003 : Record 1103;
      BalCostType@1004 : Record 1103;
    BEGIN
      LibraryCostAccounting.CreateCostTypeNoGLRange(CostType);
      LibraryCostAccounting.CreateCostTypeNoGLRange(BalCostType);
      LibraryCostAccounting.CreateCostJournalTemplate(CostJournalTemplate);
      LibraryCostAccounting.CreateCostJournalBatch(CostJournalBatch,CostJournalTemplate.Name);
      LibraryCostAccounting.CreateCostJournalLineBasic(
        CostJournalLine,CostJournalTemplate.Name,CostJournalBatch.Name,WORKDATE,CostType."No.",BalCostType."No.");
    END;

    LOCAL PROCEDURE CreateCostObject@34() : Code[20];
    VAR
      CostObject@1000 : Record 1113;
    BEGIN
      CostObject.VALIDATE(Code,LibraryUtility.GenerateRandomCode(CostObject.FIELDNO(Code),DATABASE::"Cost Object"));
      CostObject.INSERT(TRUE);

      EXIT(CostObject.Code);
    END;

    LOCAL PROCEDURE CreateCostRegister@88(VAR CostRegister@1000 : Record 1105;CostRegisterNo@1001 : Integer);
    BEGIN
      CLEAR(CostRegister);
      CostRegister.VALIDATE("No.",CostRegisterNo);
      CostRegister.INSERT;
    END;

    LOCAL PROCEDURE CreateCostType@150(VAR CostType@1006 : Record 1103);
    VAR
      CostCenter@1004 : Record 1112;
      CostObject@1003 : Record 1113;
    BEGIN
      LibraryCostAccounting.CreateCostCenter(CostCenter);
      LibraryCostAccounting.CreateCostObject(CostObject);

      CostType.VALIDATE("No.",LibraryUtility.GenerateRandomCode(CostType.FIELDNO("No."),DATABASE::"Cost Type"));
      CostType.VALIDATE(Name,LibraryUtility.GenerateRandomCode(CostType.FIELDNO(Name),DATABASE::"Cost Type"));
      CostType.VALIDATE("Cost Center Code",CostCenter.Code);
      CostType.VALIDATE("Cost Object Code",CostObject.Code);
      CostType.INSERT;
    END;

    LOCAL PROCEDURE CreateGLEntryWithCostCenterDim@66() : Integer;
    VAR
      CostAccSetup@1003 : Record 1108;
      CostCenter@1006 : Record 1112;
      DimSetID@1005 : Integer;
    BEGIN
      CostAccSetup.GET;
      LibraryCostAccounting.CreateCostCenterFromDimension(CostCenter);
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,CostAccSetup."Cost Center Dimension",CostCenter.Code);
      EXIT(CreateGLEntry(DimSetID));
    END;

    LOCAL PROCEDURE CreateGLEntryWithCostObjectDim@75() : Integer;
    VAR
      CostAccSetup@1003 : Record 1108;
      CostObject@1006 : Record 1113;
      DimSetID@1005 : Integer;
    BEGIN
      CostAccSetup.GET;
      LibraryCostAccounting.CreateCostObjectFromDimension(CostObject);
      DimSetID := LibraryDimension.CreateDimSet(DimSetID,CostAccSetup."Cost Object Dimension",CostObject.Code);
      EXIT(CreateGLEntry(DimSetID));
    END;

    LOCAL PROCEDURE CreateGLEntry@176(DimSetID@1002 : Integer) : Integer;
    VAR
      GLEntry@1000 : Record 17;
      GLAccount@1001 : Record 15;
    BEGIN
      LibraryCostAccounting.FindGLAccLinkedToCostType(GLAccount);
      WITH GLEntry DO BEGIN
        IF FINDLAST THEN
          INIT;
        "Entry No." += 1;
        "G/L Account No." := GLAccount."No.";
        "Dimension Set ID" := DimSetID;
        "Document No." := GLAccount."No."; // Document No just needs to have a value, so it can be the same as G/L Account No.
        Amount := LibraryRandom.RandDec(100,2);
        "Posting Date" := WORKDATE;
        INSERT;
        EXIT("Entry No.");
      END;
    END;

    LOCAL PROCEDURE CreateRandomCostBudgetEntryWithCostCenter@129(VAR CostBudgetEntry@1000 : Record 1109;OnInsert@1002 : Boolean);
    BEGIN
      FillRandomCostBudgetEntryWithCostCenter(CostBudgetEntry);
      CostBudgetEntry.INSERT(OnInsert)
    END;

    LOCAL PROCEDURE CreateRandomCostBudgetEntryWithCostObject@130(VAR CostBudgetEntry@1000 : Record 1109;OnInsert@1001 : Boolean);
    BEGIN
      FillRandomCostBudgetEntryWithCostObject(CostBudgetEntry);
      CostBudgetEntry.INSERT(OnInsert)
    END;

    LOCAL PROCEDURE FillCostBudgetEntry@134(VAR CostBudgetEntry@1006 : Record 1109;EntryNo@1000 : Integer;BudgetName@1001 : Code[10];CostTypeNo@1002 : Code[20];NewDate@1003 : Date;CostCenterCode@1004 : Code[20];CostObjectCode@1005 : Code[20];NewAmount@1007 : Decimal);
    BEGIN
      WITH CostBudgetEntry DO BEGIN
        IF EntryNo = 0 THEN BEGIN
          IF FINDLAST THEN
            INIT;
          "Entry No." += 1;
        END;
        "Budget Name" := BudgetName;
        "Cost Type No." := CostTypeNo;
        Date := NewDate;
        "Cost Center Code" := CostCenterCode;
        "Cost Object Code" := CostObjectCode;
        Amount := NewAmount;
      END
    END;

    LOCAL PROCEDURE FillRandomCostBudgetEntryWithCostCenter@132(VAR CostBudgetEntry@1001 : Record 1109);
    BEGIN
      FillCostBudgetEntry(CostBudgetEntry,0,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Budget Name"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Budget Name")),
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Type No."),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Type No.")),WORKDATE,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Center Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Center Code")),'',RANDOM(1000))
    END;

    LOCAL PROCEDURE FillRandomCostBudgetEntryWithCostObject@133(VAR CostBudgetEntry@1001 : Record 1109);
    BEGIN
      FillCostBudgetEntry(CostBudgetEntry,0,
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Budget Name"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Budget Name")),
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Type No."),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Type No.")),WORKDATE,
        '',
        COPYSTR(
          LibraryUtility.GenerateRandomCode(CostBudgetEntry.FIELDNO("Cost Object Code"),DATABASE::"Cost Budget Entry"),1,
          MAXSTRLEN(CostBudgetEntry."Cost Object Code")),RANDOM(1000))
    END;

    LOCAL PROCEDURE InsertCostBudgetEntriesToCompress@127(VAR CostBudgetEntry@1003 : Record 1109;VAR FromEntryNo@1000 : Integer;VAR ToEntryNo@1001 : Integer;FillAmount@1002 : Boolean;VAR TotalAmount@1004 : Decimal);
    VAR
      i@1005 : Integer;
    BEGIN
      CreateRandomCostBudgetEntryWithCostCenter(CostBudgetEntry,FALSE);
      IF NOT FillAmount THEN BEGIN
        CostBudgetEntry.Amount := 0;
        CostBudgetEntry.MODIFY
      END;
      TotalAmount := CostBudgetEntry.Amount;
      FromEntryNo := CostBudgetEntry."Entry No.";
      FOR i := 1 TO RANDOM(10) DO BEGIN
        CreateCostBudgetEntryCopy(CostBudgetEntry);
        TotalAmount += CostBudgetEntry.Amount;
        CostBudgetEntry.MODIFY
      END;
      ToEntryNo := CostBudgetEntry."Entry No."
    END;

    LOCAL PROCEDURE LookupGroupFilter@53(BaseType@1002 : Option;ExpectedGroupFilter@1000 : Text[30]);
    VAR
      CostAllocTargetListPage@1001 : TestPage 1114;
    BEGIN
      // Setup:
      CostAllocTargetListPage.OPENEDIT;
      CostAllocTargetListPage.Base.SETVALUE(BaseType);

      // Exercise:
      CostAllocTargetListPage."Group Filter".LOOKUP;

      // Verify:
      CostAllocTargetListPage."Group Filter".ASSERTEQUALS(ExpectedGroupFilter);
    END;

    LOCAL PROCEDURE LookupNoFilter@52(BaseType@1002 : Option;ExpectedNoFilter@1000 : Text[30]);
    VAR
      CostAllocTargetListPage@1001 : TestPage 1114;
    BEGIN
      // Setup:
      CostAllocTargetListPage.OPENEDIT;
      CostAllocTargetListPage.Base.SETVALUE(BaseType);

      // Exercise:
      CostAllocTargetListPage."No. Filter".LOOKUP;

      // Verify:
      CostAllocTargetListPage."No. Filter".ASSERTEQUALS(ExpectedNoFilter);
    END;

    LOCAL PROCEDURE NextAllocTargetLineNo@56(AllocSourceID@1000 : Code[10]) : Integer;
    VAR
      CostAllocTarget@1001 : Record 1107;
    BEGIN
      CostAllocTarget.SETFILTER(ID,AllocSourceID);
      IF CostAllocTarget.FINDLAST THEN
        EXIT(CostAllocTarget."Line No." + 1);

      EXIT(0);
    END;

    LOCAL PROCEDURE SetUpCostJournalLineTestCases@148();
    VAR
      CostCenter@1002 : Record 1112;
      CostObject@1001 : Record 1113;
      CostObject1@1005 : Record 1113;
      CostCenter1@1004 : Record 1112;
    BEGIN
      // By the test requirement, it is needed to create two different Cost Type records
      LibraryCostAccounting.CreateCostCenter(CostCenter);

      CostCenter.VALIDATE("Line Type",CostCenter."Line Type"::Heading);
      CostCenter.MODIFY(TRUE);

      LibraryCostAccounting.CreateCostCenter(CostCenter1);
      CostCenter1.VALIDATE("Line Type",CostCenter1."Line Type"::"Cost Center");
      CostCenter1.MODIFY(TRUE);

      LibraryCostAccounting.CreateCostObject(CostObject);
      CostObject.VALIDATE("Line Type",CostObject."Line Type"::"Cost Object");
      CostObject.MODIFY(TRUE);
      CostObject.RESET;

      LibraryCostAccounting.CreateCostObject(CostObject1);
      CostObject1.VALIDATE("Line Type",CostObject1."Line Type"::Heading);
      CostObject1.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCostCenter@151(VAR CostCenter@1000 : Record 1112);
    BEGIN
      CostCenter.VALIDATE("Line Type",CostCenter."Line Type"::Heading);
      CostCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCostJournalLine@160(VAR CostJournalLine@1000 : Record 1101;CostCenterCode@1001 : Code[20];CostObjectCode@1002 : Code[20]);
    BEGIN
      CostJournalLine.VALIDATE("Cost Center Code",CostCenterCode);
      CostJournalLine.VALIDATE("Cost Object Code",CostObjectCode);
      CostJournalLine.VALIDATE("Bal. Cost Center Code",CostCenterCode);
      CostJournalLine.VALIDATE("Bal. Cost Object Code",CostObjectCode);
      CostJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCostObject@172(VAR CostObject@1000 : Record 1113);
    BEGIN
      CostObject.VALIDATE("Line Type",CostObject."Line Type"::Heading);
      CostObject.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateCostRegisterClosed@77(VAR CostRegister@1000 : Record 1105;Closed@1001 : Boolean);
    BEGIN
      CostRegister.VALIDATE(Closed,Closed);
      CostRegister.MODIFY;
    END;

    LOCAL PROCEDURE ValidateCostTypeInsert@80(InvokeOnInsert@1000 : Boolean);
    VAR
      CostType@1003 : Record 1103;
      CostTypeNo@1001 : Code[20];
    BEGIN
      // Setup and Exercise
      CostTypeInsert(CostTypeNo,InvokeOnInsert);

      // Verify
      VerifyCostTypeInsert(CostTypeNo);

      IF InvokeOnInsert THEN
        VerifyCostTypeModifiedFields(CostTypeNo,TODAY,UPPERCASE(USERID))
      ELSE
        VerifyCostTypeModifiedFields(CostTypeNo,0D,'');

      // Cleanup
      CostType.GET(CostTypeNo);
      CostType.DELETE(TRUE);
    END;

    LOCAL PROCEDURE ValidateCostTypeModify@79(InvokeOnModify@1003 : Boolean);
    VAR
      CostType@1000 : Record 1103;
      ModifiedBy@1004 : Code[50];
      ModifiedDate@1005 : Date;
    BEGIN
      // Setup
      CostTypeModifySetup(CostType,ModifiedDate,ModifiedBy,InvokeOnModify);

      // Exercise
      CostType.VALIDATE("New Page",TRUE);
      CostType.MODIFY(InvokeOnModify);

      // Verify
      CostType.TESTFIELD("New Page",TRUE);

      VerifyCostTypeModifiedFields(CostType."No.",ModifiedDate,ModifiedBy);

      // Cleanup
      CostType.DELETE;
    END;

    LOCAL PROCEDURE VerifyCostTypeInsert@86(CostTypeNo@1003 : Code[20]);
    VAR
      CostType@1000 : Record 1103;
    BEGIN
      CostType.GET(CostTypeNo);

      WITH CostType DO BEGIN
        TESTFIELD("Search Name",Name);
        TESTFIELD(Type,Type::"Cost Type");
        TESTFIELD("G/L Account Range",'');
      END;
    END;

    LOCAL PROCEDURE VerifyCostTypeModifiedFields@35(CostTypeNo@1005 : Code[20];ModifiedDate@1000 : Date;ModifiedBy@1001 : Code[50]);
    VAR
      CostType@1003 : Record 1103;
    BEGIN
      CostType.GET(CostTypeNo);
      CostType.TESTFIELD("Modified Date",ModifiedDate);
      CostType.TESTFIELD("Modified By",ModifiedBy);
    END;

    LOCAL PROCEDURE VerifyCostEntry@173(GLEntryNo@1000 : Integer);
    VAR
      CostEntry@1001 : Record 1104;
    BEGIN
      CostEntry.SETRANGE("G/L Entry No.",GLEntryNo);
      Assert.IsTrue(NOT CostEntry.ISEMPTY,STRSUBSTNO(CostEntryErr,GLEntryNo));
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandlerNo@54(Message@1001 : Text[1024];VAR Reply@1000 : Boolean);
    BEGIN
      Reply := FALSE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandlerYes@39(Message@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@55(Message@1000 : Text[1024]);
    BEGIN
      // dummy message handler
    END;

    [ModalPageHandler]
    PROCEDURE RPHandlerChartOfCostCenters@44(VAR ChartOfCostCenters@1000 : TestPage 1122);
    BEGIN
      ChartOfCostCenters.FILTER.SETFILTER(Code,CostCenterFilter);
      ChartOfCostCenters.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE RPHandlerChartOfCostObjects@46(VAR ChartOfCostObjects@1000 : TestPage 1123);
    BEGIN
      ChartOfCostObjects.FILTER.SETFILTER(Code,CostObjectFilter);
      ChartOfCostObjects.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE RPHandlerCostBudgetNames@64(VAR CostBudgetNames@1000 : TestPage 1116);
    BEGIN
      CostBudgetNames.FILTER.SETFILTER(Name,CostBudgetNameFilter);
      CostBudgetNames.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE RPHandlerCostTypeList@42(VAR CostTypeList@1000 : TestPage 1124);
    BEGIN
      CostTypeList.FILTER.SETFILTER("No.",CostTypeFilter);
      CostTypeList.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE RPHandlerGLAccList@29(VAR GLAccList@1000 : TestPage 18);
    BEGIN
      GLAccList.FILTER.SETFILTER("No.",GLAccFilter);
      GLAccList.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE RPHandlerGLBudgetNames@63(VAR GLBudgetNames@1000 : TestPage 121);
    BEGIN
      GLBudgetNames.FILTER.SETFILTER(Name,GLBudgetNameFilter);
      GLBudgetNames.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE RPHandlerInvtPostingGroups@95(VAR InvtPostingGroups@1000 : TestPage 112);
    BEGIN
      InvtPostingGroups.FILTER.SETFILTER(Code,InvtPostingGroupFilter);
      InvtPostingGroups.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE RPHandlerItemList@43(VAR ItemList@1000 : TestPage 31);
    BEGIN
      ItemList.FILTER.SETFILTER("No.",ItemFilter);
      ItemList.OK.INVOKE;
    END;

    LOCAL PROCEDURE UpdateCostAccSetupAutoTransferFromGL@164(AutoTransferFromGL@1001 : Boolean);
    VAR
      CostAccountingSetup@1000 : TestPage 1113;
    BEGIN
      CostAccountingSetup.OPENEDIT;
      CostAccountingSetup."Auto Transfer from G/L".SETVALUE(AutoTransferFromGL);
      CostAccountingSetup.OK.INVOKE;
    END;

    LOCAL PROCEDURE UpdateCostAccSetupStartingDateForGLTransfer@181(StartingDateForGLTransfer@1001 : Date);
    VAR
      CostAccountingSetup@1000 : TestPage 1113;
    BEGIN
      CostAccountingSetup.OPENEDIT;
      CostAccountingSetup."Starting Date for G/L Transfer".SETVALUE(StartingDateForGLTransfer);
      CostAccountingSetup.OK.INVOKE;
    END;

    BEGIN
    {
      // [FEATURE] [Cost Accounting] [Allocation]
      TFS270016 - Tables 1103, 1104, 1105
      TFS270017 - Tables 1106, 1107, 1108
      TFS270018 - Tables 1109, 1110, 1111
      TFS270019 - Tables 1112, 1113

      -------------------------------------------------------------------------------------------------
      Test Function Name                                                                         TFS ID
      -------------------------------------------------------------------------------------------------
      TestCostCenterValidateDeleteCostCenterOnConfirmYes,                                        270019
      TestCostCenterValidateDeleteCostCenterOnConfirmNo,
      TestCostCenterValidateLineTypeConfirmationYes,
      TestCostCenterValidateLineTypeConfirmationNo,
      TestCostCenterValidateTotaling,
      TestCostObjectValidateDeleteCostCenterOnConfirmYes,
      TestCostObjectValidateDeleteCostCenterOnConfirmNo,
      TestCostObjectValidateLineTypeConfirmationYes,
      TestCostObjectValidateLineTypeConfirmationNo,
      TestCostObjectValidateTotaling.

      ---------------------------------------------------------------------------------------------------
      Test Function Name                                                                         TFS ID
      ---------------------------------------------------------------------------------------------------
      TestGLAccLinkToCostTypeWhenAlignGLAccIsPrompt,                                             286155
      TestGLAccLinkToCostTypeWhenAlignGLAccIsAutomatic.

      TransferGLEntriesToCAWithCombinedCostCenterAndCostObjectDimensions                         354616
    }
    END.
  }
}

