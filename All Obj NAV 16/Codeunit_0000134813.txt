OBJECT Codeunit 134813 ERM Cost Acc. Allocations
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,NAVIN9.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      Assert@1006 : Codeunit 130000;
      LibraryCostAccounting@1002 : Codeunit 131340;
      LibraryERM@1019 : Codeunit 131300;
      LibraryHumanResource@1011 : Codeunit 131901;
      LibraryRandom@1004 : Codeunit 130440;
      LibraryVariableStorage@1018 : Codeunit 131004;
      AllocToDateField@1013 : Date;
      AllocSourceHasCCAndCOMsg@1021 : TextConst 'ENU=You cannot define both cost center and cost object.';
      AllocTargetHasCCAndCOMsg@1022 : TextConst 'ENU=You cannot define both cost center and cost object.';
      DynAllocTargetWrongShareErr@1017 : TextConst 'ENU=The share of the dynamic Allocation Target %1 is %2 even though it was supposed to be %3.';
      LastAllocIDNotUpdatedErr@1008 : TextConst 'ENU=The Last Allocation ID field in Cost Accounting Setup did not get updated although an Allocation Source was created with the auto-assigned ID %1.';
      LastAllocIDWrongUpdateErr@1007 : TextConst 'ENU=The Last Allocation ID field in Cost Accounting Setup got updated although the custom ID %1 was used while creating an Allocation Source.';
      NoRecordsInFilterErr@1003 : TextConst 'ENU=There are no records within the filters specified for table %1. The filters are: %2.';
      ProcessedDynAllocTargetsErr@1016 : TextConst 'ENU=Number of processed dynamic Allocation Targets is %1, although there are %2 dynamic Allocation Targets.';
      RecordNotDeletedErr@1023 : TextConst 'ENU=The record no. %1 was not deleted from table %2. The filters are: %3.';
      TotalValuesNotEqualErr@1015 : TextConst 'ENU=Amount for Source * -1 <> Total Amount for Targets.';
      UnexpectedMessageErr@1020 : TextConst 'ENU=The raised message is not the expected one. The actual message is: [%1], while the expected message is: [%2].';
      UnexpectedOptionValueErr@1026 : TextConst 'ENU=The requested option %1 is not supported.';
      Filtering@1005 : 'Enabled,Disabled';
      MaxLevel@1010 : Integer;
      SelectedCostBudget@1014 : Code[10];
      Status@1028 : 'Exists,Deleted';
      TypeOfID@1027 : 'Auto Generated,Custom';
      VariantField@1012 : Code[10];
      WrongBalanceErr@1001 : TextConst 'ENU=Wrong balance for cost center %1.';

    [Test]
    PROCEDURE CalcAllocKeysSkipStaticShare@52();
    VAR
      CostAllocationTarget@1000 : Record 1107;
      CostAccountAllocation@1170000000 : Codeunit 1104;
      Actual@1001 : Integer;
      Expected@1002 : Integer;
    BEGIN
      // Setup:
      Initialize;

      CostAllocationTarget.SETFILTER(Base,'<>%1',CostAllocationTarget.Base::Static);
      IF CostAllocationTarget.ISEMPTY THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationTarget.TABLECAPTION,CostAllocationTarget.GETFILTERS));
      Expected := CostAllocationTarget.COUNT;

      // Exercise:
      Actual := CostAccountAllocation.CalcAllocationKeys;

      // Verify:
      Assert.AreEqual(Expected,Actual,STRSUBSTNO(ProcessedDynAllocTargetsErr,Actual,Expected));
    END;

    [Test]
    PROCEDURE CalcAllocKeysUpdateDynShare@13();
    VAR
      CostAllocationTarget@1000 : Record 1107;
      CostAccountAllocation@1170000000 : Codeunit 1104;
      ID@1001 : Code[10];
      LineNo@1003 : Integer;
      NewShare@1004 : Decimal;
      OldShare@1002 : Decimal;
    BEGIN
      // Setup:
      Initialize;
      CalcAllocKeysUpdateShareInit(CostAllocationTarget);

      ID := CostAllocationTarget.ID;
      LineNo := CostAllocationTarget."Line No.";
      OldShare := CostAllocationTarget.Share;
      NewShare := OldShare * LibraryRandom.RandInt(10);

      CostAllocationTarget.VALIDATE(Share,NewShare);
      CostAllocationTarget.MODIFY(TRUE);

      // Exercise:
      CLEAR(CostAllocationTarget);
      CostAllocationTarget.GET(ID,LineNo);
      CostAllocationTarget.TESTFIELD(Share,NewShare);
      CostAccountAllocation.CalcAllocationKeys;

      // Verify:
      CLEAR(CostAllocationTarget);
      CostAllocationTarget.GET(ID,LineNo);
      Assert.AreNotEqual(NewShare,CostAllocationTarget.Share,DynAllocTargetWrongShareErr);
      CostAllocationTarget.TESTFIELD(Share,OldShare);
    END;

    [Test]
    PROCEDURE AllocSrcFromCostCenToCostCen@125();
    VAR
      CostAllocationSource@1002 : Record 1106;
      CostAllocationTarget@1000 : Record 1107;
      Index@1001 : Integer;
    BEGIN
      // Setup.
      Initialize;

      // Exercise.
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");

      FOR Index := 1 TO LibraryRandom.RandInt(4) DO
        LibraryCostAccounting.CreateAllocTargetWithCCenter(
          CostAllocationTarget,CostAllocationSource,Index * 10,
          CostAllocationTarget.Base::Static,CostAllocationTarget."Allocation Target Type"::"All Costs");

      // Verify.
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);
    END;

    [Test]
    PROCEDURE AllocSrcFromCostCenToCostObj@126();
    VAR
      CostAllocationSource@1002 : Record 1106;
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup.
      Initialize;

      // Exercise.
      CreateAllocSourceAndTargets(CostAllocationSource,LibraryRandom.RandInt(10),CostAllocationTarget.Base::Static);

      // Verify.
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);
    END;

    [Test]
    PROCEDURE AllocSrcUseAsStaticAllocTarget@11();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
    BEGIN
      // Setup.
      Initialize;
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");

      // Exercise.
      LibraryCostAccounting.CreateAllocTargetWithCCenter(
        CostAllocationTarget,CostAllocationSource,LibraryRandom.RandInt(10),
        CostAllocationTarget.Base::Static,CostAllocationTarget."Allocation Target Type"::"All Costs");

      // Create another Allocation Target based on the Allocation Source.
      CLEAR(CostAllocationTarget);
      LibraryCostAccounting.CreateAllocTarget(
        CostAllocationTarget,CostAllocationSource,LibraryRandom.RandInt(10),
        CostAllocationTarget.Base::Static,CostAllocationTarget."Allocation Target Type"::"All Costs");
      CostAllocationTarget.VALIDATE("Target Cost Center",CostAllocationSource."Cost Center Code");
      CostAllocationTarget.MODIFY(TRUE);

      // Verify.
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);
    END;

    [Test]
    PROCEDURE CreateAllocSourceAutoGenID@25();
    BEGIN
      ValidateAllocSourceWithID(TypeOfID::"Auto Generated");
    END;

    [Test]
    PROCEDURE CreateAllocSourceCustomID@26();
    BEGIN
      ValidateAllocSourceWithID(TypeOfID::Custom);
    END;

    [Test]
    PROCEDURE DeleteAllocSrcNoAllocTargets@40();
    VAR
      CostAllocationSource@1000 : Record 1106;
      AllocSourceID@1001 : Code[10];
    BEGIN
      // Setup.
      Initialize;
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");
      AllocSourceID := CostAllocationSource.ID;

      // Exercise.
      DeleteAllocSource(AllocSourceID);

      // Verify.
      CheckAllocSourceStatus(AllocSourceID,Status::Deleted);
    END;

    [Test]
    PROCEDURE DeleteAllocSrcWithAllocTargets@45();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
      AllocSourceID@1002 : Code[10];
    BEGIN
      // Setup.
      Initialize;
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");
      LibraryCostAccounting.CreateAllocTargetWithCObject(
        CostAllocationTarget,CostAllocationSource,LibraryRandom.RandInt(10),
        CostAllocationTarget.Base::Static,CostAllocationTarget."Allocation Target Type"::"All Costs");
      AllocSourceID := CostAllocationSource.ID;

      // Exercise.
      DeleteAllocSource(AllocSourceID);

      // Verify.
      CheckAllocSourceStatus(AllocSourceID,Status::Deleted);
      CheckAllocTargetStatus(AllocSourceID,Status::Deleted);
    END;

    [Test]
    PROCEDURE DeleteAllocTargetOfAllocSource@41();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
      AllocSourceID@1003 : Code[10];
    BEGIN
      // Setup.
      Initialize;
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");
      LibraryCostAccounting.CreateAllocTargetWithCObject(
        CostAllocationTarget,CostAllocationSource,LibraryRandom.RandInt(10),
        CostAllocationTarget.Base::Static,CostAllocationTarget."Allocation Target Type"::"All Costs");
      AllocSourceID := CostAllocationSource.ID;

      // Exercise.
      DeleteAllocTargets(AllocSourceID);

      // Verify.
      CheckAllocSourceStatus(AllocSourceID,Status::Exists);
      CheckAllocTargetStatus(AllocSourceID,Status::Deleted);
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForLevels,ConfirmHandlerYes,MessageHandler,DeleteCostEntries)]
    PROCEDURE DeleteAllocatedCostEntries@62();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1002 : Record 1107;
      CostEntry@1005 : Record 1104;
      CostJournalBatch@1006 : Record 1102;
      CostJournalLine@1004 : Record 1101;
      CostRegister@1001 : Record 1105;
    BEGIN
      // Setup.
      Initialize;

      ClearAllocSourceLevel(MaxLevel);
      CreateAllocSourceAndTargets(CostAllocationSource,MaxLevel,CostAllocationTarget.Base::Static);

      SelectCostJournalBatch(CostJournalBatch);
      CreateCostJournalLineWithCC(CostJournalLine,CostJournalBatch,CostAllocationSource."Cost Center Code",WORKDATE);

      // Exercise.
      LibraryCostAccounting.PostCostJournalLine(CostJournalLine);
      RunCostAllocationReport;

      VerifyCostRegisterAndEntry(CostRegister);

      LibraryVariableStorage.Enqueue(CostRegister."No.");
      REPORT.RUN(REPORT::"Delete Cost Entries");

      // Verify
      CostRegister.FINDLAST;
      CostEntry.GET(CostRegister."To Cost Entry No.");
      CostEntry.TESTFIELD(Allocated,FALSE);
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForBudget,ConfirmHandlerYes,MessageHandler,DeleteCostBudgetEntries)]
    PROCEDURE DeleteAllocatedCostBudgetEntries@51();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
      CostBudgetEntry@1002 : Record 1109;
      CostBudgetName@1004 : Record 1110;
      CostBudgetRegister@1005 : Record 1111;
    BEGIN
      // Setup.
      Initialize;

      ClearAllocSourceLevel(MaxLevel);
      CreateAllocSourceAndTargets(CostAllocationSource,MaxLevel,CostAllocationTarget.Base::Static);

      CreateCostBudgetName(CostBudgetName);
      CreateCostBudgetEntry(
        CostBudgetEntry,CostBudgetName.Name,CostAllocationSource."Credit to Cost Type",CostAllocationSource."Cost Center Code");

      // Exercise.
      SelectedCostBudget := CostBudgetName.Name;
      RunCostAllocationReport;

      IF NOT CostBudgetRegister.FINDLAST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostBudgetRegister.TABLECAPTION,CostBudgetRegister.GETFILTERS));

      CostBudgetEntry.SETRANGE("Allocated with Journal No.",CostBudgetRegister."No.");
      CostBudgetEntry.FINDFIRST;
      CostBudgetEntry.TESTFIELD(Allocated,TRUE);

      LibraryVariableStorage.Enqueue(CostBudgetRegister."No.");
      REPORT.RUN(REPORT::"Delete Cost Budget Entries");

      // Verify
      CostBudgetRegister.FINDLAST;
      CostBudgetEntry.GET(CostBudgetRegister."To Cost Budget Entry No.");
      CostBudgetEntry.TESTFIELD(Allocated,FALSE);
    END;

    [Test]
    PROCEDURE DynAllocNumOfEmployeesFiltered@34();
    BEGIN
      ValidateDynAllocNumOfEmployees(Filtering::Enabled);
    END;

    [Test]
    PROCEDURE DynAllocNumOfEmployeesNoFilter@71();
    BEGIN
      ValidateDynAllocNumOfEmployees(Filtering::Disabled);
    END;

    [Test]
    PROCEDURE DynAllocTargetBaseCostBudgetEntries@69();
    VAR
      CostAllocationTarget@1000 : Record 1107;
      CostBudgetEntry@1500000 : Record 1109;
    BEGIN
      CostBudgetEntry.INIT;
      CostBudgetEntry.Date := CALCDATE('<-CY-1Y>',WORKDATE);
      CostBudgetEntry.VALIDATE(Amount,100);
      CostBudgetEntry.INSERT;
      ValidateDynAllocItems(CostAllocationTarget.Base::"Cost Budget Entries",CostAllocationTarget."Date Filter Code"::"Last Year");
    END;

    [Test]
    PROCEDURE DynAllocTargetBaseCostTypeEntries@67();
    VAR
      CostAllocationTarget@1000 : Record 1107;
      CostEntry@1500000 : Record 1104;
    BEGIN
      CostEntry.INIT;
      CostEntry."Posting Date" := CALCDATE('<-CY-1Y>',WORKDATE);
      CostEntry.VALIDATE(Amount,100);
      CostEntry.INSERT;
      ValidateDynAllocItems(CostAllocationTarget.Base::"Cost Type Entries",CostAllocationTarget."Date Filter Code"::"Last Year");
    END;

    [Test]
    PROCEDURE DynAllocTargetBaseGLBudgetEntries@66();
    VAR
      CostAllocationTarget@1000 : Record 1107;
      GLBudgetEntry@1500000 : Record 96;
    BEGIN
      GLBudgetEntry.INIT;
      GLBudgetEntry.Date := CALCDATE('<-CY-1Y>',WORKDATE);
      GLBudgetEntry.VALIDATE(Amount,100);
      GLBudgetEntry.INSERT;
      ValidateDynAllocItems(CostAllocationTarget.Base::"G/L Budget Entries",CostAllocationTarget."Date Filter Code"::"Last Year");
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE DynAllocTargetBaseGLEntries@16();
    VAR
      GLAccount@1000 : Record 15;
      CostAllocationSource@1001 : Record 1106;
      CostAllocationTarget@1002 : Record 1107;
      CostAccountAllocation@1005 : Codeunit 1104;
      Amount@1003 : Decimal;
      LineNo@1004 : Integer;
    BEGIN
      // Setup:
      Initialize;
      Amount := LibraryRandom.RandInt(1000);

      CreateAndPostGenJournalLine(GLAccount,Amount);
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");
      CreateDynAllocTargetGLEntries(CostAllocationTarget,CostAllocationSource,GLAccount."No.");
      LineNo := CostAllocationTarget."Line No.";

      // Exercise.
      CostAccountAllocation.CalcAllocationKey(CostAllocationSource);

      // Verify.
      CLEAR(CostAllocationTarget);
      CostAllocationTarget.GET(CostAllocationSource.ID,LineNo);
      CostAllocationTarget.TESTFIELD(Share,Amount);
    END;

    [Test]
    PROCEDURE DynAllocTargetBaseItemsPurchAmount@78();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      ValidateDynAllocItems(
        CostAllocationTarget.Base::"Items Purchased (Amount)",CostAllocationTarget."Date Filter Code"::"Last Year");
    END;

    [Test]
    PROCEDURE DynAllocTargetBaseItemsPurchQty@75();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      ValidateDynAllocItems(CostAllocationTarget.Base::"Items Purchased (Qty.)",CostAllocationTarget."Date Filter Code"::"Last Year");
    END;

    [Test]
    PROCEDURE DynAllocTargetBaseItemsSoldAmount@77();
    VAR
      CostAllocationTarget@1002 : Record 1107;
    BEGIN
      ValidateDynAllocItems(CostAllocationTarget.Base::"Items Sold (Amount)",CostAllocationTarget."Date Filter Code"::"Last Year");
    END;

    [Test]
    PROCEDURE DynAllocTargetBaseItemsSoldQty@73();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      ValidateDynAllocItems(CostAllocationTarget.Base::"Items Sold (Qty.)",CostAllocationTarget."Date Filter Code"::"Last Year");
    END;

    [Test]
    PROCEDURE DynAllocTargetDateFilterLastMonth@56();
    VAR
      CostAllocationTarget@1002 : Record 1107;
    BEGIN
      ValidateDynAllocItems(CostAllocationTarget.Base::"Items Sold (Amount)",CostAllocationTarget."Date Filter Code"::"Last Month");
    END;

    [Test]
    PROCEDURE DynAllocTargetDateFilterLastPeriod@61();
    VAR
      CostAllocationTarget@1002 : Record 1107;
    BEGIN
      ValidateDynAllocItems(CostAllocationTarget.Base::"Items Sold (Amount)",CostAllocationTarget."Date Filter Code"::"Last Period");
    END;

    [Test]
    PROCEDURE DynAllocTargetDateFilterPeriod@60();
    VAR
      CostAllocationTarget@1002 : Record 1107;
    BEGIN
      ValidateDynAllocItems(CostAllocationTarget.Base::"Items Sold (Amount)",CostAllocationTarget."Date Filter Code"::Period);
    END;

    [Test]
    PROCEDURE DynAllocTargetDateFilterWeek@54();
    VAR
      CostAllocationTarget@1002 : Record 1107;
    BEGIN
      ValidateDynAllocItems(CostAllocationTarget.Base::"Items Sold (Amount)",CostAllocationTarget."Date Filter Code"::Week);
    END;

    [Test]
    PROCEDURE DynAllocTargetDateFilterYear@59();
    VAR
      CostAllocationTarget@1002 : Record 1107;
    BEGIN
      ValidateDynAllocItems(CostAllocationTarget.Base::"Items Sold (Amount)",CostAllocationTarget."Date Filter Code"::Year);
    END;

    [Test]
    PROCEDURE ErrorIfAllocSourceHasCCAndCO@6();
    VAR
      CostAllocationSource@1000 : Record 1106;
    BEGIN
      // Setup.
      Initialize;

      // Exercise.
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");

      // Verify.
      ASSERTERROR LibraryCostAccounting.UpdateAllocSourceWithCObject(CostAllocationSource);
      Assert.IsTrue(STRPOS(AllocSourceHasCCAndCOMsg,GETLASTERRORTEXT) > 0,
        STRSUBSTNO(UnexpectedMessageErr,GETLASTERRORTEXT,AllocSourceHasCCAndCOMsg));
      CLEARLASTERROR;
    END;

    [Test]
    PROCEDURE ErrorIfAllocTargetHasCCAndCO@28();
    VAR
      CostAllocationSource@1001 : Record 1106;
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup.
      Initialize;

      // Exercise.
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");
      LibraryCostAccounting.CreateAllocTargetWithCCenter(
        CostAllocationTarget,CostAllocationSource,LibraryRandom.RandInt(10),
        CostAllocationTarget.Base::Static,CostAllocationTarget."Allocation Target Type"::"All Costs");

      // Verify.
      ASSERTERROR LibraryCostAccounting.UpdateAllocTargetWithCObject(CostAllocationTarget);
      Assert.IsTrue(STRPOS(AllocTargetHasCCAndCOMsg,GETLASTERRORTEXT) > 0,
        STRSUBSTNO(UnexpectedMessageErr,GETLASTERRORTEXT,AllocTargetHasCCAndCOMsg));
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForBudget,ConfirmHandlerYes,MessageHandler)]
    PROCEDURE RunAllocateCostsForBudget@29();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
      CostBudgetEntry@1002 : Record 1109;
      CostBudgetName@1004 : Record 1110;
      CostBudgetRegister@1005 : Record 1111;
      TotalAmount@1003 : Decimal;
    BEGIN
      // Setup.
      Initialize;

      ClearAllocSourceLevel(MaxLevel);
      CreateAllocSourceAndTargets(CostAllocationSource,MaxLevel,CostAllocationTarget.Base::Static);

      CreateCostBudgetName(CostBudgetName);
      CreateCostBudgetEntry(
        CostBudgetEntry,CostBudgetName.Name,CostAllocationSource."Credit to Cost Type",CostAllocationSource."Cost Center Code");

      // Exercise.
      SelectedCostBudget := CostBudgetName.Name;
      RunCostAllocationReport;

      // Verify.
      CLEAR(CostAllocationSource);
      GetAllocSources(CostAllocationSource,MaxLevel);
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);

      IF NOT CostBudgetRegister.FINDLAST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostBudgetRegister.TABLECAPTION,CostBudgetRegister.GETFILTERS));

      CLEAR(CostBudgetEntry);
      TotalAmount :=
        GetTotalAmountOfSrcEntry(
          DATABASE::"Cost Budget Entry",CostBudgetEntry.FIELDNO("Entry No."),
          CostBudgetRegister."To Cost Budget Entry No.",CostBudgetEntry.FIELDNO(Amount));

      CheckAllocationCostEntries(
        CostAllocationSource.ID,TotalAmount,DATABASE::"Cost Budget Entry",CostBudgetEntry.FIELDNO("Entry No."),
        CostBudgetEntry.FIELDNO(Amount),CostBudgetRegister."From Cost Budget Entry No.",CostBudgetRegister."To Cost Budget Entry No.");
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForDateRange,ConfirmHandlerYes,MessageHandler)]
    PROCEDURE RunAllocateCostsForDateRange@14();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1002 : Record 1107;
      CostEntry@1003 : Record 1104;
      CostJournalBatch@1005 : Record 1102;
      CostJournalLine@1004 : Record 1101;
      CostRegister@1007 : Record 1105;
      AllocToDate@1001 : Date;
      TotalAmount@1006 : Decimal;
    BEGIN
      // Setup.
      Initialize;
      AllocToDate := CALCDATE('<-1D>',WORKDATE);

      ClearAllocSourceLevel(MaxLevel);
      CreateAllocSourceAndTargets(CostAllocationSource,MaxLevel,CostAllocationTarget.Base::Static);
      CreateMultipleCostJournalLines(CostJournalBatch,CostAllocationSource."Cost Center Code");

      // Exercise.
      GetCostJournalLineEntries(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);
      LibraryCostAccounting.PostCostJournalLine(CostJournalLine);
      AllocToDateField := AllocToDate;
      RunCostAllocationReport;

      // Verify.
      CLEAR(CostAllocationSource);
      GetAllocSources(CostAllocationSource,MaxLevel);
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);

      IF NOT CostRegister.FINDLAST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostRegister.TABLECAPTION,CostRegister.GETFILTERS));

      TotalAmount :=
        GetTotalAmountOfSrcCostEntries(
          CostRegister."From Cost Entry No.",CostRegister."To Cost Entry No.",AllocToDate,CostAllocationSource."Cost Center Code");

      CheckAllocationCostEntries(
        CostAllocationSource.ID,TotalAmount,DATABASE::"Cost Entry",CostEntry.FIELDNO("Entry No."),
        CostEntry.FIELDNO(Amount),CostRegister."From Cost Entry No.",CostRegister."To Cost Entry No.");
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForLevels,ConfirmHandlerYes,MessageHandler)]
    PROCEDURE RunAllocateCostsForLevels@1();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1002 : Record 1107;
      CostEntry@1005 : Record 1104;
      CostJournalBatch@1006 : Record 1102;
      CostJournalLine@1004 : Record 1101;
      CostRegister@1001 : Record 1105;
      TotalAmount@1003 : Decimal;
    BEGIN
      // Setup.
      Initialize;

      ClearAllocSourceLevel(MaxLevel);
      CreateAllocSourceAndTargets(CostAllocationSource,MaxLevel,CostAllocationTarget.Base::Static);

      SelectCostJournalBatch(CostJournalBatch);
      CreateCostJournalLineWithCC(CostJournalLine,CostJournalBatch,CostAllocationSource."Cost Center Code",WORKDATE);

      // Exercise.
      LibraryCostAccounting.PostCostJournalLine(CostJournalLine);
      RunCostAllocationReport;

      // Verify.
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);

      IF NOT CostRegister.FINDLAST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostRegister.TABLECAPTION,CostRegister.GETFILTERS));

      TotalAmount :=
        GetTotalAmountOfSrcEntry(
          DATABASE::"Cost Entry",CostEntry.FIELDNO("Entry No."),
          CostRegister."To Cost Entry No.",CostEntry.FIELDNO(Amount));

      CheckAllocationCostEntries(
        CostAllocationSource.ID,TotalAmount,DATABASE::"Cost Entry",CostEntry.FIELDNO("Entry No."),
        CostEntry.FIELDNO(Amount),CostRegister."From Cost Entry No.",CostRegister."To Cost Entry No.");
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForVariant,ConfirmHandlerYes,MessageHandler)]
    PROCEDURE RunAllocateCostsForVariant@24();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1005 : Record 1107;
      CostJournalBatch@1004 : Record 1102;
      CostJournalLine@1001 : Record 1101;
      Variant@1002 : Code[10];
    BEGIN
      // Setup.
      Initialize;
      Variant := FORMAT(CostAllocationSource.COUNT);

      ClearAllocSourceLevel(MaxLevel);
      CreateAllocSourcesWithVariant(MaxLevel,Variant);
      CreateAllocSourceAndTargets(CostAllocationSource,MaxLevel,CostAllocationTarget.Base::Static);

      SelectCostJournalBatch(CostJournalBatch);
      CreateCostJnlLinePerAllocSrc(CostJournalBatch,MaxLevel);

      // Exercise.
      GetCostJournalLineEntries(CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name);
      LibraryCostAccounting.PostCostJournalLine(CostJournalLine);
      VariantField := Variant;
      RunCostAllocationReport;

      // Verify.
      CLEAR(CostAllocationSource);
      GetAllocSources(CostAllocationSource,MaxLevel);
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);
      CheckVariantAllocCostEntries(MaxLevel,Variant);
    END;

    [Test]
    PROCEDURE StaticAllocTargetAmountPercent@5();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      ValidateStaticAllocTarget(CostAllocationTarget."Allocation Target Type"::"Amount per Share");
    END;

    [Test]
    PROCEDURE StaticAllocTargetBaseAndWeight@9();
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
      Index@1002 : Integer;
    BEGIN
      // Setup.
      Initialize;
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");

      FOR Index := 1 TO LibraryRandom.RandInt(4) DO BEGIN
        LibraryCostAccounting.CreateAllocTargetWithCCenter(
          CostAllocationTarget,CostAllocationSource,0,
          CostAllocationTarget.Base::Static,CostAllocationTarget."Allocation Target Type"::"All Costs");
        CLEAR(CostAllocationTarget);
      END;

      // Exercise.
      GetAllocTargets(CostAllocationTarget,CostAllocationSource.ID);
      REPEAT
        CostAllocationTarget.VALIDATE("Static Base",LibraryRandom.RandInt(10));
        CostAllocationTarget.VALIDATE("Static Weighting",LibraryRandom.RandInt(10));
        CostAllocationTarget.MODIFY(TRUE);
      UNTIL CostAllocationTarget.NEXT = 0;

      // Verify.
      CLEAR(CostAllocationTarget);
      GetAllocTargets(CostAllocationTarget,CostAllocationSource.ID);

      REPEAT
        CostAllocationTarget.TESTFIELD(Share,CostAllocationTarget."Static Base" * CostAllocationTarget."Static Weighting");
      UNTIL CostAllocationTarget.NEXT = 0;
    END;

    [Test]
    PROCEDURE StaticAllocTargetPercentValue@7();
    VAR
      CostAllocationSource@1002 : Record 1106;
      CostAllocationTarget@1001 : Record 1107;
    BEGIN
      // Setup.
      Initialize;

      // Exercise.
      CreateAllocSourceAndTargets(CostAllocationSource,LibraryRandom.RandInt(10),CostAllocationTarget.Base::Static);

      // Verify.
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);
    END;

    [Test]
    PROCEDURE StaticAllocTargetSharePercent@4();
    VAR
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      ValidateStaticAllocTarget(CostAllocationTarget."Allocation Target Type"::"Percent per Share");
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForLevels,ConfirmHandlerYes,MessageHandler)]
    PROCEDURE CostAllocationWithSingleLevel@64();
    BEGIN
      // Verify that system does not throw error while running the report Cost Allocation with Single level when Cost entry, Cost budget entries are empty.
      Initialize;
      MaxLevel := 1;
      RunCostAllocationReportForLevels;
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForMultipleLevels,ConfirmHandlerYes,MessageHandler)]
    PROCEDURE CostAllocationWithMultipleLevel@70();
    BEGIN
      // Verify that system does not throw error while running the report Cost Allocation with multiple level when Cost entry, Cost budget entries are empty.
      Initialize;
      RunCostAllocationReportForLevels;
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForBudget,ConfirmHandlerYes,MessageHandler)]
    PROCEDURE CostAllocationWithBudgetName@84();
    VAR
      CostBudgetEntry@1001 : Record 1109;
      CostBudgetName@1003 : Record 1110;
      CostBudgetRegister@1004 : Record 1111;
    BEGIN
      // Verify that system does not throw error while running the report Cost Allocation With Budget Name when Cost entry, Cost budget entries are empty.

      // Setup:  Delete the Cost Entry, Cost Register and Cost budget Entry Table and create a new cost budget.
      Initialize;
      DeleteEntryAndRegisterOfCostAcc;
      LibraryCostAccounting.CreateCostBudgetName(CostBudgetName);
      SelectedCostBudget := CostBudgetName.Name;
      MaxLevel := 1;

      // Exercise: Run the report Cost Allocation.
      RunCostAllocationReport;

      // Verify: Verify that no error comes up and also verifies that Cost register and Cost allocation entries gets created.
      IF NOT CostBudgetRegister.FINDLAST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostBudgetRegister.TABLECAPTION,CostBudgetRegister.GETFILTERS));

      CostBudgetEntry.SETRANGE(
        "Entry No.",CostBudgetRegister."From Cost Budget Entry No.",CostBudgetRegister."To Cost Budget Entry No.");
      IF CostBudgetEntry.ISEMPTY THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostBudgetEntry.TABLECAPTION,CostBudgetEntry.GETFILTERS));
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForBudget,ConfirmHandlerYes,MessageHandler)]
    PROCEDURE CostAllocationWithoutBudgetName@104();
    VAR
      CostBudgetRegister@1004 : Record 1111;
    BEGIN
      // Verify that system does not throw error while running the report Cost Allocation Without Budget Name when Cost entry, Cost budget entries are empty.

      // Setup:  Delete the Cost Entry, Cost Register and Cost budget Entry Table.
      Initialize;
      DeleteEntryAndRegisterOfCostAcc;
      MaxLevel := 1;

      // Exercise: Run the report Cost Allocation.
      RunCostAllocationReport;

      // Verify: Verify that no error comes up and verify that Cost budget register is empty.
      IF CostBudgetRegister.FINDLAST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostBudgetRegister.TABLECAPTION,CostBudgetRegister.GETFILTERS));
    END;

    [Test]
    [HandlerFunctions(AllocateCostsForVariant,ConfirmHandlerYes,MessageHandler)]
    PROCEDURE TestAllocationWithRoundings@94();
    VAR
      CostAllocationSource@1003 : Record 1106;
      CostAllocationTarget@1002 : Record 1107;
      Index@1001 : Integer;
      TotalShare@1000 : Decimal;
      CurrentShare@1004 : Decimal;
    BEGIN
      // Run allocations from Cost Center to Cost Center with multiple Cost Allocation Targets with roundings.

      // Setup.
      Initialize;

      // Exercise.
      CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::Custom);

      TotalShare := 100; // Value needed for test
      FOR Index := 1 TO LibraryRandom.RandIntInRange(20,40) DO BEGIN
        CurrentShare := 1.555; // Value needed for test
        CreateAllocTargetWithCCenter(CostAllocationSource,CostAllocationTarget,CurrentShare);
        TotalShare -= CurrentShare;
      END;
      CreateAllocTargetWithCCenter(CostAllocationSource,CostAllocationTarget,TotalShare);
      COMMIT;
      MaxLevel := CostAllocationSource.Level;
      REPORT.RUN(REPORT::"Cost Allocation");

      // Verify.
      VerifyCostCenterBalance(CostAllocationSource."Cost Center Code",0);
    END;

    LOCAL PROCEDURE Initialize@8();
    BEGIN
      LibraryVariableStorage.Clear;
      ResetGlobalVariables;
      LibraryCostAccounting.InitializeCASetup;
    END;

    LOCAL PROCEDURE CreateAllocSourceWithCCenter@80(VAR CostAllocationSource@1001 : Record 1106;TypeOfID@1000 : 'Auto Generated,Custom');
    VAR
      CostCenter@1003 : Record 1112;
      CostJournalBatch@1002 : Record 1102;
      CostJournalLine@1004 : Record 1101;
    BEGIN
      LibraryCostAccounting.CreateAllocSource(CostAllocationSource,TypeOfID::Custom);
      LibraryCostAccounting.CreateCostCenter(CostCenter);
      CostAllocationSource.VALIDATE("Cost Center Code",CostCenter.Code);
      CostAllocationSource.MODIFY(TRUE);
      WITH CostAllocationSource DO BEGIN
        VariantField := FORMAT(COUNT);
        VALIDATE(Variant,VariantField);
        MODIFY(TRUE);
      END;

      SelectCostJournalBatch(CostJournalBatch);
      CreateCostJournalLineWithCC(
        CostJournalLine,CostJournalBatch,CostAllocationSource."Cost Center Code",CALCDATE('<-12M>',WORKDATE));
      CostJournalLine.VALIDATE(Amount,LibraryRandom.RandIntInRange(10,100));
      CostJournalLine.MODIFY(TRUE);
      LibraryCostAccounting.PostCostJournalLine(CostJournalLine);
    END;

    LOCAL PROCEDURE CreateAllocTargetWithCCenter@95(CostAllocationSource@1001 : Record 1106;VAR CostAllocationTarget@1002 : Record 1107;Share@1000 : Decimal);
    VAR
      CostCenter@1003 : Record 1112;
    BEGIN
      LibraryCostAccounting.CreateAllocTarget(
        CostAllocationTarget,CostAllocationSource,Share,CostAllocationTarget.Base::Static,
        CostAllocationTarget."Allocation Target Type"::"All Costs");
      LibraryCostAccounting.CreateCostCenter(CostCenter);
      CostAllocationTarget.VALIDATE("Target Cost Center",CostCenter.Code);
      CostAllocationTarget.MODIFY(TRUE);
    END;

    [RequestPageHandler]
    PROCEDURE AllocateCostsForBudget@33(VAR CostAllocation@1000 : TestRequestPage 1131);
    BEGIN
      LibraryCostAccounting.AllocateCostsFromTo(CostAllocation,MaxLevel,MaxLevel,WORKDATE,'',SelectedCostBudget);
      CostAllocation.OK.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE AllocateCostsForDateRange@21(VAR CostAllocation@1000 : TestRequestPage 1131);
    BEGIN
      LibraryCostAccounting.AllocateCostsFromTo(CostAllocation,MaxLevel,MaxLevel,AllocToDateField,'','');
      CostAllocation.OK.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE AllocateCostsForLevels@10(VAR CostAllocation@1000 : TestRequestPage 1131);
    BEGIN
      LibraryCostAccounting.AllocateCostsFromTo(CostAllocation,MaxLevel,MaxLevel,WORKDATE,'','');
      CostAllocation.OK.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE AllocateCostsForVariant@35(VAR CostAllocation@1000 : TestRequestPage 1131);
    BEGIN
      LibraryCostAccounting.AllocateCostsFromTo(CostAllocation,MaxLevel,MaxLevel,WORKDATE,VariantField,'');
      CostAllocation.OK.INVOKE;
    END;

    LOCAL PROCEDURE CalcAllocKeysUpdateShareInit@53(VAR CostAllocationTarget@1000 : Record 1107);
    VAR
      CostAllocationSource@1001 : Record 1106;
      CostAccountAllocation@1002 : Codeunit 1104;
    BEGIN
      CreateDynAllocTargetEmployees(CostAllocationSource,Filtering::Enabled);
      CostAccountAllocation.CalcAllocationKey(CostAllocationSource);

      GetAllocTargets(CostAllocationTarget,CostAllocationSource.ID);
      CostAllocationTarget.SETFILTER(Share,'>%1',0);
      CostAllocationTarget.SETFILTER(Base,'<>%1',CostAllocationTarget.Base::Static);
      IF NOT CostAllocationTarget.FINDFIRST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationTarget.TABLECAPTION,CostAllocationTarget.GETFILTERS));
    END;

    LOCAL PROCEDURE CheckAllocationCostEntries@22(AllocSourceID@1000 : Code[10];TotalAmount@1009 : Decimal;TableNumber@1008 : Integer;KeyFieldNumber@1007 : Integer;AmountFieldNumber@1006 : Integer;FromEntryNo@1002 : Integer;ToEntryNo@1001 : Integer);
    VAR
      CostAllocationTarget@1004 : Record 1107;
      TotalDebitValue@1005 : Decimal;
    BEGIN
      GetAllocTargets(CostAllocationTarget,AllocSourceID);

      TotalDebitValue :=
        LibraryCostAccounting.GetAllocTargetEntryAmount(
          CostAllocationTarget,TotalAmount,TableNumber,KeyFieldNumber,AmountFieldNumber,FromEntryNo,ToEntryNo);

      Assert.AreEqual(-TotalAmount,TotalDebitValue,TotalValuesNotEqualErr);
    END;

    LOCAL PROCEDURE CheckAllocSourceStatus@49(AllocSourceID@1002 : Code[10];Status@1000 : 'Exists,Deleted');
    VAR
      CostAllocationSource@1001 : Record 1106;
    BEGIN
      CASE Status OF
        Status::Exists:
          IF NOT CostAllocationSource.GET(AllocSourceID) THEN
            ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationSource.TABLECAPTION,CostAllocationSource.GETFILTERS));
        Status::Deleted:
          IF CostAllocationSource.GET(AllocSourceID) THEN
            ERROR(STRSUBSTNO(RecordNotDeletedErr,AllocSourceID,CostAllocationSource.TABLECAPTION,CostAllocationSource.GETFILTERS));
        ELSE
          ERROR(STRSUBSTNO(UnexpectedOptionValueErr,FORMAT(Status)));
      END;
    END;

    LOCAL PROCEDURE CheckAllocTargetStatus@48(AllocSourceID@1002 : Code[10];Status@1000 : 'Exists,Deleted');
    VAR
      CostAllocationTarget@1001 : Record 1107;
    BEGIN
      CASE Status OF
        Status::Exists:
          BEGIN
            CostAllocationTarget.SETFILTER(ID,AllocSourceID);
            IF CostAllocationTarget.ISEMPTY THEN
              ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationTarget.TABLECAPTION,CostAllocationTarget.GETFILTERS));
          END;
        Status::Deleted:
          BEGIN
            CostAllocationTarget.SETFILTER(ID,AllocSourceID);
            IF NOT CostAllocationTarget.ISEMPTY THEN
              ERROR(STRSUBSTNO(RecordNotDeletedErr,AllocSourceID,CostAllocationTarget.TABLECAPTION,CostAllocationTarget.GETFILTERS));
          END;
        ELSE
          ERROR(STRSUBSTNO(UnexpectedOptionValueErr,FORMAT(Status)));
      END;
    END;

    LOCAL PROCEDURE CheckVariantAllocCostEntries@12(Level@1002 : Integer;Variant@1004 : Code[10]);
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostEntry@1003 : Record 1104;
      CostRegister@1001 : Record 1105;
    BEGIN
      CostAllocationSource.SETFILTER(Level,'%1',Level);
      CostAllocationSource.SETFILTER(Variant,'%1',Variant);
      IF NOT CostAllocationSource.FINDFIRST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationSource.TABLECAPTION,CostAllocationSource.GETFILTERS));

      IF NOT CostRegister.FINDLAST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostRegister.TABLECAPTION,CostRegister.GETFILTERS));

      CostEntry.SETRANGE("Entry No.",CostRegister."From Cost Entry No.",CostRegister."To Cost Entry No.");
      CostEntry.SETFILTER("Cost Center Code",'%1',CostAllocationSource."Cost Center Code");
      CostEntry.SETFILTER("Allocation ID",'%1',CostAllocationSource.ID);
      IF CostEntry.ISEMPTY THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostEntry.TABLECAPTION,CostEntry.GETFILTERS));
    END;

    LOCAL PROCEDURE ClearAllocSourceLevel@3(Level@1001 : Integer);
    VAR
      CostAllocationSource@1000 : Record 1106;
    BEGIN
      CostAllocationSource.SETFILTER(Level,'%1',Level);
      CostAllocationSource.MODIFYALL(Level,Level - 1,TRUE);
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandlerYes@37(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    LOCAL PROCEDURE CreateAllocSourceAndTargets@38(VAR CostAllocationSource@1000 : Record 1106;Level@1003 : Integer;Base@1004 : Option);
    VAR
      CostAllocationTarget@1001 : Record 1107;
      Index@1002 : Integer;
    BEGIN
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");
      CostAllocationSource.VALIDATE(Level,Level);
      CostAllocationSource.MODIFY(TRUE);

      FOR Index := 1 TO LibraryRandom.RandInt(4) DO BEGIN
        CLEAR(CostAllocationTarget);
        LibraryCostAccounting.CreateAllocTargetWithCObject(
          CostAllocationTarget,CostAllocationSource,Index * 10,Base,CostAllocationTarget."Allocation Target Type"::"All Costs");
      END;
    END;

    LOCAL PROCEDURE CreateAllocSourcesWithVariant@18(Level@1000 : Integer;Variant@1002 : Code[10]);
    VAR
      CostAllocationSource@1001 : Record 1106;
    BEGIN
      CreateMultipleAllocSources(CostAllocationSource,Level);
      CostAllocationSource.MODIFYALL(Variant,Variant,TRUE);
    END;

    LOCAL PROCEDURE CreateAndPostGenJournalLine@63(VAR GLAccount@1003 : Record 15;Amount@1000 : Decimal);
    VAR
      GenJournalBatch@1002 : Record 232;
      GenJournalLine@1001 : Record 81;
    BEGIN
      LibraryCostAccounting.CreateIncomeStmtGLAccount(GLAccount);
      LibraryERM.SelectGenJnlBatch(GenJournalBatch);
      LibraryERM.ClearGenJournalLines(GenJournalBatch);
      LibraryERM.CreateGeneralJnlLine(GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,
        GenJournalLine."Document Type"::Payment,GenJournalLine."Account Type"::"G/L Account",GLAccount."No.",Amount);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
    END;

    LOCAL PROCEDURE CreateCostBudgetEntry@46(VAR CostBudgetEntry@1002 : Record 1109;CostBudgetName@1003 : Code[10];CostTypeNo@1000 : Code[20];CostCenterCode@1001 : Code[20]);
    BEGIN
      CostBudgetEntry.INIT;
      CostBudgetEntry.VALIDATE(Date,WORKDATE);
      CostBudgetEntry.VALIDATE("Budget Name",CostBudgetName);
      CostBudgetEntry.VALIDATE("Cost Type No.",CostTypeNo);
      CostBudgetEntry.VALIDATE("Cost Center Code",CostCenterCode);
      CostBudgetEntry.VALIDATE(Amount,LibraryRandom.RandDec(100,2));
      CostBudgetEntry.INSERT(TRUE);
    END;

    LOCAL PROCEDURE CreateCostBudgetName@57(VAR CostBudgetName@1000 : Record 1110);
    VAR
      LibraryUtility@1001 : Codeunit 131000;
    BEGIN
      CostBudgetName.INIT;
      CostBudgetName.VALIDATE(
        Name,LibraryUtility.GenerateRandomCode(CostBudgetName.FIELDNO(Description),DATABASE::"Cost Budget Name"));
      CostBudgetName.VALIDATE(Description,CostBudgetName.Name);
      CostBudgetName.INSERT(TRUE);
    END;

    LOCAL PROCEDURE CreateCostJnlLinePerAllocSrc@30(VAR CostJournalBatch@1004 : Record 1102;Level@1000 : Integer);
    VAR
      CostAllocationSource@1001 : Record 1106;
      CostJournalLine@1003 : Record 1101;
    BEGIN
      CostAllocationSource.SETFILTER(Level,'%1',Level);
      IF NOT CostAllocationSource.FINDSET THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationSource.TABLECAPTION,CostAllocationSource.GETFILTERS));

      REPEAT
        CreateCostJournalLineWithCC(CostJournalLine,CostJournalBatch,CostAllocationSource."Cost Center Code",WORKDATE);
        CLEAR(CostJournalLine);
      UNTIL CostAllocationSource.NEXT = 0;
    END;

    LOCAL PROCEDURE CreateCostJournalLineWithCC@36(VAR CostJournalLine@1000 : Record 1101;CostJournalBatch@1006 : Record 1102;CostCenterCode@1001 : Code[20];PostingDate@1005 : Date);
    VAR
      CostType@1002 : Record 1103;
      BalCostType@1004 : Record 1103;
    BEGIN
      LibraryCostAccounting.FindCostTypeWithCostCenter(CostType);
      FindCostTypeWithCostCenter(BalCostType,CostCenterCode);
      LibraryCostAccounting.CreateCostJournalLineBasic(
        CostJournalLine,CostJournalBatch."Journal Template Name",CostJournalBatch.Name,PostingDate,CostType."No.",BalCostType."No.");

      CostJournalLine.VALIDATE("Cost Center Code",CostCenterCode);
      CostJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateDynAllocTargetEmployees@20(VAR CostAllocationSource@1005 : Record 1106;UseFilters@1000 : Option);
    VAR
      CostAllocationTarget@1004 : Record 1107;
      CostObject@1003 : Record 1113;
      Employee@1002 : Record 5200;
      Index@1001 : Integer;
    BEGIN
      CreateAllocSourceAndTargets(CostAllocationSource,LibraryRandom.RandInt(10),CostAllocationTarget.Base::"No of Employees");

      IF UseFilters = Filtering::Enabled THEN BEGIN
        LibraryCostAccounting.CreateCostObject(CostObject);

        FOR Index := 1 TO LibraryRandom.RandInt(4) DO BEGIN
          CLEAR(Employee);
          LibraryHumanResource.CreateEmployee(Employee);
          Employee.VALIDATE("Cost Object Code",CostObject.Code);
          Employee.MODIFY(TRUE);
        END;

        GetAllocTargets(CostAllocationTarget,CostAllocationSource.ID);
        CostAllocationTarget.MODIFYALL("Cost Object Filter",CostObject.Code,TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateDynAllocTargetGLEntries@65(VAR CostAllocationTarget@1001 : Record 1107;CostAllocationSource@1003 : Record 1106;GLAccountNo@1002 : Code[20]);
    BEGIN
      LibraryCostAccounting.CreateAllocTargetWithCObject(
        CostAllocationTarget,CostAllocationSource,LibraryRandom.RandInt(10),
        CostAllocationTarget.Base::"G/L Entries",CostAllocationTarget."Allocation Target Type"::"All Costs");

      CostAllocationTarget.VALIDATE("No. Filter",GLAccountNo);
      CostAllocationTarget.VALIDATE("Date Filter Code",CostAllocationTarget."Date Filter Code"::Month);
      CostAllocationTarget.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateMultipleAllocSources@39(VAR CostAllocationSource@1003 : Record 1106;Level@1002 : Integer);
    VAR
      CostAllocationTarget@1001 : Record 1107;
      Index@1000 : Integer;
    BEGIN
      FOR Index := 1 TO LibraryRandom.RandInt(3) DO BEGIN
        CLEAR(CostAllocationSource);
        CreateAllocSourceAndTargets(CostAllocationSource,Level,CostAllocationTarget.Base::Static);
      END;

      CLEAR(CostAllocationSource);
      CostAllocationSource.SETFILTER(Level,'%1',Level);
      IF NOT CostAllocationSource.FINDSET THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationSource.TABLECAPTION,CostAllocationSource.GETFILTERS));
    END;

    LOCAL PROCEDURE CreateMultipleCostJournalLines@15(VAR CostJournalBatch@1001 : Record 1102;CostCenterCode@1004 : Code[20]);
    VAR
      CostJournalLine@1003 : Record 1101;
      Index@1002 : Integer;
    BEGIN
      SelectCostJournalBatch(CostJournalBatch);

      FOR Index := LibraryRandom.RandInt(4) DOWNTO 1 DO BEGIN
        CLEAR(CostJournalLine);
        CreateCostJournalLineWithCC(CostJournalLine,CostJournalBatch,CostCenterCode,CALCDATE('<-' + FORMAT(Index) + 'D>',WORKDATE));
      END;

      CreateCostJournalLineWithCC(CostJournalLine,CostJournalBatch,CostCenterCode,WORKDATE);
    END;

    LOCAL PROCEDURE CreateValueEntry@76(BaseInput@1000 : Option;DateFilterCode@1001 : Option);
    VAR
      CostAllocTarget@1002 : Record 1107;
      ValueEntry@1003 : Record 5802;
      StartDate@1004 : Date;
      EndDate@1005 : Date;
    BEGIN
      // Create Value Entry for the specified period in the case of absence in the local Demo Data
      // to avoid division by zero error in test

      WITH CostAllocTarget DO BEGIN
        Base := BaseInput;
        "Date Filter Code" := DateFilterCode;
        IF NOT (CostAllocTargetBaseSales(CostAllocTarget) OR CostAllocTargetBasePurchase(CostAllocTarget)) THEN
          EXIT;
        CASE "Date Filter Code" OF
          "Date Filter Code"::"Last Month","Date Filter Code"::"Last Period":
            BEGIN
              StartDate := CALCDATE('<-CM-1M>',WORKDATE);
              EndDate := CALCDATE('<CM>',StartDate);
            END;
          "Date Filter Code"::Period,"Date Filter Code"::Week:
            BEGIN
              StartDate := CALCDATE('<-CW>',WORKDATE);
              EndDate := CALCDATE('<CW>',WORKDATE);
            END;
          "Date Filter Code"::"Last Year","Date Filter Code"::"Last Fiscal Year":
            BEGIN
              StartDate := CALCDATE('<-CY-1Y>',WORKDATE);
              EndDate := CALCDATE('<CY>',StartDate);
            END;
          ELSE
            EXIT;
        END;
      END;

      WITH ValueEntry DO BEGIN
        IF CostAllocTargetBaseSales(CostAllocTarget) THEN
          SETRANGE("Item Ledger Entry Type","Item Ledger Entry Type"::Sale)
        ELSE
          SETRANGE("Item Ledger Entry Type","Item Ledger Entry Type"::Purchase);

        SETRANGE("Posting Date",StartDate,EndDate);
        IF ISEMPTY THEN BEGIN
          RESET;
          FINDLAST;
          "Entry No." += 1;
          "Posting Date" :=
            CALCDATE('<''' + FORMAT(LibraryRandom.RandInt(EndDate - StartDate)) + 'D''>',StartDate);
          IF CostAllocTargetBaseSales(CostAllocTarget) THEN BEGIN
            "Item Ledger Entry Type" := "Item Ledger Entry Type"::Sale;
            "Sales Amount (Actual)" := LibraryRandom.RandInt(100);
            "Invoiced Quantity" := LibraryRandom.RandInt(100);
          END ELSE BEGIN
            "Item Ledger Entry Type" := "Item Ledger Entry Type"::Purchase;
            "Purchase Amount (Actual)" := LibraryRandom.RandInt(100);
            "Invoiced Quantity" := LibraryRandom.RandInt(100);
          END;
          INSERT;
        END;
      END;
    END;

    LOCAL PROCEDURE DeleteAllocSource@42(AllocSourceID@1000 : Code[10]);
    VAR
      CostAllocationSource@1001 : Record 1106;
    BEGIN
      IF NOT CostAllocationSource.GET(AllocSourceID) THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationSource.TABLECAPTION,CostAllocationSource.GETFILTERS));
      CostAllocationSource.DELETE(TRUE);
    END;

    LOCAL PROCEDURE DeleteAllocTargets@50(AllocSourceID@1000 : Code[10]);
    VAR
      CostAllocationTarget@1001 : Record 1107;
    BEGIN
      CostAllocationTarget.SETFILTER(ID,AllocSourceID);
      IF NOT CostAllocationTarget.FINDFIRST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationTarget.TABLECAPTION,CostAllocationTarget.GETFILTERS));
      CostAllocationTarget.DELETE(TRUE);
    END;

    [RequestPageHandler]
    PROCEDURE DeleteCostEntries@58(VAR DeleteCostEntries@1000 : TestRequestPage 1130);
    VAR
      RegisterNo@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(RegisterNo);
      DeleteCostEntries.FromRegisterNo.SETVALUE(RegisterNo);
      DeleteCostEntries.ToRegisterNo.SETVALUE(RegisterNo);
      DeleteCostEntries.OK.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE DeleteCostBudgetEntries@55(VAR DeleteCostBudgetEntries@1000 : TestRequestPage 1139);
    VAR
      RegisterNo@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(RegisterNo);
      DeleteCostBudgetEntries.FromRegisterNo.SETVALUE(RegisterNo);
      DeleteCostBudgetEntries.ToRegisterNo.SETVALUE(RegisterNo);
      DeleteCostBudgetEntries.OK.INVOKE;
    END;

    LOCAL PROCEDURE DeleteEntryAndRegisterOfCostAcc@68();
    VAR
      CostEntry@1002 : Record 1104;
      CostBudgetEntry@1001 : Record 1109;
      CostRegister@1000 : Record 1105;
      CostBudgetRegister@1003 : Record 1111;
    BEGIN
      CostEntry.DELETEALL;
      CostRegister.DELETEALL;
      CostBudgetEntry.DELETEALL;
      CostBudgetRegister.DELETEALL;
    END;

    LOCAL PROCEDURE FindCostTypeWithCostCenter@103(VAR CostType@1000 : Record 1103;CostCenterCode@1001 : Code[20]);
    BEGIN
      LibraryCostAccounting.GetAllCostTypes(CostType);
      CostType.SETFILTER("Cost Center Code",'<>%1&<>%2','',CostCenterCode);
      CostType.SETFILTER("Cost Object Code",'%1','');
      IF CostType.ISEMPTY THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostType.TABLECAPTION,CostType.GETFILTERS));

      CostType.NEXT(LibraryRandom.RandInt(CostType.COUNT));
    END;

    LOCAL PROCEDURE GetAllocSources@31(VAR CostAllocationSource@1000 : Record 1106;Level@1001 : Integer);
    BEGIN
      CostAllocationSource.SETFILTER(Level,'%1',Level);
      IF NOT CostAllocationSource.FINDSET THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationSource.TABLECAPTION,CostAllocationSource.GETFILTERS));
    END;

    LOCAL PROCEDURE GetAllocTargets@17(VAR CostAllocationTarget@1000 : Record 1107;ID@1001 : Code[10]);
    BEGIN
      CostAllocationTarget.INIT;
      CostAllocationTarget.SETFILTER(ID,'%1',ID);
      IF NOT CostAllocationTarget.FINDSET THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostAllocationTarget.TABLECAPTION,CostAllocationTarget.GETFILTERS));
    END;

    LOCAL PROCEDURE GetCostJournalLineEntries@23(VAR CostJournalLine@1000 : Record 1101;CostJournalTemplateName@1001 : Code[10];CostJournalBatchName@1002 : Code[10]);
    BEGIN
      CostJournalLine.SETFILTER("Journal Template Name",'%1',CostJournalTemplateName);
      CostJournalLine.SETFILTER("Journal Batch Name",'%1',CostJournalBatchName);
      IF NOT CostJournalLine.FINDSET THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostJournalLine.TABLECAPTION,CostJournalLine.GETFILTERS));
    END;

    LOCAL PROCEDURE GetTotalAmountOfSrcEntry@74(TableNumber@1003 : Integer;KeyFieldNumber@1005 : Integer;KeyFieldValue@1001 : Integer;AmountFieldNumber@1006 : Integer) : Decimal;
    VAR
      KeyFieldRef@1004 : FieldRef;
      AmountFieldRef@1007 : FieldRef;
      RecordRef@1002 : RecordRef;
    BEGIN
      RecordRef.OPEN(TableNumber);
      KeyFieldRef := RecordRef.FIELD(KeyFieldNumber);
      KeyFieldRef.SETFILTER('%1',KeyFieldValue);
      RecordRef.FINDLAST;
      IF RecordRef.ISEMPTY THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,RecordRef.NAME,RecordRef.GETFILTERS));
      AmountFieldRef := RecordRef.FIELD(AmountFieldNumber);
      EXIT(AmountFieldRef.VALUE);
    END;

    LOCAL PROCEDURE GetTotalAmountOfSrcCostEntries@19(FromCostEntryNo@1000 : Integer;ToCostEntryNo@1001 : Integer;ToDate@1002 : Date;CostCenterCode@1004 : Code[20]) TotalAmount : Decimal;
    VAR
      CostEntry@1003 : Record 1104;
    BEGIN
      CostEntry.SETRANGE("Entry No.",FromCostEntryNo,ToCostEntryNo);
      CostEntry.SETRANGE("Posting Date",0D,ToDate);
      CostEntry.SETFILTER("Cost Center Code",'%1',CostCenterCode);
      IF NOT CostEntry.FINDSET THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostEntry.TABLECAPTION,CostEntry.GETFILTERS));

      REPEAT
        TotalAmount := TotalAmount + CostEntry.Amount;
      UNTIL CostEntry.NEXT = 0;

      EXIT(TotalAmount);
    END;

    LOCAL PROCEDURE VerifyCostCenterBalance@96(CostCenterCode@1000 : Code[20];ExpectedBalance@1001 : Decimal);
    VAR
      CostCenter@1002 : Record 1112;
    BEGIN
      WITH CostCenter DO BEGIN
        GET(CostCenterCode);
        SETRANGE("Date Filter",WORKDATE);
        CALCFIELDS("Balance at Date");
        Assert.AreEqual(ExpectedBalance,"Balance at Date",STRSUBSTNO(WrongBalanceErr,CostCenterCode));
      END;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@44(Message@1000 : Text[1024]);
    BEGIN
      // A dummy handler to simulate clicking the OK button.
    END;

    LOCAL PROCEDURE ResetGlobalVariables@47();
    BEGIN
      MaxLevel := 99;
      AllocToDateField := WORKDATE;
      VariantField := '';
      SelectedCostBudget := '';
    END;

    LOCAL PROCEDURE RunCostAllocationReportForLevels@72();
    VAR
      CostRegister@1000 : Record 1105;
      GLEntry@1500000 : Record 17;
      CostAccSetup@1500001 : Record 1108;
      DimEntry@1500002 : Record 480;
      Dimvalue@1500003 : Record 349;
    BEGIN
      // Setup:  Delete the Cost Entry, Cost Register and Cost budget Entry Table and then run the TransferGLEntries batch.
      DeleteEntryAndRegisterOfCostAcc;

      CostAccSetup.GET;
      GLEntry.SETFILTER("Posting Date",'%1..',WORKDATE);
      IF GLEntry.FINDSET THEN
        REPEAT
          IF NOT DimEntry.GET(GLEntry."Dimension Set ID",CostAccSetup."Cost Center Dimension") THEN BEGIN
            Dimvalue.SETRANGE("Dimension Code",CostAccSetup."Cost Center Dimension");
            Dimvalue.FINDFIRST;
            DimEntry.INIT;
            DimEntry."Dimension Set ID" := GLEntry."Dimension Set ID";
            DimEntry."Dimension Code" := CostAccSetup."Cost Center Dimension";
            DimEntry."Dimension Value Code" := Dimvalue.Code;
            DimEntry.INSERT;
          END;
        UNTIL GLEntry.NEXT = 0;

      LibraryCostAccounting.TransferGLEntries;

      // Exercise: Run the report Cost Allocation.
      RunCostAllocationReport;

      // Verify: Verify that no error comes up and also verifies that Cost allocation entries gets created.
      VerifyCostRegisterAndEntry(CostRegister);
    END;

    LOCAL PROCEDURE RunCostAllocationReport@83();
    BEGIN
      COMMIT;
      REPORT.RUN(REPORT::"Cost Allocation");
    END;

    LOCAL PROCEDURE SelectCostJournalBatch@32(VAR CostJournalBatch@1000 : Record 1102);
    VAR
      CostJournalTemplate@1001 : Record 1100;
    BEGIN
      IF NOT CostJournalTemplate.FINDLAST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostJournalTemplate.TABLECAPTION,CostJournalTemplate.GETFILTERS));
      LibraryCostAccounting.FindCostJournalBatch(CostJournalBatch,CostJournalTemplate.Name);
      LibraryCostAccounting.ClearCostJournalLines(CostJournalBatch);
    END;

    LOCAL PROCEDURE ValidateAllocSourceWithID@27(ID@1001 : Option);
    VAR
      CostAllocationSource@1000 : Record 1106;
      LastAllocationID@1002 : Code[10];
    BEGIN
      // Setup.
      Initialize;
      LastAllocationID := LibraryCostAccounting.LastAllocSourceID;

      // Exercise.
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,ID);

      // Verify.
      IF ID = TypeOfID::"Auto Generated" THEN BEGIN
        CostAllocationSource.TESTFIELD(ID,LibraryCostAccounting.LastAllocSourceID);
        Assert.AreEqual(
          LibraryCostAccounting.LastAllocSourceID,INCSTR(LastAllocationID),
          STRSUBSTNO(LastAllocIDNotUpdatedErr,CostAllocationSource.ID));
      END ELSE
        IF ID = TypeOfID::Custom THEN
          Assert.AreNotEqual(
            LibraryCostAccounting.LastAllocSourceID,CostAllocationSource.ID,
            STRSUBSTNO(LastAllocIDWrongUpdateErr,CostAllocationSource.ID))
        ELSE
          ERROR(STRSUBSTNO(UnexpectedOptionValueErr,FORMAT(ID)));
    END;

    LOCAL PROCEDURE ValidateDynAllocItems@2(Base@1002 : Option;DateFilterCode@1003 : Option);
    VAR
      CostAllocationSource@1001 : Record 1106;
      CostAllocationTarget@1000 : Record 1107;
      CostAccountAllocation@1004 : Codeunit 1104;
    BEGIN
      // Setup.
      Initialize;
      CreateAllocSourceAndTargets(CostAllocationSource,LibraryRandom.RandInt(10),Base);
      GetAllocTargets(CostAllocationTarget,CostAllocationSource.ID);
      CostAllocationTarget.MODIFYALL("Date Filter Code",DateFilterCode,TRUE);
      CreateValueEntry(Base,DateFilterCode);

      // Exercise.
      CostAccountAllocation.CalcAllocationKey(CostAllocationSource);

      // Verify.
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);
    END;

    LOCAL PROCEDURE ValidateDynAllocNumOfEmployees@43(UseFilters@1003 : Option);
    VAR
      CostAllocationSource@1000 : Record 1106;
      CostAccountAllocation@1001 : Codeunit 1104;
    BEGIN
      // Setup.
      Initialize;
      CreateDynAllocTargetEmployees(CostAllocationSource,UseFilters);

      // Exercise.
      CostAccountAllocation.CalcAllocationKey(CostAllocationSource);

      // Verify.
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);
    END;

    LOCAL PROCEDURE ValidateStaticAllocTarget@102(AllocationType@1002 : Option);
    VAR
      CostAllocationSource@1001 : Record 1106;
      CostAllocationTarget@1000 : Record 1107;
    BEGIN
      // Setup.
      Initialize;
      LibraryCostAccounting.CreateAllocSourceWithCCenter(CostAllocationSource,TypeOfID::"Auto Generated");

      // Exercise.
      LibraryCostAccounting.CreateAllocTargetWithCCenter(
        CostAllocationTarget,CostAllocationSource,LibraryRandom.RandInt(10),CostAllocationTarget.Base::Static,AllocationType);

      // Verify.
      LibraryCostAccounting.CheckAllocTargetSharePercent(CostAllocationSource);
    END;

    LOCAL PROCEDURE VerifyCostRegisterAndEntry@87(VAR CostRegister@1001 : Record 1105);
    VAR
      CostEntry@1002 : Record 1104;
    BEGIN
      IF NOT CostRegister.FINDLAST THEN
        ERROR(STRSUBSTNO(NoRecordsInFilterErr,CostRegister.TABLECAPTION,CostRegister.GETFILTERS));

      CostEntry.SETRANGE("Allocated with Journal No.",CostRegister."No.");
      CostEntry.FINDFIRST;
      CostEntry.TESTFIELD(Allocated,TRUE);
    END;

    [RequestPageHandler]
    PROCEDURE AllocateCostsForMultipleLevels@79(VAR CostAllocation@1000 : TestRequestPage 1131);
    VAR
      CostAllocationSource@1001 : Record 1106;
    BEGIN
      CostAllocationSource.FINDLAST;
      LibraryCostAccounting.AllocateCostsFromTo(CostAllocation,1,CostAllocationSource.Level,WORKDATE,'','');
      CostAllocation.OK.INVOKE;
    END;

    LOCAL PROCEDURE CostAllocTargetBaseSales@89(CostAllocTarget@1000 : Record 1107) : Boolean;
    BEGIN
      IF CostAllocTarget.Base IN [CostAllocTarget.Base::"Items Sold (Qty.)",CostAllocTarget.Base::"Items Sold (Amount)"] THEN
        EXIT(TRUE);
      EXIT(FALSE);
    END;

    LOCAL PROCEDURE CostAllocTargetBasePurchase@91(CostAllocTarget@1000 : Record 1107) : Boolean;
    BEGIN
      IF CostAllocTarget.Base IN [CostAllocTarget.Base::"Items Purchased (Qty.)",CostAllocTarget.Base::"Items Purchased (Amount)"] THEN
        EXIT(TRUE);
      EXIT(FALSE);
    END;

    BEGIN
    {
      // [FEATURE] [Cost Accounting] [Allocation]

       1. Define allocations from Cost Center to Cost Center.
       2. Define allocations from Cost Center to Cost Object.
       3. Create a new allocation source with an auto-generated ID.
       4. Create a new allocation source with a custom ID.
       5. Delete an allocation source with no allocation targets.
       6. Delete an allocation source with allocation targets.
       7. Delete allocated cost entries.
       8. Delete allocated cost budget entries.
       9. Create an allocation source and reuse it as an allocation target.
      10. Create static allocation targets with Allocation Type Percent per Share.
      11. Create static allocation targets with Allocation Type Percent per Amount.
      12. Create a static allocation target and fill in Static Base and Weighting.
      13. Create a dynamic allocation target where Base is Cost Type Budget.
      14. Create a dynamic allocation target where Base is Cost Type Movement.
      15. Create a dynamic allocation target where Base is G/L Budget.
      16. Create a dynamic allocation target where Base is G/L Movement.
      17. Create a dynamic allocation target where Base is Items Purchased (Amount).
      18. Create a dynamic allocation target where Base is Items Purchased (Qty.).
      19. Create a dynamic allocation target where Base is Items Sold (Amount).
      20. Create a dynamic allocation target where Base is Items Sold (Qty.).
      21. Create a dynamic allocation target where Base is No of Employees.
      22. Create an allocation source with both CC and CO values are filled in.
      23. Create an allocation target with both CC and CO values are filled in.
      24. Run allocations with the Budget field is filled in.
      25. Run allocations with the Date field is filled in.
      26. Run allocations with both From Level and To Level fields are filled in.21.
      27. Run allocations with the Variant field is filled in.
      28. Verify that system does not throw error while running the report Cost Allocation with Single level when Cost entry, Cost budget entries are empty.
      29. Verify that system does not throw error while running the report Cost Allocation with Multiple level when Cost entry, Cost budget entries are empty.
      30. Verify that system does not throw error while running the report Cost Allocation with Budget Name when Cost entry, Cost budget entries are empty.
      31. Verify that system does not throw error while running the report Cost Allocation without Budget Name when Cost entry, Cost budget entries are empty.
      32. Run allocations from Cost Center to Cost Center with multiple Cost Allocation Targets with roundings.

      BUG ID 53389
      ----------------------------------------------------------------------------------------
      Test Function Name                                                                TFS ID
      ----------------------------------------------------------------------------------------
      CostAllocationWithSingleLevel
      CostAllocationWithMultipleLevel
      CostAllocationWithBudgetName
      CostAllocationWithoutBudgetName

      ----------------------------------------------------------------------------------------------------------
      Test Function Name                                                                TFS ID
      ----------------------------------------------------------------------------------------------------------
      TestAllocationWithRoundings                                                       85940
    }
    END.
  }
}

