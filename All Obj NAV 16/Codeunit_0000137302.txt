OBJECT Codeunit 137302 SCM Inventory Reports - II
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      ItemJournalBatch@1022 : Record 233;
      OutputItemJournalTemplate@1020 : Record 82;
      OutputItemJournalBatch@1017 : Record 233;
      ConsumptionItemJournalTemplate@1016 : Record 82;
      ConsumptionItemJournalBatch@1053 : Record 233;
      LibraryReportDataset@1012 : Codeunit 131007;
      LibraryPurchase@1021 : Codeunit 130512;
      LibraryPlanning@1026 : Codeunit 132203;
      LibraryInventory@1002 : Codeunit 132201;
      LibraryManufacturing@1023 : Codeunit 132202;
      LibraryMarketing@1005 : Codeunit 131900;
      LibraryUtility@1010 : Codeunit 131000;
      LibrarySales@1015 : Codeunit 130509;
      LibraryVariableStorage@1034 : Codeunit 131004;
      LibraryCosting@1006 : Codeunit 132200;
      LibraryERM@1013 : Codeunit 131300;
      LibraryPatterns@1024 : Codeunit 132212;
      LibraryRandom@1001 : Codeunit 130440;
      Assert@1008 : Codeunit 130000;
      isInitialized@1000 : Boolean;
      FullShipmentValueTxt@1019 : TextConst 'ENU=Full Shipment';
      NoShipmentValueTxt@1018 : TextConst 'ENU=No Shipment';
      PartialShipmentValueTxt@1007 : TextConst 'ENU=Partial Shipment';
      DirectUnitCostErr@1027 : TextConst 'ENU=Direct Unit Cost must match.';
      MsgQtytoShipErr@1003 : TextConst 'ENU=Qty. to Ship  must match.';
      MsgQtytoReceiveErr@1004 : TextConst 'ENU=Qty. to Receive  must match.';
      PostJournalLinesConfirmationMessageQst@1039 : TextConst 'ENU=Do you want to post the journal lines?';
      JournalLinesPostedMessageMsg@1038 : TextConst 'ENU=The journal lines were successfully posted.';
      StatusConstantCap@1040 : TextConst 'ENU=Finished';
      InvtSetupConfirmationMessageQst@1014 : TextConst 'ENU=If you change the Expected Cost Posting to G/L, the program must update table Post Value Entry to G/L.This can take several hours.';
      ReportQtyErr@1025 : TextConst 'ENU=Wrong Quantity on Report';

    [Test]
    [HandlerFunctions(PriceListRequestPageHandler)]
    PROCEDURE PriceListCustomer@3();
    BEGIN
      // Test Price List Report - Sales Type: Customer.
      Initialize;
      CustomerPriceListReport('');
    END;

    [Test]
    [HandlerFunctions(PriceListRequestPageHandler)]
    PROCEDURE PriceListCustomerCurr@7();
    VAR
      CurrencyCode@1000 : Code[10];
    BEGIN
      // Test Price List Report - Sales Type: Customer, and Random Currency.
      Initialize;
      CurrencyCode := SelectCurrencyCode;
      CustomerPriceListReport(CurrencyCode);
    END;

    LOCAL PROCEDURE CustomerPriceListReport@8(CurrencyCode@1000 : Code[10]);
    VAR
      Item@1006 : Record 27;
      SalesType@1001 : 'Customer,Customer Price Group,All Customers,Campaign';
      CustNo@1002 : Code[20];
    BEGIN
      // 1. Setup: Create Item with random unit price.
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      UpdateItem(Item,Item.FIELDNO("Unit Price"),LibraryRandom.RandDec(10,2));

      // 2. Exercise: Generate the Price List.
      CustNo := LibrarySales.CreateCustomerNo;
      COMMIT;
      RunPriceListReport(Item."No.",SalesType::Customer,CustNo,CurrencyCode);

      // 3. Verify: Check the value of Item Unit Price in Price List.
      VerifyUnitPrice(Item,CurrencyCode,Item."Unit Price");
    END;

    [Test]
    [HandlerFunctions(PriceListRequestPageHandler)]
    PROCEDURE PriceListCustPriceGroup@5();
    BEGIN
      // Test Price List Report - Sales Type: Customer Price Group.
      Initialize;
      CustPriceGroupPriceListReport('');
    END;

    [Test]
    [HandlerFunctions(PriceListRequestPageHandler)]
    PROCEDURE PriceListCustPriceGroupCurr@18();
    VAR
      CurrencyCode@1000 : Code[10];
    BEGIN
      // Test Price List Report - Sales Type: Customer Price Group, and Random Currency.
      Initialize;
      CurrencyCode := SelectCurrencyCode;
      CustPriceGroupPriceListReport(CurrencyCode);
    END;

    LOCAL PROCEDURE CustPriceGroupPriceListReport@19(CurrencyCode@1000 : Code[10]);
    VAR
      Item@1008 : Record 27;
      CustomerPriceGroup@1006 : Record 6;
      SalesType@1002 : 'Customer,Customer Price Group,All Customers,Campaign';
    BEGIN
      // 1. Setup: Create Item with random unit price and Customer Price Group.
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      UpdateItem(Item,Item.FIELDNO("Unit Price"),LibraryRandom.RandDec(10,2));
      LibrarySales.CreateCustomerPriceGroup(CustomerPriceGroup);
      CreateCustomerWithPriceGroup(CustomerPriceGroup.Code);

      // 2. Exercise: Generate the Price List.
      COMMIT;
      RunPriceListReport(Item."No.",SalesType::"Customer Price Group",CustomerPriceGroup.Code,CurrencyCode);

      // 3. Verify: Check the value of Item Unit Price in Price List.
      VerifyUnitPrice(Item,CurrencyCode,Item."Unit Price");
    END;

    [Test]
    [HandlerFunctions(PriceListRequestPageHandler)]
    PROCEDURE PriceListAllCustomer@10();
    BEGIN
      // Test Price List Report - Sales Type: All Customer.
      Initialize;
      AllCustomerPriceListReport('');
    END;

    [Test]
    [HandlerFunctions(PriceListRequestPageHandler)]
    PROCEDURE PriceListAllCustomerCurr@6();
    VAR
      CurrencyCode@1000 : Code[10];
    BEGIN
      // Test Price List Report - Sales Type: All Customer, and Random Currency.
      Initialize;
      CurrencyCode := SelectCurrencyCode;
      AllCustomerPriceListReport(CurrencyCode);
    END;

    LOCAL PROCEDURE AllCustomerPriceListReport@9(CurrencyCode@1000 : Code[10]);
    VAR
      Item@1006 : Record 27;
      SalesType@1001 : 'Customer,Customer Price Group,All Customers,Campaign';
    BEGIN
      // 1. Setup: Create Item with random unit price.
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      UpdateItem(Item,Item.FIELDNO("Unit Price"),LibraryRandom.RandDec(10,2));

      // 2. Exercise: Generate the Price List.
      COMMIT;
      RunPriceListReport(Item."No.",SalesType::"All Customers",'',CurrencyCode);

      // 3. Verify: Check the value of Item Unit Price in Price List.
      VerifyUnitPrice(Item,CurrencyCode,Item."Unit Price");
    END;

    [Test]
    [HandlerFunctions(PriceListRequestPageHandler)]
    PROCEDURE PriceListReportCampaign@15();
    BEGIN
      // Test Price List Report - Sales Type: Campaign.
      Initialize;
      CampaignPriceListReport('');
    END;

    [Test]
    [HandlerFunctions(PriceListRequestPageHandler)]
    PROCEDURE PriceListReportCampaignCurr@17();
    VAR
      CurrencyCode@1000 : Code[10];
    BEGIN
      // Test Price List Report - Sales Type: Campaign, and Random Currency.
      Initialize;
      CurrencyCode := SelectCurrencyCode;
      CampaignPriceListReport(CurrencyCode);
    END;

    LOCAL PROCEDURE CampaignPriceListReport@20(CurrencyCode@1008 : Code[10]);
    VAR
      Item@1007 : Record 27;
      Campaign@1005 : Record 5071;
      SalesPrice@1004 : Record 7002;
      SalesType@1000 : 'Customer,Customer Price Group,All Customers,Campaign';
    BEGIN
      // 1. Setup: Create Item, Campaign and Sales Price.
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      LibraryMarketing.CreateCampaign(Campaign);
      CreateSalesPriceForCampaign(SalesPrice,Item."No.",Campaign."No.");

      // 2. Exercise: Generate the Price List.
      COMMIT;
      RunPriceListReport(Item."No.",SalesType::Campaign,Campaign."No.",CurrencyCode);

      // 3. Verify: Check the value of Unit Price from Sales Price.
      SalesPrice.SETRANGE("Item No.",Item."No.");
      SalesPrice.FINDFIRST;
      VerifyUnitPrice(Item,CurrencyCode,SalesPrice."Unit Price");
    END;

    [Test]
    [HandlerFunctions(InventoryPostingTestRequestPageHandler)]
    PROCEDURE InventoryPostingReport@1();
    VAR
      Item@1002 : Record 27;
      ItemJournalBatch@1005 : Record 233;
      ItemJournalLine@1009 : Record 83;
      GeneralLedgerSetup@1007 : Record 98;
    BEGIN
      // 1. Setup: Create Item and Item Journal Line.
      Initialize;
      GeneralLedgerSetup.GET;
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      CreateItemJournalLine(ItemJournalBatch,ItemJournalLine,Item."No.");

      // 2. Exercise: Generate the Inventory Posting - Test report.
      COMMIT;
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      REPORT.RUN(REPORT::"Inventory Posting - Test",TRUE,FALSE,ItemJournalLine);

      // 3. Verify: Check the values of Quantity, Unit Cost and Cost Amount in the report.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('Item_Journal_Line__Item_No__',Item."No.");
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('Item_Journal_Line_Quantity',ItemJournalLine.Quantity);
      LibraryReportDataset.AssertCurrentRowValue('Item_Journal_Line__Unit_Cost_',ItemJournalLine."Unit Cost");
      LibraryReportDataset.AssertCurrentRowValue('CostAmount',ItemJournalLine.Quantity * ItemJournalLine."Unit Cost");

      // 4. Tear Down.
      ItemJournalBatch.DELETEALL;
    END;

    [Test]
    [HandlerFunctions(StatusRequestPageHandler)]
    PROCEDURE StatusReport@2();
    VAR
      Item@1002 : Record 27;
      ItemJournalBatch@1008 : Record 233;
      ItemJournalLine@1009 : Record 83;
    BEGIN
      // 1. Setup: Create Item and post Item Journal Line for Item purchase.
      Initialize;
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      CreateItemJournalLine(ItemJournalBatch,ItemJournalLine,Item."No.");
      ItemJournalLine.VALIDATE("Document No.",Item."No.");
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);

      // 2. Exercise: Generate the Status report.
      RunStatusReport(Item."No.");

      // 3. Verify: Check the value of Quantity in the report.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_Item',Item."No.");
      Item.CALCFIELDS(Inventory);
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('RemainingQty',Item.Inventory);

      // 4. Tear Down.
      ItemJournalBatch.DELETEALL;
    END;

    [Test]
    [HandlerFunctions(InvtValCostSpecWithFiltersPageHandler)]
    PROCEDURE InvtValuationCostSpecReportWithLimitsTotalsFilter@100();
    VAR
      Item@1005 : Record 27;
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      // [SCENARIO 360763] Report Inventory Valuation - Cost Spec. Quantity is equal to ItemLedgerEntry's Quantity that correspondes with "Limits Totals to" filters
      Initialize;

      // [GIVEN] Create Item
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      // [GIVEN] Item Ledger Entry for Item 'I', where Quantity='Q1', 'Location' ='L1','Varian'= 'V1', 'Global Dim' = 'D1'
      CreateItemLedgerEntry(ItemLedgerEntry,Item."No.");
      // [GIVEN] Item Ledger Entry for Item 'I', where Quantity='Q2' , 'Location' ='L2','Varian'= 'V2', 'Global Dim' = 'D2'
      CreateItemLedgerEntry(ItemLedgerEntry,Item."No.");
      COMMIT;

      // [WHEN]  Run 'Inventory Valuation - Cost Spec.' report with filters: 'L2', 'V2', 'D2'
      SetLimitsTotalsFilterOnItem(Item,ItemLedgerEntry);
      REPORT.RUN(REPORT::"Invt. Valuation - Cost Spec.",TRUE,FALSE,Item);

      // [THEN] Report shows 'Quantity' = 'Q2'
      VerifyLibraryReportDatasetQuantity(ItemLedgerEntry.Quantity,Item."No.");
    END;

    [Test]
    [HandlerFunctions(InvtValCostSpecRequestPageHandler)]
    PROCEDURE InvtValuationCostSpecReport@11();
    VAR
      Item@1005 : Record 27;
      ItemJournalBatch@1004 : Record 233;
      ItemJournalLine@1003 : Record 83;
      Quantity@1000 : Decimal;
    BEGIN
      // 1. Setup: Create Item and post Item Journal Line for Item purchase.
      Initialize;
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      UpdateItem(Item,Item.FIELDNO(Description),Item."No.");
      CreateItemJournalLine(ItemJournalBatch,ItemJournalLine,Item."No.");
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);

      // 2. Exercise: Generate the Inventory Valuation - Cost Spec. report.
      RunInvtValuationCostSpecReport(Item."No.");

      // 3. Verify: Check the value of Quantity in the report.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_Item',Item."No.");
      Quantity := LibraryReportDataset.Sum('RemainingQty');
      ItemJournalLine.TESTFIELD(Quantity,Quantity);

      // 4. Tear Down.
      ItemJournalBatch.DELETEALL;
    END;

    [Test]
    [HandlerFunctions(PostProdJournalPageHandler,InventoryValuationWIPRequestPageHandler)]
    PROCEDURE InventoryValuationWIPReport@14();
    VAR
      Item@1000 : Record 27;
      RoutingHeader@1005 : Record 99000763;
      ProductionOrder@1002 : Record 5405;
      ItemLedgerEntry@1006 : Record 32;
      ItemJournalBatch@1001 : Record 233;
      ProductionBOMHeader@1011 : Record 99000771;
      CostAmountActual@1008 : Decimal;
      ChildItemNo@1009 : Code[20];
      ChildItemNo2@1010 : Code[20];
    BEGIN
      // 1. Setup: Create Production Order Setup.
      Initialize;
      ItemJournalSetup(ItemJournalBatch);
      ChildItemNo := CreateChildItemWithInventory(ItemJournalBatch);
      ChildItemNo2 := CreateChildItemWithInventory(ItemJournalBatch);

      // Create Production BOM.
      LibraryManufacturing.CreateCertifProdBOMWithTwoComp(ProductionBOMHeader,ChildItemNo,ChildItemNo2,1);  // Value important.

      // Create Parent Item and attach Routing and Production BOM.
      CreateRoutingSetup(RoutingHeader);
      CreateItem(Item,RoutingHeader."No.",ProductionBOMHeader."No.",Item."Manufacturing Policy"::"Make-to-Order");
      CreateAndRefreshRelProdOrder(ProductionOrder,ProductionOrder."Source Type"::Item,Item."No.",RANDOM(5));
      LibraryVariableStorage.Enqueue(ProductionOrder."No.");
      OpenProductionJournal(ProductionOrder);

      // 2. Exercise: Generate the Inventory Valuation WIP report.
      COMMIT;
      LibraryVariableStorage.Enqueue(WORKDATE);
      LibraryVariableStorage.Enqueue(WORKDATE);
      REPORT.RUN(REPORT::"Inventory Valuation - WIP",TRUE,FALSE,ProductionOrder);

      // 3. Verify: Check the value of Source No. and Consumption.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_ProductionOrder',ProductionOrder."No.");
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('SourceNo_ProductionOrder',ProductionOrder."Source No.");

      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::Consumption);
      ItemLedgerEntry.SETRANGE("Source No.",Item."No.");
      ItemLedgerEntry.FINDSET;
      REPEAT
        ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
        CostAmountActual += ItemLedgerEntry."Cost Amount (Actual)";
      UNTIL ItemLedgerEntry.NEXT = 0;

      LibraryReportDataset.AssertCurrentRowValue('ValueOfMatConsump',-CostAmountActual)
    END;

    [Test]
    [HandlerFunctions(PurchResAvailRequestPageHandler)]
    PROCEDURE PurchaseReserveAvail@35();
    VAR
      Item@1003 : Record 27;
      PurchaseHeader@1002 : Record 38;
    BEGIN
      // Setup.
      Initialize;
      LibraryInventory.CreateItem(Item);
      PurchaseReserveAvailReport(PurchaseHeader,Item."No.",FALSE);  // PurchaseReserveAvailReport contains Exercise.

      // Verify: Check Expected Receipt Date value in the report.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('DocumentStatus',FullShipmentValueTxt);
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('ExpctRecptDate_PurchLine',FORMAT(PurchaseHeader."Expected Receipt Date"));
    END;

    [Test]
    [HandlerFunctions(PurchResAvailRequestPageHandler)]
    PROCEDURE PurchaseReserveAvailWithLines@34();
    VAR
      Item@1003 : Record 27;
      PurchaseHeader@1002 : Record 38;
      PurchaseLine@1001 : Record 39;
    BEGIN
      // Setup.
      Initialize;
      LibraryInventory.CreateItem(Item);
      PurchaseReserveAvailReport(PurchaseHeader,Item."No.",TRUE);  // PurchaseReserveAvailReport contains Exercise.

      // Verify: Check Outstanding Quantity (Base) in the report.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_PurchaseLine',Item."No.");
      FindPurchaseOrderLine(PurchaseLine,PurchaseHeader."No.");
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('OutstQtyBase_PurchLine',PurchaseLine."Outstanding Qty. (Base)")
    END;

    [Test]
    [HandlerFunctions(SalesResAvailRequestPageHandler)]
    PROCEDURE SalesReserveAvail@29();
    VAR
      Item@1003 : Record 27;
      SalesHeader@1002 : Record 36;
    BEGIN
      // Setup.
      Initialize;
      LibraryInventory.CreateItem(Item);
      SalesReserveAvailReport(SalesHeader,Item."No.",FALSE);  // SalesReserveAvailReport contains Exercise.

      // Verify: Check the Shipment Date in the report.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('DocumentStatus',NoShipmentValueTxt);
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('ShipmentDt_SalesHeader',FORMAT(SalesHeader."Shipment Date"));
    END;

    [Test]
    [HandlerFunctions(SalesResAvailRequestPageHandler)]
    PROCEDURE SalesReserveAvailWithLines@27();
    VAR
      Item@1003 : Record 27;
      SalesHeader@1002 : Record 36;
      SalesLine@1001 : Record 37;
    BEGIN
      // Setup.
      Initialize;
      LibraryInventory.CreateItem(Item);
      SalesReserveAvailReport(SalesHeader,Item."No.",TRUE);  // SalesReserveAvailReport contains Exercise.

      // Verify: Check the Outstanding Quantity (Base) in the report.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_SalesLine',Item."No.");
      SelectSalesLine(SalesLine,SalesHeader."No.");
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('OutstdngQtyBase_SalesLine',SalesLine."Outstanding Qty. (Base)")
    END;

    [Test]
    [HandlerFunctions(SalesResAvailRequestPageHandler)]
    PROCEDURE SalesReserveAvailWithReserve@23();
    VAR
      Item@1003 : Record 27;
      SalesHeader@1002 : Record 36;
      SalesLine@1001 : Record 37;
      PurchaseHeader@1008 : Record 38;
      Quantity@1000 : Decimal;
    BEGIN
      // Setup: Create Item with Reservation - Always, Purchase Order and Sales Order. Auto-reserve Item.
      Initialize;
      LibraryInventory.CreateItem(Item);
      UpdateItem(Item,Item.FIELDNO(Reserve),Item.Reserve::Always);
      Quantity := LibraryRandom.RandDec(10,2);
      CreatePurchaseOrder(PurchaseHeader,Item."No.",Quantity);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      CreateSalesOrder(SalesHeader,Item."No.",Quantity);
      SelectSalesLine(SalesLine,SalesHeader."No.");
      LibrarySales.AutoReserveSalesLine(SalesLine);
      CLEAR(SalesLine);

      // Exercise: Generate the Sales Reservation Avail. report with Show Reservation Entries.
      COMMIT;
      RunSalesReservationAvail(SalesHeader."No.",TRUE,TRUE);

      // Verify: Check the Reserved Quantity in the report.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_SalesLine',Item."No.");
      SelectSalesLine(SalesLine,SalesHeader."No.");
      SalesLine.CALCFIELDS("Reserved Qty. (Base)");
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('Qty_ReservationEntry',-SalesLine."Reserved Qty. (Base)");
      LibraryReportDataset.AssertCurrentRowValue('ResrvdQtyBase_SalesLine',SalesLine."Reserved Qty. (Base)");
    END;

    [Test]
    [HandlerFunctions(RolledUpCostSharesRequestPageHandler)]
    PROCEDURE RolledUpCostSharesReport@49();
    VAR
      Item@1001 : Record 27;
      ProductionBOMLine@1000 : Record 99000772;
    BEGIN
      // Setup: Create Production Item Setup.
      Initialize;
      CreateProdItemSetup(Item);

      // Exercise: Generate the Rolled up Cost Shares report.
      COMMIT;
      Item.SETRANGE("No.",Item."No.");
      REPORT.RUN(REPORT::"Rolled-up Cost Shares",TRUE,FALSE,Item);

      // Verify: Check Item details.
      LibraryReportDataset.LoadDataSetFile;

      // Verify Child Items exist in the report.
      SelectProductionBOMLines(ProductionBOMLine,Item."Production BOM No.");
      REPEAT
        LibraryReportDataset.SetRange('ProdBOMLineIndexNo',ProductionBOMLine."No.");
        Item.GET(ProductionBOMLine."No.");
        LibraryReportDataset.GetNextRow;
        LibraryReportDataset.AssertCurrentRowValue('ProdBOMLineIndexDesc',Item.Description);
      UNTIL ProductionBOMLine.NEXT = 0;
    END;

    [Test]
    [HandlerFunctions(SglLevelCostSharesRequestPageHandler)]
    PROCEDURE SingleLevelCostSharesReport@50();
    VAR
      Item@1001 : Record 27;
    BEGIN
      // Setup: Create Item.
      Initialize;
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");

      // Exercise: Generate the Single Level Cost Shares report.
      COMMIT;
      Item.SETRANGE("No.",Item."No.");
      REPORT.RUN(REPORT::"Single-level Cost Shares",TRUE,FALSE,Item);

      // Verify: Check Item details.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_Item',Item."No.");
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('UnitCost_Item',Item."Unit Cost");
    END;

    [Test]
    [HandlerFunctions(DetailedCalculationRequestPageHandler)]
    PROCEDURE DetailedCalculationReport@55();
    VAR
      Item@1000 : Record 27;
      ProductionBOMLine@1001 : Record 99000772;
    BEGIN
      // Setup: Create Production Item Setup.
      Initialize;
      CreateProdItemSetup(Item);

      // Exercise: Generate the Detailed Calculation report.
      COMMIT;
      Item.SETRANGE("No.",Item."No.");
      REPORT.RUN(REPORT::"Detailed Calculation",TRUE,FALSE,Item);

      // Verify: Check Item details.
      LibraryReportDataset.LoadDataSetFile;

      // Verify Child Items exist in the report.
      SelectProductionBOMLines(ProductionBOMLine,Item."Production BOM No.");
      REPEAT
        LibraryReportDataset.SetRange('ProdBOMLineLevelNo',ProductionBOMLine."No.");
        LibraryReportDataset.GetNextRow;
        Item.GET(ProductionBOMLine."No.");
        LibraryReportDataset.AssertCurrentRowValue('ProdBOMLineLevelDesc',Item.Description);
      UNTIL ProductionBOMLine.NEXT = 0;
    END;

    [Test]
    [HandlerFunctions(WhereUsedTopLevelRequestPageHandler)]
    PROCEDURE WhereUsedTopLevelReport@56();
    VAR
      Item@1000 : Record 27;
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      // Setup: Create Production Item Setup and select a child item.
      Initialize;
      CreateProdItemSetup(Item);
      SelectProductionBOMLines(ProductionBOMLine,Item."Production BOM No.");

      // Exercise: Generate the Where Used (Top Level) report.
      COMMIT;
      Item.SETRANGE("No.",ProductionBOMLine."No.");
      REPORT.RUN(REPORT::"Where-Used (Top Level)",TRUE,FALSE,Item);

      // Verify: Check Item details.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_Item',ProductionBOMLine."No.");
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('WhereUsedListItemNo',Item."No.");
    END;

    [Test]
    [HandlerFunctions(InventoryAvailabilityRequestPageHandler)]
    PROCEDURE InventoryAvailabilityReport@57();
    VAR
      SalesHeader@1004 : Record 36;
      PurchaseHeader@1005 : Record 38;
      Item@1000 : Record 27;
      GrossReq@1002 : Decimal;
      ScheduledReceipt@1003 : Decimal;
    BEGIN
      // Setup: Create Item.
      Initialize;
      ScheduledReceipt := LibraryRandom.RandDecInRange(10,100,2);
      GrossReq := LibraryRandom.RandDecInDecimalRange(1,ScheduledReceipt,2);
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      CreatePurchaseOrder(PurchaseHeader,Item."No.",ScheduledReceipt);
      CreateSalesOrder(SalesHeader,Item."No.",GrossReq);

      // Exercise: Generate the Inventory Availability report.
      COMMIT;
      Item.SETRANGE("No.",Item."No.");
      REPORT.RUN(REPORT::"Inventory Availability",TRUE,FALSE,Item);

      // Verify: Check Item details.
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_Item',Item."No.");
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('ScheduledReceipt',ScheduledReceipt);
      LibraryReportDataset.AssertCurrentRowValue('GrossRequirement',GrossReq);
      LibraryReportDataset.AssertCurrentRowValue('ProjAvailBalance',ScheduledReceipt - GrossReq);
    END;

    [Test]
    [HandlerFunctions(StatusRequestPageHandler)]
    PROCEDURE StatusReportForPurchaseOrderWithSameUOM@62();
    BEGIN
      // Setup.
      Initialize;
      StatusReportForPurchaseOrder(FALSE);  // Change Unit of Measure as False.
    END;

    [Test]
    [HandlerFunctions(StatusRequestPageHandler)]
    PROCEDURE StatusReportForPurchaseOrderWithDiffUOM@107();
    BEGIN
      // Setup.
      Initialize;
      StatusReportForPurchaseOrder(TRUE);  // Change Unit of Measure as True.
    END;

    LOCAL PROCEDURE StatusReportForPurchaseOrder@108(ChangeUnitOfMeasure@1006 : Boolean);
    VAR
      PurchaseLine@1000 : Record 39;
      Item@1001 : Record 27;
      PurchaseHeader@1004 : Record 38;
    BEGIN
      // Create Item, Create Purchase Order, Change Unit of Measure on Purchase Line and Post Purchase Order with Receive Option.
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      CreateAndPostPurchaseOrderWithUOM(PurchaseHeader,Item,ChangeUnitOfMeasure);

      // Exercise: Generate the Status report.
      RunStatusReport(Item."No.");

      // Verify: Verify Item No, Direct Unit Cost and Quantity(Base) on Generated Report.
      FindPurchaseOrderLine(PurchaseLine,PurchaseHeader."No.");
      VerifyStatusReport(PurchaseLine);
    END;

    [Test]
    [HandlerFunctions(InvtValCostSpecRequestPageHandler)]
    PROCEDURE InventoryValuationCostSpecReportForPurchaseOrder@61();
    VAR
      PurchaseLine@1000 : Record 39;
      Item@1001 : Record 27;
      PurchaseHeader@1004 : Record 38;
    BEGIN
      // Setup: Create Item, Create and Post Purchase Order with Receive Option.
      Initialize;
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      CreateAndPostPurchaseOrderWithUOM(PurchaseHeader,Item,FALSE);  // Change Unit Of Measure  as False.

      // Exercise: Generate the Invt. Valuation - Cost Spec. report.
      RunInvtValuationCostSpecReport(Item."No.");

      // Verify: Verify Amount, Direct Unit Cost and Quantity on Generated Report.
      FindPurchaseOrderLine(PurchaseLine,PurchaseHeader."No.");
      VerifyInventoryValuationCostSpecReport(PurchaseLine);
    END;

    [Test]
    [HandlerFunctions(PostProdJournalPageHandler,InventoryValuationWIPRequestPageHandler,MessageHandler,ConfirmHandler)]
    PROCEDURE CostPostedToGLAfterRunningInventoryValuationWIPReport@59();
    VAR
      Item@1002 : Record 27;
      InventorySetup@1004 : Record 313;
      ItemJournalLine@1000 : Record 83;
      ProductionOrder@1003 : Record 5405;
      LibraryCosting@1005 : Codeunit 132200;
    BEGIN
      // Run the Inventory Valuation - WIP report. Verify Cost Posted To GL After Posting Revalution Journal.

      // Setup: Create and Post Revaluation Journal after Adjusting Cost Item Entries.
      Initialize;
      LibraryVariableStorage.Enqueue('');
      ExecuteUIHandlers;
      LibraryVariableStorage.Enqueue(InvtSetupConfirmationMessageQst);
      LibraryInventory.UpdateInventorySetup(InventorySetup,TRUE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,
        InventorySetup."Average Cost Calc. Type"::Item,InventorySetup."Average Cost Period"::Day);
      LibraryVariableStorage.Clear;// Clear the queue as confirm might not be triggered

      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Stock");
      UpdateItem(Item,Item.FIELDNO("Costing Method"),Item."Costing Method"::Standard);
      UpdateItem(Item,Item.FIELDNO("Standard Cost"),LibraryRandom.RandDec(10,2));
      CreateAndRefreshRelProdOrder(ProductionOrder,ProductionOrder."Source Type"::Item,Item."No.",RANDOM(5));
      LibraryVariableStorage.Enqueue(ProductionOrder."No.");
      OpenProductionJournal(ProductionOrder);
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
      UpdateItem(Item,Item.FIELDNO("Standard Cost"),Item."Standard Cost" + LibraryRandom.RandDec(5,2));
      CreateAndUpdateRevaluationJournal(ItemJournalLine,Item."No.",Item."Standard Cost");
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Exercise: Run Inventory Valuation WIP Report.
      COMMIT;
      LibraryVariableStorage.Enqueue(CALCDATE('<-CM>',WORKDATE));
      LibraryVariableStorage.Enqueue(CALCDATE('<CM>',WORKDATE));
      ProductionOrder.GET(ProductionOrder.Status::Finished,ProductionOrder."No.");
      REPORT.RUN(REPORT::"Inventory Valuation - WIP",TRUE,FALSE,ProductionOrder);

      // Verify: Verify  Cost Posted To GL on Generated Report.
      VerifyCostPostedToGL(ProductionOrder."No.",ItemJournalLine."Document No.");

      // Teardown.
      LibraryInventory.UpdateInventorySetup(InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,
        InventorySetup."Average Cost Calc. Type"::Item,InventorySetup."Average Cost Period"::Day);
    END;

    [Test]
    [HandlerFunctions(SalesResAvailRequestPageHandler)]
    PROCEDURE SalesReservationAvailWithFullReservFromInventory@167();
    VAR
      Item@1001 : Record 27;
      SalesLine@1008 : Record 37;
      PurchHeader@1002 : Record 38;
      SalesHeader@1011 : Record 36;
      PurchQty@1000 : Decimal;
      ExpectedPurchQty@1003 : Decimal;
    BEGIN
      // Setup: Create Item.
      Initialize;
      LibraryInventory.CreateItem(Item);

      // Setup: Create and post Purchase Order
      PurchQty := LibraryRandom.RandDec(10,2) * 10;
      CreatePurchaseOrder(PurchHeader,Item."No.",PurchQty);
      LibraryPurchase.PostPurchaseDocument(PurchHeader,TRUE,TRUE);

      // Setup: Auto-reserve for Sales Order.
      AutoReserveForSalesOrder(SalesHeader,Item."No.",WORKDATE,PurchQty - 1);
      ExpectedPurchQty := PurchQty - 1;

      // Exercise: Generate the Sales Reservation Avail. report with Show Sales Line & Reservation Entries & Modify Qty. to Ship In Order Lines.
      COMMIT;
      RunSalesReservationAvailReport(SalesHeader."No.",TRUE,TRUE,TRUE);

      // Verify: Check the Quantity On Hand(Base) in the report.
      VerifySalesReservationAvailReport(SalesLine,SalesHeader."No.",ExpectedPurchQty,FullShipmentValueTxt);

      // Verify: Check Qty. to Ship in Sales Line.
      Assert.AreEqual(ExpectedPurchQty,SalesLine."Qty. to Ship",MsgQtytoShipErr);
    END;

    [Test]
    [HandlerFunctions(SalesResAvailRequestPageHandler,PurchResAvailRequestPageHandler)]
    PROCEDURE SalesReservationAvailReportFullReservFromPurchOrder@70();
    VAR
      Item@1007 : Record 27;
      SalesLine@1006 : Record 37;
      PurchHeader@1005 : Record 38;
      SalesHeader@1004 : Record 36;
      PurchQty@1003 : Decimal;
    BEGIN
      // Setup: Create Item.
      Initialize;
      LibraryInventory.CreateItem(Item);

      // Setup: Create and post Purchase Order.
      PurchQty := LibraryRandom.RandDec(10,2) * 10;
      CreatePurchaseOrder(PurchHeader,Item."No.",PurchQty);

      // Setup: Auto-reserve for Sales Order.
      AutoReserveForSalesOrder(SalesHeader,Item."No.",CALCDATE('<+5D>',WORKDATE),PurchQty - 1);

      // Exercise1: Generate the Sales Reservation Avail. report with Show Sales Line & Reservation Entries & Modify Qty. to Ship In Order Lines.
      COMMIT;
      RunSalesReservationAvailReport(SalesHeader."No.",TRUE,TRUE,TRUE);

      // Verify: Check the Quantity On Hand(Base) in the Sales Reservation Avail. Report.
      VerifySalesReservationAvailReport(SalesLine,SalesHeader."No.",0,NoShipmentValueTxt);

      // Verify: Check Qty. to Ship in Sales Line.
      Assert.AreEqual(0,SalesLine."Qty. to Ship",MsgQtytoShipErr);

      // Exercise2: Generate the Purchase Reservation Avail. report with Show Sales Line & Reservation Entries & Modify Qty. to Ship In Order Lines.
      COMMIT;
      RunPurchReserveAvailReport(PurchHeader."No.",TRUE,TRUE,TRUE);

      // Verify: Check Qty. to Ship in Purchase Line.
      VerifyQtyToReceiveInPurchLine(PurchHeader);
    END;

    [Test]
    [HandlerFunctions(SalesResAvailRequestPageHandler,PurchResAvailRequestPageHandler)]
    PROCEDURE SalesReservationAvailReportReserveFromDifSupplyType@74();
    VAR
      Item@1007 : Record 27;
      SalesLine@1006 : Record 37;
      PurchHeader@1005 : ARRAY [3] OF Record 38;
      SalesHeader@1004 : Record 36;
      PurchQty@1003 : Decimal;
      ExpectedPurchQty@1000 : Decimal;
    BEGIN
      // Setup: Create Item. Create three Purchase Order and post two of them. Create Sales Order. Auto-reserve Item.
      Initialize;
      LibraryInventory.CreateItem(Item);

      // Setup: Create three Purchase Order and post two of them.
      PurchQty := LibraryRandom.RandDec(10,2) * 10;
      CreatePurchaseOrder(PurchHeader[1],Item."No.",PurchQty);
      CreatePurchaseOrder(PurchHeader[2],Item."No.",PurchQty);
      CreatePurchaseOrder(PurchHeader[3],Item."No.",PurchQty);
      LibraryPurchase.PostPurchaseDocument(PurchHeader[1],TRUE,TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchHeader[2],TRUE,TRUE);

      // Setup: Auto-reserve for Sales Order.
      AutoReserveForSalesOrder(SalesHeader,Item."No.",CALCDATE('<+7D>',WORKDATE),3 * PurchQty - 1);
      ExpectedPurchQty := 2 * PurchQty;
      // Exercise1: Generate the Sales Reservation Avail. report with Show Sales Line & Reservation Entries & Modify Qty. to Ship In Order Lines.
      COMMIT;
      RunSalesReservationAvailReport(SalesHeader."No.",TRUE,TRUE,TRUE);

      // Verify: Check the Quantity On Hand(Base) in the report.
      VerifySalesReservationAvailReport(SalesLine,SalesHeader."No.",ExpectedPurchQty,PartialShipmentValueTxt);

      // Verify: Check Qty. to Ship in Sales Line.
      Assert.AreEqual(ExpectedPurchQty,SalesLine."Qty. to Ship",MsgQtytoShipErr);

      // Exercise2: Generate the Purchase Reservation Avail. report with Show Sales Line & Reservation Entries & Modify Qty. to Ship In Order Lines.
      COMMIT;
      RunPurchReserveAvailReport(PurchHeader[3]."No.",TRUE,TRUE,TRUE);

      // Verify: Check Qty. to Receive in Purchase Line.
      VerifyQtyToReceiveInPurchLine(PurchHeader[3]);
    END;

    [Test]
    [HandlerFunctions(PriceListRequestPageHandler)]
    PROCEDURE PriceListReportVariant@85();
    VAR
      Item@1009 : Record 27;
      SalesPrice@1007 : Record 7002;
      ItemVariant1@1006 : Record 5401;
      ItemVariant2@1005 : Record 5401;
      SalesType@1004 : 'Customer,Customer Price Group,All Customers,Campaign';
      CustomerNo@1003 : Code[20];
      MinimumQty@1002 : ARRAY [4] OF Decimal;
      UnitPrice@1001 : ARRAY [2] OF Decimal;
      LineDiscount@1000 : ARRAY [2] OF Decimal;
      i@1008 : Integer;
    BEGIN
      // 1. Setup: Create Item with Variant Code, Sales Price & Line Discount.
      Initialize;
      CustomerNo := LibrarySales.CreateCustomerNo;
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      UpdateItem(Item,Item.FIELDNO("Unit Price"),LibraryRandom.RandDec(100,2));

      LibraryInventory.CreateItemVariant(ItemVariant1,Item."No.");
      LibraryInventory.CreateItemVariant(ItemVariant2,Item."No.");

      FOR i := 1 TO 4 DO
        MinimumQty[i] := LibraryRandom.RandDec(10,2);

      FOR i := 1 TO 2 DO BEGIN
        UnitPrice[i] := LibraryRandom.RandDec(100,2);
        LineDiscount[i] := LibraryRandom.RandDec(99,2);
      END;

      CreateSalesPriceForItem(
        Item,SalesPrice."Sales Type"::Customer,CustomerNo,ItemVariant1.Code,MinimumQty[1],UnitPrice[1]);
      CreateSalesPriceForItem(
        Item,SalesPrice."Sales Type"::Customer,CustomerNo,ItemVariant1.Code,MinimumQty[2],UnitPrice[2]);

      CreateSalesLineDiscountForItem(Item,CustomerNo,ItemVariant2.Code,MinimumQty[3],LineDiscount[1]);
      CreateSalesLineDiscountForItem(Item,CustomerNo,ItemVariant2.Code,MinimumQty[4],LineDiscount[2]);

      // 2. Execise: Generate Price List Report.
      COMMIT;
      RunPriceListReport(Item."No.",SalesType::Customer,CustomerNo,'');

      // 3. Verify: Check Variant lines in Price List Report.
      LibraryReportDataset.LoadDataSetFile;

      VerifyVariantLineInPriceListReport(
        'ItemNo_Variant_SalesPrices',ItemVariant1.Code,'MinimumQty_Variant_SalesPrices',MinimumQty[1],
        'UnitPrince_Variant_SalesPrices',UnitPrice[1]);
      VerifyVariantLineInPriceListReport(
        'ItemNo_Variant_SalesPrices',ItemVariant1.Code,'MinimumQty_Variant_SalesPrices',MinimumQty[2],
        'UnitPrince_Variant_SalesPrices',UnitPrice[2]);
      VerifyVariantLineInPriceListReport(
        'ItemNo_Variant_SalesLineDescs',ItemVariant2.Code,'MinimumQty_Variant_SalesLineDescs',MinimumQty[3],
        'LineDisc_Variant_SalesLineDescs',LineDiscount[1]);
      VerifyVariantLineInPriceListReport(
        'ItemNo_Variant_SalesLineDescs',ItemVariant2.Code,'MinimumQty_Variant_SalesLineDescs',MinimumQty[4],
        'LineDisc_Variant_SalesLineDescs',LineDiscount[2]);
    END;

    [Test]
    [HandlerFunctions(PostProductionJournalHandler,ProductionJournalPostingMessageHandler,ConfirmHandler,RequestPageHandler)]
    PROCEDURE ZeroLineNotDisplayedInInventoryValuationWIPReport@90();
    VAR
      ProdOrderArray@1000 : ARRAY [3] OF Code[10];
    BEGIN
      // Setup
      ChangeThreeReleasedProdOrdersToFinished(ProdOrderArray);

      // Exercise
      LibraryCosting.AdjustCostItemEntries('','');
      LibraryCosting.PostInvtCostToGL(FALSE,WORKDATE,'');

      // Verify: Starting Date and Ending Date is work correctly in Inventory Valuation WIP report.
      COMMIT;
      RunInventoryValuationWIPReportWithTimePeriod(CALCDATE('<-1M-1D>',WORKDATE),CALCDATE('<-1D>',WORKDATE),ProdOrderArray);
      ValidateInventoryValuationWIPReport(ProdOrderArray);
    END;

    [Test]
    [HandlerFunctions(PostInvtCostToGLRequestPageHandler,InventoryValuationWIPRequestPageHandler)]
    PROCEDURE CostPostedToGLShownInWIPReport@92();
    VAR
      Item@1000 : Record 27;
      RoutingHeader@1005 : Record 99000763;
      ProductionOrder@1002 : Record 5405;
      ProductionBOMHeader@1011 : Record 99000771;
      ValueEntry@1001 : Record 5802;
      PostMethod@1003 : 'per Posting Group,per Entry';
      ChildItemNo@1009 : Code[20];
      ChildItemNo2@1010 : Code[20];
      CostPostedToGL@1004 : Decimal;
    BEGIN
      // Setup: Create Production Order Setup.
      Initialize;
      ItemJournalSetup(ItemJournalBatch);
      ChildItemNo := CreateChildItemWithInventory(ItemJournalBatch);
      ChildItemNo2 := CreateChildItemWithInventory(ItemJournalBatch);

      // Setup: Create Production BOM.
      LibraryManufacturing.CreateCertifProdBOMWithTwoComp(ProductionBOMHeader,ChildItemNo,ChildItemNo2,1);

      // Setup: Create Parent Item and attach Routing and Production BOM.
      CreateRoutingSetup(RoutingHeader);
      CreateItem(Item,RoutingHeader."No.",ProductionBOMHeader."No.",Item."Manufacturing Policy"::"Make-to-Order");

      // Setup: Create a Production Order and post Output.
      CreateAndRefreshRelProdOrder(ProductionOrder,ProductionOrder."Source Type"::Item,Item."No.",RANDOM(5));
      ExplodeAndPostOutputJournal(Item."No.",ProductionOrder."No.");

      // Setup: Post consumptions in the next month.
      WORKDATE := CALCDATE('<+1M>',WORKDATE);
      CalculateAndPostConsumption(ProductionOrder);
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

      // Setup: Run Adjust Cost Item Entries batch job and Run Post Inventory Cost to G/L.
      LibraryCosting.AdjustCostItemEntries('','');
      PostInventoryCostToGLRun(PostMethod::"per Entry",TRUE);

      // Exercise: Run WIP report.
      LibraryVariableStorage.Enqueue(CALCDATE('<-1M>',WORKDATE));
      LibraryVariableStorage.Enqueue(CALCDATE('<-1M+CM>',WORKDATE));
      REPORT.RUN(REPORT::"Inventory Valuation - WIP",TRUE,FALSE,ProductionOrder);

      // Verify: Check the value of Cost Posted to G/L column.
      ValueEntry.SETRANGE("Posting Date",CALCDATE('<-1M>',WORKDATE),CALCDATE('<-1M+CM>',WORKDATE));
      ValueEntry.SETRANGE("Source No.",Item."No.");
      ValueEntry.FINDSET;
      REPEAT
        CostPostedToGL += ValueEntry."Cost Posted to G/L";
      UNTIL ValueEntry.NEXT = 0;

      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('SourceNo_ProductionOrder',Item."No.");
      IF LibraryReportDataset.GetNextRow THEN
        LibraryReportDataset.AssertCurrentRowValue('ValueEntryCostPostedtoGL',-CostPostedToGL);
    END;

    [Test]
    [HandlerFunctions(RolledUpCostSharesRequestPageHandler)]
    PROCEDURE RolledUpCostShareRepWithUnderDevelopmentStatus@79();
    VAR
      ProductionBOMVersion@1001 : Record 99000779;
    BEGIN
      // Run the Rolled Up Cost Shares report and check the item on report when one component is delete from Production BOM Version with Under Development status.
      RolledUpCostShareReportWithStatus(ProductionBOMVersion.Status::"Under Development");
    END;

    [Test]
    [HandlerFunctions(RolledUpCostSharesRequestPageHandler)]
    PROCEDURE RolledUpCostShareRepWithCertifiedStatus@207();
    VAR
      ProductionBOMVersion@1001 : Record 99000779;
    BEGIN
      // Run the Rolled Up Cost Shares report and check the item on report when one component is delete from Production BOM Version with certified status.
      RolledUpCostShareReportWithStatus(ProductionBOMVersion.Status::Certified);
    END;

    [Test]
    [HandlerFunctions(RolledUpCostSharesRequestPageHandler)]
    PROCEDURE RolledUpCostShareRepWithUnderDevStatusWithProdBOM@95();
    VAR
      ProductionBOMHeader@1000 : Record 99000771;
    BEGIN
      // Run the Rolled Up Cost Shares report with type Production BOM and check the item on report when one component is delete from Production BOM Version with Under Development status.
      RolledUpCostShareReportWithTypeProdBOM(ProductionBOMHeader.Status::"Under Development");
    END;

    [Test]
    [HandlerFunctions(RolledUpCostSharesRequestPageHandler)]
    PROCEDURE RolledUpCostShareRepWithCertifiedStatusWithTypeProdBOM@96();
    VAR
      ProductionBOMHeader@1000 : Record 99000771;
    BEGIN
      // Run the Rolled Up Cost Shares report with type Production BOM and check the item on report when one component is delete from Production BOM Version with Certified status.
      RolledUpCostShareReportWithTypeProdBOM(ProductionBOMHeader.Status::Certified);
    END;

    [Test]
    [HandlerFunctions(InventoryValuationWIPRequestPageHandler)]
    PROCEDURE AsOfValueInInventoryValuationWIPReport@192();
    VAR
      Item@1000 : Record 27;
      ComponentItem@1006 : Record 27;
      ProductionOrder@1002 : Record 5405;
      ProdOrderLine@1008 : Record 5406;
      ItemJournalLine@1007 : Record 83;
      Quantity@1005 : Decimal;
      ConsumptionQty@1001 : ARRAY [3] OF Decimal;
      OutputQty@1003 : ARRAY [3] OF Decimal;
      PostingDate@1004 : ARRAY [3] OF Date;
      i@1009 : Integer;
      Number@1010 : Integer;
    BEGIN
      // Setup: Create Component Item and Production Item, and update Inventory.
      Initialize;
      CreateItem(ComponentItem,'','',ComponentItem."Manufacturing Policy"::"Make-to-Stock");
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      ItemJournalSetup(ItemJournalBatch);
      Quantity := 4 * LibraryRandom.RandIntInRange(1,10);
      PostItemPositiveAdjmt(ItemJournalBatch,ItemJournalLine."Entry Type"::"Positive Adjmt.",ComponentItem."No.",Quantity);

      // Create a Production Order.
      CreateAndRefreshRelProdOrder(ProductionOrder,ProductionOrder."Source Type"::Item,Item."No.",Quantity);

      // Post Consumption and Output in different period.
      Number := LibraryRandom.RandIntInRange(1,10);
      PostingDate[1] := WORKDATE;
      PostingDate[2] := CALCDATE('<' + FORMAT(Number) + 'D>',WORKDATE);
      PostingDate[3] := CALCDATE('<' + FORMAT(2 * Number) + 'D>',WORKDATE);
      ConsumptionQty[1] := Quantity / 4;
      ConsumptionQty[2] := 3 * Quantity / 4;
      ConsumptionQty[3] := 0;
      OutputQty[1] := Quantity / 2;
      OutputQty[2] := Quantity / 4;
      OutputQty[3] := Quantity / 4;
      FindProdOrderLine(ProdOrderLine,ProductionOrder.Status,ProductionOrder."No.");
      FOR i := 1 TO 3 DO
        PostConsumptionAndOutput(ProdOrderLine,ComponentItem,Item."Unit Cost",ConsumptionQty[i],OutputQty[i],PostingDate[i]);

      // Finish the Production Order.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

      // Run Adjust Cost Item Entries batch job
      LibraryCosting.AdjustCostItemEntries('','');
      COMMIT; // To avoid test failure.

      // Exercise: Run Inventory Valuation - WIP report.
      RunInventoryValuationWIPReport(ProductionOrder,CALCDATE('<+1D>',WORKDATE),CALCDATE('<' + FORMAT(Number + 1) + 'D>',WORKDATE));

      // Verify: Verify "As of..." value is correct in report Inventory Valuation - WIP
      LibraryReportDataset.LoadDataSetFile;
      VerifyVariantLineInPriceListReport(
        'SourceNo_ProductionOrder',Item."No.",'LastWIP',-ComponentItem."Unit Cost",'AtLastDate',ComponentItem."Unit Cost");
    END;

    [Test]
    [HandlerFunctions(InventoryAvailabilityRequestPageHandler)]
    PROCEDURE CheckInventoryAvailabilityReportForRequisitionLine@106();
    VAR
      Item@1000 : Record 27;
      Qty@1006 : Decimal;
    BEGIN
      // [FEATURE] [Inventory Availability]
      // [SCENARIO 363787] Planned Order Receipt and Projected Available Balance in Inventory Availability report is equal to Quantity of appropriate Requisition Line
      Initialize;

      // [GIVEN] Item with Inventory = 0
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Order");
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::Purchase);
      Item.MODIFY(TRUE);

      // [GIVEN] Requisition Line for Item with Quantity = "X"
      Qty := LibraryRandom.RandDec(10,2);
      CreateReqLine(Item."No.",Qty);

      // [WHEN] Run Inventory Availability report
      COMMIT;
      Item.SETRANGE("No.",Item."No.");
      REPORT.RUN(REPORT::"Inventory Availability",TRUE,FALSE,Item);

      // [THEN] Planned Order Receipt = "X", Projected Available Balance = "X"
      VerifyInventoryAvailabilityReport(Item."No.",Qty);
    END;

    [Test]
    [HandlerFunctions(DetailedCalculationRequestPageHandler)]
    PROCEDURE DetailedCalculationReportIncludesPhantomBOMComponents@101();
    VAR
      ParentItem@1000 : Record 27;
      ProdBOMHeaderParent@1001 : Record 99000771;
      ProdBOMHeaderChild@1004 : Record 99000771;
      ProductionBOMLine@1003 : Record 99000772;
      ProductionBomVersion@1002 : Record 99000779;
      ChildItem@1005 : Record 27;
    BEGIN
      // [FEATURE] [Manufacturing] [Production BOM] [Phantom BOM]
      // [SCENARIO 371942] Phantom BOM components should be included in the report "Detailed Calculation" when the phantom BOM is a part of the active BOM version

      // [GIVEN] Item "I1" with bill of materials "ParentBOM"
      LibraryInventory.CreateItem(ParentItem);
      LibraryManufacturing.CreateCertifiedProductionBOM(ProdBOMHeaderParent,LibraryInventory.CreateItemNo,1);
      ParentItem.VALIDATE("Production BOM No.",ProdBOMHeaderParent."No.");
      ParentItem.MODIFY(TRUE);

      // [GIVEN] Component item "I2"
      LibraryInventory.CreateItem(ChildItem);
      // [GIVEN] Bill of materials "Child BOM" that includes item "I2"
      LibraryManufacturing.CreateCertifiedProductionBOM(ProdBOMHeaderChild,ChildItem."No.",1);

      // [GIVEN] Version of the "ParentBOM" including the "ChildBOM" as a phantom BOM
      LibraryManufacturing.CreateProductionBOMVersion(
        ProductionBomVersion,ProdBOMHeaderParent."No.",LibraryUtility.GenerateGUID,ProdBOMHeaderParent."Unit of Measure Code");
      LibraryManufacturing.CreateProductionBOMLine(
        ProdBOMHeaderParent,ProductionBOMLine,ProductionBomVersion."Version Code",
        ProductionBOMLine.Type::"Production BOM",ProdBOMHeaderChild."No.",1);
      ProductionBomVersion.VALIDATE(Status,ProductionBomVersion.Status::Certified);
      ProductionBomVersion.MODIFY(TRUE);

      // [WHEN] Run report "Detailed Calculation" for item "I1"
      COMMIT;
      ParentItem.SETRECFILTER;
      REPORT.RUN(REPORT::"Detailed Calculation",TRUE,FALSE,ParentItem);

      // [THEN] Item "I2" is reported in the list of components
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.AssertElementWithValueExists('ProdBOMLineLevelNo',ChildItem."No.");
    END;

    [Test]
    PROCEDURE PhantomBOMScrapIncludedInCostSharesReport@254();
    VAR
      Item@1000 : ARRAY [2] OF Record 27;
      ProductionBOMHeader@1003 : ARRAY [2] OF Record 99000771;
      ProductionBOMLine@1004 : Record 99000772;
      TempBOMBuffer@1006 : TEMPORARY Record 5870;
      QtyPerBOMLine@1001 : Integer;
      ScrapPct@1007 : Integer;
    BEGIN
      // [FEATURE] [Production BOM] [Phantom BOM] [Scrap] [Cost Shares]
      // [SCENARIO 378057] When generating "Cost Shares" report, scrap % in a phantom BOM line is included in calculation

      // [GIVEN] Component item "I1" with unit cost 10
      CreateItem(Item[1],'','',Item[2]."Manufacturing Policy"::"Make-to-Stock");

      // [GIVEN] Production BOM "B1" with one component "I1"
      CreateCertifiedProductionBOM(ProductionBOMHeader[1],Item[1]."Base Unit of Measure",ProductionBOMLine.Type::Item,Item[1]."No.",1);

      // [GIVEN] Production BOM "B2" which includes BOM "B1" as a phantom BOM. Set "Scrap %" = 5 in prod. BOM line, "Qty. per" = 1
      QtyPerBOMLine := LibraryRandom.RandInt(10);
      ScrapPct := LibraryRandom.RandIntInRange(5,10);
      CreateCertifiedProdBOMWithScrap(
        ProductionBOMHeader[2],Item[1]."Base Unit of Measure",ProductionBOMLine.Type::"Production BOM",ProductionBOMHeader[1]."No.",
        QtyPerBOMLine,ScrapPct);

      // [GIVEN] Manufactured item "I2" with BOM "B2"
      CreateItem(Item[2],'',ProductionBOMHeader[2]."No.",Item[2]."Manufacturing Policy"::"Make-to-Stock");

      // [WHEN] Generate "Cost Shares" report for item "I2"
      GenerateBOMCostTree(Item[2],TempBOMBuffer);

      // [THEN] In the component line, "Scrap Qty. per Parent" = 0,05, "Qty. per Parent" = 1,05, "Rolled-up Material Cost" = 10,5
      VerifyBOMBuffer(TempBOMBuffer,Item[1],QtyPerBOMLine,QtyPerBOMLine * ScrapPct / 100);
    END;

    [Test]
    PROCEDURE PhantomBOMScrapIncludedInCostSharesReportMultilevelBOM@116();
    VAR
      Item@1000 : ARRAY [2] OF Record 27;
      ProductionBOMHeader@1003 : ARRAY [3] OF Record 99000771;
      ProductionBOMLine@1004 : Record 99000772;
      TempBOMBuffer@1006 : TEMPORARY Record 5870;
      Scrap@1001 : ARRAY [2] OF Integer;
      QtyPer@1007 : ARRAY [2] OF Integer;
      TotalScrapQty@1008 : Decimal;
    BEGIN
      // [FEATURE] [Production BOM] [Phantom BOM] [Scrap] [Cost Shares]
      // [SCENARIO 378057] When generating "Cost Shares" report for a multilevel phantom BOM, scrap % in all phantom BOM lines is included in calculation

      // [GIVEN] Component item "I1" with unit cost 10
      CreateItem(Item[1],'','',Item[1]."Manufacturing Policy"::"Make-to-Stock");

      // [GIVEN] Production BOM "B1" with one component "I1"
      CreateCertifiedProductionBOM(ProductionBOMHeader[1],Item[1]."Base Unit of Measure",ProductionBOMLine.Type::Item,Item[1]."No.",1);

      // [GIVEN] Production BOM "B2" which includes BOM "B1" as a phantom BOM. Set "Scrap %" = 5 in prod. BOM line, "Qty. per" = 1
      QtyPer[1] := LibraryRandom.RandInt(50);
      Scrap[1] := LibraryRandom.RandIntInRange(10,20);
      CreateCertifiedProdBOMWithScrap(
        ProductionBOMHeader[2],Item[1]."Base Unit of Measure",
        ProductionBOMLine.Type::"Production BOM",ProductionBOMHeader[1]."No.",QtyPer[1],Scrap[1]);

      // [GIVEN] Production BOM "B3" which includes BOM "B2" as a phantom BOM. Set "Scrap %" = 5 in prod. BOM line, "Qty. per" = 1
      QtyPer[2] := LibraryRandom.RandInt(50);
      Scrap[2] := LibraryRandom.RandIntInRange(10,20);
      CreateCertifiedProdBOMWithScrap(
        ProductionBOMHeader[3],Item[1]."Base Unit of Measure",
        ProductionBOMLine.Type::"Production BOM",ProductionBOMHeader[2]."No.",QtyPer[2],Scrap[2]);

      // [GIVEN] Manufactured item "I2" with BOM "B3"
      CreateItem(Item[2],'',ProductionBOMHeader[3]."No.",Item[2]."Manufacturing Policy"::"Make-to-Stock");

      // [WHEN] Generate "Cost Shares" report for item "I2"
      GenerateBOMCostTree(Item[2],TempBOMBuffer);

      // [THEN] In the component line, "Scrap Qty. per Parent" = 0,1025, "Qty. per Parent" = 1,1025, "Rolled-up Material Cost" = 11,025
      TotalScrapQty := QtyPer[1] * QtyPer[2] * (Scrap[1] + Scrap[2] + Scrap[1] * Scrap[2] / 100) / 100;
      VerifyBOMBuffer(TempBOMBuffer,Item[1],QtyPer[1] * QtyPer[2],TotalScrapQty);
    END;

    [Test]
    PROCEDURE MultilevelPhantomBOMWithDifferentUOM@46();
    VAR
      Item@1000 : ARRAY [2] OF Record 27;
      ProductionBOMHeader@1003 : ARRAY [3] OF Record 99000771;
      ProductionBOMLine@1004 : Record 99000772;
      TempBOMBuffer@1006 : TEMPORARY Record 5870;
      ItemUnitOfMeasure@1001 : Record 5404;
      I@1002 : Integer;
      QtyPer@1007 : ARRAY [3] OF Integer;
    BEGIN
      // [FEATURE] [Production BOM] [Phantom BOM] [Unit of Measure] [Cost Shares]
      // [SCENARIO 378057] When generating "Cost Shares" report for a multilevel phantom BOM with different UoMs on BOM levels, unit of measure is considered in calculation

      // [GIVEN] Component item "I1"
      CreateItem(Item[1],'','',Item[1]."Manufacturing Policy"::"Make-to-Stock");

      FOR I := 1 TO ARRAYLEN(QtyPer) DO
        QtyPer[I] := LibraryRandom.RandInt(50);

      // [GIVEN] Production BOM "B1" with one component "I1", "Qty. per" = "X"
      CreateCertifiedProductionBOM(
        ProductionBOMHeader[1],Item[1]."Base Unit of Measure",ProductionBOMLine.Type::Item,Item[1]."No.",QtyPer[1]);

      // [GIVEN] Production BOM "B2" which includes BOM "B1" as a phantom BOM. Set "Qty. per" = "Y", unit of measure = "U1"
      CreateCertifiedProductionBOM(
        ProductionBOMHeader[2],Item[1]."Base Unit of Measure",
        ProductionBOMLine.Type::"Production BOM",ProductionBOMHeader[1]."No.",QtyPer[2]);

      // [GIVEN] Production BOM "B3" and manufactured item "I2" with BOM "B3", "Qty. per" = "Z"
      // [GIVEN] Create item unit of measure "U2" with "quantity per" = "Q", set it a UoM for production BOM "B3"
      CreateItem(Item[2],'','',Item[2]."Manufacturing Policy"::"Make-to-Stock");
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,Item[2]."No.",LibraryRandom.RandIntInRange(5,10));
      CreateCertifiedProductionBOM(
        ProductionBOMHeader[3],ItemUnitOfMeasure.Code,
        ProductionBOMLine.Type::"Production BOM",ProductionBOMHeader[2]."No.",QtyPer[3]);
      UpdateProdBOMCodeOnItem(Item[2],ProductionBOMHeader[3]."No.");

      // [WHEN] Generate "Cost Shares" report for item "I2"
      GenerateBOMCostTree(Item[2],TempBOMBuffer);

      // [THEN] In the component line, "Qty. per Parent" = "X" * "Y" * "Z" / "Q"
      VerifyBOMBuffer(
        TempBOMBuffer,Item[1],
        ROUND(QtyPer[1] * QtyPer[2] * QtyPer[3] / ItemUnitOfMeasure."Qty. per Unit of Measure",0.00001),0);
    END;

    [Test]
    PROCEDURE MultilevelPhantomBOMWithBOMVersion@136();
    VAR
      Item@1000 : ARRAY [2] OF Record 27;
      ProductionBOMHeader@1003 : ARRAY [3] OF Record 99000771;
      ProductionBOMVersion@1001 : Record 99000779;
      ProductionBOMLine@1004 : Record 99000772;
      ItemUnitOfMeasure@1008 : Record 5404;
      TempBOMBuffer@1006 : TEMPORARY Record 5870;
      I@1002 : Integer;
      QtyPer@1007 : ARRAY [3] OF Integer;
    BEGIN
      // [FEATURE] [Production BOM] [Phantom BOM] [Unit of Measure] [Cost Shares] [BOM Version]
      // [SCENARIO 378057] When generating "Cost Shares" report for a multilevel phantom BOM with different UoMs on BOM levels, unit of measure is taken from active BOM version

      // [GIVEN] Component item "I1"
      CreateItem(Item[1],'','',Item[1]."Manufacturing Policy"::"Make-to-Stock");

      FOR I := 1 TO ARRAYLEN(QtyPer) DO
        QtyPer[I] := LibraryRandom.RandInt(50);

      // [GIVEN] Production BOM "B1" with one component "I1", "Qty. per" = "X1"
      CreateCertifiedProductionBOM(
        ProductionBOMHeader[1],Item[1]."Base Unit of Measure",ProductionBOMLine.Type::Item,Item[1]."No.",QtyPer[1]);

      // [GIVEN] Create active BOM version for production BOM "B1", set "Qty. per" = "X2"
      CreateCertifiedProdBOMVersion(ProductionBOMVersion,ProductionBOMHeader[1],Item[1]."Base Unit of Measure");

      // [GIVEN] Production BOM "B2" which includes BOM "B1" as a phantom BOM. Set "Qty. per" = "Y", unit of measure = "U1"
      CreateCertifiedProductionBOM(
        ProductionBOMHeader[2],Item[1]."Base Unit of Measure",
        ProductionBOMLine.Type::"Production BOM",ProductionBOMHeader[1]."No.",QtyPer[2]);

      // [GIVEN] Production BOM "B3" and manufactured item "I2" with BOM "B3", "Qty. per" = "Z"
      // [GIVEN] Create item unit of measure "U2" with "quantity per" = "Q", set it a UoM for production BOM "B3"
      CreateItem(Item[2],'','',Item[2]."Manufacturing Policy"::"Make-to-Stock");
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,Item[2]."No.",LibraryRandom.RandIntInRange(10,20));
      CreateCertifiedProductionBOM(
        ProductionBOMHeader[3],ItemUnitOfMeasure.Code,
        ProductionBOMLine.Type::"Production BOM",ProductionBOMHeader[2]."No.",QtyPer[3]);
      UpdateProdBOMCodeOnItem(Item[2],ProductionBOMHeader[3]."No.");

      // [WHEN] Generate "Cost Shares" report for item "I2"
      GenerateBOMCostTree(Item[2],TempBOMBuffer);

      // [THEN] In the component line, "Qty. per Parent" = "X2" * "Y" * "Z" / "Q"
      VerifyBOMBuffer(
        TempBOMBuffer,Item[1],
        ROUND(QtyPer[1] * QtyPer[2] * QtyPer[3] / ItemUnitOfMeasure."Qty. per Unit of Measure",0.00001),0);
    END;

    [Test]
    PROCEDURE MultilevelBOMWithDifferentUOMAndMultipleLines@26();
    VAR
      Item@1006 : ARRAY [3] OF Record 27;
      ProductionBOMHeader@1005 : ARRAY [3] OF Record 99000771;
      ProductionBOMLine@1004 : Record 99000772;
      TempBOMBuffer@1003 : TEMPORARY Record 5870;
      ItemUnitOfMeasure@1002 : ARRAY [2] OF Record 5404;
    BEGIN
      // [FEATURE] [Production BOM]  [Unit of Measure]
      // [SCENARIO 379112] When generating BOM tree for a multilevel BOM with different UoMs on BOM levels, unit of measure should be taken from Base Unit of Measure.
      Initialize;

      // [GIVEN] Component item "I1" with Production BOM "B1" and base UoM = "X"
      CreateItemWithProductionBOM(Item[1]);

      // [GIVEN] Item "ParentItem" with base UoM = "Y"
      CreateItemWithUpdatedBaseUnitOfMeasure(ItemUnitOfMeasure[1],Item[2],'','',Item[2]."Manufacturing Policy"::"Make-to-Stock");

      // [GIVEN] Component item "I3" with base UoM = "Z"
      CreateItemWithUpdatedBaseUnitOfMeasure(ItemUnitOfMeasure[2],Item[3],'','',Item[3]."Manufacturing Policy"::"Make-to-Stock");

      // [GIVEN] Production BOM "B2" with component items "I1" and "I3".
      CreateCertifiedProductionBOMWithMultipleLines(ProductionBOMHeader[2],ItemUnitOfMeasure[1].Code,
        ItemUnitOfMeasure[2].Code,ProductionBOMLine.Type::Item,Item[1]."No.",1,Item[3]."No.",ProductionBOMLine.Type::Item);
      UpdateProdBOMCodeOnItem(Item[2],ProductionBOMHeader[2]."No.");

      // [WHEN] Generate BOM tree for ParentItem
      GenerateBOMCostTree(Item[2],TempBOMBuffer);

      // [THEN] In the component line with item "I3" Unit of Measure Code = "X"
      TempBOMBuffer.SETRANGE("No.",Item[3]."No.");
      TempBOMBuffer.FINDFIRST;
      TempBOMBuffer.TESTFIELD("Unit of Measure Code",Item[3]."Base Unit of Measure");
    END;

    [Test]
    PROCEDURE RoutingScrapConsideredInCostSharesForPhantomBOM@110();
    VAR
      Item@1000 : ARRAY [2] OF Record 27;
      ProductionBOMHeader@1003 : ARRAY [2] OF Record 99000771;
      ProductionBOMLine@1004 : Record 99000772;
      TempBOMBuffer@1006 : TEMPORARY Record 5870;
      RoutingHeader@1002 : Record 99000763;
      QtyPerBOMLine@1001 : Integer;
      ScrapPct@1007 : Integer;
    BEGIN
      // [FEATURE] [Production BOM] [Phantom BOM] [Scrap] [Cost Shares] [Routing]
      // [SCENARIO 378260] When generating "Cost Shares" for a phantom BOM, scrap % in a routing line is included in calculation

      // [GIVEN] Component item "I1" with unit cost 10
      CreateItem(Item[1],'','',Item[2]."Manufacturing Policy"::"Make-to-Stock");

      // [GIVEN] Production BOM "B1" with one component "I1"
      CreateCertifiedProductionBOM(ProductionBOMHeader[1],Item[1]."Base Unit of Measure",ProductionBOMLine.Type::Item,Item[1]."No.",1);

      // [GIVEN] Production BOM "B2" which includes BOM "B1" as a phantom BOM. Set "Qty. per" = 1
      QtyPerBOMLine := LibraryRandom.RandInt(10);
      ScrapPct := LibraryRandom.RandIntInRange(5,10);
      CreateCertifiedProductionBOM(
        ProductionBOMHeader[2],Item[1]."Base Unit of Measure",ProductionBOMLine.Type::"Production BOM",ProductionBOMHeader[1]."No.",
        QtyPerBOMLine);

      // [GIVEN] Manufactured item "I2" with BOM "B2" and routing "R". Routing line has 5% scrap
      CreateRoutingWithScrap(RoutingHeader,ScrapPct);
      CreateItem(Item[2],RoutingHeader."No.",ProductionBOMHeader[2]."No.",Item[2]."Manufacturing Policy"::"Make-to-Stock");

      // [WHEN] Generate "Cost Shares" report for item "I2"
      GenerateBOMCostTree(Item[2],TempBOMBuffer);

      // [THEN] In the component line, "Scrap Qty. per Parent" = 0,05, "Qty. per Parent" = 1,05, "Rolled-up Material Cost" = 10,5
      VerifyBOMBuffer(TempBOMBuffer,Item[1],QtyPerBOMLine,QtyPerBOMLine * ScrapPct / 100);
    END;

    [Test]
    PROCEDURE RoutingAndBOMScrapConsideredInCostSharesForPhantomBOM@114();
    VAR
      Item@1000 : ARRAY [2] OF Record 27;
      ProductionBOMHeader@1003 : ARRAY [2] OF Record 99000771;
      ProductionBOMLine@1004 : Record 99000772;
      TempBOMBuffer@1006 : TEMPORARY Record 5870;
      RoutingHeader@1002 : Record 99000763;
      QtyPerBOMLine@1001 : Integer;
      ScrapPct@1007 : Integer;
    BEGIN
      // [FEATURE] [Production BOM] [Phantom BOM] [Scrap] [Cost Shares] [Routing]
      // [SCENARIO 378260] When generating "Cost Shares" for a phantom BOM with scrap % in routing line and BOM line, both settings are included in calculation

      // [GIVEN] Component item "I1" with unit cost 10
      CreateItem(Item[1],'','',Item[2]."Manufacturing Policy"::"Make-to-Stock");

      // [GIVEN] Production BOM "B1" with one component "I1"
      CreateCertifiedProductionBOM(ProductionBOMHeader[1],Item[1]."Base Unit of Measure",ProductionBOMLine.Type::Item,Item[1]."No.",1);

      // [GIVEN] Production BOM "B2" which includes BOM "B1" as a phantom BOM. Set "Scrap %" = 5 in prod. BOM line, "Qty. per" = 1
      QtyPerBOMLine := LibraryRandom.RandInt(10);
      ScrapPct := LibraryRandom.RandIntInRange(5,10);
      CreateCertifiedProdBOMWithScrap(
        ProductionBOMHeader[2],Item[1]."Base Unit of Measure",ProductionBOMLine.Type::"Production BOM",ProductionBOMHeader[1]."No.",
        QtyPerBOMLine,ScrapPct);

      // [GIVEN] Manufactured item "I2" with BOM "B2" and routing "R". Routing line has 5% scrap
      CreateRoutingWithScrap(RoutingHeader,ScrapPct);
      CreateItem(Item[2],RoutingHeader."No.",ProductionBOMHeader[2]."No.",Item[2]."Manufacturing Policy"::"Make-to-Stock");

      // [WHEN] Generate "Cost Shares" report for item "I2"
      GenerateBOMCostTree(Item[2],TempBOMBuffer);

      // [THEN] In the component line, "Scrap Qty. per Parent" = 0,1025, "Qty. per Parent" = 1,1025, "Rolled-up Material Cost" = 11,025
      VerifyBOMBuffer(TempBOMBuffer,Item[1],QtyPerBOMLine,QtyPerBOMLine * ScrapPct * (2 + ScrapPct / 100) / 100);
    END;

    [Test]
    PROCEDURE DecimalRoutingAndBOMScrapInCostShares@111();
    VAR
      Item@1000 : ARRAY [2] OF Record 27;
      ProductionBOMHeader@1003 : ARRAY [2] OF Record 99000771;
      ProductionBOMLine@1004 : Record 99000772;
      TempBOMBuffer@1006 : TEMPORARY Record 5870;
      RoutingHeader@1002 : Record 99000763;
      QtyPerBOMLine@1001 : Integer;
      ScrapPct@1007 : Decimal;
    BEGIN
      // [FEATURE] [Production BOM] [Scrap] [Cost Shares] [Routing]
      // [SCENARIO 378260] "Cost Shares" report can be generated for an item which has scrap in both linked routing and production BOM, and scrap % is a decimal value

      // [GIVEN] Component item "I1" with unit cost 10
      CreateItem(Item[1],'','',Item[2]."Manufacturing Policy"::"Make-to-Stock");

      // [GIVEN] Production BOM "BOM" which includes item "I1" as a component. Set "Scrap %" = 5.1 in prod. BOM line, "Qty. per" = 1
      QtyPerBOMLine := LibraryRandom.RandInt(10);
      ScrapPct := LibraryRandom.RandDecInRange(5,10,1);
      CreateCertifiedProdBOMWithScrap(
        ProductionBOMHeader[2],Item[1]."Base Unit of Measure",ProductionBOMLine.Type::Item,Item[1]."No.",
        QtyPerBOMLine,ScrapPct);

      // [GIVEN] Manufactured item "I2" with BOM "B2" and routing "R". Routing line has 5.1 % scrap
      CreateRoutingWithScrap(RoutingHeader,ScrapPct);
      CreateItem(Item[2],RoutingHeader."No.",ProductionBOMHeader[2]."No.",Item[2]."Manufacturing Policy"::"Make-to-Stock");

      // [WHEN] Generate "Cost Shares" report for item "I2"
      GenerateBOMCostTree(Item[2],TempBOMBuffer);

      // [THEN] In the component line, "Scrap Qty. per Parent" = 0,1046, "Qty. per Parent" = 1,1046, "Rolled-up Material Cost" = 11,046
      VerifyBOMBuffer(TempBOMBuffer,Item[1],QtyPerBOMLine,QtyPerBOMLine * ScrapPct * (2 + ScrapPct / 100) / 100);
    END;

    LOCAL PROCEDURE Initialize@4();
    VAR
      LibraryERMCountryData@1003 : Codeunit 131305;
    BEGIN
      LibraryVariableStorage.Clear;

      IF isInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      isInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE CreateItem@45(VAR Item@1000 : Record 27;RoutingNo@1001 : Code[20];ProductionBOMNo@1003 : Code[20];ItemManufacturingPolicy@1005 : Option);
    BEGIN
      // Random value unimportant for test.
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::FIFO,LibraryRandom.RandDec(50,2),Item."Reordering Policy",
        Item."Flushing Method",RoutingNo,ProductionBOMNo);
      Item.VALIDATE("Manufacturing Policy",ItemManufacturingPolicy);
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::"Prod. Order");
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemWithUpdatedBaseUnitOfMeasure@104(VAR ItemUnitOfMeasure@1004 : Record 5404;VAR Item@1003 : Record 27;RoutingNo@1002 : Code[20];ProductionBOMNo@1001 : Code[20];ItemManufacturingPolicy@1000 : Option);
    VAR
      ItemUnitOfMeasure2@1005 : Record 5404;
    BEGIN
      CreateItem(Item,RoutingNo,ProductionBOMNo,ItemManufacturingPolicy);
      ItemUnitOfMeasure2.GET(Item."No.",Item."Base Unit of Measure");
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,Item."No.",1);
      Item.VALIDATE("Base Unit of Measure",ItemUnitOfMeasure.Code);
      Item.MODIFY(TRUE);
      ItemUnitOfMeasure2.DELETE(TRUE);
    END;

    LOCAL PROCEDURE UpdateItem@22(VAR Item@1000 : Record 27;FieldNo@1001 : Integer;Value@1002 : Variant);
    VAR
      RecRef@1003 : RecordRef;
      FieldRef@1004 : FieldRef;
    BEGIN
      // Update Item based on Field and its corresponding value.
      RecRef.GETTABLE(Item);
      FieldRef := RecRef.FIELD(FieldNo);
      FieldRef.VALIDATE(Value);
      RecRef.SETTABLE(Item);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateCertifiedProductionBOM@127(VAR ProductionBOMHeader@1000 : Record 99000771;UoMCode@1002 : Code[10];Type@1003 : Option;No@1004 : Code[20];QtyPer@1005 : Decimal);
    VAR
      ProductionBOMLine@1001 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UoMCode);
      LibraryManufacturing.CreateProductionBOMLine(ProductionBOMHeader,ProductionBOMLine,'',Type,No,QtyPer);
      UpdateProdBOMStatus(ProductionBOMHeader,ProductionBOMHeader.Status::Certified);
    END;

    LOCAL PROCEDURE CreateCertifiedProductionBOMWithMultipleLines@109(VAR ProductionBOMHeader@1004 : Record 99000771;UoMCode@1003 : Code[10];UoMCode2@1008 : Code[10];Type@1002 : Option;No@1001 : Code[20];QtyPer@1000 : Decimal;No2@1005 : Code[20];Type2@1006 : Option);
    VAR
      ProductionBOMLine@1007 : ARRAY [2] OF Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UoMCode);
      LibraryManufacturing.CreateProductionBOMLine(ProductionBOMHeader,ProductionBOMLine[1],'',Type,No,QtyPer);
      LibraryManufacturing.CreateProductionBOMLine(ProductionBOMHeader,ProductionBOMLine[2],'',Type2,No2,QtyPer);
      ProductionBOMLine[2].VALIDATE("Unit of Measure Code",UoMCode2);
      ProductionBOMLine[2].MODIFY(TRUE);
      UpdateProdBOMStatus(ProductionBOMHeader,ProductionBOMHeader.Status::Certified);
    END;

    LOCAL PROCEDURE CreateCertifiedProdBOMWithScrap@165(VAR ProductionBOMHeader@1000 : Record 99000771;UoMCode@1001 : Code[10];Type@1003 : Option;No@1004 : Code[20];QtyPer@1005 : Decimal;ScrapPct@1006 : Decimal);
    VAR
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UoMCode);
      CreateProdBOMLineWithScrap(ProductionBOMHeader,ProductionBOMLine,Type,No,QtyPer,ScrapPct);
    END;

    LOCAL PROCEDURE CreateCertifiedProdBOMVersion@143(VAR ProductionBOMVersion@1000 : Record 99000779;ProductionBOMHeader@1002 : Record 99000771;UoMCode@1003 : Code[10]);
    VAR
      ProductionBOMCopy@1004 : Codeunit 99000768;
    BEGIN
      LibraryManufacturing.CreateProductionBOMVersion(
        ProductionBOMVersion,ProductionBOMHeader."No.",LibraryUtility.GenerateGUID,UoMCode);

      ProductionBOMCopy.CopyBOM(ProductionBOMHeader."No.",'',ProductionBOMHeader,ProductionBOMVersion."Version Code");
      ProductionBOMVersion.VALIDATE(Status,ProductionBOMVersion.Status::Certified);
      ProductionBOMVersion.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE SelectCurrencyCode@28() : Code[10];
    VAR
      Currency@1001 : Record 4;
      CurrencyExchangeRate@1042 : Record 330;
      LibraryERM@1000 : Codeunit 131300;
    BEGIN
      LibraryERM.CreateCurrency(Currency);
      LibraryERM.CreateExchRate(CurrencyExchangeRate,Currency.Code,WORKDATE);

      // Using RANDOM Exchange Rate Amount and Adjustment Exchange Rate, between 100 and 400 (Standard Value).
      CurrencyExchangeRate.VALIDATE("Exchange Rate Amount",100 * LibraryRandom.RandInt(4));
      CurrencyExchangeRate.VALIDATE("Adjustment Exch. Rate Amount",CurrencyExchangeRate."Exchange Rate Amount");

      // Relational Exch. Rate Amount and Relational Adjmt Exch Rate Amt always greater than Exchange Rate Amount.
      CurrencyExchangeRate.VALIDATE("Relational Exch. Rate Amount",2 * CurrencyExchangeRate."Exchange Rate Amount");
      CurrencyExchangeRate.VALIDATE("Relational Adjmt Exch Rate Amt",CurrencyExchangeRate."Relational Exch. Rate Amount");
      CurrencyExchangeRate.MODIFY(TRUE);

      EXIT(Currency.Code);
    END;

    LOCAL PROCEDURE CreateCustomerWithPriceGroup@33(CustomerPriceGroup@1000 : Code[10]);
    VAR
      Customer@1001 : Record 18;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      Customer.VALIDATE("Customer Price Group",CustomerPriceGroup);
      Customer.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateProdBOMVersion@103(VAR ProductionBOMVersion@1000 : Record 99000779;Item@1001 : Record 27;Status@1002 : Option);
    BEGIN
      LibraryManufacturing.CreateProductionBOMVersion(
        ProductionBOMVersion,Item."Production BOM No.",LibraryUtility.GenerateGUID,Item."Base Unit of Measure");
      UpdateProdBOMVersionLine(Item."Production BOM No.",ProductionBOMVersion."Version Code");
      ProductionBOMVersion.VALIDATE(Status,Status);
      ProductionBOMVersion.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE RunPriceListReport@38(No@1003 : Code[20];SalesType@1000 : Option;SalesCode@1001 : Code[20];CurrencyCode@1002 : Code[10]);
    VAR
      Item@1005 : Record 27;
    BEGIN
      // Execute Price List report with the required combinations of Sales Type and Sales Code.
      Item.SETRANGE("No.",No);
      LibraryVariableStorage.Enqueue(WORKDATE);
      LibraryVariableStorage.Enqueue(SalesType);
      LibraryVariableStorage.Enqueue(SalesCode);
      LibraryVariableStorage.Enqueue(CurrencyCode);
      REPORT.RUN(REPORT::"Price List",TRUE,FALSE,Item);
    END;

    LOCAL PROCEDURE VerifyUnitPrice@44(Item@1000 : Record 27;CurrencyCode@1001 : Code[10];ExpUnitPrice@1004 : Decimal);
    VAR
      CurrencyExchangeRate@1003 : Record 330;
    BEGIN
      LibraryReportDataset.LoadDataSetFile;
      IF CurrencyCode <> '' THEN BEGIN
        CurrencyExchangeRate.SETRANGE("Currency Code",CurrencyCode);
        CurrencyExchangeRate.FINDFIRST;
        LibraryReportDataset.SetRange('UnitPriceFieldCaption',Item.FIELDCAPTION("Unit Price") + ' ' + '(' + CurrencyCode + ')');
        LibraryReportDataset.GetNextRow;
        LibraryReportDataset.AssertCurrentRowValue('SalesPriceUnitPrice',ExpUnitPrice /
          (CurrencyExchangeRate."Relational Exch. Rate Amount" / CurrencyExchangeRate."Exchange Rate Amount"));
      END ELSE BEGIN
        LibraryReportDataset.SetRange('UnitPriceFieldCaption',Item.FIELDCAPTION("Unit Price"));
        LibraryReportDataset.GetNextRow;
        LibraryReportDataset.AssertCurrentRowValue('SalesPriceUnitPrice',ExpUnitPrice);
      END;
    END;

    LOCAL PROCEDURE VerifyVariantLineInPriceListReport@68(VariantCap@1004 : Text[40];VariantCode@1005 : Code[20];MinimumQtyCap@1003 : Text[40];MinimumQty@1001 : Decimal;AmountCap@1002 : Text[40];Amount@1000 : Decimal);
    BEGIN
      LibraryReportDataset.SetRange(VariantCap,VariantCode);
      LibraryReportDataset.AssertElementWithValueExists(MinimumQtyCap,MinimumQty);
      LibraryReportDataset.AssertElementWithValueExists(AmountCap,Amount);
    END;

    LOCAL PROCEDURE CreateItemLedgerEntry@187(VAR ItemLedgerEntry@1000 : Record 32;ItemNo@1001 : Code[20]);
    BEGIN
      WITH ItemLedgerEntry DO BEGIN
        IF FINDLAST THEN;

        INIT;
        "Entry No." += 1;
        "Item No." := ItemNo;
        Quantity := LibraryRandom.RandDec(100,2);
        "Location Code" := LibraryUtility.GenerateGUID;
        "Variant Code" := LibraryUtility.GenerateGUID;
        "Global Dimension 1 Code" := LibraryUtility.GenerateGUID;
        "Global Dimension 2 Code" := LibraryUtility.GenerateGUID;
        INSERT;
      END;
    END;

    LOCAL PROCEDURE CreateSalesPriceForCampaign@13(VAR SalesPrice@1000 : Record 7002;ItemNo@1001 : Code[20];CampaignNo@1002 : Code[20]);
    BEGIN
      // Create Sales Price with random unit price.
      LibraryMarketing.CreateSalesPriceForCampaign(SalesPrice,ItemNo,CampaignNo);
      SalesPrice.VALIDATE("Unit Price",LibraryRandom.RandDec(10,2));
      SalesPrice.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesPriceForItem@89(Item@1005 : Record 27;SalesType@1004 : Option;SalesCode@1003 : Code[20];VariantCode@1002 : Code[10];MinimumQty@1001 : Decimal;UnitPrice@1000 : Decimal);
    VAR
      SalesPrice@1007 : Record 7002;
    BEGIN
      LibraryCosting.CreateSalesPrice(
        SalesPrice,SalesType,SalesCode,Item."No.",WORKDATE,'',VariantCode,Item."Base Unit of Measure",MinimumQty);
      SalesPrice.VALIDATE("Unit Price",UnitPrice);
      SalesPrice.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesLineDiscountForItem@88(Item@1006 : Record 27;SalesCode@1003 : Code[20];VariantCode@1002 : Code[10];MinimumQty@1001 : Decimal;LineDiscount@1000 : Decimal);
    VAR
      SalesLineDiscount@1007 : Record 7004;
    BEGIN
      LibraryERM.CreateLineDiscForCustomer(
        SalesLineDiscount,SalesLineDiscount.Type::Item,Item."No.",
        SalesLineDiscount."Sales Type"::Customer,SalesCode,WORKDATE,'',VariantCode,Item."Base Unit of Measure",MinimumQty);
      SalesLineDiscount.VALIDATE("Line Discount %",LineDiscount);
      SalesLineDiscount.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemWithProductionBOM@134(VAR Item@1000 : Record 27);
    VAR
      ItemComponent@1001 : Record 27;
      ProductionBOMHeader@1002 : Record 99000771;
      ProductionBOMLine@1003 : Record 99000772;
      ItemUnitOfMeasure@1004 : Record 5404;
    BEGIN
      CreateItemWithUpdatedBaseUnitOfMeasure(
        ItemUnitOfMeasure,Item,'',ProductionBOMHeader."No.",Item."Manufacturing Policy"::"Make-to-Stock");
      CreateItem(ItemComponent,'','',ItemComponent."Manufacturing Policy"::"Make-to-Stock");
      CreateCertifiedProductionBOM(ProductionBOMHeader,ItemUnitOfMeasure.Code,ProductionBOMLine.Type::Item,ItemComponent."No.",1);
      UpdateProdBOMCodeOnItem(Item,ProductionBOMHeader."No.");
    END;

    LOCAL PROCEDURE CreateItemJournalLine@47(VAR ItemJournalBatch@1004 : Record 233;VAR ItemJournalLine@1000 : Record 83;ItemNo@1003 : Code[20]);
    BEGIN
      ItemJournalSetup(ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",
        ItemJournalBatch.Name,ItemJournalLine."Entry Type"::Purchase,ItemNo,LibraryRandom.RandDec(10,2));
      // Value not important.
      ItemJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(10,2));
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndUpdateRevaluationJournal@69(VAR ItemJournalLine@1002 : Record 83;ItemNo@1000 : Code[20];UnitCostRevalued@1001 : Decimal);
    VAR
      ItemLedgerEntry@1003 : Record 32;
      ItemJournalBatch@1004 : Record 233;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,ItemNo);
      CreateItemJournalLine(ItemJournalBatch,ItemJournalLine,ItemNo);
      ItemJournalLine.VALIDATE("Value Entry Type",ItemJournalLine."Value Entry Type"::Revaluation);
      ItemJournalLine.VALIDATE("Applies-to Entry",ItemLedgerEntry."Entry No.");
      ItemJournalLine.VALIDATE("Unit Cost (Revalued)",UnitCostRevalued);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ItemJournalSetup@75(VAR ItemJournalBatch@1002 : Record 233);
    VAR
      ItemJournalTemplate@1000 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type::Item,ItemJournalTemplate.Name);
    END;

    LOCAL PROCEDURE CreateRouting@120(VAR RoutingHeader@1000 : Record 99000763);
    VAR
      WorkCenter@1003 : Record 99000754;
      MachineCenter@1002 : Record 99000758;
      RoutingLine@1001 : Record 99000764;
    BEGIN
      CreateWorkCenter(WorkCenter);
      CreateMachineCenter(MachineCenter,WorkCenter."No.");
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);
      CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenter."No.");
      RoutingLine.Type := RoutingLine.Type::"Machine Center";
      CreateRoutingLine(RoutingLine,RoutingHeader,MachineCenter."No.");
    END;

    LOCAL PROCEDURE CreateRoutingSetup@42(VAR RoutingHeader@1001 : Record 99000763);
    BEGIN
      CreateRouting(RoutingHeader);
      UpdateRoutingStatus(RoutingHeader,RoutingHeader.Status::Certified);
    END;

    LOCAL PROCEDURE CreateRoutingWithScrap@115(VAR RoutingHeader@1000 : Record 99000763;ScrapPct@1001 : Decimal);
    VAR
      RoutingLine@1002 : Record 99000764;
    BEGIN
      CreateRouting(RoutingHeader);

      FindRoutingLine(RoutingLine,RoutingHeader."No.");
      RoutingLine.VALIDATE("Scrap Factor %",ScrapPct);
      RoutingLine.MODIFY(TRUE);

      UpdateRoutingStatus(RoutingHeader,RoutingHeader.Status::Certified);
    END;

    LOCAL PROCEDURE CreateWorkCenter@53(VAR WorkCenter@1004 : Record 99000754);
    VAR
      GenProductPostingGroup@1000 : Record 251;
    BEGIN
      LibraryManufacturing.CreateWorkCenterWithCalendar(WorkCenter);
      LibraryERM.FindGenProductPostingGroup(GenProductPostingGroup);
      WorkCenter.VALIDATE("Gen. Prod. Posting Group",GenProductPostingGroup.Code);
      WorkCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateMachineCenter@51(VAR MachineCenter@1002 : Record 99000758;WorkCenterNo@1000 : Code[20]);
    VAR
      GenProductPostingGroup@1001 : Record 251;
    BEGIN
      // Random value important for test.
      LibraryManufacturing.CreateMachineCenterWithCalendar(MachineCenter,WorkCenterNo,LibraryRandom.RandDec(105,1));
      LibraryERM.FindGenProductPostingGroup(GenProductPostingGroup);
      MachineCenter.VALIDATE("Gen. Prod. Posting Group",GenProductPostingGroup.Code);
      MachineCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRoutingLine@41(VAR RoutingLine@1003 : Record 99000764;RoutingHeader@1000 : Record 99000763;CenterNo@1002 : Code[20]);
    VAR
      OperationNo@1001 : Code[10];
    BEGIN
      // Random used such that the Next Operation No is greater than the Previous Operation No.
      OperationNo := FindLastOperationNo(RoutingHeader."No.") + FORMAT(LibraryRandom.RandInt(5));

      // Random values not important for test.
      LibraryManufacturing.CreateRoutingLineSetup(
        RoutingLine,RoutingHeader,CenterNo,OperationNo,LibraryRandom.RandDec(5,2),LibraryRandom.RandDec(5,2));
    END;

    LOCAL PROCEDURE FindLastOperationNo@40(RoutingNo@1000 : Code[20]) : Code[10];
    VAR
      RoutingLine@1001 : Record 99000764;
    BEGIN
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      IF RoutingLine.FINDLAST THEN
        EXIT(RoutingLine."Operation No.");
    END;

    LOCAL PROCEDURE CreateChildItemWithInventory@12(ItemJournalBatch@1000 : Record 233) : Code[20];
    VAR
      Item@1001 : Record 27;
      ItemJournalLine@1002 : Record 83;
    BEGIN
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Stock");
      PostItemPositiveAdjmt(
        ItemJournalBatch,ItemJournalLine."Entry Type"::"Positive Adjmt.",Item."No.",LibraryRandom.RandDec(100,2) + 10);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE PostItemPositiveAdjmt@25(ItemJournalBatch@1000 : Record 233;EntryType@1002 : Option;ItemNo@1004 : Code[20];Qty@1005 : Decimal);
    VAR
      ItemJournalLine@1003 : Record 83;
    BEGIN
      // Create Item Journal to populate Item Quantity.
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,EntryType,ItemNo,Qty);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateItemJournal@1015(VAR ItemJournalBatch@1006 : Record 233;EntryType@1003 : Option;ItemNo@1002 : Code[20];Quantity@1004 : Integer;UnitAmount@1005 : Decimal);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      ItemJournalSetup(ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,EntryType,ItemNo,Quantity );
      ItemJournalLine.VALIDATE("Unit Amount",UnitAmount);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE SelectProdOrderLine@37(VAR ProdOrderLine@1000 : Record 5406;ProdOrderNo@1002 : Code[20]);
    VAR
      ProductionOrder@1001 : Record 5405;
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status::Released);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProdOrderNo);
      ProdOrderLine.FINDSET;
    END;

    LOCAL PROCEDURE CreateAndRefreshRelProdOrder@58(VAR ProductionOrder@1000 : Record 5405;SourceType@1001 : Option;SourceNo@1002 : Code[20];Qty@1003 : Decimal);
    BEGIN
      // Create Production Order with small random value.
      LibraryManufacturing.CreateProductionOrder(ProductionOrder,ProductionOrder.Status::Released,SourceType,SourceNo,Qty);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
    END;

    LOCAL PROCEDURE ChangeThreeReleasedProdOrdersToFinished@1016(VAR ProdOrderArray@1004 : ARRAY [3] OF Code[20]);
    VAR
      CompItem1@1015 : Record 27;
      CompItem2@1014 : Record 27;
      ProdOrderItem@1013 : Record 27;
      ProductionBOMHeader@1009 : Record 99000771;
      ProductionOrder@1006 : Record 5405;
      ProdOrderLine@1007 : Record 5406;
      ItemJournalLine@1003 : Record 83;
      ItemJournalBatch@1000 : Record 233;
      QtyPer@1002 : Decimal;
      i@1001 : Integer;
    BEGIN
      FOR i := 1 TO 3 DO BEGIN
        // Create 3 Items
        LibraryInventory.CreateItem(CompItem1);
        LibraryInventory.CreateItem(CompItem2);
        LibraryInventory.CreateItem(ProdOrderItem);
        ProdOrderItem.VALIDATE("Replenishment System",ProdOrderItem."Replenishment System"::"Prod. Order");
        ProdOrderItem.MODIFY(TRUE);

        // Create BOM
        QtyPer := LibraryRandom.RandInt(10);
        LibraryManufacturing.CreateCertifProdBOMWithTwoComp(ProductionBOMHeader,CompItem1."No.",CompItem2."No.",QtyPer);

        // Update Item Card
        ProdOrderItem.VALIDATE("Production BOM No.",ProductionBOMHeader."No.");
        ProdOrderItem.MODIFY(TRUE);

        // Create Production Order
        LibraryManufacturing.CreateProductionOrder(ProductionOrder,ProductionOrder.Status::Released,
          ProductionOrder."Source Type"::Item,ProdOrderItem."No.",LibraryRandom.RandInt(10));
        ProdOrderArray[i] := ProductionOrder."No.";

        // Post Item Journal
        CreateItemJournal(ItemJournalBatch,ItemJournalLine."Entry Type"::Purchase,CompItem1."No.",
          ProductionOrder.Quantity * QtyPer,15);
        CreateItemJournal(ItemJournalBatch,ItemJournalLine."Entry Type"::Purchase,CompItem2."No.",
          ProductionOrder.Quantity * QtyPer,15);
        LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);

        // Refresh Production Order, Post Production Journal and Change the Status to Finished
        LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

        ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
        ProdOrderLine.FINDFIRST;
        LibraryManufacturing.OpenProductionJournal(ProductionOrder,ProdOrderLine."Line No.");
        LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

        // Update the WORKDATE
        WORKDATE := CALCDATE('<+1M>',WORKDATE);
      END;
    END;

    LOCAL PROCEDURE CreateReqLine@112(ItemNo@1000 : Code[20];Qty@1004 : Decimal);
    VAR
      ReqWkshTemplate@1001 : Record 244;
      RequisitionWkshName@1002 : Record 245;
      RequisitionLine@1003 : Record 246;
    BEGIN
      ReqWkshTemplate.SETRANGE(Type,ReqWkshTemplate.Type::"Req.");
      ReqWkshTemplate.FINDFIRST;
      LibraryPlanning.CreateRequisitionWkshName(RequisitionWkshName,ReqWkshTemplate.Name);
      LibraryPlanning.CreateRequisitionLine(RequisitionLine,RequisitionWkshName."Worksheet Template Name",RequisitionWkshName.Name);
      WITH RequisitionLine DO BEGIN
        VALIDATE(Type,Type::Item);
        VALIDATE("No.",ItemNo);
        VALIDATE(Quantity,Qty);
        VALIDATE("Due Date",WORKDATE);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE GenerateBOMCostTree@121(VAR Item@1001 : Record 27;VAR TempBOMBuffer@1002 : TEMPORARY Record 5870);
    VAR
      CalcBOMTree@1000 : Codeunit 5870;
    BEGIN
      CalcBOMTree.GenerateTreeForItem(Item,TempBOMBuffer,WORKDATE,2);
    END;

    LOCAL PROCEDURE OpenProductionJournal@21(ProductionOrder@1003 : Record 5405);
    VAR
      ProdOrderLine@1001 : Record 5406;
      ProductionJournalMgt@1000 : Codeunit 5510;
    BEGIN
      // Open Production Journal based on selected Production Order Line.
      SelectProdOrderLine(ProdOrderLine,ProductionOrder."No.");
      ProductionJournalMgt.Handling(ProductionOrder,ProdOrderLine."Line No.");
    END;

    LOCAL PROCEDURE PurchaseReserveAvailReport@30(VAR PurchaseHeader@1003 : Record 38;ItemNo@1005 : Code[20];ShowPurchLines@1000 : Boolean);
    VAR
      PurchLine@1002 : Record 39;
    BEGIN
      CreatePurchaseOrder(PurchaseHeader,ItemNo,LibraryRandom.RandDec(10,2));  // Random Values not important.

      // Exercise: Generate the Purchase Reservation Avail. report.
      COMMIT;
      PurchLine.SETRANGE("Document Type",PurchLine."Document Type"::Order);
      PurchLine.SETRANGE("Document No.",PurchaseHeader."No.");
      LibraryVariableStorage.Enqueue(ShowPurchLines);
      LibraryVariableStorage.Enqueue(FALSE);
      LibraryVariableStorage.Enqueue(FALSE);
      REPORT.RUN(REPORT::"Purchase Reservation Avail.",TRUE,FALSE,PurchLine);
    END;

    LOCAL PROCEDURE RolledUpCostShareReportWithStatus@262(Status@1002 : Option);
    VAR
      Item@1000 : Record 27;
      ProductionBOMVersion@1001 : Record 99000779;
    BEGIN
      // Setup: Create Production BOM with component Item and Production BOM Version.
      Initialize;
      CreateProdItemSetup(Item);
      CreateProdBOMVersion(ProductionBOMVersion,Item,Status);

      // Exercise: Run report Rolled-up Cost Shares.
      RunRolledUpCostShareReport(Item."No.");

      // Verify: Verifying component Item exist on Report.
      VerifyComponentItem(Item."Production BOM No.",ProductionBOMVersion."Version Code");
    END;

    LOCAL PROCEDURE RolledUpCostShareReportWithTypeProdBOM@83(Status@1005 : Option);
    VAR
      Item@1000 : Record 27;
      Item2@1003 : Record 27;
      ProductionBOMHeader@1001 : Record 99000771;
      ProductionBOMLine@1002 : Record 99000772;
      ProductionBOMVersion@1004 : Record 99000779;
    BEGIN
      // Run the Rolled Up Cost Shares report with Type Production BOM and check the component item on report when one component is delete from Production BOM Version with Under Development status.

      // Setup: Create Production BOM with component Item and with One Production BOM and Create Production BOM Version.
      Initialize;
      CreateProdItemSetup(Item);
      ProductionBOMHeader.GET(Item."Production BOM No.");
      UpdateProdBOMStatus(ProductionBOMHeader,ProductionBOMHeader.Status::"Under Development");
      CreateProdItemSetup(Item2);
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::"Production BOM",Item2."Production BOM No.",
        LibraryRandom.RandInt(10));
      UpdateProdBOMStatus(ProductionBOMHeader,ProductionBOMHeader.Status::Certified);
      CreateProdBOMVersion(ProductionBOMVersion,Item,Status);

      // Exercise: Run report Rolled-up Cost Shares.
      RunRolledUpCostShareReport(Item."No.");

      // Verify: Verifying component Item exist on Report.
      VerifyComponentItem(Item."Production BOM No.",ProductionBOMVersion."Version Code");
    END;

    LOCAL PROCEDURE RunPurchReserveAvailReport@48(PurchHeaderNo@1003 : Code[20];ShowPurchLines@1000 : Boolean;ShowReservationEntries@1001 : Boolean;ShowModifyQtytoReceive@1004 : Boolean);
    VAR
      PurchLine@1002 : Record 39;
    BEGIN
      PurchLine.SETRANGE("Document Type",PurchLine."Document Type"::Order);
      PurchLine.SETRANGE("Document No.",PurchHeaderNo);
      LibraryVariableStorage.Enqueue(ShowPurchLines);
      LibraryVariableStorage.Enqueue(ShowReservationEntries);
      LibraryVariableStorage.Enqueue(ShowModifyQtytoReceive);
      REPORT.RUN(REPORT::"Purchase Reservation Avail.",TRUE,FALSE,PurchLine);
    END;

    LOCAL PROCEDURE CreatePurchaseOrder@54(VAR PurchaseHeader@1000 : Record 38;ItemNo@1001 : Code[20];Quantity@1003 : Decimal);
    VAR
      PurchaseLine@1002 : Record 39;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      PurchaseHeader.VALIDATE("Expected Receipt Date",WORKDATE);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity);
    END;

    LOCAL PROCEDURE SalesReserveAvailReport@24(VAR SalesHeader@1000 : Record 36;ItemNo@1006 : Code[20];ShowSalesLines@1001 : Boolean);
    BEGIN
      CreateSalesOrder(SalesHeader,ItemNo,LibraryRandom.RandDec(10,2));  // Random Values not important.

      // Exercise: Generate the Sales Reservation Avail. report.
      COMMIT;
      RunSalesReservationAvail(SalesHeader."No.",ShowSalesLines,FALSE);
    END;

    LOCAL PROCEDURE CreateSalesOrder@60(VAR SalesHeader@1000 : Record 36;ItemNo@1001 : Code[20];Quantity@1002 : Decimal);
    VAR
      SalesLine@1003 : Record 37;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,'');
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
    END;

    LOCAL PROCEDURE AutoReserveForSalesOrder@39(VAR SalesHeader@1000 : Record 36;ItemNo@1002 : Code[20];ShipmentDate@1001 : Date;SalesQty@1004 : Decimal);
    VAR
      SalesLine@1003 : Record 37;
    BEGIN
      CreateSalesOrder(SalesHeader,ItemNo,SalesQty);
      SelectSalesLine(SalesLine,SalesHeader."No.");
      SalesLine.VALIDATE("Shipment Date",ShipmentDate);
      SalesLine.MODIFY(TRUE);
      LibrarySales.AutoReserveSalesLine(SalesLine);
    END;

    LOCAL PROCEDURE RunSalesReservationAvail@32(SalesHeaderNo@1001 : Code[20];ShowSalesLines@1002 : Boolean;ShowReservationEntries@1004 : Boolean);
    VAR
      SalesLine@1000 : Record 37;
    BEGIN
      SalesLine.SETRANGE("Document Type",SalesLine."Document Type"::Order);
      SalesLine.SETRANGE("Document No.",SalesHeaderNo);
      LibraryVariableStorage.Enqueue(ShowSalesLines);
      LibraryVariableStorage.Enqueue(ShowReservationEntries);
      LibraryVariableStorage.Enqueue(FALSE);
      REPORT.RUN(REPORT::"Sales Reservation Avail.",TRUE,FALSE,SalesLine);
    END;

    LOCAL PROCEDURE RunSalesReservationAvailReport@16(SalesHeaderNo@1001 : Code[20];ShowSalesLines@1002 : Boolean;ShowReservationEntries@1004 : Boolean;ModifyQtyToShip@1003 : Boolean);
    VAR
      SalesLine@1000 : Record 37;
    BEGIN
      SalesLine.SETRANGE("Document Type",SalesLine."Document Type"::Order);
      SalesLine.SETRANGE("Document No.",SalesHeaderNo);
      LibraryVariableStorage.Enqueue(ShowSalesLines);
      LibraryVariableStorage.Enqueue(ShowReservationEntries);
      LibraryVariableStorage.Enqueue(ModifyQtyToShip);
      REPORT.RUN(REPORT::"Sales Reservation Avail.",TRUE,FALSE,SalesLine);
    END;

    LOCAL PROCEDURE SelectSalesLine@31(VAR SalesLine@1000 : Record 37;DocumentNo@1001 : Code[20]);
    BEGIN
      SalesLine.SETRANGE("Document Type",SalesLine."Document Type"::Order);
      SalesLine.SETRANGE("Document No.",DocumentNo);
      SalesLine.FINDFIRST;
    END;

    LOCAL PROCEDURE CreateProdItemSetup@43(VAR Item3@1004 : Record 27);
    VAR
      Item@1003 : Record 27;
      Item2@1002 : Record 27;
      ProductionBOMHeader@1001 : Record 99000771;
    BEGIN
      CreateItem(Item,'','',Item."Manufacturing Policy"::"Make-to-Stock");
      CreateItem(Item2,'','',Item2."Manufacturing Policy"::"Make-to-Stock");
      LibraryManufacturing.CreateCertifProdBOMWithTwoComp(ProductionBOMHeader,Item."No.",Item2."No.",LibraryRandom.RandInt(10));  // Random Values not important.
      CreateItem(Item3,'',ProductionBOMHeader."No.",Item3."Manufacturing Policy"::"Make-to-Order");
    END;

    LOCAL PROCEDURE SelectProductionBOMLines@73(VAR ProductionBOMLine@1000 : Record 99000772;ProductionBOMNo@1001 : Code[20]);
    BEGIN
      ProductionBOMLine.SETRANGE("Production BOM No.",ProductionBOMNo);
      ProductionBOMLine.FINDSET;
    END;

    LOCAL PROCEDURE FindPurchaseOrderLine@72(VAR PurchaseLine@1000 : Record 39;DocumentNo@1001 : Code[20]);
    BEGIN
      PurchaseLine.SETRANGE("Document Type",PurchaseLine."Document Type"::Order);
      PurchaseLine.SETRANGE("Document No.",DocumentNo);
      PurchaseLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindProdOrderLine@81(VAR ProdOrderLine@1000 : Record 5406;Status@1001 : Option;ProdOrderNo@1002 : Code[20]);
    BEGIN
      ProdOrderLine.SETRANGE(Status,Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProdOrderNo);
      ProdOrderLine.FINDFIRST;
    END;

    LOCAL PROCEDURE RunStatusReport@82(No@1001 : Code[20]);
    VAR
      Item@1002 : Record 27;
    BEGIN
      Item.SETRANGE("No.",No);
      LibraryVariableStorage.Enqueue(WORKDATE);
      REPORT.RUN(REPORT::Status,TRUE,FALSE,Item);
    END;

    LOCAL PROCEDURE CreateItemUnitOfMeasure@94(VAR ItemUnitOfMeasure@1001 : Record 5404;ItemNo@1002 : Code[20]);
    BEGIN
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,ItemNo,2 * LibraryRandom.RandInt(10));
    END;

    LOCAL PROCEDURE UpdateProdBOMVersionLine@190(ProductionBOMNo@1000 : Code[20];VersionCode@1001 : Code[20]);
    VAR
      ProdBOMHeader@1002 : Record 99000771;
      ProductionBOMLine@1004 : Record 99000772;
      ProductionBOMVersion@1008 : Record 99000779;
      ProductionBOMCopy@1003 : Codeunit 99000768;
    BEGIN
      ProdBOMHeader.GET(ProductionBOMNo);
      ProductionBOMCopy.CopyBOM(ProductionBOMNo,'',ProdBOMHeader,VersionCode);
      ProductionBOMVersion.GET(ProductionBOMNo,VersionCode);
      ProductionBOMVersion.VALIDATE("Unit of Measure Code",ProdBOMHeader."Unit of Measure Code");
      ProductionBOMVersion.MODIFY(TRUE);
      ProductionBOMLine.SETRANGE("Version Code",VersionCode);
      ProductionBOMLine.FINDFIRST;
      ProductionBOMLine.DELETE;
    END;

    LOCAL PROCEDURE UpdatePurchaseLine@132(VAR PurchaseLine@1002 : Record 39;UnitOfMeasureCode@1000 : Code[10];DirectUnitCost@1001 : Decimal);
    BEGIN
      PurchaseLine.VALIDATE("Unit of Measure Code",UnitOfMeasureCode);
      PurchaseLine.VALIDATE("Direct Unit Cost",DirectUnitCost);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE RunInventoryValuationWIPReportWithTimePeriod@1011(StartingDate@1000 : Date;EndingDate@1001 : Date;ProdOrderArray@1002 : ARRAY [3] OF Code[10]);
    VAR
      ProductNoFilter@1005 : Code[50];
    BEGIN
      ProductNoFilter := ProdOrderArray[1] + '|' + ProdOrderArray[2] + '|' + ProdOrderArray[3];
      LibraryVariableStorage.Enqueue(StartingDate);
      LibraryVariableStorage.Enqueue(EndingDate);
      LibraryVariableStorage.Enqueue(ProductNoFilter);
      REPORT.RUN(REPORT::"Inventory Valuation - WIP");
    END;

    LOCAL PROCEDURE RunInvtValuationCostSpecReport@78(No@1003 : Code[20]);
    VAR
      Item@1001 : Record 27;
    BEGIN
      Item.SETRANGE("No.",No);
      LibraryVariableStorage.Enqueue(WORKDATE);
      REPORT.RUN(REPORT::"Invt. Valuation - Cost Spec.",TRUE,FALSE,Item);
    END;

    LOCAL PROCEDURE RunInventoryValuationWIPReport@99(ProductionOrder@1002 : Record 5405;StartingDate@1000 : Date;EndingDate@1001 : Date);
    BEGIN
      LibraryVariableStorage.Enqueue(StartingDate);
      LibraryVariableStorage.Enqueue(EndingDate);
      REPORT.RUN(REPORT::"Inventory Valuation - WIP",TRUE,FALSE,ProductionOrder);
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrderWithUOM@63(VAR PurchaseHeader@1000 : Record 38;Item@1001 : Record 27;ChangeUnitOfMeasure@1002 : Boolean);
    VAR
      ItemUnitOfMeasure@1003 : Record 5404;
      PurchaseLine@1004 : Record 39;
    BEGIN
      CreatePurchaseOrder(PurchaseHeader,Item."No.",LibraryRandom.RandDec(10,2));
      FindPurchaseOrderLine(PurchaseLine,PurchaseHeader."No.");
      IF ChangeUnitOfMeasure THEN BEGIN
        CreateItemUnitOfMeasure(ItemUnitOfMeasure,Item."No.");
        UpdatePurchaseLine(PurchaseLine,ItemUnitOfMeasure.Code,LibraryRandom.RandDec(10,2));
      END ELSE
        UpdatePurchaseLine(PurchaseLine,Item."Base Unit of Measure",LibraryRandom.RandDec(10,2));
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);  // Post with Receive Option.
    END;

    LOCAL PROCEDURE CreateProdBOMLineWithScrap@268(ProductionBOMHeader@1000 : Record 99000771;VAR ProductionBOMLine@1001 : Record 99000772;Type@1002 : Option;No@1003 : Code[20];QtyPer@1005 : Decimal;ScrapPct@1004 : Decimal);
    BEGIN
      LibraryManufacturing.CreateProductionBOMLine(ProductionBOMHeader,ProductionBOMLine,'',Type,No,QtyPer);
      ProductionBOMLine.VALIDATE("Scrap %",ScrapPct);
      ProductionBOMLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE FindItemLedgerEntry@66(VAR ItemLedgerEntry@1000 : Record 32;ItemNo@1001 : Code[20]);
    BEGIN
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindRoutingLine@123(VAR RoutingLine@1000 : Record 99000764;RoutingNo@1001 : Code[20]);
    BEGIN
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      RoutingLine.FINDFIRST;
    END;

    LOCAL PROCEDURE ExplodeOutputJournal@229(ItemNo@1002 : Code[20];ProductionOrderNo@1004 : Code[20]);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      LibraryManufacturing.CreateOutputJournal(
        ItemJournalLine,OutputItemJournalTemplate,OutputItemJournalBatch,ItemNo,ProductionOrderNo);
      CODEUNIT.RUN(CODEUNIT::"Output Jnl.-Expl. Route",ItemJournalLine);
    END;

    LOCAL PROCEDURE ExplodeAndPostOutputJournal@327(ItemNo@1002 : Code[20];ProductionOrderNo@1004 : Code[20]);
    BEGIN
      OutputJournalSetup;

      ExplodeOutputJournal(ItemNo,ProductionOrderNo);
      LibraryInventory.PostItemJournalLine(OutputItemJournalTemplate.Name,OutputItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE OutputJournalSetup@144();
    BEGIN
      CLEAR(OutputItemJournalTemplate);
      OutputItemJournalTemplate.INIT;
      LibraryInventory.SelectItemJournalTemplateName(OutputItemJournalTemplate,OutputItemJournalTemplate.Type::Output);

      CLEAR(OutputItemJournalBatch);
      OutputItemJournalBatch.INIT;
      LibraryInventory.SelectItemJournalBatchName(
        OutputItemJournalBatch,OutputItemJournalTemplate.Type,OutputItemJournalTemplate.Name);
    END;

    LOCAL PROCEDURE CalculateAndPostConsumption@227(ProductionOrder@1000 : Record 5405);
    BEGIN
      ConsumptionJournalSetup;

      LibraryManufacturing.CalculateConsumption(
        ProductionOrder."No.",ConsumptionItemJournalTemplate.Name,ConsumptionItemJournalBatch.Name);
      LibraryInventory.PostItemJournalLine(ConsumptionItemJournalTemplate.Name,ConsumptionItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE ConsumptionJournalSetup@226();
    BEGIN
      CLEAR(ConsumptionItemJournalTemplate);
      ConsumptionItemJournalTemplate.INIT;
      LibraryInventory.SelectItemJournalTemplateName(
        ConsumptionItemJournalTemplate,ConsumptionItemJournalTemplate.Type::Consumption);

      CLEAR(ConsumptionItemJournalBatch);
      ConsumptionItemJournalBatch.INIT;
      LibraryInventory.SelectItemJournalBatchName(ConsumptionItemJournalBatch,ConsumptionItemJournalTemplate.Type,
        ConsumptionItemJournalTemplate.Name);
    END;

    LOCAL PROCEDURE PostInventoryCostToGLRun@93(PostMethod@1003 : 'per Posting Group,per Entry';Post@1001 : Boolean);
    VAR
      PostValueEntryToGL@1000 : Record 5811;
    BEGIN
      COMMIT; // Required to run the report.

      LibraryVariableStorage.Enqueue(PostMethod);
      LibraryVariableStorage.Enqueue(''); // Blank for Document No..
      LibraryVariableStorage.Enqueue(Post);
      REPORT.RUN(REPORT::"Post Inventory Cost to G/L",TRUE,FALSE,PostValueEntryToGL);
    END;

    LOCAL PROCEDURE PostConsumptionAndOutput@84(ProdOrderLine@1000 : Record 5406;ComponentItem@1001 : Record 27;ProdItemUnitCost@1005 : Decimal;ConsumptionQty@1002 : Decimal;OutputQty@1003 : Decimal;PostingDate@1004 : Date);
    BEGIN
      IF ConsumptionQty <> 0 THEN
        LibraryPatterns.POSTConsumption(ProdOrderLine,ComponentItem,'','',ConsumptionQty,PostingDate,ComponentItem."Unit Cost");
      LibraryPatterns.POSTOutput(ProdOrderLine,OutputQty,PostingDate,ProdItemUnitCost);
    END;

    LOCAL PROCEDURE RunRolledUpCostShareReport@170(ItemNo@1000 : Code[20]);
    VAR
      Item@1001 : Record 27;
    BEGIN
      Item.SETRANGE("No.",ItemNo);
      COMMIT;
      REPORT.RUN(REPORT::"Rolled-up Cost Shares",TRUE,FALSE,Item);
    END;

    LOCAL PROCEDURE UpdateProdBOMCodeOnItem@174(VAR Item@1000 : Record 27;ProdBOMNo@1001 : Code[20]);
    BEGIN
      Item.VALIDATE("Production BOM No.",ProdBOMNo);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateProdBOMStatus@157(VAR ProductionBOMHeader@1000 : Record 99000771;Status@1001 : Option);
    BEGIN
      ProductionBOMHeader.VALIDATE(Status,Status);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateRoutingStatus@122(VAR RoutingHeader@1000 : Record 99000763;Status@1001 : Option);
    BEGIN
      RoutingHeader.VALIDATE(Status,Status);
      RoutingHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE VerifyBOMBuffer@278(VAR BOMBuffer@1000 : Record 5870;Item@1003 : Record 27;QtyPerTop@1001 : Decimal;ScrapQty@1002 : Decimal);
    VAR
      GLSetup@1004 : Record 98;
    BEGIN
      GLSetup.GET;
      BOMBuffer.SETRANGE("No.",Item."No.");
      BOMBuffer.FINDFIRST;
      Assert.AreEqual(ROUND(QtyPerTop + ScrapQty,0.00001),BOMBuffer."Qty. per Parent",ReportQtyErr);
      Assert.AreEqual(ROUND(QtyPerTop + ScrapQty,0.00001),BOMBuffer."Qty. per Top Item",ReportQtyErr);
      Assert.AreEqual(ROUND(ScrapQty,0.00001),BOMBuffer."Scrap Qty. per Parent",ReportQtyErr);
      Assert.AreEqual(
        ROUND(Item."Unit Cost" * ROUND(ScrapQty,0.00001),GLSetup."Unit-Amount Rounding Precision"),
        BOMBuffer."Rolled-up Scrap Cost",ReportQtyErr);
      Assert.AreEqual(
        ROUND(Item."Unit Cost" * (QtyPerTop + ROUND(ScrapQty,0.00001)),GLSetup."Unit-Amount Rounding Precision"),
        BOMBuffer."Rolled-up Material Cost",ReportQtyErr);
    END;

    LOCAL PROCEDURE VerifyStatusReport@113(PurchaseLine@1000 : Record 39);
    VAR
      ItemLedgerEntry@1003 : Record 32;
      UnitCost@1001 : Decimal;
    BEGIN
      FindItemLedgerEntry(ItemLedgerEntry,PurchaseLine."No.");

      // Verify Item No exist on the Report.
      LibraryReportDataset.LoadDataSetFile;
      UnitCost := LibraryReportDataset.Sum('UnitCost');
      LibraryReportDataset.SetRange('No_Item',PurchaseLine."No.");
      LibraryReportDataset.SetRange('DocumentNo_ItemLedgerEntry',ItemLedgerEntry."Document No.");
      LibraryReportDataset.GetNextRow;

      // Verify Unit Cost on the Report.
      Assert.AreNearlyEqual(PurchaseLine."Direct Unit Cost" / PurchaseLine."Qty. per Unit of Measure",UnitCost,
        LibraryERM.GetAmountRoundingPrecision,'Wrong unit cost in report.');

      // Verify Quantity on the Report.
      LibraryReportDataset.AssertCurrentRowValue('RemainingQty',PurchaseLine."Quantity (Base)");
    END;

    LOCAL PROCEDURE VerifyInventoryValuationCostSpecReport@87(PurchaseLine@1000 : Record 39);
    VAR
      UnitCost@1001 : Decimal;
    BEGIN
      // Verify Item No exist on the Report.
      LibraryReportDataset.LoadDataSetFile;
      UnitCost := LibraryReportDataset.Sum('UnitCost1');
      LibraryReportDataset.SetRange('No_Item',PurchaseLine."No.");
      LibraryReportDataset.GetNextRow;

      // Verify Direct Unit Cost, quantity and line amount on the Report.
      LibraryReportDataset.AssertCurrentRowValue('TotalCostTotal1',PurchaseLine.Amount);
      LibraryReportDataset.AssertCurrentRowValue('RemainingQty',PurchaseLine.Quantity);
      Assert.AreNearlyEqual(PurchaseLine."Unit Cost (LCY)",UnitCost,LibraryERM.GetAmountRoundingPrecision,DirectUnitCostErr);
    END;

    LOCAL PROCEDURE VerifyComponentItem@133(ProductionBOMNo@1001 : Code[20];VersionCode@1002 : Code[20]);
    VAR
      ProductionBOMLine@1000 : Record 99000772;
    BEGIN
      LibraryReportDataset.LoadDataSetFile;
      ProductionBOMLine.SETRANGE("Version Code",VersionCode);
      ProductionBOMLine.SETRANGE("Production BOM No.",ProductionBOMNo);
      ProductionBOMLine.FINDSET;
      REPEAT
        LibraryReportDataset.AssertElementWithValueExists('ProdBOMLineIndexNo',ProductionBOMLine."No.");
      UNTIL ProductionBOMLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyCostPostedToGL@67(ProductionOrderNo@1000 : Code[20];DocumentNo@1001 : Code[20]);
    VAR
      GLEntry@1002 : Record 17;
    BEGIN
      GLEntry.SETCURRENTKEY("Document No.");
      GLEntry.SETRANGE("Document No.",DocumentNo);
      GLEntry.CALCSUMS(Amount);
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_ProductionOrder',ProductionOrderNo);
      IF LibraryReportDataset.GetNextRow THEN
        LibraryReportDataset.AssertCurrentRowValue('ValueEntryCostPostedtoGL',GLEntry.Amount);
    END;

    LOCAL PROCEDURE VerifySalesReservationAvailReport@158(VAR SalesLine@1004 : Record 37;SalesHeaderNo@1003 : Code[20];LineQtyOnHand@1001 : Decimal;LineStatus@1002 : Text);
    VAR
      DocTypeAndNo@1000 : Text;
    BEGIN
      LibraryReportDataset.LoadDataSetFile;
      SelectSalesLine(SalesLine,SalesHeaderNo);
      DocTypeAndNo := STRSUBSTNO('%1 %2',FORMAT(SalesLine."Document Type"),FORMAT(SalesLine."Document No."));
      LibraryReportDataset.SetRange('StrsubstnoDocTypeDocNo',DocTypeAndNo);
      LibraryReportDataset.AssertElementWithValueExists('LineQuantityOnHand',LineQtyOnHand);
      LibraryReportDataset.AssertElementWithValueExists('LineStatus',LineStatus);
    END;

    LOCAL PROCEDURE VerifyQtyToReceiveInPurchLine@36(VAR PurchHeader@1000 : Record 38);
    VAR
      PurchLine@1001 : Record 39;
    BEGIN
      FindPurchaseOrderLine(PurchLine,PurchHeader."No.");
      Assert.AreEqual(0,PurchLine."Qty. to Receive",MsgQtytoReceiveErr);
    END;

    LOCAL PROCEDURE ValidateInventoryValuationWIPReport@1013(VAR ProdOrderArray@1006 : ARRAY [3] OF Code[10]);
    BEGIN
      LibraryReportDataset.LoadDataSetFile;

      ASSERTERROR LibraryReportDataset.AssertElementWithValueExists('No_ProductionOrder',ProdOrderArray[1]);
      ASSERTERROR LibraryReportDataset.AssertElementWithValueExists('No_ProductionOrder',ProdOrderArray[2]);
      LibraryReportDataset.AssertElementWithValueExists('No_ProductionOrder',ProdOrderArray[3]);
    END;

    [ModalPageHandler]
    PROCEDURE PostProdJournalPageHandler@52(VAR ProductionJournal@1001 : Page 5510;VAR Response@1000 : Action);
    VAR
      ItemJournalLine@1003 : Record 83;
      ItemJnlPostLine@1004 : Codeunit 22;
      ProdOrderNo@1002 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ProdOrderNo);
      ItemJournalLine.SETRANGE("Order Type",ItemJournalLine."Order Type"::Production);
      ItemJournalLine.SETRANGE("Order No.",ProdOrderNo);
      ItemJournalLine.FINDFIRST;
      ItemJnlPostLine.RunWithCheck(ItemJournalLine);
    END;

    [RequestPageHandler]
    PROCEDURE InventoryValuationWIPRequestPageHandler@77(VAR InventoryValuationWIP@1000 : TestRequestPage 5802);
    VAR
      StartingDate@1002 : Variant;
      EndingDate@1003 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(StartingDate);
      InventoryValuationWIP.StartingDate.SETVALUE(StartingDate);
      LibraryVariableStorage.Dequeue(EndingDate);
      InventoryValuationWIP.EndingDate.SETVALUE(EndingDate);
      InventoryValuationWIP.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName)
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@65(MessageTest@1000 : Text[1024]);
    BEGIN
      // Dummy message Handler.
    END;

    [RequestPageHandler]
    PROCEDURE PriceListRequestPageHandler@86(VAR PriceList@1004 : TestRequestPage 715);
    VAR
      DateReq@1005 : Variant;
      SalesType@1002 : Variant;
      SalesCode@1000 : Variant;
      CurrencyCode@1003 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(DateReq);
      PriceList.Date.SETVALUE(DateReq);
      LibraryVariableStorage.Dequeue(SalesType);
      PriceList.SalesType.SETVALUE(SalesType); // Sales Type: Customer,Customer Price Group,All Customers,Campaign.
      LibraryVariableStorage.Dequeue(SalesCode);
      PriceList.SalesCodeCtrl.SETVALUE(SalesCode);
      LibraryVariableStorage.Dequeue(CurrencyCode);
      PriceList.Control3.SETVALUE(CurrencyCode);
      PriceList.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE InventoryPostingTestRequestPageHandler@102(VAR InventoryPostingTest@1000 : TestRequestPage 702);
    BEGIN
      InventoryPostingTest.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE StatusRequestPageHandler@71(VAR Status@1174 : TestRequestPage 706);
    VAR
      StatusDate@1000 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(StatusDate);
      Status.StatusDate.SETVALUE(StatusDate);
      Status.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE InvtValCostSpecWithFiltersPageHandler@181(VAR InvtValuationCostSpec@1174 : TestRequestPage 5801);
    BEGIN
      InvtValuationCostSpec.ValuationDate.SETVALUE(WORKDATE);
      InvtValuationCostSpec.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE InvtValCostSpecRequestPageHandler@117(VAR InvtValuationCostSpec@1174 : TestRequestPage 5801);
    VAR
      ValuationDate@1000 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ValuationDate);
      InvtValuationCostSpec.ValuationDate.SETVALUE(ValuationDate);
      InvtValuationCostSpec.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE PurchResAvailRequestPageHandler@125(VAR PurchaseReservationAvail@1004 : TestRequestPage 409);
    VAR
      ShowPurchaseLines@1005 : Variant;
      ShowResEntries@1002 : Variant;
      ModifyQtyToShip@1000 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ShowPurchaseLines);
      PurchaseReservationAvail.ShowPurchLine.SETVALUE(ShowPurchaseLines);
      LibraryVariableStorage.Dequeue(ShowResEntries);
      PurchaseReservationAvail.ShowReservationEntries.SETVALUE(ShowResEntries);
      LibraryVariableStorage.Dequeue(ModifyQtyToShip);
      PurchaseReservationAvail.ModifyQtuantityToShip.SETVALUE(ModifyQtyToShip);
      PurchaseReservationAvail.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE SalesResAvailRequestPageHandler@64(VAR SalesReservationAvail@1004 : TestRequestPage 209);
    VAR
      ShowSalesLines@1005 : Variant;
      ShowResEntries@1002 : Variant;
      ModifyQtyToShip@1000 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ShowSalesLines);
      SalesReservationAvail.ShowSalesLines.SETVALUE(ShowSalesLines);
      LibraryVariableStorage.Dequeue(ShowResEntries);
      SalesReservationAvail.ShowReservationEntries.SETVALUE(ShowResEntries);
      LibraryVariableStorage.Dequeue(ModifyQtyToShip);
      SalesReservationAvail.ModifyQuantityToShip.SETVALUE(ModifyQtyToShip);
      SalesReservationAvail.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE RolledUpCostSharesRequestPageHandler@80(VAR RolledUpCostShares@1004 : TestRequestPage 99000754);
    BEGIN
      RolledUpCostShares.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE SglLevelCostSharesRequestPageHandler@91(VAR SingleLevelCostShares@1004 : TestRequestPage 99000755);
    BEGIN
      SingleLevelCostShares.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE DetailedCalculationRequestPageHandler@98(VAR DetailedCalculation@1004 : TestRequestPage 99000756);
    BEGIN
      DetailedCalculation.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE WhereUsedTopLevelRequestPageHandler@105(VAR WhereUsedTopLevel@1004 : TestRequestPage 99000757);
    BEGIN
      WhereUsedTopLevel.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE InventoryAvailabilityRequestPageHandler@118(VAR InventoryAvailability@1004 : TestRequestPage 705);
    BEGIN
      InventoryAvailability.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [ModalPageHandler]
    PROCEDURE PostProductionJournalHandler@1014(VAR ProductionJournal@1000 : TestPage 5510);
    BEGIN
      LibraryVariableStorage.Enqueue(PostJournalLinesConfirmationMessageQst);
      ProductionJournal.Post.INVOKE;
    END;

    [MessageHandler]
    PROCEDURE ProductionJournalPostingMessageHandler@1017(Message@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(STRPOS(Message,JournalLinesPostedMessageMsg) > 0,Message);
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@1012(ConfirmMessage@1001 : Text[1024];VAR Reply@1000 : Boolean);
    VAR
      ExpectedMessage@1002 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ExpectedMessage);
      IF ConfirmMessage <> '' THEN
        Assert.IsTrue(STRPOS(ConfirmMessage,ExpectedMessage) > 0,ConfirmMessage);

      Reply := TRUE;
    END;

    [RequestPageHandler]
    PROCEDURE RequestPageHandler@1010(VAR InventoryValuationWIPRep@1000 : TestRequestPage 5802);
    VAR
      StartingDate@1001 : Variant;
      EndingDate@1002 : Variant;
      ProductNoFilter@1005 : Variant;
    BEGIN
      // Set the Starting Date and Ending Date in the report Inventory Valuation WIP.
      LibraryVariableStorage.Dequeue(StartingDate);
      LibraryVariableStorage.Dequeue(EndingDate);
      LibraryVariableStorage.Dequeue(ProductNoFilter);
      InventoryValuationWIPRep.StartingDate.SETVALUE(StartingDate);
      InventoryValuationWIPRep.EndingDate.SETVALUE(EndingDate);
      InventoryValuationWIPRep."Production Order".SETFILTER(Status,StatusConstantCap);
      InventoryValuationWIPRep."Production Order".SETFILTER("No.",ProductNoFilter);

      InventoryValuationWIPRep.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [RequestPageHandler]
    PROCEDURE PostInvtCostToGLRequestPageHandler@186(VAR PostInventoryCostToGL@1174 : TestRequestPage 1002);
    VAR
      PostMethod@1002 : Variant;
      DocNo@1000 : Variant;
      Post@1003 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(PostMethod);
      PostInventoryCostToGL.PostMethod.SETVALUE(PostMethod); // Post Method: per entry or per Posting Group.
      LibraryVariableStorage.Dequeue(DocNo);
      PostInventoryCostToGL.DocumentNo.SETVALUE(DocNo); // Doc No. required when posting per Posting Group.
      LibraryVariableStorage.Dequeue(Post); // Post to G/L.
      PostInventoryCostToGL.Post.SETVALUE(Post);
      PostInventoryCostToGL.SAVEASXML(LibraryReportDataset.GetParametersFileName,LibraryReportDataset.GetFileName);
    END;

    [Normal]
    LOCAL PROCEDURE ExecuteUIHandlers@76();
    BEGIN
      // Generate Dummy message. Required for executing the test case successfully.
      MESSAGE('');
      IF CONFIRM('') THEN;
    END;

    LOCAL PROCEDURE VerifyInventoryAvailabilityReport@97(ItemNo@1000 : Code[20];Qty@1001 : Decimal);
    BEGIN
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_Item',ItemNo);
      LibraryReportDataset.GetNextRow;
      LibraryReportDataset.AssertCurrentRowValue('PlannedOrderReceipt',Qty);
      LibraryReportDataset.AssertCurrentRowValue('ProjAvailBalance',Qty);
    END;

    LOCAL PROCEDURE VerifyLibraryReportDatasetQuantity@130(ExpectedQty@1000 : Decimal;ItemNo@1001 : Code[20]);
    BEGIN
      LibraryReportDataset.LoadDataSetFile;
      LibraryReportDataset.SetRange('No_Item',ItemNo);
      Assert.AreEqual(ExpectedQty,LibraryReportDataset.Sum('RemainingQty'),ReportQtyErr);
    END;

    LOCAL PROCEDURE SetLimitsTotalsFilterOnItem@119(VAR Item@1000 : Record 27;ItemLedgerEntry@1001 : Record 32);
    BEGIN
      WITH Item DO BEGIN
        SETRANGE("Location Filter",ItemLedgerEntry."Location Code");
        SETRANGE("Variant Filter",ItemLedgerEntry."Variant Code");
        SETRANGE("Global Dimension 1 Filter",ItemLedgerEntry."Global Dimension 1 Code");
        SETRANGE("Global Dimension 2 Filter",ItemLedgerEntry."Global Dimension 2 Code");
      END;
    END;

    BEGIN
    {
      // [FEATURE] [SCM]
      Unsupported version tags:
      US: Unable to Compile
      MX: Unable to Compile
      CA: Unable to Compile

      Test Inventory Reports - II:
       1. Run the Price List report with Customer and no Currency. Verify Unit Price.
       2. Run the Price List report with Customer and random Currency. Verify Unit Price.
       3. Run the Price List report with Customer Price Group and no Currency. Verify Unit Price.
       4. Run the Price List report with Customer Price Group and random Currency. Verify Unit Price.
       5. Run the Price List report with All Customer and no Currency. Verify Unit Price.
       6. Run the Price List report with All Customer and random Currency. Verify Unit Price.
       7. Run the Price List report with Campaign and no Currency. Verify Unit Price.
       8. Run the Price List report with Campaign and random Currency. Verify Unit Price.
       9. Run the Inventory Posting - Test report. Verify Quantity, Unit Cost and Cost Amount.
      10. Run the Status report. Verify Quantity.
      11. Run the Inventory Valuation - Cost Spec. report. Verify Quantity.
      12. Run the Inventory Valuation - WIP report. Verify Quantity.
      13. Run the Purchase Reservation Avail. report. Verify Expected Receipt Date.
      14. Run the Purchase Reservation Avail. report with Show Purchase Lines. Verify Outstanding Quantity.
      15. Run the Sales Reservation Avail. report. Verify Shipment Date.
      16. Run the Sales Reservation Avail. report with Show Sales Lines. Verify Outstanding Quantity.
      17. Run the Sales Reservation Avail. report with Show Reservation Entries. Verify Reserved Quantity.
      18. Run the Rolled Up Cost Shares report. Verify Item details.
      19. Run the Single Level Cost Shares report. Verify Item details.
      20. Run the Detailed Calculation report. Verify Item details.
      21. Run the Where Used (Top Level) report. Verify Item details.
      22. Run the Inventory Availability report. Verify Item details.
      23. Run the Status report for Purchase Order post with Receive Option. Verify Details on Generated Report.
      24. Run the Status report for Purchase Order post with Receive Option with Change Unit of Measure code on Purchase Line. Verify Details on Generated Report.
      25. Run the Inventory Valuation - Cost Spec. report for Purchase Order post with Receive Option. Verify Details on Generated Report.
      26. Run the Inventory Valuation - WIP report. Verify Cost Posted To GL After Posting Revalution Journal.
      27. Run the Sales Reservation Avail. report when Sales Order Auto Reserve From Inventory.
      28. Run the Sales & Purchase Reservation Avail. report when Sales Order Auto Reserve From Purchase Order.
      29. Run the Sales & Purchase Reservation Avail. report when Sales Order Auto Reserve From Different Summary Type.
      30. Run the Price List report with Variant Code. Verify Variant Lines.
      31. Run the Inventory Valuation - WIP report. Zero line should not displayed in Report 5802
      32. Run the Inventory Valuation - WIP report. Cost Posted to G/L column should show the value incorrectly.
      33. Run the Rolled Up Cost Shares report and check the item on report when one component is delete from Production BOM Version with Under Development status.
      34. Run the Rolled Up Cost Shares report and check the item on report when one component is delete from Production BOM Version with Certified status.
      35. Run the Rolled Up Cost Shares report with type Production BOM and check the item on report when one component is delete from Production BOM Version with Under Development status.
      36. Run the Rolled Up Cost Shares report with type Production BOM and check the item on report when one component is delete from Production BOM Version with Certified status.
      37. Run the Inventory Valuation - WIP report. "As of..." column is correct in report 5802.

        Covers Test Cases:
        -------------------------------------------------------------------
        Test Function Name                       TFS ID
        -------------------------------------------------------------------
        PriceListCustomer                        139358
        PriceListCustomerCurr                    139358
        PriceListCustPriceGroup                  139358
        PriceListCustPriceGroupCurr              139358
        PriceListAllCustomer                     139358
        PriceListAllCustomerCurr                 139358
        PriceListReportCampaign                  139358
        PriceListReportCampaignCurr              139358
        InventoryPostingReport                   139356
        StatusReport                             139357
        InvtValuationCostSpecReport              139509
        InventoryValuationWIPReport              139446
        PurchaseReserveAvail                     142040
        PurchaseReserveAvailWithLines            142040
        SalesReserveAvail                        142037
        SalesReserveAvailWithLines               142037
        SalesReserveAvailWithReserve             142037
        RolledUpCostSharesReport                 139560
        SingleLevelCostSharesReport              139561
        DetailedCalculationReport                139562
        WhereUsedTopLevelReport                  139563
        InventoryAvailabilityReport              139402

        Covers Test Cases: 294364
        -------------------------------------------------------------------
        Test Function Name                                      TFS ID
        -------------------------------------------------------------------
        StatusReportForPurchaseOrderWithSameUOM                 127541
        StatusReportForPurchaseOrderWithDiffUOM                 127541
        InventoryValuationCostSpecReportForPurchaseOrder        127543

        Covers Test Cases: 319682
        -------------------------------------------------------------------
        Test Function Name                                      TFS ID
        -------------------------------------------------------------------
        CostPostedToGLAfterRunningInventoryValuationWIPReport   320014

        Covers Test Cases:332507
        -------------------------------------------------------------------
        Test Function Name                                      TFS ID
        -------------------------------------------------------------------
        SalesReservationAvailWithFullReservFromInventory
        SalesReservationAvailReportFullReservFromPurchOrder
        SalesReservationAvailReportReserveFromDifSupplyType

        Covers Test Cases: 333148
        -------------------------------------------------------------------
        Test Function Name                                      TFS ID
        -------------------------------------------------------------------
        PriceListReportVariant

        Covers Test Cases:
        -------------------------------------------------------------------
        Test Function Name                                      TFS ID
        -------------------------------------------------------------------
        ZeroLineNotDisplayedInInventoryValuationWIPReport           328231

        Covers Test Cases:
        -------------------------------------------------------------------
        Test Function Name                                      TFS ID
        -------------------------------------------------------------------
        CostPostedToGLShownInWIPReport                               7843

        BUG ID 49157
        ---------------------------------------------------------------------------------------------------------
        Test Function Name
        ---------------------------------------------------------------------------------------------------------
        RolledUpCostShareRepWithUnderDevelopmentStatus,RolledUpCostShareRepWithCertifiedStatus
        RolledUpCostShareRepWithUnderDevStatusWithProdBOM,RolledUpCostShareRepWithCertifiedStatusWithTypeProdBOM

        Covers Test Cases:
        -------------------------------------------------------------------
        Test Function Name                                      TFS ID
        -------------------------------------------------------------------
        AsOfValueInInventoryValuationWIPReport                  88606
    }
    END.
  }
}

