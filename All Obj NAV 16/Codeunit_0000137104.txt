OBJECT Codeunit 137104 SCM Kitting ATS in Whse/IT BM
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            IsInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LocationBM@1023 : Record 14;
      CompItem@1035 : Record 27;
      KitItem@1036 : Record 27;
      Assert@1009 : Codeunit 130000;
      LibraryWarehouse@1002 : Codeunit 132204;
      LibraryUtility@1003 : Codeunit 131000;
      LibraryAssembly@1010 : Codeunit 132207;
      LibraryInventory@1014 : Codeunit 132201;
      LibraryPurchase@1043 : Codeunit 130512;
      LibraryKitting@1024 : Codeunit 132205;
      LibraryRandom@1017 : Codeunit 130440;
      IsInitialized@1000 : Boolean;
      MSG_NOT_ON_INVT@1008 : TextConst 'ENU="Item "';
      MSG_QTY_BASE_NOT@1048 : TextConst 'ENU=Qty. to Handle (Base) in Tracking Specification';
      LocationTakeBinCode@1032 : Code[20];
      LocationAdditionalBinCode@1013 : Code[20];
      LocationToBinCode@1004 : Code[20];
      LocationFromBinCode@1058 : Code[20];
      LocationAdditionalPickBinCode@1044 : Code[20];
      WhseActivityType@1041 : 'None,WhsePick,InvtMvmt';
      Tracking@1049 : 'Untracked,Lot,Serial,LotSerial';
      GLB_ITPageHandler@1040 : 'AssignITSpec,SelectITSpec,AssignITSpecPartial,PutManuallyITSpec';
      PAR_ITPage_AssignSerial@1039 : Boolean;
      PAR_ITPage_AssignLot@1020 : Boolean;
      PAR_ITPage_AssignPartial@1011 : Boolean;
      PAR_ITPage_AssignQty@1005 : Decimal;
      PAR_ITPage_ITNo@1012 : Code[20];
      PAR_ITPage_FINDDIR@1028 : Code[20];
      WorkDate2@1019 : Date;
      ConfirmPostCount@1001 : Integer;
      MSG_WANT_TO_POST@1006 : TextConst 'ENU="Do you want to post the "';
      MSG_ORDERS_POSTED@1007 : TextConst 'ENU=1 orders out of a total of 1 have now been posted.';
      MSG_POSTING_DATE_NOTALLOWED@1015 : TextConst 'ENU=Posting Date is not within your range of allowed posting dates. in Assembly Header Document Type';
      MSG_INCORRECT_COMMENT@1016 : TextConst 'ENU=Type should be blank for comment text:';
      MSG_ENTER_POSTING_DATE@1018 : TextConst 'ENU=Enter the posting date.';
      MSG_NOTHING_TO_POST@1021 : TextConst 'ENU=There is nothing to post';
      MSG_CANNOT_RENAME@1022 : TextConst 'ENU=You cannot rename an Assembly Header.';

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostNotAllowedDate@6();
    VAR
      UserSetup@1004 : Record 91;
      TempAssemblyLine@1003 : TEMPORARY Record 901;
      AssemblyHeader@1002 : Record 900;
      LibraryTimeSheet@1005 : Codeunit 131904;
      NoOfItems@1000 : Integer;
    BEGIN
      // Test posting on not allowed date
      Initialize;

      LibraryTimeSheet.CreateUserSetup(UserSetup,TRUE);
      UserSetup.VALIDATE("Allow Posting From",CALCDATE('<-11M>',WORKDATE));
      UserSetup.VALIDATE("Allow Posting To",CALCDATE('<11M>',WORKDATE));
      UserSetup.MODIFY(TRUE);

      AssignBinCodesBM;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationToBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,100,100,TRUE,WorkDate2);

      AssemblyHeader.VALIDATE("Posting Date",CALCDATE('<-11M-1D>',WORKDATE));

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,MSG_POSTING_DATE_NOTALLOWED);

      UserSetup.DELETE;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostWrongComment@21();
    VAR
      AssemblyLine@1005 : Record 901;
      TempAssemblyLine@1003 : TEMPORARY Record 901;
      AssemblyHeader@1002 : Record 900;
      NoOfItems@1000 : Integer;
    BEGIN
      // Test posting when you have comment with not empty type
      Initialize;

      AssignBinCodesBM;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationToBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,100,100,TRUE,WorkDate2);

      LibraryAssembly.CreateAssemblyLine(AssemblyHeader,AssemblyLine,AssemblyLine.Type::Item,'','',0,0,'');
      AssemblyLine.VALIDATE(Description,'Comment');
      AssemblyLine.VALIDATE(Type,AssemblyLine.Type::Item);
      AssemblyLine.MODIFY(TRUE);

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,MSG_INCORRECT_COMMENT);
    END;

    [Test]
    PROCEDURE PostEmptyOrder1@24();
    VAR
      AssemblyHeader@1002 : Record 900;
    BEGIN
      // Test posting when you have only resoure and comment lines
      Initialize;

      AssignBinCodesBM;

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,0);

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
    END;

    [Test]
    PROCEDURE PostEmptyOrder2@29();
    VAR
      AssemblyLine@1005 : Record 901;
      AssemblyHeader@1002 : Record 900;
    BEGIN
      // Test posting when you have only comment lines
      Initialize;

      AssignBinCodesBM;

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,0);

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Resource);
      AssemblyLine.DELETEALL;

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,MSG_NOTHING_TO_POST);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler,ConfirmPostQuestion)]
    PROCEDURE PostWithQuestion@2();
    VAR
      TempAssemblyLine@1003 : TEMPORARY Record 901;
      AssemblyHeader@1002 : Record 900;
      AssembledQty@1001 : Decimal;
      NoOfItems@1000 : Integer;
    BEGIN
      // This test case calls codeunit 901 in order to get code coverage
      Initialize;

      AssignBinCodesBM;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationToBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,100,100,TRUE,WorkDate2);
      AssembledQty := AssemblyHeader."Quantity to Assemble";

      CODEUNIT.RUN(CODEUNIT::"Assembly-Post (Yes/No)",AssemblyHeader); // First time reply is no
      CODEUNIT.RUN(CODEUNIT::"Assembly-Post (Yes/No)",AssemblyHeader); // First time reply is yes

      // Verify.
      VerifyBinContents(AssemblyHeader,TempAssemblyLine,0,AssembledQty);
      VerifyWarehouseEntries(
        AssemblyHeader,TempAssemblyLine,AssembledQty,TRUE,TempAssemblyLine.COUNT + 1,AssemblyHeader."Posting Date");
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssembledQty);
      LibraryAssembly.VerifyItemRegister(AssemblyHeader);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler,PostBatchHandler,MessageHandler)]
    PROCEDURE PostWithBatch@5();
    VAR
      TempAssemblyLine@1003 : TEMPORARY Record 901;
      AssemblyHeader@1002 : Record 900;
      AssembledQty@1001 : Decimal;
      NoOfItems@1000 : Integer;
    BEGIN
      // This test case calls report 900 in order to get code coverage
      Initialize;

      AssignBinCodesBM;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationToBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,100,100,TRUE,WorkDate2);
      AssembledQty := AssemblyHeader."Quantity to Assemble";

      COMMIT;
      AssemblyHeader.SETRANGE("No.",AssemblyHeader."No.");

      REPORT.RUNMODAL(REPORT::"Batch Post Assembly Orders",TRUE,TRUE,AssemblyHeader);

      // Verify.
      VerifyBinContents(AssemblyHeader,TempAssemblyLine,0,AssembledQty);
      VerifyWarehouseEntries(AssemblyHeader,TempAssemblyLine,AssembledQty,TRUE,TempAssemblyLine.COUNT + 1,CALCDATE('<1M>',WORKDATE));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler,PostBatchHandlerError)]
    PROCEDURE PostWithBatchError@14();
    VAR
      TempAssemblyLine@1003 : TEMPORARY Record 901;
      AssemblyHeader@1002 : Record 900;
      NoOfItems@1000 : Integer;
    BEGIN
      // This test case calls report 900 in order to get code coverage
      Initialize;

      AssignBinCodesBM;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationToBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,100,100,TRUE,WorkDate2);

      COMMIT;
      AssemblyHeader.SETRANGE("No.",AssemblyHeader."No.");
      ASSERTERROR REPORT.RUNMODAL(REPORT::"Batch Post Assembly Orders",TRUE,TRUE,AssemblyHeader);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,MSG_ENTER_POSTING_DATE) > 0,
        'Expected:' + MSG_ENTER_POSTING_DATE + '. Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostFullRelease@135();
    BEGIN
      // TC-BINPOST
      Initialize;
      NormalPosting(100,100,0,TRUE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostFullPartCompRelease@37();
    BEGIN
      // TC-BINPOST
      Initialize;
      NormalPosting(100,LibraryRandom.RandIntInRange(1,99),0,TRUE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostFullNotRelease@12();
    BEGIN
      // TC-BINPOST
      Initialize;
      NormalPosting(100,100,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostPartialRelease@13();
    BEGIN
      // TC-BINPOST
      Initialize;
      NormalPosting(LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        0,
        TRUE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostPartialNotRelease@119();
    BEGIN
      // TC-BINPOST
      Initialize;
      NormalPosting(LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        0,
        FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostFullReleaseQtySupplem@19();
    BEGIN
      // TC-BINPOST
      Initialize;
      NormalPosting(100,100,LibraryRandom.RandIntInRange(1,10),TRUE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostFullNotReleaseQtySupplem@18();
    BEGIN
      // TC-BINPOST
      Initialize;
      NormalPosting(100,100,LibraryRandom.RandIntInRange(1,10),FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostPartReleaseQtySupplem@17();
    BEGIN
      // TC-BINPOST
      Initialize;
      NormalPosting(LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,10),
        TRUE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostPartNotReleaseQtySuppl@16();
    BEGIN
      // TC-BINPOST
      Initialize;
      NormalPosting(LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,10),
        FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostFull2Steps@53();
    VAR
      AssemblyHeader@1013 : Record 900;
      AssemblyLine@1012 : Record 901;
      TempAssemblyLine2@1010 : TEMPORARY Record 901;
      AssemblyHeaderNo@1008 : Code[20];
      HeaderQtyFactor@1007 : Decimal;
      PartialPostFactor@1006 : Decimal;
      QtySupplement@1003 : Decimal;
      AssembledQty@1002 : Decimal;
      FullAssembledQty@1001 : Decimal;
    BEGIN
      // TC-BINPOST
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesBM;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,99);
      PartialPostFactor := HeaderQtyFactor;
      QtySupplement := LibraryRandom.RandIntInRange(1,50);

      AssemblyHeaderNo := NormalPosting(HeaderQtyFactor,
          PartialPostFactor,
          QtySupplement,
          TRUE);

      // Post rest of the asembly order
      AssemblyHeader.RESET;
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");

      AssemblyLine.FINDSET;
      REPEAT
        IF AssemblyLine."Quantity to Consume" > 0 THEN BEGIN
          TempAssemblyLine2 := AssemblyLine;
          TempAssemblyLine2.INSERT
        END;
      UNTIL (AssemblyLine.NEXT = 0);

      AssembledQty := AssemblyHeader."Quantity to Assemble";
      FullAssembledQty := AssemblyHeader.Quantity;
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify.
      VerifyBinContents(AssemblyHeader,TempAssemblyLine2,QtySupplement,FullAssembledQty);

      TempAssemblyLine2.RESET;
      TempAssemblyLine2.SETRANGE(Type,TempAssemblyLine2.Type::Item);
      VerifyWarehouseEntries(
        AssemblyHeader,TempAssemblyLine2,AssembledQty,TRUE,2 * (TempAssemblyLine2.COUNT + 1),AssemblyHeader."Posting Date");
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostFullNotEnoughItemInBin@1();
    BEGIN
      // TC-BINPOST
      // There is enough item in inventory, but there is not enough item in ToBin.
      // Test checks that correspondent error appears during full posting
      Initialize;
      NotEnoughItemPosting(100,100,TRUE,MSG_NOT_ON_INVT);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostPartNotEnoughItemInBin@38();
    BEGIN
      // TC-BINPOST
      // There is enough item in inventory, but there is not enough item in ToBin.
      // Test checks that correspondent error appears during full posting
      Initialize;
      NotEnoughItemPosting(
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        TRUE,
        MSG_NOT_ON_INVT);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostFullNotEnoughItemInInvt@70();
    BEGIN
      // TC-BINPOST
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      NotEnoughItemPosting(100,100,TRUE,MSG_NOT_ON_INVT);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostPartNotEnoughItemInInvt@59();
    BEGIN
      // TC-BINPOST
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during partial posting
      Initialize;
      NotEnoughItemPosting(
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        FALSE,
        MSG_NOT_ON_INVT);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostPartNotEnoughItemReduce@45();
    VAR
      TempAssemblyLine@1011 : TEMPORARY Record 901;
      AssemblyHeader@1009 : Record 900;
      AssemblyLine@1007 : Record 901;
      NotEnoughItemNo@1006 : Code[20];
      Qtys@1005 : ARRAY [10] OF Decimal;
      AssembledQty@1004 : Decimal;
      i@1003 : Integer;
      NotEnoughNo@1002 : Integer;
      NoOfItems@1001 : Integer;
      EarliestDate@1000 : Date;
    BEGIN
      // TC-BINPOST
      // There is enough item in inventory, but there is not enough item in ToBin.
      // Test checks that partial posting works fine after reducing Qty To Assemble to smallest avaliable
      Initialize;
      AssignBinCodesBM;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,NoOfItems);

      NotEnoughNo := LibraryRandom.RandIntInRange(1,NoOfItems) - 1;
      AddCompInventoryNotEnough(AssemblyHeader,NotEnoughNo,NotEnoughItemNo,100,Qtys,FALSE,LocationToBinCode);

      LibraryAssembly.SetLinkToLines(AssemblyHeader,AssemblyLine);
      LibraryAssembly.EarliestAvailableDate(AssemblyHeader,AssemblyLine,AssembledQty,EarliestDate);
      UpdateQtysConsume(AssemblyHeader,TempAssemblyLine,AssembledQty,Qtys);
      AssembledQty := AssemblyHeader."Quantity to Assemble";

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify.
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssembledQty);
      LibraryAssembly.VerifyItemRegister(AssemblyHeader);

      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      VerifyWarehouseEntries(
        AssemblyHeader,TempAssemblyLine,AssembledQty,TRUE,TempAssemblyLine.COUNT + 1,AssemblyHeader."Posting Date");

      // Veryfy bin content for header assembly item
      VerifyBinContent(AssemblyHeader."Location Code",AssemblyHeader."Bin Code",AssemblyHeader."Item No.",AssembledQty);

      // Verify bin contents for components
      Assert.AreEqual(NoOfItems,TempAssemblyLine.COUNT,'Too many component item ' + AssemblyHeader."Item No." + ' in a bin content');
      i := 1;
      TempAssemblyLine.FINDSET;
      REPEAT
        VerifyBinContent(TempAssemblyLine."Location Code",TempAssemblyLine."Bin Code",
          TempAssemblyLine."No.",Qtys[i] - TempAssemblyLine."Quantity to Consume");
        i += 1;
      UNTIL TempAssemblyLine.NEXT = 0;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostFullNoEnoughItemSplit@8();
    VAR
      AssemblyHeader@1009 : Record 900;
      AssemblyLine@1008 : Record 901;
      TempAssemblyLine@1006 : TEMPORARY Record 901;
      NotEnoughItemNo@1005 : Code[20];
      Qtys@1003 : ARRAY [10] OF Decimal;
      AssembledQty@1002 : Decimal;
      NotEnoughNo@1001 : Integer;
      NoOfItems@1000 : Integer;
    BEGIN
      // TC-BINPOST
      // There is enough item in inventory but there is not enough item in ToBin.
      // Test checks that full posting works fine after reducing Qty To Consume on a line with not enough inventory
      // and adding one more line with rest of the quantity and another ToBin
      Initialize;
      AssignBinCodesBM;

      NoOfItems := 1;
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,NoOfItems);

      NotEnoughNo := 1;
      AddCompInventoryNotEnough(AssemblyHeader,NotEnoughNo,NotEnoughItemNo,100,Qtys,TRUE,LocationToBinCode);

      NoOfItems += 1;
      UpdateQtysConsumeAssemble(AssemblyHeader,Qtys,TempAssemblyLine);
      AssembledQty := AssemblyHeader."Quantity to Assemble";

      // Split lines
      LibraryAssembly.CreateAssemblyLine(AssemblyHeader,AssemblyLine,AssemblyLine.Type::Item,NotEnoughItemNo,
        LibraryAssembly.GetUnitOfMeasureCode(AssemblyLine.Type::Item,NotEnoughItemNo,TRUE),0,0,'');

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE("No.",NotEnoughItemNo);
      AssemblyLine.FINDLAST;

      AssemblyLine.VALIDATE("Quantity per",1);
      AssemblyLine.VALIDATE("Quantity to Consume",Qtys[NoOfItems]);
      AssemblyLine.VALIDATE("Bin Code",LocationAdditionalBinCode);
      AssemblyLine.MODIFY(TRUE);

      TempAssemblyLine := AssemblyLine;
      TempAssemblyLine.INSERT;

      AssemblyHeader.VALIDATE("Posting Date",WorkDate2);
      PostAssemblyHeader(AssemblyHeader."No.",'');

      // Verify
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssembledQty);
      LibraryAssembly.VerifyItemRegister(AssemblyHeader);

      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      VerifyWarehouseEntries(
        AssemblyHeader,TempAssemblyLine,AssembledQty,TRUE,TempAssemblyLine.COUNT + 1,AssemblyHeader."Posting Date");
      VerifyBinContentsQtys(AssemblyHeader,TempAssemblyLine,AssembledQty,Qtys,NoOfItems);
    END;

    [Test]
    PROCEDURE RenameAO@26();
    VAR
      AssemblyHeader@1002 : Record 900;
    BEGIN
      Initialize;

      AssignBinCodesBM;

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,0);
      ASSERTERROR AssemblyHeader.RENAME(AssemblyHeader."Document Type",'New');
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,MSG_CANNOT_RENAME) > 0,'Expected:' + MSG_CANNOT_RENAME + '. Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Test]
    PROCEDURE ITPostFull@328();
    BEGIN
      Initialize;
      AssignBinCodesBM;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationBM,100,0,WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    PROCEDURE ITPostPartial@327();
    BEGIN
      Initialize;
      AssignBinCodesBM;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationBM,LibraryRandom.RandIntInRange(50,99),0,WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    PROCEDURE ITPostFullQtySupplem@326();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationBM,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    PROCEDURE ITPostPartQtySupplem@325();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationBM,LibraryRandom.RandIntInRange(50,99),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    PROCEDURE ITPostFull2Steps@324();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Untracked);

      Post2Steps(LocationBM,WhseActivityType::None,TRUE,FALSE);
    END;

    [Test]
    PROCEDURE ITPostFullNotEnoughItemInBin@323();
    BEGIN
      // There is enough item in inventory, but there is not enough item in FromBin.
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Untracked);

      NotEnoughItemPostingIT(LocationBM,100,100,TRUE,WhseActivityType::None,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    PROCEDURE ITPostFullNotEnoughItemInInvt@322();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Untracked);

      NotEnoughItemPostingIT(LocationBM,100,100,FALSE,WhseActivityType::None,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullNoEnoughItemSplitLS@321();
    VAR
      AssemblyHeader@1009 : Record 900;
      TempAssemblyLine@1006 : TEMPORARY Record 901;
      NotEnoughItemNo@1005 : Code[20];
      Qtys@1003 : ARRAY [10] OF Decimal;
      NotEnoughNo@1001 : Integer;
      NoOfLines@1000 : Integer;
    BEGIN
      // There is enough item in inventory but there is not enough item in ToBin.
      // Test checks that full posting works fine after reducing Qty To Consume on a line with not enough inventory
      // and adding one more line with rest of the quantity and another ToBin
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::LotSerial);

      CreateAssemblyOrder(LocationBM,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      NotEnoughNo := 1;
      PurchaseComponentsNotEnough(LocationBM,AssemblyHeader,NotEnoughNo,NotEnoughItemNo,100,Qtys,TRUE,LocationToBinCode);

      NoOfLines := 2;
      UpdateQtysConsumeAssemble(AssemblyHeader,Qtys,TempAssemblyLine);

      AssignITToAssemblyLines(AssemblyHeader,FALSE,TRUE,'-');

      // Create new line with remaining qty
      CreateAssemblyLine(AssemblyHeader,NotEnoughItemNo,Qtys[NoOfLines],TRUE,TRUE);

      PostAssemblyHeader(AssemblyHeader."No.",'');
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullS@320();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationBM,100,0,WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostPartialS@319();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationBM,LibraryRandom.RandIntInRange(50,99),0,WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullQtySupplemS@318();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationBM,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostPartQtySupplemS@317();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationBM,LibraryRandom.RandIntInRange(50,99),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFull2StepsS@316();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Serial);

      Post2Steps(LocationBM,WhseActivityType::None,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullNotEnoughItemInBinS@315();
    BEGIN
      // There is enough item in inventory, but there is not enough item in FromBin.
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Serial);

      NotEnoughItemPostingIT(LocationBM,100,100,TRUE,WhseActivityType::None,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullNotEnoughItemInInvtS@314();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Serial);

      NotEnoughItemPostingIT(LocationBM,100,100,FALSE,WhseActivityType::None,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullPartITS@313();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationBM,100,0,WhseActivityType::None,MSG_QTY_BASE_NOT,TRUE,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullL@312();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationBM,100,0,WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostPartialL@311();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationBM,LibraryRandom.RandIntInRange(50,99),0,WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullQtySupplemL@310();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationBM,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostPartQtySupplemL@309();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationBM,LibraryRandom.RandIntInRange(50,99),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFull2StepsL@308();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Lot);

      Post2Steps(LocationBM,WhseActivityType::None,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullNotEnoughItemInBinL@307();
    BEGIN
      // There is enough item in inventory, but there is not enough item in FromBin.
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Lot);

      NotEnoughItemPostingIT(LocationBM,100,100,TRUE,WhseActivityType::None,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullNotEnoughItemInInvtL@306();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Lot);

      NotEnoughItemPostingIT(LocationBM,100,100,FALSE,WhseActivityType::None,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullPartITL@305();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationBM,100,0,WhseActivityType::None,MSG_QTY_BASE_NOT,TRUE,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostPartialLS@304();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationBM,LibraryRandom.RandIntInRange(50,99),0,WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullQtySupplemLS@303();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationBM,100,LibraryRandom.RandIntInRange(1,10),WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostPartQtySupplemLS@302();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationBM,LibraryRandom.RandIntInRange(50,99),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFull2StepsLS@301();
    BEGIN
      // Test does partial posting and verifies it. Then it postes rest of the order and verifies
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::LotSerial);

      Post2Steps(LocationBM,WhseActivityType::None,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullNotEnoughItemInBinLS@300();
    BEGIN
      // There is enough item in inventory, but there is not enough item in FromBin.
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::LotSerial);

      NotEnoughItemPostingIT(LocationBM,100,100,TRUE,WhseActivityType::None,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullNotEnoughItemInInvtLS@299();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::LotSerial);

      NotEnoughItemPostingIT(LocationBM,100,100,FALSE,WhseActivityType::None,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITPostFullPartITLS@298();
    BEGIN
      Initialize;
      AssignBinCodesBM;

      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationBM,100,0,WhseActivityType::None,MSG_QTY_BASE_NOT,TRUE,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(DummyMessageHandler)]
    PROCEDURE WhsePickRequestDeletedWhenPostingPartiallyPickedAssembly@7();
    VAR
      AsmItem@1005 : Record 27;
      ComponentItem@1006 : Record 27;
      Location@1000 : Record 14;
      Bin@1001 : Record 7354;
      BOMComponent@1007 : Record 90;
      AssemblyHeader@1008 : Record 900;
      AssemblyLine@1011 : Record 901;
      WarehouseActivityHeader@1002 : Record 5766;
      Qty@1003 : Integer;
      QtyToHandle@1004 : Integer;
    BEGIN
      // [FEATURE] [Pick] [Warehouse pick request]
      // [SCENARIO 382261] Warehouse pick request created from an assembly order should be deleted when the assembly is posted after partial pick and consumption

      Initialize;

      CreateLocationWithAssemblyBin(Location);
      LibraryWarehouse.CreateBin(Bin,Location.Code,LibraryUtility.GenerateRandomCode(Bin.FIELDNO(Code),DATABASE::Bin),'','');

      LibraryInventory.CreateItem(AsmItem);
      LibraryInventory.CreateItem(ComponentItem);

      Qty := LibraryRandom.RandIntInRange(10,20);
      QtyToHandle := LibraryRandom.RandIntInRange(1,Qty - 1);
      LibraryAssembly.CreateAssemblyListComponent(BOMComponent.Type::Item,ComponentItem."No.",AsmItem."No.",'',0,1,TRUE);
      PostPositiveAdjmtItemJournal(ComponentItem."No.",Qty,Location.Code,Bin.Code);

      // [GIVEN] Assembly order with Quantity = 10
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WorkDate2,AsmItem."No.",Location.Code,Qty,'');
      LibraryAssembly.ReleaseAO(AssemblyHeader);

      // [GIVEN] Create warehouse pick from the assembly
      LibraryAssembly.CreateWhsePick(AssemblyHeader,'',0,FALSE,TRUE,FALSE);
      UpdateWhseActivityQtyToHandle(DATABASE::"Assembly Line",AssemblyHeader."No.",QtyToHandle);

      // [GIVEN] Set "Qty. to Handle" = 5 in the pick line and register the pick
      FindWhseActivity(WarehouseActivityHeader,Location.Code);
      LibraryWarehouse.RegisterWhseActivity(WarehouseActivityHeader);

      // [GIVEN] Delete the pick
      WarehouseActivityHeader.FIND;
      WarehouseActivityHeader.DELETE(TRUE);

      // [GIVEN] Set "Quantity to Consume" = 5 in the assembly line
      FindAssemblyLine(AssemblyLine,AssemblyHeader."Document Type",AssemblyHeader."No.");
      AssemblyLine.VALIDATE("Quantity to Consume",QtyToHandle);
      AssemblyLine.MODIFY(TRUE);

      // [WHEN] Post the assembly order
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // [THEN] Warehouse pick request does not exist
      VerifyWhsePickRequestEmpty(AssemblyHeader."Document Type",AssemblyHeader."No.");
    END;

    LOCAL PROCEDURE Initialize@25();
    VAR
      WarehouseSetup@1001 : Record 5769;
      SalesReceivablesSetup@1002 : Record 311;
      PurchasesPayablesSetup@1006 : Record 312;
      AssemblySetup@1000 : Record 905;
      MfgSetup@1004 : Record 99000765;
      LibraryERMCountryData@1008 : Codeunit 131305;
    BEGIN
      ConfirmPostCount := 0;

      IF IsInitialized THEN
        EXIT;

      // Setup Demonstration data.
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;

      CLEARLASTERROR;
      MfgSetup.GET;
      WorkDate2 := CALCDATE(MfgSetup."Default Safety Lead Time",WORKDATE); // to avoid Due Date Before Work Date message.
      LibraryAssembly.UpdateAssemblySetup(AssemblySetup,'',AssemblySetup."Copy Component Dimensions from"::"Item/Resource Card",
        LibraryUtility.GetGlobalNoSeriesCode);

      LibraryWarehouse.NoSeriesSetup(WarehouseSetup);

      SalesReceivablesSetup.GET;
      SalesReceivablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesReceivablesSetup.MODIFY(TRUE);

      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      PurchasesPayablesSetup.MODIFY(TRUE);

      LocationSetupBM(LocationBM);

      IsInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE NormalPosting@33(HeaderQtyFactor@1012 : Decimal;PartialPostFactor@1011 : Decimal;QtySupplement@1018 : Decimal;Release@1001 : Boolean) : Code[20];
    VAR
      TempAssemblyLine@1007 : TEMPORARY Record 901;
      AssemblyHeader@1019 : Record 900;
      AssembledQty@1013 : Decimal;
      NoOfItems@1000 : Integer;
    BEGIN
      AssignBinCodesBM;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,QtySupplement,AssemblyHeader."Location Code",LocationToBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);
      AssembledQty := AssemblyHeader."Quantity to Assemble";

      IF Release THEN
        CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify.
      VerifyBinContents(AssemblyHeader,TempAssemblyLine,QtySupplement,AssembledQty);
      VerifyWarehouseEntries(
        AssemblyHeader,TempAssemblyLine,AssembledQty,TRUE,TempAssemblyLine.COUNT + 1,AssemblyHeader."Posting Date");
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssembledQty);
      LibraryAssembly.VerifyItemRegister(AssemblyHeader);

      EXIT(AssemblyHeader."No.");
    END;

    LOCAL PROCEDURE NotEnoughItemPosting@3(HeaderQtyFactor@1012 : Decimal;PartialPostFactor@1011 : Decimal;AddAdditionalQty@1000 : Boolean;ExpectedErrorMessage@1001 : Text[1024]);
    VAR
      TempAssemblyLine@1007 : TEMPORARY Record 901;
      AssemblyHeader@1022 : Record 900;
      NotEnoughItemNo@1015 : Code[20];
      Qtys@1017 : ARRAY [10] OF Decimal;
      AssembledQty@1013 : Decimal;
      NotEnoughNo@1018 : Integer;
      NoOfItems@1019 : Integer;
    BEGIN
      AssignBinCodesBM;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationBM.Code,NoOfItems);

      NotEnoughNo := LibraryRandom.RandIntInRange(1,NoOfItems);
      AddCompInventoryNotEnough(AssemblyHeader,NotEnoughNo,NotEnoughItemNo,PartialPostFactor,Qtys,AddAdditionalQty,LocationToBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);
      AssembledQty := AssemblyHeader."Quantity to Assemble";

      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessage);

      // Verify.
      VerifyWarehouseEntries(
        AssemblyHeader,TempAssemblyLine,AssembledQty,FALSE,TempAssemblyLine.COUNT + 1,AssemblyHeader."Posting Date");
      VerifyBinContentsQtys(AssemblyHeader,TempAssemblyLine,0,Qtys,NoOfItems);
    END;

    LOCAL PROCEDURE SetGenWarehouseEntriesFilter@99(VAR WarehouseEntry@1001 : Record 7312;AssemblyHeader@1000 : Record 900;PostingDate@1002 : Date);
    VAR
      SourceCodeSetup@1003 : Record 242;
    BEGIN
      WarehouseEntry.RESET;
      SourceCodeSetup.GET;
      WarehouseEntry.SETRANGE("Source Code",SourceCodeSetup.Assembly);
      // WarehouseEntry.SETRANGE("Whse. Document Type",WarehouseEntry."Whse. Document Type"::Assembly);
      // WarehouseEntry.SETRANGE("Whse. Document No.",AssemblyHeader."No.");
      WarehouseEntry.SETRANGE("Source No.",AssemblyHeader."No.");
      WarehouseEntry.SETRANGE("Registering Date",PostingDate);
      WarehouseEntry.SETRANGE("User ID",USERID);
    END;

    LOCAL PROCEDURE SetLocWarehouseEntriesFilter@147(VAR WarehouseEntry@1001 : Record 7312;VariantCode@1000 : Code[20];UOMCode@1002 : Code[20];Quantity@1003 : Decimal;WarehouseEntryType@1004 : Integer;LocationCode@1005 : Code[20];BinCode@1006 : Code[20];ItemNo@1007 : Code[20];SourceLineNo@1008 : Integer);
    BEGIN
      WarehouseEntry.SETRANGE("Variant Code",VariantCode);
      WarehouseEntry.SETRANGE("Unit of Measure Code",UOMCode);
      WarehouseEntry.SETRANGE(Quantity,Quantity);
      WarehouseEntry.SETRANGE("Entry Type",WarehouseEntryType);
      WarehouseEntry.SETRANGE("Location Code",LocationCode);
      WarehouseEntry.SETRANGE("Bin Code",BinCode);
      WarehouseEntry.SETRANGE("Item No.",ItemNo);
      // Description is not set because of bug
      // WarehouseEntry.SETRANGE(Description,TempAssemblyLine.Description);
      // WarehouseEntry.SETRANGE("Source Document",WarehouseEntry."Source Document"::"Assembly Order");
      WarehouseEntry.SETRANGE("Source Line No.",SourceLineNo);
    END;

    LOCAL PROCEDURE VerifyWarehouseEntries@125(AssemblyHeader@1001 : Record 900;VAR TempAssemblyLine@1002 : TEMPORARY Record 901;AssembledQty@1003 : Decimal;ShouldBeCreated@1004 : Boolean;ExpectedNoOfWhseEntries@1005 : Integer;PostingDate@1006 : Date);
    VAR
      WarehouseEntry@1000 : Record 7312;
    BEGIN
      // Verify whole amount of warehouse entries
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);

      SetGenWarehouseEntriesFilter(WarehouseEntry,AssemblyHeader,PostingDate);
      IF ShouldBeCreated THEN
        Assert.AreEqual(ExpectedNoOfWhseEntries,WarehouseEntry.COUNT,
          'Incorect number of warehouse entries for assembly ' + AssemblyHeader."No.")
      ELSE
        Assert.AreEqual(0,WarehouseEntry.COUNT,
          'Incorect number of warehouse entries for assembly ' + AssemblyHeader."No.");

      // Verify warehouse entries for header assembly item
      SetGenWarehouseEntriesFilter(WarehouseEntry,AssemblyHeader,PostingDate);
      SetLocWarehouseEntriesFilter(WarehouseEntry,
        AssemblyHeader."Variant Code",
        AssemblyHeader."Unit of Measure Code",
        AssembledQty,
        WarehouseEntry."Entry Type"::"Positive Adjmt.",
        AssemblyHeader."Location Code",
        AssemblyHeader."Bin Code",
        AssemblyHeader."Item No.",
        0);
      IF ShouldBeCreated THEN
        Assert.AreEqual(1,WarehouseEntry.COUNT,
          'Incorrect number of warehouse entries for assembly item ' + AssemblyHeader."Item No.")
      ELSE
        Assert.AreEqual(0,WarehouseEntry.COUNT,
          'Incorrect number of warehouse entries for assembly item ' + AssemblyHeader."Item No.");

      // Verify warehouse entries for components
      TempAssemblyLine.FINDSET;
      REPEAT
        SetGenWarehouseEntriesFilter(WarehouseEntry,AssemblyHeader,PostingDate);
        SetLocWarehouseEntriesFilter(WarehouseEntry,
          TempAssemblyLine."Variant Code",
          TempAssemblyLine."Unit of Measure Code",
          -TempAssemblyLine."Quantity to Consume",
          WarehouseEntry."Entry Type"::"Negative Adjmt.",
          TempAssemblyLine."Location Code",
          TempAssemblyLine."Bin Code",
          TempAssemblyLine."No.",
          TempAssemblyLine."Line No.");
        IF ShouldBeCreated THEN
          Assert.AreEqual(1,WarehouseEntry.COUNT,
            'Incorrect number of warehouse entries for assembly line ' + TempAssemblyLine."No.")
        ELSE
          Assert.AreEqual(0,WarehouseEntry.COUNT,
            'Incorrect number of warehouse entries for assembly line ' + TempAssemblyLine."No.");
      UNTIL TempAssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyBinContent@101(LocationCode@1003 : Code[20];BinCode@1000 : Code[20];ItemNo@1002 : Code[20];Quantity@1001 : Decimal);
    VAR
      BinContent@1004 : Record 7302;
    BEGIN
      BinContent.RESET;
      BinContent.SETRANGE("Location Code",LocationCode);
      BinContent.SETRANGE("Bin Code",BinCode);
      BinContent.SETRANGE("Item No.",ItemNo);
      IF BinContent.FINDFIRST THEN BEGIN
        BinContent.CALCFIELDS(Quantity);
        BinContent.TESTFIELD(Quantity,Quantity);
      END ELSE
        Assert.AreEqual(Quantity,0,'Incorrect Qty of Item ' + ItemNo + ' in Bin ' + BinCode);
    END;

    LOCAL PROCEDURE VerifyBinContents@154(AssemblyHeader@1000 : Record 900;VAR TempAssemblyLine@1001 : TEMPORARY Record 901;QtySupplement@1002 : Decimal;AssembledQty@1003 : Decimal);
    BEGIN
      // Veryfy bin content for header assembly item
      VerifyBinContent(AssemblyHeader."Location Code",AssemblyHeader."Bin Code",AssemblyHeader."Item No.",AssembledQty);

      // Verify bin contents for components
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;
      REPEAT
        VerifyBinContent(TempAssemblyLine."Location Code",TempAssemblyLine."Bin Code",
          TempAssemblyLine."No.",
          QtySupplement + TempAssemblyLine.Quantity - TempAssemblyLine."Quantity to Consume" - TempAssemblyLine."Consumed Quantity");
      UNTIL TempAssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyBinContentsQtys@28(AssemblyHeader@1000 : Record 900;VAR TempAssemblyLine@1001 : TEMPORARY Record 901;AssembledQty@1008 : Decimal;Qtys@1003 : ARRAY [10] OF Decimal;NoOfItems@1007 : Integer);
    VAR
      BinContent@1005 : Record 7302;
      i@1006 : Integer;
      CompQty@1009 : Decimal;
    BEGIN
      // Veryfy bin content for header assembly item
      IF AssembledQty = 0 THEN BEGIN
        BinContent.SETRANGE("Location Code",AssemblyHeader."Location Code");
        BinContent.SETRANGE("Bin Code",AssemblyHeader."Bin Code");
        BinContent.SETRANGE("Item No.",AssemblyHeader."Item No.");
        Assert.AreEqual(0,BinContent.COUNT,'Too many item ' + AssemblyHeader."Item No." + ' in a bin content');
      END ELSE
        VerifyBinContent(AssemblyHeader."Location Code",AssemblyHeader."Bin Code",AssemblyHeader."Item No.",AssembledQty);

      // Verify bin contents for components
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      Assert.AreEqual(NoOfItems,TempAssemblyLine.COUNT,'Too many component item ' + AssemblyHeader."Item No." + ' in a bin content');
      i := 1;
      TempAssemblyLine.FINDSET;
      REPEAT
        IF AssembledQty = 0 THEN
          CompQty := Qtys[i]
        ELSE
          CompQty := TempAssemblyLine."Quantity to Consume" - Qtys[i];

        VerifyBinContent(TempAssemblyLine."Location Code",TempAssemblyLine."Bin Code",
          TempAssemblyLine."No.",CompQty);
        i += 1;
      UNTIL TempAssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyWhsePickRequestEmpty@51(AsmDocType@1002 : Option;AsmDocNo@1001 : Code[20]);
    VAR
      WhsePickRequest@1000 : Record 7325;
    BEGIN
      WITH WhsePickRequest DO BEGIN
        SETRANGE("Document Type","Document Type"::Assembly);
        SETRANGE("Document Subtype",AsmDocType);
        SETRANGE("Document No.",AsmDocNo);
      END;
      Assert.RecordIsEmpty(WhsePickRequest);
    END;

    LOCAL PROCEDURE AddCompInventoryNotEnough@11(AssemblyHeader@1001 : Record 900;NotEnoughNo@1003 : Integer;VAR NotEnoughItemNo@1006 : Code[20];CompQtyFactor@1007 : Integer;VAR ResultQtys@1004 : ARRAY [10] OF Decimal;AddAdditionalQty@1009 : Boolean;BinToPutCode@1000 : Code[20]);
    VAR
      Item@1002 : Record 27;
      AssemblyLine@1010 : Record 901;
      i@1005 : Integer;
      ItemsCount@1008 : Integer;
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.FINDSET;

      // Calculate result quantities
      i := 1;
      REPEAT
        ResultQtys[i] := AssemblyLine.Quantity * CompQtyFactor / 100;
        IF i = NotEnoughNo THEN BEGIN
          Item.GET(AssemblyLine."No.");
          NotEnoughItemNo := Item."No.";
          ResultQtys[i] := ROUND(ResultQtys[i],0.00001,'>');
          ResultQtys[i] -= 0.00002;
          ItemsCount := AssemblyLine.COUNT + 1;
          ResultQtys[ItemsCount] := 0.00002;
        END ELSE
          ResultQtys[i] := ROUND(ResultQtys[i],0.00001,'>');

        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add inventory
      i := 1;
      AssemblyLine.FINDSET;
      REPEAT
        LibraryAssembly.AddItemInventory(AssemblyLine,WorkDate2,AssemblyLine."Location Code",BinToPutCode,ResultQtys[i]);
        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add rest inventory to additional bin
      IF AddAdditionalQty THEN BEGIN
        AssemblyLine.RESET;
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
        AssemblyLine.SETRANGE("No.",NotEnoughItemNo);
        AssemblyLine.FINDFIRST;

        LibraryAssembly.AddItemInventory(
          AssemblyLine,WorkDate2,AssemblyLine."Location Code",LocationAdditionalBinCode,ResultQtys[ItemsCount]);
      END;
    END;

    LOCAL PROCEDURE FindWhseActivity@50(VAR WarehouseActivityHeader@1002 : Record 5766;LocationCode@1000 : Code[10]);
    BEGIN
      WarehouseActivityHeader.SETRANGE("Location Code",LocationCode);
      WarehouseActivityHeader.FINDFIRST;
    END;

    LOCAL PROCEDURE UpdateQtysConsumeAssemble@48(AssemblyHeader@1005 : Record 900;Qtys@1010 : ARRAY [10] OF Decimal;VAR TempAssemblyLine@1011 : TEMPORARY Record 901);
    VAR
      AssemblyLine@1016 : Record 901;
      i@1000 : Integer;
    BEGIN
      TempAssemblyLine.DELETEALL;
      AssemblyHeader.VALIDATE("Quantity to Assemble",AssemblyHeader."Quantity to Assemble");
      AssemblyHeader.VALIDATE(Description,
        LibraryUtility.GenerateRandomCode(AssemblyHeader.FIELDNO(Description),DATABASE::"Assembly Header"));
      AssemblyHeader.VALIDATE("Posting Date",WorkDate2);
      LibraryAssembly.AddAssemblyHeaderComment(AssemblyHeader,0);
      AssemblyHeader.MODIFY(TRUE);

      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      i := 1;

      AssemblyLine.FINDSET;
      REPEAT
        AssemblyLine.VALIDATE("Quantity to Consume",Qtys[i]);
        AssemblyLine.VALIDATE(Description,
          LibraryUtility.GenerateRandomCode(AssemblyLine.FIELDNO(Description),DATABASE::"Assembly Line"));
        LibraryAssembly.AddAssemblyHeaderComment(AssemblyHeader,AssemblyLine."Line No.");
        AssemblyLine.MODIFY(TRUE);
        TempAssemblyLine := AssemblyLine;
        TempAssemblyLine.INSERT;
        i += 1;
      UNTIL (AssemblyLine.NEXT = 0);

      TempAssemblyLine.SETRANGE("Quantity to Consume",0);
      IF TempAssemblyLine.FINDSET THEN
        TempAssemblyLine.DELETE;
    END;

    [Normal]
    LOCAL PROCEDURE UpdateQtysConsume@31(VAR AssemblyHeader@1000 : Record 900;VAR TempAssemblyLine@1006 : TEMPORARY Record 901;QtyToAssemble@1005 : Decimal;Qtys@1002 : ARRAY [10] OF Decimal);
    VAR
      AssemblyLine@1004 : Record 901;
      i@1001 : Integer;
    BEGIN
      TempAssemblyLine.DELETEALL;
      AssemblyHeader.VALIDATE("Quantity to Assemble",QtyToAssemble);
      AssemblyHeader.MODIFY(TRUE);

      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      i := 1;

      AssemblyLine.FINDSET;
      REPEAT
        AssemblyLine.VALIDATE("Quantity to Consume",Qtys[i]);
        AssemblyLine.MODIFY(TRUE);

        IF AssemblyLine."Quantity to Consume" > 0 THEN BEGIN
          TempAssemblyLine := AssemblyLine;
          TempAssemblyLine.INSERT;
        END;
        i += 1;
      UNTIL (AssemblyLine.NEXT = 0);
    END;

    LOCAL PROCEDURE UpdateWhseActivityQtyToHandle@44(SourceType@1000 : Integer;SourceNo@1001 : Code[20];QtyToHandle@1002 : Decimal);
    VAR
      WarehouseActivityLine@1003 : Record 5767;
    BEGIN
      WITH WarehouseActivityLine DO BEGIN
        SETRANGE("Source Type",SourceType);
        SETRANGE("Source No.",SourceNo);
        FINDSET(TRUE);
        REPEAT
          VALIDATE("Qty. to Handle",QtyToHandle);
          MODIFY(TRUE);
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE LocationSetupBM@60(VAR Location@1000 : Record 14);
    VAR
      WarehouseEmployee@1001 : Record 7301;
      Bin@1002 : Record 7354;
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,Location.Code,FALSE);

      // Skip validate trigger for bin mandatory to improve performance.
      Location."Bin Mandatory" := TRUE;
      Location.MODIFY(TRUE);

      AssignBinCodesBM;

      LibraryWarehouse.CreateBin(Bin,Location.Code,LocationAdditionalBinCode,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,LocationToBinCode,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,LocationFromBinCode,'','');
      Location.VALIDATE("From-Assembly Bin Code",LocationFromBinCode);
      Location.VALIDATE("To-Assembly Bin Code",LocationToBinCode);
      Location.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE AssignBinCodesBM@63();
    BEGIN
      LocationAdditionalBinCode := 'ABin';
      LocationToBinCode := 'ToBin';
      LocationFromBinCode := 'FromBin';
      LocationTakeBinCode := '';
      LocationAdditionalPickBinCode := '';
    END;

    [Normal]
    LOCAL PROCEDURE PostAssemblyHeader@172(AssemblyHeaderNo@1000 : Code[20];ExpectedError@1002 : Text[1024]);
    VAR
      AssemblyHeader@1003 : Record 900;
    BEGIN
      AssemblyHeader.INIT;
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,ExpectedError);
    END;

    LOCAL PROCEDURE Post2Steps@122(Location@1000 : Record 14;WhseActivity@1002 : Option;AssignITBeforeWhseAct@1005 : Boolean;AssignITOnWhseAct@1006 : Boolean);
    VAR
      AssemblyHeader@1003 : Record 900;
      AssemblyLine@1007 : Record 901;
      TempAssemblyLine2@1008 : TEMPORARY Record 901;
      ReleaseAssemblyDoc@1004 : Codeunit 903;
      AssemblyHeaderNo@1010 : Code[20];
      HeaderQtyFactor@1001 : Decimal;
    BEGIN
      HeaderQtyFactor := LibraryRandom.RandIntInRange(50,60);

      AssemblyHeaderNo := NormalPostingIT(Location,HeaderQtyFactor,0,WhseActivity,'',AssignITBeforeWhseAct,AssignITOnWhseAct,FALSE);

      // Post rest of the asembly order
      AssemblyHeader.RESET;
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationTakeBinCode);

      ReleaseAssemblyDoc.Reopen(AssemblyHeader);

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");

      AssemblyLine.FINDSET;
      REPEAT
        IF AssemblyLine."Quantity to Consume" > 0 THEN BEGIN
          AssemblyLine.VALIDATE("Quantity to Consume",1);
          AssemblyLine.MODIFY(TRUE);
          TempAssemblyLine2 := AssemblyLine;
          TempAssemblyLine2.INSERT
        END;
      UNTIL (AssemblyLine.NEXT = 0);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,FALSE,TRUE,'+')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,FALSE,FALSE,'+');
      END;

      CreateAndRegisterWhseActivity(AssemblyHeaderNo,WhseActivity,AssignITOnWhseAct,FALSE,'+','');

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
    END;

    LOCAL PROCEDURE PurchaseComponentsToBin@120(AssemblyHeader@1000 : Record 900;QtySupplement@1001 : Decimal;Location@1007 : Record 14;BinCode@1006 : Code[20]);
    VAR
      AssemblyLine@1003 : Record 901;
      PurchaseHeader@1002 : Record 38;
    BEGIN
      CreatePurchaseHeader(Location.Code,PurchaseHeader);

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      IF AssemblyLine.FINDSET THEN
        REPEAT
          CreatePurchaseLine(PurchaseHeader,AssemblyLine."No.",Location,BinCode,
            ROUND(AssemblyLine.Quantity + QtySupplement,1,'>'));
        UNTIL AssemblyLine.NEXT = 0;

      PostPurchaseHeader(PurchaseHeader,Location,'');
    END;

    LOCAL PROCEDURE PurchaseComponentsNotEnough@118(Location@1012 : Record 14;AssemblyHeader@1001 : Record 900;NotEnoughNo@1003 : Integer;VAR NotEnoughItemNo@1006 : Code[20];CompQtyFactor@1007 : Integer;VAR ResultQtys@1004 : ARRAY [10] OF Decimal;AddAdditionalQty@1009 : Boolean;BinToPutCode@1000 : Code[20]);
    VAR
      Item@1002 : Record 27;
      AssemblyLine@1010 : Record 901;
      PurchaseHeader@1011 : Record 38;
      i@1005 : Integer;
      ItemsCount@1008 : Integer;
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.FINDSET;

      // Calculate result quantities
      i := 1;
      REPEAT
        ResultQtys[i] := AssemblyLine.Quantity * CompQtyFactor / 100;
        IF i = NotEnoughNo THEN BEGIN
          Item.GET(AssemblyLine."No.");
          NotEnoughItemNo := Item."No.";
          ResultQtys[i] := ROUND(ResultQtys[i],1,'>');
          ResultQtys[i] -= 2;
          ItemsCount := AssemblyLine.COUNT + 1;
          ResultQtys[ItemsCount] := 2;
        END ELSE
          ResultQtys[i] := ROUND(ResultQtys[i],1,'>');

        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add inventory
      CreatePurchaseHeader(Location.Code,PurchaseHeader);

      i := 1;
      AssemblyLine.FINDSET;
      REPEAT
        CreatePurchaseLine(PurchaseHeader,AssemblyLine."No.",Location,BinToPutCode,ResultQtys[i]);
        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add rest inventory to additional bin
      IF AddAdditionalQty THEN BEGIN
        AssemblyLine.RESET;
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
        AssemblyLine.SETRANGE("No.",NotEnoughItemNo);
        AssemblyLine.FINDFIRST;

        CreatePurchaseLine(PurchaseHeader,AssemblyLine."No.",
          Location,LocationAdditionalBinCode,ResultQtys[ItemsCount]);
        PostPurchaseHeader(PurchaseHeader,Location,NotEnoughItemNo);
      END ELSE
        PostPurchaseHeader(PurchaseHeader,Location,'');
    END;

    [Normal]
    LOCAL PROCEDURE CreateAssemblyOrder@110(Location@1000 : Record 14;Qty@1002 : Integer;VAR AssemblyHeader@1001 : Record 900);
    BEGIN
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WorkDate2,KitItem."No.",Location.Code,Qty,'');

      CreateAssemblyLine(AssemblyHeader,CompItem."No.",LibraryRandom.RandIntInRange(2,4),FALSE,FALSE);
    END;

    LOCAL PROCEDURE CreateAssemblyLine@108(VAR AssemblyHeader@1000 : Record 900;ItemNo@1002 : Code[20];Quantity@1003 : Integer;AssignBinCode@1004 : Boolean;AssignIT@1005 : Boolean);
    VAR
      AssemblyLine@1001 : Record 901;
      AssemblyOrderPage@1006 : TestPage 900;
    BEGIN
      LibraryKitting.AddLine(AssemblyHeader,AssemblyLine.Type::Item,ItemNo,
        LibraryAssembly.GetUnitOfMeasureCode(AssemblyLine.Type::Item,ItemNo,TRUE),
        Quantity,1,'');

      IF AssignBinCode THEN BEGIN
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE("No.",ItemNo);
        AssemblyLine.FINDLAST;

        AssemblyLine.VALIDATE("Bin Code",LocationAdditionalBinCode);
        AssemblyLine.VALIDATE("Quantity to Consume",Quantity);
        AssemblyLine.MODIFY;
      END;

      IF AssignIT THEN BEGIN
        AssemblyOrderPage.OPENEDIT;
        AssemblyOrderPage.FILTER.SETFILTER("No.",AssemblyHeader."No.");

        AssemblyOrderPage.Lines.LAST;

        PrepareHandleSelectEntries(FALSE);
        AssemblyOrderPage.Lines."Item Tracking Lines".INVOKE;
        AssemblyOrderPage.OK.INVOKE;
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CreateItems@107(ItemTracking@1000 : Option);
    BEGIN
      CreateTrackedItem(CompItem,ItemTracking);
      CreateTrackedItem(KitItem,Tracking::Untracked);
    END;

    LOCAL PROCEDURE CreateLocationWithAssemblyBin@54(VAR Location@1000 : Record 14);
    VAR
      Bin@1001 : Record 7354;
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);

      WITH Location DO BEGIN
        VALIDATE("Bin Mandatory",TRUE);
        VALIDATE("Require Shipment",TRUE);
        VALIDATE("Require Pick",TRUE);
        MODIFY(TRUE);

        LibraryWarehouse.CreateBin(Bin,Code,LibraryUtility.GenerateRandomCode(Bin.FIELDNO(Code),DATABASE::Bin),'','');
        VALIDATE("To-Assembly Bin Code",Bin.Code);
        VALIDATE("From-Assembly Bin Code",Bin.Code);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateTrackedItem@106(VAR Item@1000 : Record 27;TrackingType@1001 : Option);
    VAR
      Serial@1003 : Boolean;
      Lot@1002 : Boolean;
    BEGIN
      LibraryInventory.CreateItem(Item);
      IF TrackingType <> Tracking::Untracked THEN BEGIN
        Lot := (TrackingType = Tracking::Lot) OR (TrackingType = Tracking::LotSerial);
        Serial := (TrackingType = Tracking::Serial) OR (TrackingType = Tracking::LotSerial);
        AssignItemTrackingCode(Item,Lot,Serial);
      END;
    END;

    LOCAL PROCEDURE CreateItemTrackingCode@105(VAR ItemTrackingCode@1000 : Record 6502;Lot@1001 : Boolean;Serial@1002 : Boolean);
    VAR
      LibraryUtility@1003 : Codeunit 131000;
    BEGIN
      IF NOT ItemTrackingCode.GET(Serial) THEN BEGIN
        ItemTrackingCode.INIT;
        ItemTrackingCode.VALIDATE(Code,
          LibraryUtility.GenerateRandomCode(ItemTrackingCode.FIELDNO(Code),DATABASE::"Item Tracking Code"));
        ItemTrackingCode.INSERT(TRUE);
        ItemTrackingCode.VALIDATE("SN Specific Tracking",Serial);
        ItemTrackingCode.VALIDATE("Lot Specific Tracking",Lot);
        ItemTrackingCode.VALIDATE("SN Warehouse Tracking",Serial);
        ItemTrackingCode.VALIDATE("Lot Warehouse Tracking",Lot);
        ItemTrackingCode.MODIFY(TRUE);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchaseHeader@104(LocationCode@1001 : Code[10];VAR PurchaseHeader@1000 : Record 38);
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      PurchaseHeader.VALIDATE("Location Code",LocationCode);
      PurchaseHeader.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchaseLine@103(PurchaseHeader@1000 : Record 38;ItemNo@1002 : Code[20];Location@1003 : Record 14;BinCode@1004 : Code[20];Qty@1005 : Decimal);
    VAR
      PurchaseLine@1001 : Record 39;
    BEGIN
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Qty);
      PurchaseLine.VALIDATE("Location Code",Location.Code);
      IF NOT Location."Require Receive" THEN
        PurchaseLine.VALIDATE("Bin Code",BinCode);
      PurchaseLine.MODIFY(TRUE);

      AssignITToPurchLine(PurchaseHeader,PurchaseLine);
    END;

    [Normal]
    LOCAL PROCEDURE CreateAndRegisterWhseActivity@102(AssemblyHeaderNo@1000 : Code[20];WhseActivity@1007 : Option;AssignITOnWhseAct@1001 : Boolean;ITPartial@1002 : Boolean;FindDirection@1003 : Code[10];ExpectedError@1004 : Text[1024]);
    VAR
      WhseActivityHeader@1006 : Record 5766;
      AssemblyHeader@1008 : Record 900;
    BEGIN
      IF WhseActivity = WhseActivityType::None THEN
        EXIT;

      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      CASE WhseActivity OF
        WhseActivityType::WhsePick:
          LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
        WhseActivityType::InvtMvmt:
          LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      END;

      AutoFillQtyWhseActivity(AssemblyHeader,WhseActivityHeader);

      IF AssignITOnWhseAct THEN
        AssignITWhseActivity(AssemblyHeader,WhseActivityHeader,ITPartial,FindDirection);

      IF ExpectedError = '' THEN
        LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader)
      ELSE BEGIN
        ASSERTERROR LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);
        Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ExpectedError) > 0,
          'Expected:' + ExpectedError + '. Actual:' + GETLASTERRORTEXT);
        CLEARLASTERROR;
      END;
    END;

    [Normal]
    LOCAL PROCEDURE PrepareOrderPosting@100(VAR AssemblyHeader@1000 : Record 900;HeaderQtyFactor@1001 : Integer);
    VAR
      AssemblyLine@1002 : Record 901;
      ITType@1005 : Option;
    BEGIN
      AssemblyHeader.VALIDATE("Quantity to Assemble",AssemblyHeader."Quantity to Assemble" * HeaderQtyFactor / 100);
      AssemblyHeader.MODIFY(TRUE);

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);

      IF AssemblyLine.FINDSET THEN
        REPEAT
          GetItemIT(AssemblyLine."No.",ITType);
          IF (ITType = Tracking::Serial) OR (ITType = Tracking::LotSerial) THEN BEGIN
            AssemblyLine.VALIDATE("Quantity to Consume",ROUND(AssemblyLine."Quantity to Consume",1,'<'));
            AssemblyLine.MODIFY(TRUE)
          END;
        UNTIL (AssemblyLine.NEXT = 0);

      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);
    END;

    [Normal]
    LOCAL PROCEDURE PostPurchaseHeader@96(PurchaseHeader@1000 : Record 38;Location@1014 : Record 14;NotEnoughItemNo@1002 : Code[20]);
    VAR
      WarehouseReceiptHeader@1011 : Record 7316;
      WarehouseActivityHeader@1004 : Record 5766;
      WarehouseActivityLine@1003 : Record 5767;
      WhseReceiptLine@1001 : Record 7317;
      Bin@1005 : Record 7354;
      GetSourceDocInbound@1008 : Codeunit 5751;
      PurchaseHeaderNo@1012 : Code[20];
    BEGIN
      PurchaseHeaderNo := PurchaseHeader."No.";

      LibraryPurchase.ReleasePurchaseDocument(PurchaseHeader);
      IF Location."Require Receive" THEN BEGIN
        GetSourceDocInbound.CreateFromPurchOrder(PurchaseHeader);

        WhseReceiptLine.SETRANGE("Source Document",WhseReceiptLine."Source Document"::"Purchase Order");
        WhseReceiptLine.SETRANGE("Source No.",PurchaseHeader."No.");
        WhseReceiptLine.FINDFIRST;
        WarehouseReceiptHeader.GET(WhseReceiptLine."No.");
        LibraryWarehouse.PostWhseReceipt(WarehouseReceiptHeader);
      END;

      PurchaseHeader.RESET;
      PurchaseHeader.SETRANGE("No.",PurchaseHeaderNo);
      PurchaseHeader.FINDFIRST;
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      IF Location."Require Put-away" THEN BEGIN
        WarehouseActivityHeader.SETRANGE("Location Code",Location.Code);
        WarehouseActivityHeader.FINDFIRST;
        WarehouseActivityLine.SETRANGE("No.",WarehouseActivityHeader."No.");
        WarehouseActivityLine.FINDFIRST;

        WarehouseActivityLine.AutofillQtyToHandle(WarehouseActivityLine);

        LibraryWarehouse.FindBin(Bin,Location.Code,'PICK',4);
        WarehouseActivityLine.RESET;
        WarehouseActivityLine.SETRANGE("No.",WarehouseActivityHeader."No.");
        WarehouseActivityLine.SETRANGE("Action Type",WarehouseActivityLine."Action Type"::Place);
        IF WarehouseActivityLine.FINDSET THEN
          REPEAT
            WarehouseActivityLine.VALIDATE("Zone Code",'PICK');
            WarehouseActivityLine.VALIDATE("Bin Code",Bin.Code);
            WarehouseActivityLine.MODIFY(TRUE)
          UNTIL (WarehouseActivityLine.NEXT = 0);

        IF (LocationAdditionalPickBinCode <> '') AND (NotEnoughItemNo <> '') THEN BEGIN
          WarehouseActivityLine.RESET;
          WarehouseActivityLine.SETRANGE("No.",WarehouseActivityHeader."No.");
          WarehouseActivityLine.SETRANGE("Item No.",NotEnoughItemNo);
          WarehouseActivityLine.SETRANGE("Action Type",WarehouseActivityLine."Action Type"::Place);
          WarehouseActivityLine.FINDSET;

          WarehouseActivityLine.VALIDATE("Bin Code",LocationAdditionalPickBinCode);
          WarehouseActivityLine.MODIFY(TRUE);
          WarehouseActivityLine.NEXT;
          WarehouseActivityLine.VALIDATE("Bin Code",LocationAdditionalPickBinCode);
          WarehouseActivityLine.MODIFY(TRUE);
        END;

        LibraryWarehouse.RegisterWhseActivity(WarehouseActivityHeader);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE AutoFillQtyWhseActivity@89(AssemblyHeader@1000 : Record 900;VAR WhseActivityHeader@1003 : Record 5766);
    VAR
      WhseActivityLine@1002 : Record 5767;
    BEGIN
      WhseActivityHeader.RESET;
      WhseActivityHeader.SETRANGE("Location Code",AssemblyHeader."Location Code");
      WhseActivityHeader.FINDLAST;

      // Check that quantity is not autofilled
      IF WhseActivityHeader.Type <> WhseActivityHeader.Type::Pick THEN BEGIN
        WhseActivityLine.RESET;
        WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");

        REPEAT
          Assert.AreEqual(0,WhseActivityLine."Qty. to Handle",'Incorrect value');
        UNTIL WhseActivityLine.NEXT = 0;

        LibraryWarehouse.AutoFillQtyInventoryActivity(WhseActivityHeader);
      END;
    END;

    LOCAL PROCEDURE AssignItemTrackingCode@86(VAR Item@1000 : Record 27;LotTracked@1001 : Boolean;SerialTracked@1002 : Boolean);
    VAR
      ItemTrackingCode@1003 : Record 6502;
      LibraryUtility@1004 : Codeunit 131000;
    BEGIN
      CreateItemTrackingCode(ItemTrackingCode,LotTracked,SerialTracked);

      Item.VALIDATE("Item Tracking Code",ItemTrackingCode.Code);

      Item.VALIDATE("Item Tracking Code",ItemTrackingCode.Code);
      Item.VALIDATE("Serial Nos.",LibraryUtility.GetGlobalNoSeriesCode);

      Item.VALIDATE("Lot Nos.",LibraryUtility.GetGlobalNoSeriesCode);

      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE NormalPostingIT@127(Location@1003 : Record 14;HeaderQtyFactor@1012 : Decimal;QtySupplement@1018 : Decimal;WhseActivity@1002 : Option;ExpectedErrorMessage@1000 : Text[1024];AssignITBeforeWhseAct@1005 : Boolean;AssignITOnWhseAct@1008 : Boolean;ITPartial@1001 : Boolean) : Code[20];
    VAR
      AssemblyHeader@1019 : Record 900;
    BEGIN
      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,QtySupplement,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,QtySupplement,Location,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,FALSE,'-');
      END;

      CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,ITPartial,'-','');

      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessage);

      EXIT(AssemblyHeader."No.");
    END;

    LOCAL PROCEDURE FindAssemblyLine@43(VAR AssemblyLine@1000 : Record 901;DocumentType@1001 : Option;DocumentNo@1002 : Code[20]);
    BEGIN
      WITH AssemblyLine DO BEGIN
        RESET;
        SETRANGE("Document Type",DocumentType);
        SETRANGE("Document No.",DocumentNo);
        FINDFIRST;
      END;
    END;

    [Normal]
    LOCAL PROCEDURE GetItemIT@84(ItemNo@1000 : Code[20];VAR ITType@1003 : Option);
    VAR
      Item@1001 : Record 27;
      ItemTrackingCode@1002 : Record 6502;
    BEGIN
      Item.GET(ItemNo);

      IF Item."Item Tracking Code" = '' THEN
        EXIT;

      ItemTrackingCode.GET(Item."Item Tracking Code");

      ITType := Tracking::Untracked;

      IF ItemTrackingCode."Lot Specific Tracking" AND ItemTrackingCode."SN Specific Tracking" THEN
        ITType := Tracking::LotSerial
      ELSE
        IF (NOT ItemTrackingCode."Lot Specific Tracking") AND ItemTrackingCode."SN Specific Tracking" THEN
          ITType := Tracking::Serial
        ELSE
          IF ItemTrackingCode."Lot Specific Tracking" AND (NOT ItemTrackingCode."SN Specific Tracking") THEN
            ITType := Tracking::Lot;
    END;

    LOCAL PROCEDURE PostPositiveAdjmtItemJournal@39(ItemNo@1003 : Code[20];Qty@1004 : Decimal;LocationCode@1005 : Code[10];BinCode@1006 : Code[20]);
    VAR
      ItemJournalTemplate@1002 : Record 82;
      ItemJournalBatch@1001 : Record 233;
      ItemJournalLine@1000 : Record 83;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Qty);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.VALIDATE("Bin Code",BinCode);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    [Normal]
    LOCAL PROCEDURE PrepareHandleSelectEntries@83(ITPartial@1000 : Boolean);
    BEGIN
      GLB_ITPageHandler := GLB_ITPageHandler::SelectITSpec;
      PAR_ITPage_AssignPartial := ITPartial;
    END;

    [Normal]
    LOCAL PROCEDURE PrepareHandlePutManually@82(ItemNo@1001 : Code[20];ITType@1002 : Option;ITPartial@1000 : Boolean;Quantity@1003 : Decimal;FindDir@1004 : Code[10]);
    BEGIN
      GLB_ITPageHandler := GLB_ITPageHandler::PutManuallyITSpec;
      PAR_ITPage_AssignLot := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Lot);
      PAR_ITPage_AssignSerial := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Serial);
      PAR_ITPage_AssignPartial := ITPartial;
      PAR_ITPage_AssignQty := Quantity;
      PAR_ITPage_ITNo := ItemNo;
      PAR_ITPage_FINDDIR := FindDir;
    END;

    LOCAL PROCEDURE PrepareHandleAssignPartial@109(ITType@1001 : Option;Quantity@1000 : Decimal);
    BEGIN
      GLB_ITPageHandler := GLB_ITPageHandler::AssignITSpec;
      PAR_ITPage_AssignLot := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Lot);
      PAR_ITPage_AssignSerial := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Serial);
      PAR_ITPage_AssignPartial := TRUE;
      PAR_ITPage_AssignQty := Quantity;
    END;

    LOCAL PROCEDURE AssignITToPurchLine@41(PurchaseHeader@1001 : Record 38;PurchaseLine@1000 : Record 39);
    VAR
      PurchaseOrderPage@1004 : TestPage 50;
      ITType@1002 : Option;
    BEGIN
      GetItemIT(PurchaseLine."No.",ITType);

      IF ITType = Tracking::Untracked THEN
        EXIT;

      PurchaseOrderPage.OPENEDIT;
      PurchaseOrderPage.FILTER.SETFILTER("No.",PurchaseHeader."No.");

      PurchaseOrderPage.PurchLines.LAST;

      PrepareHandleAssignPartial(ITType,PurchaseLine.Quantity);
      PurchaseOrderPage.PurchLines."Item Tracking Lines".INVOKE;

      PurchaseOrderPage.OK.INVOKE;
    END;

    LOCAL PROCEDURE AssignITToAssemblyLines@66(VAR AssemblyHeader@1000 : Record 900;ITPartial@1002 : Boolean;SelectEntries@1004 : Boolean;FindDir@1005 : Code[10]);
    VAR
      AssemblyLine@1001 : Record 901;
      AssemblyOrderPage@1003 : TestPage 900;
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.FINDSET;

      AssemblyOrderPage.OPENEDIT;
      AssemblyOrderPage.FILTER.SETFILTER("No.",AssemblyHeader."No.");

      REPEAT
        AssignITToAsmLine(AssemblyLine."No.",AssemblyLine."Quantity to Consume",ITPartial,SelectEntries,AssemblyOrderPage,FindDir);
      UNTIL AssemblyLine.NEXT = 0;

      AssemblyOrderPage.OK.INVOKE;
    END;

    LOCAL PROCEDURE AssignITToAsmLine@40(ItemNo@1002 : Code[20];Quantity@1006 : Decimal;ITPartial@1004 : Boolean;SelectEntries@1003 : Boolean;AssemblyOrderPage@1001 : TestPage 900;FindDir@1000 : Code[10]);
    VAR
      ITType@1005 : Option;
    BEGIN
      GetItemIT(ItemNo,ITType);

      IF ITType = Tracking::Untracked THEN
        EXIT;

      AssemblyOrderPage.Lines.FILTER.SETFILTER("No.",ItemNo);

      IF SelectEntries THEN
        PrepareHandleSelectEntries(ITPartial)
      ELSE
        PrepareHandlePutManually(ItemNo,ITType,ITPartial,Quantity,FindDir);

      AssemblyOrderPage.Lines."Item Tracking Lines".INVOKE;
    END;

    [Normal]
    LOCAL PROCEDURE AssignITWhseActivity@35(AssemblyHeader@1000 : Record 900;WhseActivityHeader@1001 : Record 5766;ITPartial@1002 : Boolean;FindDirection@1004 : Code[10]);
    VAR
      AssemblyLine@1003 : Record 901;
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);

      IF AssemblyLine.FINDSET THEN
        REPEAT
          AssingITWhseActivityLine(AssemblyLine."No.",WhseActivityHeader,ITPartial,FindDirection);
        UNTIL (AssemblyLine.NEXT = 0);
    END;

    LOCAL PROCEDURE AssingITWhseActivityLine@20(ItemNo@1001 : Code[20];WhseActivityHeader@1000 : Record 5766;ITPartial@1005 : Boolean;FindDirection@1008 : Code[10]);
    VAR
      WhseActivityLineTake@1002 : Record 5767;
      WhseActivityLinePlace@1003 : Record 5767;
      ItemLedgerEntry@1004 : Record 32;
      TrackedQty@1006 : Integer;
    BEGIN
      ItemLedgerEntry.RESET;
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.FIND(FindDirection);

      WhseActivityLineTake.RESET;
      WhseActivityLineTake.SETRANGE("No.",WhseActivityHeader."No.");
      WhseActivityLineTake.SETRANGE("Item No.",ItemNo);
      WhseActivityLineTake.SETRANGE("Serial No.",'');
      WhseActivityLineTake.SETRANGE("Lot No.",'');
      WhseActivityLineTake.SETRANGE("Action Type",WhseActivityLineTake."Action Type"::Take);

      TrackedQty := WhseActivityLineTake.COUNT;
      IF ITPartial THEN
        TrackedQty := WhseActivityLineTake.COUNT - 1;

      REPEAT
        IF TrackedQty = 0 THEN
          EXIT;

        TrackedQty -= 1;
        WhseActivityLineTake.RESET;
        WhseActivityLineTake.SETRANGE("No.",WhseActivityHeader."No.");
        WhseActivityLineTake.SETRANGE("Item No.",ItemNo);
        WhseActivityLineTake.SETRANGE("Serial No.",'');
        WhseActivityLineTake.SETRANGE("Lot No.",'');
        WhseActivityLineTake.SETRANGE("Action Type",WhseActivityLineTake."Action Type"::Take);
        IF NOT WhseActivityLineTake.FINDFIRST THEN
          EXIT; // in case of partial posting whse activity has less lines then in item ledger entries

        WhseActivityLinePlace.RESET;
        WhseActivityLinePlace.SETRANGE("No.",WhseActivityHeader."No.");
        WhseActivityLinePlace.SETRANGE("Item No.",ItemNo);
        WhseActivityLinePlace.SETRANGE("Serial No.",'');
        WhseActivityLinePlace.SETRANGE("Lot No.",'');
        WhseActivityLinePlace.SETRANGE("Action Type",WhseActivityLinePlace."Action Type"::Place);
        WhseActivityLinePlace.FINDFIRST;

        WhseActivityLineTake.VALIDATE("Serial No.",ItemLedgerEntry."Serial No.");
        WhseActivityLinePlace.VALIDATE("Serial No.",ItemLedgerEntry."Serial No.");

        WhseActivityLineTake.VALIDATE("Lot No.",ItemLedgerEntry."Lot No.");
        WhseActivityLinePlace.VALIDATE("Lot No.",ItemLedgerEntry."Lot No.");

        WhseActivityLineTake.MODIFY(TRUE);
        WhseActivityLinePlace.MODIFY(TRUE);

      UNTIL ItemLedgerEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE NotEnoughItemPostingIT@65(Location@1003 : Record 14;HeaderQtyFactor@1012 : Decimal;PartialPostFactor@1011 : Decimal;AddAdditionalQty@1000 : Boolean;WhseActivity@1002 : Option;ExpectedErrorMessagePost@1004 : Text[1024];ExpectedErrorMessageReg@1007 : Text[1024];AssignITBeforeWhseAct@1006 : Boolean;AssignITOnWhseAct@1005 : Boolean;ITPartial@1001 : Boolean);
    VAR
      AssemblyHeader@1022 : Record 900;
      NotEnoughItemNo@1015 : Code[20];
      NotEnoughNo@1018 : Integer;
      Qtys@1017 : ARRAY [10] OF Decimal;
    BEGIN
      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      NotEnoughNo := 1;

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsNotEnough(
          Location,AssemblyHeader,NotEnoughNo,NotEnoughItemNo,PartialPostFactor,Qtys,AddAdditionalQty,LocationToBinCode)
      ELSE
        PurchaseComponentsNotEnough(
          Location,AssemblyHeader,NotEnoughNo,NotEnoughItemNo,PartialPostFactor,Qtys,AddAdditionalQty,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,FALSE,'-');
      END;

      CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,ITPartial,'-',ExpectedErrorMessageReg);

      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessagePost);
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage@80(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      CASE GLB_ITPageHandler OF
        GLB_ITPageHandler::AssignITSpec,GLB_ITPageHandler::AssignITSpecPartial:
          BEGIN
            IF PAR_ITPage_AssignSerial THEN
              HNDL_ITPage_AssignSerial(ItemTrackingLinesPage)
            ELSE
              IF PAR_ITPage_AssignLot THEN
                HNDL_ITPage_AssignLot(ItemTrackingLinesPage);
          END;
        GLB_ITPageHandler::SelectITSpec:
          HNDL_ITPage_SelectEntries(ItemTrackingLinesPage);
        GLB_ITPageHandler::PutManuallyITSpec:
          HNDL_ITPage_PutITManually(ItemTrackingLinesPage);
      END
    END;

    [ModalPageHandler]
    [HandlerFunctions(HNDL_EnterQty)]
    PROCEDURE HNDL_ITPage_AssignSerial@79(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      ItemTrackingLinesPage."Assign Serial No.".INVOKE;
      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage_AssignLot@77(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      ItemTrackingLinesPage."Assign Lot No.".INVOKE; // Assign Lot No.
      IF PAR_ITPage_AssignPartial THEN
        ItemTrackingLinesPage."Quantity (Base)".SETVALUE(PAR_ITPage_AssignQty);
      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage_SelectEntries@76(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      ItemTrackingLinesPage."Select Entries".INVOKE; // Select Entries
      IF PAR_ITPage_AssignPartial THEN BEGIN
        ItemTrackingLinesPage.LAST;
        ItemTrackingLinesPage."Quantity (Base)".SETVALUE(ItemTrackingLinesPage."Quantity (Base)".ASINTEGER - 1);
      END;

      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage_PutITManually@73(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    VAR
      ItemLedgerEntry@1001 : Record 32;
      TrackedQty@1003 : Integer;
    BEGIN
      ItemLedgerEntry.RESET;
      ItemLedgerEntry.SETRANGE("Item No.",PAR_ITPage_ITNo);
      ItemLedgerEntry.FIND(PAR_ITPage_FINDDIR);

      TrackedQty := ItemLedgerEntry.COUNT;

      IF (ItemLedgerEntry."Serial No." <> '') AND (PAR_ITPage_AssignQty < ItemLedgerEntry.COUNT) THEN
        TrackedQty := PAR_ITPage_AssignQty;

      IF PAR_ITPage_AssignPartial THEN
        TrackedQty -= 1;

      IF ItemTrackingLinesPage.LAST THEN
        ItemTrackingLinesPage.NEXT;

      WHILE TrackedQty > 0 DO BEGIN
        TrackedQty -= 1;

        IF STRLEN(ItemLedgerEntry."Serial No.") > 0 THEN
          ItemTrackingLinesPage."Serial No.".SETVALUE(ItemLedgerEntry."Serial No.");
        IF STRLEN(ItemLedgerEntry."Lot No.") > 0 THEN
          ItemTrackingLinesPage."Lot No.".SETVALUE(ItemLedgerEntry."Lot No.");

        IF PAR_ITPage_AssignQty < ItemLedgerEntry.Quantity THEN
          ItemTrackingLinesPage."Quantity (Base)".SETVALUE(PAR_ITPage_AssignQty)
        ELSE
          ItemTrackingLinesPage."Quantity (Base)".SETVALUE(ItemLedgerEntry.Quantity);
        IF ItemLedgerEntry.NEXT <> 0 THEN
          ItemTrackingLinesPage.NEXT;
      END;

      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_EnterQty@71(VAR EnterQuantityPage@1000 : TestPage 6513);
    BEGIN
      IF PAR_ITPage_AssignLot THEN
        EnterQuantityPage.CreateNewLotNo.VALUE := 'yes';
      IF PAR_ITPage_AssignPartial THEN
        EnterQuantityPage.QtyToCreate.SETVALUE(PAR_ITPage_AssignQty);
      EnterQuantityPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNLD_ItemTrackingSummary@94(VAR ItemTrackingSummaryPage@1000 : TestPage 6500);
    BEGIN
      ItemTrackingSummaryPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE AvailabilityWindowHandler@9(VAR AsmAvailability@1000 : Page 908;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::Yes; // always confirm
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmPostQuestion@4(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,MSG_WANT_TO_POST) > 0,PADSTR('Actual: ' + Question + 'Expected: ' + MSG_WANT_TO_POST,1024));

      ConfirmPostCount += 1;
      IF ConfirmPostCount = 1 THEN
        Reply := FALSE
      ELSE
        Reply := TRUE;
    END;

    [RequestPageHandler]
    PROCEDURE PostBatchHandler@10(VAR PostBatchForm@1000 : TestRequestPage 900);
    BEGIN
      PostBatchForm.PostingDate.SETVALUE(CALCDATE('<1M>',WORKDATE));
      PostBatchForm.ReplacePostingDate.SETVALUE(TRUE);
      PostBatchForm.OK.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE PostBatchHandlerError@15(VAR PostBatchForm@1000 : TestRequestPage 900);
    BEGIN
      PostBatchForm.PostingDate.SETVALUE('');
      PostBatchForm.ReplacePostingDate.SETVALUE(TRUE);
      PostBatchForm.OK.INVOKE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@23(Message@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(STRPOS(Message,MSG_ORDERS_POSTED) > 0,PADSTR('Actual: ' + Message + 'Expected: ' + MSG_ORDERS_POSTED,1024));
    END;

    [MessageHandler]
    PROCEDURE DummyMessageHandler@62(Message@1000 : Text[1024]);
    BEGIN
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [Assemble-to-Stock] [Warehouse] [Item Tracking] [SCM]
      This CU is for deliverables "Kitting D07A - Assemble-to-Stock in Warehousing, as per the following" and " Kitting - Warehouse Item Tracking"
       for "Bin Mandatory" location
    }
    END.
  }
}

