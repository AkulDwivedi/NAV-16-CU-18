OBJECT Codeunit 137606 SCM CETAF Costing Reval. WIP
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LibraryCosting@1012 : Codeunit 132200;
      LibraryERM@1000 : Codeunit 131300;
      LibraryInventory@1013 : Codeunit 132201;
      LibraryManufacturing@1014 : Codeunit 132202;
      LibraryPatterns@1002 : Codeunit 132212;
      Assert@1004 : Codeunit 130000;
      LibraryRandom@1006 : Codeunit 130440;
      isInitialized@1005 : Boolean;
      CalculatePer@1008 : 'Item Ledger Entry,Item';
      CalculationBase@1007 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
      TXTIncorrectRevalCost@1003 : TextConst 'ENU=Incorrect Cost Amount in inbound ILE No. %1 after revaluation.';
      AnyQst@1010 : TextConst 'ENU=Any?';
      AnyMsg@1011 : TextConst 'ENU=Any.';

    LOCAL PROCEDURE Initialize@13();
    VAR
      InventorySetup@1001 : Record 313;
      LibraryERMCountryData@1000 : Codeunit 131305;
    BEGIN
      // Lazy Setup.
      IF isInitialized THEN
        EXIT;

      InventorySetup.GET;
      InventorySetup.TESTFIELD("Average Cost Period",InventorySetup."Average Cost Period"::Day);
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryPatterns.SETNoSeries;
      isInitialized := TRUE;
      COMMIT;
    END;

    [Test]
    PROCEDURE TestFIFO_FIFO_SimpleProdOrder@16();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::FIFO,Item."Costing Method"::FIFO,WORKDATE,FALSE,FALSE,FALSE,0,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_STD_SimpleProdOrder@40();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::FIFO,Item."Costing Method"::Standard,WORKDATE,FALSE,FALSE,FALSE,0,1.5);
    END;

    [Test]
    PROCEDURE TestAVG_AVG_SimpleProdOrder@22();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Average,Item."Costing Method"::Average,WORKDATE,FALSE,FALSE,FALSE,0,1.5);
    END;

    [Test]
    PROCEDURE TestAVG_STD_SimpleProdOrder@23();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Average,Item."Costing Method"::Standard,WORKDATE,FALSE,FALSE,FALSE,0,1.5);
    END;

    [Test]
    PROCEDURE TestSTD_STD_SimpleProdOrder@67();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Standard,Item."Costing Method"::Standard,WORKDATE,FALSE,FALSE,FALSE,0,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_FIFO_ProdOrderRevalperItem_All@10();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::FIFO,Item."Costing Method"::FIFO,WORKDATE,TRUE,FALSE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_STD_ProdOrderRevalperItem_All@25();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::FIFO,Item."Costing Method"::Standard,WORKDATE,TRUE,FALSE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestAVG_AVG_ProdOrderRevalperItem_All@8();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Average,Item."Costing Method"::Average,WORKDATE,TRUE,FALSE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestAVG_STD_ProdOrderRevalperItem_All@7();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Average,Item."Costing Method"::Standard,WORKDATE,TRUE,FALSE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestLIFO_LIFO_ProdOrderRevalperItem_All@21();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::LIFO,Item."Costing Method"::LIFO,WORKDATE,TRUE,FALSE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestLIFO_STD_ProdOrderRevalperItem_All@20();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::LIFO,Item."Costing Method"::Standard,WORKDATE,TRUE,FALSE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestSTD_STD_ProdOrderRevalperItem_All@70();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Standard,Item."Costing Method"::Standard,WORKDATE,TRUE,FALSE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_FIFO_ProdOrderRevalperItem_Partial@19();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::FIFO,Item."Costing Method"::FIFO,WORKDATE,FALSE,TRUE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_STD_ProdOrderRevalperItem_Partial@43();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::FIFO,Item."Costing Method"::Standard,WORKDATE,FALSE,TRUE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestAVG_AVG_ProdOrderRevalperItem_Partial@14();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Average,Item."Costing Method"::Average,WORKDATE,FALSE,TRUE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestAVG_STD_ProdOrderRevalperItem_Partial@11();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Average,Item."Costing Method"::Standard,WORKDATE,FALSE,TRUE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestLIFO_LIFO_ProdOrderRevalperItem_Partial@50();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::LIFO,Item."Costing Method"::LIFO,WORKDATE,FALSE,TRUE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestLIFO_STD_ProdOrderRevalperItem_Partial@48();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::LIFO,Item."Costing Method"::Standard,WORKDATE,FALSE,TRUE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestSTD_STD_ProdOrderRevalperItem_Partial@73();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Standard,Item."Costing Method"::Standard,WORKDATE,FALSE,TRUE,FALSE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_FIFO_ProdOrderRevalperItem_NonWIP@44();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::FIFO,Item."Costing Method"::FIFO,WORKDATE,FALSE,FALSE,TRUE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestLIFO_FIFO_ProdOrderRevalperItem_NonWIP@45();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::LIFO,Item."Costing Method"::FIFO,WORKDATE,FALSE,FALSE,TRUE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestAVG_FIFO_ProdOrderRevalperItem_NonWIP@46();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Average,Item."Costing Method"::FIFO,WORKDATE,FALSE,FALSE,TRUE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestSTD_FIFO_ProdOrderRevalperItem_NonWIP@47();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(Item."Costing Method"::Standard,Item."Costing Method"::FIFO,WORKDATE,FALSE,FALSE,TRUE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_FIFO_ProdOrderRevalperItemtoZero@18();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_ZeroInv(Item."Costing Method"::FIFO,Item."Costing Method"::FIFO,WORKDATE,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestFIFO_STD_ProdOrderRevalperItemtoZero@51();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_ZeroInv(Item."Costing Method"::FIFO,Item."Costing Method"::Standard,WORKDATE,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestAVG_AVG_ProdOrderRevalperItemtoZero@17();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_ZeroInv(Item."Costing Method"::Average,Item."Costing Method"::Average,WORKDATE,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestAVG_STD_ProdOrderRevalperItemtoZero@15();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_ZeroInv(Item."Costing Method"::Average,Item."Costing Method"::Standard,WORKDATE,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestLIFO_LIFO_ProdOrderRevalperItemtoZero@54();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_ZeroInv(Item."Costing Method"::LIFO,Item."Costing Method"::LIFO,WORKDATE,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestLIFO_STD_ProdOrderRevalperItemtoZero@53();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_ZeroInv(Item."Costing Method"::LIFO,Item."Costing Method"::Standard,WORKDATE,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestSTD_STD_ProdOrderRevalperItemtoZero@75();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_ZeroInv(Item."Costing Method"::Standard,Item."Costing Method"::Standard,WORKDATE,CalculatePer::Item);
    END;

    [Test]
    PROCEDURE TestFIFO_FIFO_ProdOrderRevalperILE_All@71();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(
        Item."Costing Method"::FIFO,Item."Costing Method"::FIFO,WORKDATE,FALSE,TRUE,FALSE,CalculatePer::"Item Ledger Entry",1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_STD_ProdOrderRevalperILE_All@69();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder(
        Item."Costing Method"::FIFO,Item."Costing Method"::Standard,WORKDATE,FALSE,TRUE,FALSE,CalculatePer::"Item Ledger Entry",1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_FIFO_ProdOrderRevalpartialILE@56();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_RevalPartialILEs(Item."Costing Method"::FIFO,Item."Costing Method"::FIFO,WORKDATE);
    END;

    [Test]
    PROCEDURE TestFIFO_AVG_ProdOrderRevalpartialILE@58();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_RevalPartialILEs(Item."Costing Method"::FIFO,Item."Costing Method"::Average,WORKDATE);
    END;

    [Test]
    PROCEDURE TestFIFO_STD_ProdOrderRevalpartialILE@57();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_RevalPartialILEs(Item."Costing Method"::FIFO,Item."Costing Method"::Standard,WORKDATE);
    END;

    [Test]
    PROCEDURE TestLIFO_STD_ProdOrderRevalpartialILE@60();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_RevalPartialILEs(Item."Costing Method"::LIFO,Item."Costing Method"::Standard,WORKDATE);
    END;

    [Test]
    PROCEDURE TestSTD_STD_ProdOrderRevalpartialILE@76();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_RevalPartialILEs(Item."Costing Method"::Standard,Item."Costing Method"::Standard,WORKDATE);
    END;

    [Test]
    PROCEDURE TestFIFO_FIFO_ProdOrder_NegConsumption@65();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_NegConsumption(Item."Costing Method"::FIFO,Item."Costing Method"::FIFO,WORKDATE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_STD_ProdOrder_NegConsumption@2();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_NegConsumption(Item."Costing Method"::FIFO,Item."Costing Method"::Standard,WORKDATE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestAVG_AVG_ProdOrder_NegConsumption@4();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_NegConsumption(Item."Costing Method"::Average,Item."Costing Method"::Average,WORKDATE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestAVG_STD_ProdOrder_NegConsumption@6();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_NegConsumption(Item."Costing Method"::Average,Item."Costing Method"::Standard,WORKDATE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestLIFO_LIFO_ProdOrder_NegConsumption@31();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_NegConsumption(Item."Costing Method"::LIFO,Item."Costing Method"::LIFO,WORKDATE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestLIFO_STD_ProdOrder_NegConsumption@30();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_NegConsumption(Item."Costing Method"::LIFO,Item."Costing Method"::Standard,WORKDATE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestSTD_STD_ProdOrder_NegConsumption@33();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_NegConsumption(Item."Costing Method"::Standard,Item."Costing Method"::Standard,WORKDATE,CalculatePer::Item,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_FIFO_TestProdOrder_RevalPartialConsmp@35();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_RevalPartialConsumption(Item."Costing Method"::FIFO,Item."Costing Method"::FIFO,WORKDATE,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_STD_TestProdOrder_RevalPartialConsmp@12();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_RevalPartialConsumption(Item."Costing Method"::FIFO,Item."Costing Method"::Standard,WORKDATE,1.5);
    END;

    [Test]
    PROCEDURE TestLIFO_LIFO_TestProdOrder_RevalPartialConsmp@64();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_RevalPartialConsumption(Item."Costing Method"::LIFO,Item."Costing Method"::LIFO,WORKDATE,1.5);
    END;

    [Test]
    PROCEDURE TestLIFO_STD_TestProdOrder_RevalPartialConsmp@29();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_RevalPartialConsumption(Item."Costing Method"::LIFO,Item."Costing Method"::Standard,WORKDATE,1.5);
    END;

    [Test]
    PROCEDURE TestSTD_STD_TestProdOrder_RevalPartialConsmp@34();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrder_RevalPartialConsumption(Item."Costing Method"::Standard,Item."Costing Method"::Standard,WORKDATE,1.5);
    END;

    [Test]
    PROCEDURE TestFIFO_ProdOrderAverageComponent@66();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrderAverageComponent(Item."Costing Method"::FIFO,WORKDATE);
    END;

    [Test]
    PROCEDURE TestAVG_ProdOrderAverageComponent@42();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrderAverageComponent(Item."Costing Method"::Average,WORKDATE);
    END;

    [Test]
    PROCEDURE TestLIFO_ProdOrderAverageComponent@68();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrderAverageComponent(Item."Costing Method"::LIFO,WORKDATE);
    END;

    [Test]
    PROCEDURE TestSTD_ProdOrderAverageComponent@72();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrderAverageComponent(Item."Costing Method"::Standard,WORKDATE);
    END;

    [Test]
    PROCEDURE TestFIFO_ProdOrderAvgCompwithReval@55();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrderAvgCompwithReval(Item."Costing Method"::FIFO,WORKDATE);
    END;

    [Test]
    PROCEDURE TestLIFO_ProdOrderAvgCompwithReval@59();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrderAvgCompwithReval(Item."Costing Method"::LIFO,WORKDATE);
    END;

    [Test]
    PROCEDURE TestAVG_ProdOrderAvgCompwithReval@62();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrderAvgCompwithReval(Item."Costing Method"::Standard,WORKDATE);
    END;

    [Test]
    PROCEDURE TestSTD_ProdOrderAvgCompwithReval@74();
    VAR
      Item@1000 : Record 27;
    BEGIN
      Initialize;
      TestProdOrderAvgCompwithReval(Item."Costing Method"::Standard,WORKDATE);
    END;

    LOCAL PROCEDURE TestProdOrder@9(ComponentCostingMethod@1006 : Option;ProducedItemCostingMethod@1007 : Option;StartDate@1013 : Date;RevalueBeforeProdOrder1@1017 : Boolean;RevalueBeforeProdOrder2@1018 : Boolean;RevalueAfterProdOrder2@1005 : Boolean;CalcPer@1020 : 'Item Ledger Entry,Item';RevaluationFactor@1021 : Decimal);
    VAR
      ComponentItem@1004 : Record 27;
      ProducedItem1@1003 : Record 27;
      ProducedItem2@1002 : Record 27;
      EmptyItem@1023 : Record 27;
      ProductionOrder1@1001 : Record 5405;
      ProductionOrder2@1000 : Record 5405;
      EmptyProdOrder@1024 : Record 5405;
      ItemJnlBatch@1019 : Record 233;
      QtyCompInProdItem1@1008 : Decimal;
      QtyCompInProdItem2@1009 : Decimal;
      QtyProdItem1InProdItem2@1010 : Decimal;
      ProdOrder1Qty@1011 : Decimal;
      ProdOrder2Qty@1012 : Decimal;
      QtyCompInProdOrder1@1014 : Decimal;
      QtyCompInProdOrder2@1015 : Decimal;
      QtyProdItem1InProdOrder2@1016 : Decimal;
      SaleProdItem2Qty@1022 : Decimal;
      VerifyVariance@1025 : Boolean;
    BEGIN
      EmptyItem.INIT;
      EmptyProdOrder.INIT;
      VerifyVariance := ProducedItemCostingMethod = ProducedItem1."Costing Method"::Standard;
      InitializeQuantities(QtyCompInProdItem1,QtyCompInProdItem2,QtyProdItem1InProdItem2,ProdOrder1Qty,ProdOrder2Qty,SaleProdItem2Qty);
      SetupItems(
        ComponentItem,ProducedItem1,ProducedItem2,ComponentCostingMethod,ProducedItemCostingMethod,QtyCompInProdItem1,
        QtyCompInProdItem2,QtyProdItem1InProdItem2);
      SetupProdOrders(ProductionOrder1,ProductionOrder2,ProducedItem1,ProducedItem2,ProdOrder1Qty,ProdOrder2Qty,StartDate + 30);

      QtyCompInProdOrder1 := ROUND(QtyCompInProdItem1 * ProdOrder1Qty,ComponentItem."Rounding Precision",'>');
      QtyCompInProdOrder2 := ROUND(QtyCompInProdItem2 * ProdOrder2Qty,ComponentItem."Rounding Precision",'>');
      QtyProdItem1InProdOrder2 := ROUND(QtyProdItem1InProdItem2 * ProdOrder2Qty,ProducedItem1."Rounding Precision",'>');
      PurchaseItemSplitApplication(ComponentItem,QtyCompInProdOrder1,QtyCompInProdOrder2,ComponentItem."Unit Cost",StartDate);

      PostProdOrder1(ProductionOrder1,ComponentItem,ProducedItem1,StartDate + 4,QtyCompInProdOrder1,ProdOrder1Qty,0);
      // Finish Order 1
      LibraryManufacturing.ChangeProdOrderStatus(ProductionOrder1,ProductionOrder1.Status::Finished,StartDate + 10,FALSE);

      // AdjustCost
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ComponentItem."No.",ProducedItem1."No."),'');
      // Verify
      VerifyCost(ComponentItem,EmptyItem,EmptyItem,ProductionOrder1,EmptyProdOrder,VerifyVariance);

      PostProdOrder2(
        ProductionOrder2,ComponentItem,ProducedItem1,ProducedItem2,StartDate + 20,QtyCompInProdOrder2,QtyProdItem1InProdOrder2,
        ProdOrder2Qty);
      // Finish Order 2
      LibraryManufacturing.ChangeProdOrderStatus(ProductionOrder2,ProductionOrder2.Status::Finished,StartDate + 25,FALSE);
      // Sell ProducedItem2
      LibraryPatterns.POSTSaleJournal(ProducedItem2,'','','',SaleProdItem2Qty,StartDate + 30,0);
      // AdjustCost
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2|%3',ComponentItem."No.",ProducedItem1."No.",ProducedItem2."No."),'');

      // Verify
      VerifyCost(ComponentItem,ProducedItem1,ProducedItem2,EmptyProdOrder,ProductionOrder2,VerifyVariance);
      // Revalue
      IF RevalueBeforeProdOrder1 THEN BEGIN
        // Perform revaluation before consumption of order 1 was posted
        ExecuteRevalueExistingInventory(ComponentItem,ItemJnlBatch,StartDate + 1,CalcPer,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
        LibraryPatterns.ModifyPostRevaluation(ItemJnlBatch,RevaluationFactor);
        LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2|%3',ComponentItem."No.",ProducedItem1."No.",ProducedItem2."No."),'');
        // Verify
        VerifyCost(ComponentItem,ProducedItem1,ProducedItem2,ProductionOrder1,ProductionOrder2,VerifyVariance);
      END;

      IF RevalueBeforeProdOrder2 THEN BEGIN
        // Perform revaluation after Order1 was finished, but before consumption of order 2 was posted
        ExecuteRevalueExistingInventory(
          ComponentItem,ItemJnlBatch,StartDate + 15,CalcPer,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
        LibraryPatterns.ModifyPostRevaluation(ItemJnlBatch,RevaluationFactor);
        LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2|%3',ComponentItem."No.",ProducedItem1."No.",ProducedItem2."No."),'');
        // Verify
        VerifyCost(ComponentItem,ProducedItem1,ProducedItem2,ProductionOrder1,ProductionOrder2,VerifyVariance);
      END;

      IF RevalueAfterProdOrder2 THEN BEGIN
        // Perform revaluation after Order2 was finished
        ExecuteRevalueExistingInventory(
          ComponentItem,ItemJnlBatch,StartDate + 27,CalcPer,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
        LibraryPatterns.ModifyPostRevaluation(ItemJnlBatch,RevaluationFactor);
        LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2|%3',ComponentItem."No.",ProducedItem1."No.",ProducedItem2."No."),'');
        // Verify
        VerifyCost(ComponentItem,ProducedItem1,ProducedItem2,ProductionOrder1,ProductionOrder2,VerifyVariance);
      END;
    END;

    LOCAL PROCEDURE TestProdOrder_ZeroInv@26(ComponentCostingMethod@1006 : Option;ProducedItemCostingMethod@1007 : Option;StartDate@1013 : Date;CalcPer@1020 : 'Item Ledger Entry,Item');
    VAR
      ComponentItem@1004 : Record 27;
      ProducedItem1@1003 : Record 27;
      ProducedItem2@1002 : Record 27;
      EmptyItem@1017 : Record 27;
      ProductionOrder1@1001 : Record 5405;
      ProductionOrder2@1000 : Record 5405;
      ItemJnlBatch@1019 : Record 233;
      QtyCompInProdItem1@1008 : Decimal;
      QtyCompInProdItem2@1009 : Decimal;
      QtyProdItem1InProdItem2@1010 : Decimal;
      ProdOrder1Qty@1011 : Decimal;
      ProdOrder2Qty@1012 : Decimal;
      QtyCompInProdOrder1@1014 : Decimal;
      QtyCompInProdOrder2@1015 : Decimal;
      QtyProdItem1InProdOrder2@1016 : Decimal;
      SaleProdItem2Qty@1022 : Decimal;
      VerifyVariance@1005 : Boolean;
    BEGIN
      EmptyItem.INIT;
      VerifyVariance := ProducedItemCostingMethod = ProducedItem1."Costing Method"::Standard;
      InitializeQuantities(QtyCompInProdItem1,QtyCompInProdItem2,QtyProdItem1InProdItem2,ProdOrder1Qty,ProdOrder2Qty,SaleProdItem2Qty);
      SetupItems(
        ComponentItem,ProducedItem1,ProducedItem2,ComponentCostingMethod,ProducedItemCostingMethod,QtyCompInProdItem1,
        QtyCompInProdItem2,QtyProdItem1InProdItem2);
      SetupProdOrders(ProductionOrder1,ProductionOrder2,ProducedItem1,ProducedItem2,ProdOrder1Qty,ProdOrder2Qty,StartDate + 30);

      QtyCompInProdOrder1 := ROUND(QtyCompInProdItem1 * ProdOrder1Qty,ComponentItem."Rounding Precision",'>');
      QtyCompInProdOrder2 := ROUND(QtyCompInProdItem2 * ProdOrder2Qty,ComponentItem."Rounding Precision",'>');
      QtyProdItem1InProdOrder2 := ROUND(QtyProdItem1InProdItem2 * ProdOrder2Qty,ProducedItem1."Rounding Precision",'>');
      PurchaseItemSplitApplication(ComponentItem,QtyCompInProdOrder1,QtyCompInProdOrder2,ComponentItem."Unit Cost",StartDate);

      PostProdOrder1(ProductionOrder1,ComponentItem,ProducedItem1,StartDate + 4,QtyCompInProdOrder1,ProdOrder1Qty,0);

      PostProdOrder2(
        ProductionOrder2,ComponentItem,ProducedItem1,ProducedItem2,StartDate + 20,QtyCompInProdOrder2,QtyProdItem1InProdOrder2,
        ProdOrder2Qty);

      // Finish Order 1
      LibraryManufacturing.ChangeProdOrderStatus(ProductionOrder1,ProductionOrder1.Status::Finished,StartDate + 20,FALSE);
      // Finish Order 2
      LibraryManufacturing.ChangeProdOrderStatus(ProductionOrder2,ProductionOrder2.Status::Finished,StartDate + 20,FALSE);

      // Sell ProducedItem2
      LibraryPatterns.POSTSaleJournal(ProducedItem2,'','','',SaleProdItem2Qty,StartDate + 30,0);

      // AdjustCost
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2|%3',ComponentItem."No.",ProducedItem1."No.",ProducedItem2."No."),'');
      // Verify
      VerifyCost(ComponentItem,ProducedItem1,ProducedItem2,ProductionOrder1,ProductionOrder2,VerifyVariance);

      // Perform revaluation before consumption of order 1 was posted
      ExecuteRevalueExistingInventory(ComponentItem,ItemJnlBatch,StartDate + 1,CalcPer,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
      LibraryPatterns.ModifyPostRevaluation(ItemJnlBatch,0);
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2|%3',ComponentItem."No.",ProducedItem1."No.",ProducedItem2."No."),'');

      // Verify
      VerifyCost(ComponentItem,ProducedItem1,ProducedItem2,ProductionOrder1,ProductionOrder2,VerifyVariance);
    END;

    LOCAL PROCEDURE TestProdOrder_RevalPartialILEs@24(ComponentCostingMethod@1006 : Option;ProducedItemCostingMethod@1007 : Option;StartDate@1013 : Date);
    VAR
      ComponentItem@1004 : Record 27;
      ProducedItem1@1003 : Record 27;
      ProducedItem2@1002 : Record 27;
      EmptyItem@1023 : Record 27;
      ProductionOrder1@1001 : Record 5405;
      ProductionOrder2@1000 : Record 5405;
      EmptyProdOrder@1005 : Record 5405;
      ItemJnlBatch@1019 : Record 233;
      QtyCompInProdItem1@1008 : Decimal;
      QtyCompInProdItem2@1009 : Decimal;
      QtyProdItem1InProdItem2@1010 : Decimal;
      ProdOrder1Qty@1011 : Decimal;
      ProdOrder2Qty@1012 : Decimal;
      QtyCompInProdOrder1@1014 : Decimal;
      QtyCompInProdOrder2@1015 : Decimal;
      QtyProdItem1InProdOrder2@1016 : Decimal;
      SaleProdItem2Qty@1022 : Decimal;
      VerifyVariance@1018 : Boolean;
    BEGIN
      EmptyItem.INIT;
      EmptyProdOrder.INIT;
      VerifyVariance := ProducedItemCostingMethod = ProducedItem1."Costing Method"::Standard;
      InitializeQuantities(QtyCompInProdItem1,QtyCompInProdItem2,QtyProdItem1InProdItem2,ProdOrder1Qty,ProdOrder2Qty,SaleProdItem2Qty);
      SetupItems(
        ComponentItem,ProducedItem1,ProducedItem2,ComponentCostingMethod,ProducedItemCostingMethod,QtyCompInProdItem1,
        QtyCompInProdItem2,QtyProdItem1InProdItem2);
      SetupProdOrders(ProductionOrder1,ProductionOrder2,ProducedItem1,ProducedItem2,ProdOrder1Qty,ProdOrder2Qty,StartDate + 30);

      QtyCompInProdOrder1 := ROUND(QtyCompInProdItem1 * ProdOrder1Qty,ComponentItem."Rounding Precision",'>');
      QtyCompInProdOrder2 := ROUND(QtyCompInProdItem2 * ProdOrder2Qty,ComponentItem."Rounding Precision",'>');
      QtyProdItem1InProdOrder2 := ROUND(QtyProdItem1InProdItem2 * ProdOrder2Qty,ProducedItem1."Rounding Precision",'>');
      PurchaseItemSplitApplication(ComponentItem,QtyCompInProdOrder1,QtyCompInProdOrder2,ComponentItem."Unit Cost",StartDate);

      PostProdOrder1(ProductionOrder1,ComponentItem,ProducedItem1,StartDate + 4,QtyCompInProdOrder1,ProdOrder1Qty,0);
      // Finish Order 1
      LibraryManufacturing.ChangeProdOrderStatus(ProductionOrder1,ProductionOrder1.Status::Finished,StartDate + 10,FALSE);

      // AdjustCost
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ComponentItem."No.",ProducedItem1."No."),'');
      // Verify
      VerifyCost(ComponentItem,EmptyItem,EmptyItem,ProductionOrder1,EmptyProdOrder,VerifyVariance);

      PostProdOrder2(
        ProductionOrder2,ComponentItem,ProducedItem1,ProducedItem2,StartDate + 20,QtyCompInProdOrder2,QtyProdItem1InProdOrder2,
        ProdOrder2Qty);
      // Finish Order 2
      LibraryManufacturing.ChangeProdOrderStatus(ProductionOrder2,ProductionOrder2.Status::Finished,StartDate + 30,FALSE);
      // Sell ProducedItem2
      LibraryPatterns.POSTSaleJournal(ProducedItem2,'','','',SaleProdItem2Qty,StartDate + 30,0);
      // AdjustCost
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2|%3',ComponentItem."No.",ProducedItem1."No.",ProducedItem2."No."),'');

      // Verify
      VerifyCost(ComponentItem,ProducedItem1,ProducedItem2,EmptyProdOrder,ProductionOrder2,VerifyVariance);

      // Perform revaluation after Order1 was finished, but before consumption of order 2 was posted
      ExecuteRevalueExistingInventory(
        ComponentItem,ItemJnlBatch,StartDate + 15,CalculatePer::"Item Ledger Entry",FALSE,FALSE,FALSE,CalculationBase::" ",'','');
      ModifyRevaluationLine(ItemJnlBatch."Journal Template Name",ItemJnlBatch.Name,10000,0.66,LibraryERM.GetAmountRoundingPrecision);
      ModifyRevaluationLine(ItemJnlBatch."Journal Template Name",ItemJnlBatch.Name,20000,0.66,LibraryERM.GetAmountRoundingPrecision);
      ModifyRevaluationLine(ItemJnlBatch."Journal Template Name",ItemJnlBatch.Name,40000,0.66,LibraryERM.GetAmountRoundingPrecision);
      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);

      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2|%3',ComponentItem."No.",ProducedItem1."No.",ProducedItem2."No."),'');
      // Verify
      VerifyCost(ComponentItem,ProducedItem1,ProducedItem2,ProductionOrder1,ProductionOrder2,VerifyVariance);
    END;

    LOCAL PROCEDURE TestProdOrder_NegConsumption@61(ComponentCostingMethod@1006 : Option;ProducedItemCostingMethod@1007 : Option;StartDate@1013 : Date;CalcPer@1020 : 'Item Ledger Entry,Item';RevaluationFactor@1021 : Decimal);
    VAR
      ComponentItem@1004 : Record 27;
      ProducedItem@1003 : Record 27;
      EmptyItem@1023 : Record 27;
      ItemLedgerEntry@1000 : Record 32;
      ProductionOrder@1001 : Record 5405;
      EmptyProdOrder@1010 : Record 5405;
      ProdOrderLine@1005 : Record 5406;
      ConsumptionItemJournalLine@1025 : Record 83;
      ConsumptionItemJournalBatch@1024 : Record 233;
      ItemJnlBatch@1019 : Record 233;
      QtyCompInProdItem@1008 : Decimal;
      ProdOrderQty@1011 : Decimal;
      QtyCompInProdOrder@1014 : Decimal;
      TotalPurchQty@1002 : Decimal;
      ConsumptionQty@1009 : Decimal;
      NegConsmpCostbeforeReval@1012 : Decimal;
      NegConsmpCostafterReval@1015 : Decimal;
      RefNegConsmpCostafterReval@1016 : Decimal;
      VerifyVariance@1018 : Boolean;
    BEGIN
      EmptyItem.INIT;
      EmptyProdOrder.INIT;
      VerifyVariance := ProducedItemCostingMethod = ProducedItem."Costing Method"::Standard;

      QtyCompInProdItem := LibraryRandom.RandDecInDecimalRange(0.1,1,2);
      ProdOrderQty := LibraryRandom.RandDecInDecimalRange(100,200,2);

      SetupItems1Comp1ProdItem(ComponentItem,ProducedItem,ComponentCostingMethod,ProducedItemCostingMethod,QtyCompInProdItem);
      LibraryPatterns.MAKEProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProducedItem,'','',ProdOrderQty,StartDate + 30);

      QtyCompInProdOrder := ROUND(QtyCompInProdItem * ProdOrderQty,ComponentItem."Rounding Precision",'>');
      TotalPurchQty := PurchaseItem1Comp1ProdPartialAppln(ComponentItem,QtyCompInProdOrder,ComponentItem."Unit Cost",StartDate);

      ConsumptionQty :=
        LibraryRandom.RandDecInDecimalRange(QtyCompInProdOrder + 1,TotalPurchQty - 1,ComponentItem."Rounding Precision");

      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderLine.FINDFIRST;
      LibraryPatterns.POSTConsumption(ProdOrderLine,ComponentItem,'','',ConsumptionQty,StartDate + 4,ComponentItem."Unit Cost");

      LibraryPatterns.POSTOutput(ProdOrderLine,ProdOrderQty,StartDate + 4,ProducedItem."Unit Cost");

      // Post negative consumption for the excess consumption posted previously
      ItemLedgerEntry.SETRANGE("Item No.",ComponentItem."No.");
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::Consumption);
      ItemLedgerEntry.FINDLAST;
      LibraryPatterns.MAKEConsumptionJournalLine(
        ConsumptionItemJournalBatch,ProdOrderLine,ComponentItem,StartDate + 4,'','',-(ConsumptionQty - QtyCompInProdOrder),
        ComponentItem."Unit Cost");
      ConsumptionItemJournalLine.SETRANGE("Journal Template Name",ConsumptionItemJournalBatch."Journal Template Name");
      ConsumptionItemJournalLine.SETRANGE("Journal Batch Name",ConsumptionItemJournalBatch.Name);
      ConsumptionItemJournalLine.SETRANGE("Item No.",ComponentItem."No.");
      ConsumptionItemJournalLine.FINDFIRST;
      ConsumptionItemJournalLine.VALIDATE("Applies-from Entry",ItemLedgerEntry."Entry No.");
      ConsumptionItemJournalLine.MODIFY;
      LibraryInventory.PostItemJournalBatch(ConsumptionItemJournalBatch);

      // Finish Order
      LibraryManufacturing.ChangeProdOrderStatus(ProductionOrder,ProductionOrder.Status::Finished,StartDate + 10,FALSE);

      // AdjustCost
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ComponentItem."No.",ProducedItem."No."),'');
      // Verify
      VerifyCost(ComponentItem,EmptyItem,EmptyItem,ProductionOrder,EmptyProdOrder,VerifyVariance);

      ItemLedgerEntry.SETRANGE(Positive,TRUE);
      ItemLedgerEntry.FINDLAST;
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      NegConsmpCostbeforeReval := ItemLedgerEntry."Cost Amount (Actual)";

      ExecuteRevalueExistingInventory(ComponentItem,ItemJnlBatch,StartDate + 1,CalcPer,FALSE,FALSE,FALSE,CalculationBase::" ",'','');
      LibraryPatterns.ModifyPostRevaluation(ItemJnlBatch,RevaluationFactor);
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ComponentItem."No.",ProducedItem."No."),'');

      // Verify
      VerifyCost(ComponentItem,EmptyItem,EmptyItem,ProductionOrder,EmptyProdOrder,VerifyVariance);

      // Test Revaluation Cost Flow to the negative consumption item
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      NegConsmpCostafterReval := ItemLedgerEntry."Cost Amount (Actual)";
      RefNegConsmpCostafterReval := ROUND(NegConsmpCostbeforeReval * RevaluationFactor,LibraryERM.GetAmountRoundingPrecision);
      Assert.AreEqual(
        RefNegConsmpCostafterReval,NegConsmpCostafterReval,STRSUBSTNO(TXTIncorrectRevalCost,ItemLedgerEntry."Entry No."));
    END;

    LOCAL PROCEDURE TestProdOrder_RevalPartialConsumption@52(ComponentCostingMethod@1006 : Option;ProducedItemCostingMethod@1007 : Option;StartDate@1013 : Date;RevaluationFactor@1021 : Decimal);
    VAR
      ComponentItem@1004 : Record 27;
      ProducedItem@1003 : Record 27;
      EmptyItem@1023 : Record 27;
      ProductionOrder@1001 : Record 5405;
      EmptyProdOrder@1010 : Record 5405;
      ProdOrderLine@1005 : Record 5406;
      ItemJnlBatch@1019 : Record 233;
      QtyCompInProdItem@1008 : Decimal;
      ProdOrderQty@1011 : Decimal;
      QtyCompInProdOrder@1014 : Decimal;
      ConsumptionQty1@1009 : Decimal;
      ConsumptionQty2@1022 : Decimal;
      ConsumptionQty3@1026 : Decimal;
      VerifyVariance@1018 : Boolean;
    BEGIN
      EmptyItem.INIT;
      EmptyProdOrder.INIT;
      VerifyVariance := ProducedItemCostingMethod = ProducedItem."Costing Method"::Standard;

      QtyCompInProdItem := LibraryRandom.RandDecInDecimalRange(0.1,1,2);
      ProdOrderQty := LibraryRandom.RandDecInDecimalRange(100,200,2);

      SetupItems1Comp1ProdItem(ComponentItem,ProducedItem,ComponentCostingMethod,ProducedItemCostingMethod,QtyCompInProdItem);
      LibraryPatterns.MAKEProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProducedItem,'','',ProdOrderQty,StartDate + 30);

      QtyCompInProdOrder := ROUND(QtyCompInProdItem * ProdOrderQty,ComponentItem."Rounding Precision",'>');
      PurchaseItem1Comp1ProdPartialAppln(ComponentItem,QtyCompInProdOrder,ComponentItem."Unit Cost",StartDate);

      // Consumption 1 should be applied from purchase 1
      ConsumptionQty1 := ROUND(QtyCompInProdOrder / 4,ComponentItem."Rounding Precision");
      // Consumption 1 should be applied partly from purchase 1, and partly from purchase 2
      ConsumptionQty2 := ROUND(QtyCompInProdOrder / 2,ComponentItem."Rounding Precision");
      // Consumption 1 should be applied from purchase 2
      ConsumptionQty3 := QtyCompInProdOrder - ConsumptionQty1 - ConsumptionQty2;

      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderLine.FINDFIRST;
      LibraryPatterns.POSTConsumption(ProdOrderLine,ComponentItem,'','',ConsumptionQty1,StartDate + 4,ComponentItem."Unit Cost");
      LibraryPatterns.POSTConsumption(ProdOrderLine,ComponentItem,'','',ConsumptionQty2,StartDate + 6,ComponentItem."Unit Cost");
      LibraryPatterns.POSTConsumption(ProdOrderLine,ComponentItem,'','',ConsumptionQty3,StartDate + 8,ComponentItem."Unit Cost");

      LibraryPatterns.POSTOutput(ProdOrderLine,ProdOrderQty,StartDate + 10,ProducedItem."Unit Cost");

      // Finish Order
      LibraryManufacturing.ChangeProdOrderStatus(ProductionOrder,ProductionOrder.Status::Finished,StartDate + 11,FALSE);

      // AdjustCost
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ComponentItem."No.",ProducedItem."No."),'');
      // Verify
      VerifyCost(ComponentItem,EmptyItem,EmptyItem,ProductionOrder,EmptyProdOrder,VerifyVariance);

      // Execute Revaluation after consumption 1, but before consumption 2
      ExecuteRevalueExistingInventory(
        ComponentItem,ItemJnlBatch,StartDate + 5,CalculatePer::"Item Ledger Entry",FALSE,FALSE,FALSE,CalculationBase::" ",'','');
      LibraryPatterns.ModifyPostRevaluation(ItemJnlBatch,RevaluationFactor);

      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ComponentItem."No.",ProducedItem."No."),'');

      // Verify
      VerifyCost(ComponentItem,EmptyItem,EmptyItem,ProductionOrder,EmptyProdOrder,VerifyVariance);
    END;

    LOCAL PROCEDURE TestProdOrderAverageComponent@27(ProducedItemCostingMethod@1015 : Option;StartDate@1016 : Date);
    VAR
      ProdOrderLine@1014 : Record 5406;
      ItemJnlBatch@1013 : Record 233;
      ItemJnlLine@1012 : Record 83;
      ComponentItem@1011 : Record 27;
      ProducedItem@1010 : Record 27;
      ProductionOrder@1009 : Record 5405;
      QtyCompInProdItem@1008 : Decimal;
      ProdOrderQty@1007 : Decimal;
      QtyCompInProdOrder@1006 : Decimal;
      PurchaseQty1@1005 : Decimal;
      PurchaseQty2@1004 : Decimal;
      Cost1@1002 : Decimal;
      Cost2@1001 : Decimal;
      Cost3@1000 : Decimal;
      VerifyVariance@1017 : Boolean;
    BEGIN
      QtyCompInProdItem := LibraryRandom.RandDecInDecimalRange(0.1,1,2);
      ProdOrderQty := LibraryRandom.RandDecInDecimalRange(100,200,2);

      SetupItems1Comp1ProdItem(
        ComponentItem,ProducedItem,ComponentItem."Costing Method"::Average,ProducedItemCostingMethod,QtyCompInProdItem);

      LibraryPatterns.MAKEProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProducedItem,'','',ProdOrderQty,StartDate + 30);

      QtyCompInProdOrder := ROUND(QtyCompInProdItem * ProdOrderQty,ComponentItem."Rounding Precision",'>');

      PurchaseQty1 := ROUND(QtyCompInProdOrder / 2,ComponentItem."Rounding Precision");
      PurchaseQty2 := QtyCompInProdOrder - PurchaseQty1;

      Cost1 := LibraryPatterns.RandCost(ComponentItem);
      Cost2 := LibraryPatterns.RandCost(ComponentItem);
      Cost3 := LibraryPatterns.RandCost(ComponentItem);

      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatch,ItemJnlBatch."Template Type"::Item);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,ComponentItem,'','',StartDate,ItemJnlLine."Entry Type"::Purchase,PurchaseQty1,Cost1);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,ComponentItem,'','',StartDate + 1,ItemJnlLine."Entry Type"::Purchase,PurchaseQty2,Cost2);
      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);

      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderLine.FINDFIRST;
      LibraryPatterns.POSTConsumption(ProdOrderLine,ComponentItem,'','',QtyCompInProdOrder,StartDate + 2,ComponentItem."Unit Cost");

      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatch,ItemJnlBatch."Template Type"::Item);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,ComponentItem,'','',StartDate + 2,ItemJnlLine."Entry Type"::Purchase,PurchaseQty2,Cost3);
      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);

      LibraryPatterns.POSTOutput(ProdOrderLine,ProdOrderQty,StartDate + 9,ProducedItem."Unit Cost");

      // Finish
      LibraryManufacturing.ChangeProdOrderStatus(ProductionOrder,ProductionOrder.Status::Finished,StartDate + 10,FALSE);

      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ComponentItem."No.",ProducedItem."No."),'');

      // Verify
      VerifyVariance := ProducedItemCostingMethod = ProducedItem."Costing Method"::Standard;
      LibraryCosting.CheckAdjustment(ComponentItem);
      LibraryCosting.CheckProductionOrderCost(ProductionOrder,VerifyVariance);
    END;

    LOCAL PROCEDURE TestProdOrderAvgCompwithReval@38(ProducedItemCostingMethod@1007 : Option;StartDate@1003 : Date);
    VAR
      ItemJournalBatch@1012 : Record 233;
      ProductionOrder@1011 : Record 5405;
      ProdOrderLine@1010 : Record 5406;
      ParentItem@1006 : Record 27;
      CompItem@1005 : Record 27;
      ProdOrderStatusManagement@1004 : Codeunit 5407;
      Status@1002 : 'Quote,Planned,Firm Planned,Released,Finished';
      Qty@1001 : Decimal;
      QtyPer@1000 : Decimal;
      CalculatePer@1016 : 'Item Ledger Entry,Item';
      CalculationBase@1015 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
    BEGIN
      Initialize;
      Qty := LibraryRandom.RandInt(20);
      QtyPer := LibraryRandom.RandInt(10);

      // Setup.
      SetupItems1Comp1ProdItem(CompItem,ParentItem,CompItem."Costing Method"::Average,ProducedItemCostingMethod,QtyPer);

      LibraryPatterns.MAKEProductionOrder(ProductionOrder,ProductionOrder.Status::Released,ParentItem,'','',Qty,StartDate);
      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderLine.FINDFIRST;

      // Purchase component item.
      LibraryPatterns.POSTPositiveAdjustment(CompItem,'','','',Qty * QtyPer / 2,StartDate,LibraryRandom.RandDec(100,2));
      LibraryPatterns.POSTPositiveAdjustment(CompItem,'','','',(Qty * QtyPer) / 2 + 1,
        StartDate + 1,LibraryRandom.RandDec(100,2));

      // Post consumption.
      LibraryPatterns.MAKEConsumptionJournalLine(ItemJournalBatch,ProdOrderLine,CompItem,StartDate + 5,'','',Qty * QtyPer,0);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(ParentItem."No." + '|' + CompItem."No.",'');

      // Revalue component.
      LibraryPatterns.CalculateInventoryValueRun(
        ItemJournalBatch,CompItem,StartDate + 7,CalculatePer::Item,FALSE,FALSE,FALSE,CalculationBase::" ",FALSE,'','');
      LibraryPatterns.ModifyPostRevaluation(ItemJournalBatch,LibraryRandom.RandDecInRange(1,3,2));

      // Post output.
      LibraryPatterns.MAKEOutputJournalLine(ItemJournalBatch,ProdOrderLine,StartDate + 6,Qty,0);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(ParentItem."No." + '|' + CompItem."No.",'');

      // Revalue component again.
      LibraryPatterns.CalculateInventoryValueRun(
        ItemJournalBatch,CompItem,StartDate + 7,CalculatePer::Item,FALSE,FALSE,FALSE,CalculationBase::" ",FALSE,'','');
      LibraryPatterns.ModifyPostRevaluation(ItemJournalBatch,LibraryRandom.RandDecInRange(1,3,2));

      // Finish prod. order.
      ProductionOrder.GET(ProdOrderLine.Status,ProdOrderLine."Prod. Order No.");
      ProdOrderStatusManagement.ChangeStatusOnProdOrder(ProductionOrder,Status::Finished,StartDate,FALSE);

      // Adjust.
      LibraryCosting.AdjustCostItemEntries(ParentItem."No." + '|' + CompItem."No.",'');

      // Verify adjustment.
      LibraryCosting.CheckAdjustment(ParentItem);
      LibraryCosting.CheckAdjustment(CompItem);
      LibraryCosting.CheckProductionOrderCost(ProductionOrder,TRUE);
    END;

    [Test]
    [HandlerFunctions(ChangeAvgCostPeriodConfirmHndl,ChangeAvgCostPeriodMessageHndl)]
    PROCEDURE TestProdAverageItemConsNone@2221();
    BEGIN
      TestProdAverageItemCons(FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ChangeAvgCostPeriodConfirmHndl,ChangeAvgCostPeriodMessageHndl)]
    PROCEDURE TestProdAverageItemConsReserv@2133();
    BEGIN
      TestProdAverageItemCons(TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ChangeAvgCostPeriodConfirmHndl,ChangeAvgCostPeriodMessageHndl)]
    PROCEDURE TestProdAverageItemConsFixApp@1422();
    BEGIN
      TestProdAverageItemCons(FALSE,TRUE);
    END;

    LOCAL PROCEDURE TestProdAverageItemCons@1723(Reserve@2311 : Boolean;FixedAppl@1213 : Boolean);
    VAR
      InventorySetup@1002 : Record 313;
      CompItem@1000 : Record 27;
      ProdItem@1001 : Record 27;
      ProductionOrder@1008 : ARRAY [4] OF Record 5405;
      ItemLedgEntry@1014 : Record 32;
      ValueEntry@1015 : Record 5802;
      StartDate@1004 : Date;
      TotalQty@1005 : Decimal;
      ProdQty@1007 : Decimal;
      UnitAmount@2170 : Decimal;
      CompILEoutput@2172 : Integer;
      RevaluationFactor@1013 : Decimal;
      ExpectedCostAmount@1703 : Decimal;
      OldAvgCostPeriod@2171 : Option;
      NewAvgCostPeriod@2211 : Option;
      i@1170 : Integer;
    BEGIN
      // VSTF 336187 Positive Cost Amount (Actual) figures while it should be negative in a specific Scenario including Production,
      // the use of reservation and a revaluation.

      // Setup
      Initialize;
      NewAvgCostPeriod := InventorySetup."Average Cost Period"::Month;
      SetupAvgCostPeriod(NewAvgCostPeriod,OldAvgCostPeriod);
      CreateItem(CompItem,CompItem."Costing Method"::Average);
      CreateItem(ProdItem,ProdItem."Costing Method"::FIFO);
      StartDate := WORKDATE;
      TotalQty := 10000;
      ProdQty := 9990;
      UnitAmount := 0.2;

      // Repro steps
      LibraryPatterns.POSTPositiveAdjustment(CompItem,'','','',TotalQty,StartDate,UnitAmount);

      CreateAndPostProdOrder1Comp(ProductionOrder[1],CompItem,ProdItem,StartDate,ProdQty,0,FALSE);
      // ProdItem is consumed & CompItem is output - later date
      CreateAndPostProdOrder1Comp(ProductionOrder[2],ProdItem,CompItem,StartDate + 1,ProdQty,0,FALSE);
      // CompItem is consumed again
      IF Reserve OR FixedAppl THEN // Use the output entry from production of CompItem
        CompILEoutput := FindFirstILE(ItemLedgEntry,ProductionOrder[2]."No.",CompItem."No.",ItemLedgEntry."Entry Type"::Output)
      ELSE
        CompILEoutput := 0; // Use entry found by system
      CreateAndPostProdOrder1Comp(ProductionOrder[3],CompItem,ProdItem,StartDate + 1,ProdQty,CompILEoutput,Reserve);
      // Use the remainder on inventory of CompItem - first date
      CreateAndPostProdOrder1Comp(ProductionOrder[4],CompItem,ProdItem,StartDate,TotalQty - ProdQty,0,FALSE);
      // Finish production orders
      FOR i := 1 TO 4 DO
        LibraryManufacturing.ChangeProdOrderStatus(
          ProductionOrder[i],ProductionOrder[i].Status::Finished,ProductionOrder[i]."Due Date",FALSE);

      // Adjust and verify Cost per Unit
      LibraryCosting.AdjustCostItemEntries(CompItem."No." + '|' + ProdItem."No.",'');

      // Revaluate ProdItem - first output entry - and then adjust
      RevaluationFactor := 0.25;
      FindFirstILE(ItemLedgEntry,ProductionOrder[1]."No.",ProdItem."No.",ItemLedgEntry."Entry Type"::Output);
      LibraryPatterns.ExecutePostRevalueInboundILE(ProdItem,ItemLedgEntry,RevaluationFactor);
      LibraryCosting.AdjustCostItemEntries(CompItem."No." + '|' + ProdItem."No.",'');

      // Verification
      IF FixedAppl THEN
        ExpectedCostAmount := ProdQty * UnitAmount * RevaluationFactor
      ELSE BEGIN
        ExpectedCostAmount := ProdQty * UnitAmount * RevaluationFactor + UnitAmount * (TotalQty - ProdQty) ;
        ExpectedCostAmount := ExpectedCostAmount / TotalQty * ProdQty;
      END;

      // ProdItem
      FindFirstILE(ItemLedgEntry,ProductionOrder[3]."No.",ProdItem."No.",ItemLedgEntry."Entry Type"::Output);
      Assert.AreNearlyEqual(ExpectedCostAmount,ItemLedgEntry."Cost Amount (Actual)",0.01,'Cost Amount in ProdItem is wrong.');
      // CompItem
      FindFirstILE(ItemLedgEntry,ProductionOrder[3]."No.",CompItem."No.",ItemLedgEntry."Entry Type"::Consumption);
      Assert.AreNearlyEqual(-ExpectedCostAmount,ItemLedgEntry."Cost Amount (Actual)",0.01,'Cost Amount in CompItem is wrong.');

      LibraryCosting.CheckAdjustment(ProdItem);
      CompItem.CALCFIELDS(Inventory);
      Assert.IsTrue(CompItem.Inventory = 0,'Inventory for component should be 0.');
      ValueEntry.SETRANGE("Item No.",CompItem."No.");
      ValueEntry.CALCSUMS("Cost Amount (Actual)",ValueEntry."Cost Amount (Expected)");
      Assert.IsTrue(ValueEntry."Cost Amount (Expected)" = 0,'Cost amount expected for component should be 0.');
      Assert.IsTrue(ValueEntry."Cost Amount (Actual)" = 0,'Cost amount actual for component should be 0.');

      // Tear down
      SetupAvgCostPeriod(OldAvgCostPeriod,NewAvgCostPeriod);
    END;

    LOCAL PROCEDURE InitializeQuantities@1(VAR QtyCompInProdItem1@1004 : Decimal;VAR QtyCompInProdItem2@1003 : Decimal;VAR QtyProdItem1InProdItem2@1002 : Decimal;VAR ProdOrder1Qty@1001 : Decimal;VAR ProdOrder2Qty@1000 : Decimal;VAR SaleProdItem2Qty@1005 : Decimal);
    BEGIN
      QtyCompInProdItem1 := LibraryRandom.RandDecInDecimalRange(0.1,1,2);
      QtyCompInProdItem2 := LibraryRandom.RandDecInDecimalRange(1,10,2);
      QtyProdItem1InProdItem2 := LibraryRandom.RandDecInDecimalRange(1,10,2);
      ProdOrder1Qty := LibraryRandom.RandDecInDecimalRange(100,200,2);
      // Ensure that quantity of ProdItem1 consumed in ProdOrder2 should not be greater than what is produced in ProdItem1
      ProdOrder2Qty := LibraryRandom.RandDecInDecimalRange(10,ProdOrder1Qty / QtyProdItem1InProdItem2,2);
      SaleProdItem2Qty := LibraryRandom.RandDecInDecimalRange(1,ProdOrder2Qty,2);
    END;

    LOCAL PROCEDURE SetupItems@3(VAR ComponentItem@1002 : Record 27;VAR ProducedItem1@1001 : Record 27;VAR ProducedItem2@1000 : Record 27;ComponentCostingMethod@1008 : Option;ProducedItemCostingMethod@1007 : Option;QtyCompInProd1@1011 : Decimal;QtyCompInProd2@1010 : Decimal;QtyProd1InProd2@1009 : Decimal);
    VAR
      ProductionBOMHeader@1003 : Record 99000771;
      ProductionBOMLine@1004 : Record 99000772;
      Cost1@1012 : Decimal;
      Cost2@1013 : Decimal;
      Cost3@1014 : Decimal;
    BEGIN
      // ProducedItem1 contains ComponentItem; ProducedItem2 contains ProducedItem1 and ComponentItem

      Cost1 := LibraryRandom.RandDecInDecimalRange(1,10,2);
      Cost2 := LibraryRandom.RandDecInDecimalRange(1,10,2);
      Cost3 := LibraryRandom.RandDecInDecimalRange(1,10,2);

      LibraryPatterns.MAKEItemSimple(ComponentItem,ComponentCostingMethod,Cost1);
      LibraryPatterns.MAKEItemSimple(ProducedItem1,ProducedItemCostingMethod,Cost2);
      LibraryPatterns.MAKEItemSimple(ProducedItem2,ProducedItemCostingMethod,Cost3);

      // Make Production BOM 1
      LibraryPatterns.MAKEProductionBOM(ProductionBOMHeader,ProducedItem1,ComponentItem,QtyCompInProd1,'');

      // Make Production BOM 2
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,ProducedItem2."Base Unit of Measure");
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ComponentItem."No.",QtyCompInProd2);
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ProducedItem1."No.",QtyProd1InProd2);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY;
      ProducedItem2.VALIDATE("Production BOM No.",ProductionBOMHeader."No.");
      ProducedItem2.MODIFY;
    END;

    LOCAL PROCEDURE SetupItems1Comp1ProdItem@83(VAR ComponentItem@1002 : Record 27;VAR ProducedItem@1001 : Record 27;ComponentCostingMethod@1008 : Option;ProducedItemCostingMethod@1007 : Option;QtyCompInProdItem@1011 : Decimal);
    VAR
      ProductionBOMHeader@1003 : Record 99000771;
      CostCompItem@1012 : Decimal;
      CostProdItem@1013 : Decimal;
    BEGIN
      // ProducedItem1 contains ComponentItem; ProducedItem2 contains ProducedItem1 and ComponentItem
      CostCompItem := LibraryPatterns.RandCost(ComponentItem);
      CostProdItem := LibraryPatterns.RandCost(ProducedItem);

      LibraryPatterns.MAKEItemSimple(ComponentItem,ComponentCostingMethod,CostCompItem);
      LibraryPatterns.MAKEItemSimple(ProducedItem,ProducedItemCostingMethod,CostProdItem);

      // Make Production BOM
      LibraryPatterns.MAKEProductionBOM(ProductionBOMHeader,ProducedItem,ComponentItem,QtyCompInProdItem,'');
    END;

    LOCAL PROCEDURE CreateItem@1719(VAR Item@1701 : Record 27;CostingMethod@1700 : Option);
    BEGIN
      LibraryPatterns.MAKEItemSimple(Item,CostingMethod,0);
      Item.Description := FORMAT(Item."Costing Method");
      Item.MODIFY;
    END;

    LOCAL PROCEDURE CreateAndPostProdOrder1Comp@1718(VAR ProductionOrder@1001 : Record 5405;ComponentItem@1002 : Record 27;ProducedItem@1006 : Record 27;PostingDate@1004 : Date;ProdQty@1005 : Decimal;ApplyToEntry@1700 : Integer;ReservComp@1702 : Boolean);
    BEGIN
      LibraryPatterns.MAKEProductionOrder(ProductionOrder,ProductionOrder.Status::Released,ProducedItem,'','',ProdQty,PostingDate);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,FALSE,FALSE,FALSE);

      IF ReservComp THEN BEGIN
        MakeProdOrderCompReservation(ProductionOrder,ComponentItem."No.",ApplyToEntry,ProdQty);
        ApplyToEntry := 0; // Reservation replaces fixed application
      END;

      PostProdOrder1(ProductionOrder,ComponentItem,ProducedItem,PostingDate,ProdQty,ProdQty,ApplyToEntry);
    END;

    LOCAL PROCEDURE SetupProdOrders@41(VAR ProductionOrder1@1001 : Record 5405;VAR ProductionOrder2@1000 : Record 5405;ProducedItem1@1002 : Record 27;ProducedItem2@1003 : Record 27;ProdOrder1Qty@1005 : Decimal;ProdOrder2Qty@1004 : Decimal;DueDate@1006 : Date);
    BEGIN
      // Create production order 1
      LibraryPatterns.MAKEProductionOrder(
        ProductionOrder1,ProductionOrder1.Status::Released,ProducedItem1,'','',ProdOrder1Qty,DueDate);
      // Create production order 2
      LibraryPatterns.MAKEProductionOrder(
        ProductionOrder2,ProductionOrder1.Status::Released,ProducedItem2,'','',ProdOrder2Qty,DueDate);
    END;

    LOCAL PROCEDURE PurchaseItemSplitApplication@5(ComponentItem@1000 : Record 27;QtyCompInProdOrder1@1007 : Decimal;QtyCompInProdOrder2@1006 : Decimal;UnitCost@1014 : Decimal;PostingDate@1013 : Date);
    VAR
      ItemJnlBatch@1002 : Record 233;
      ItemJnlLine@1001 : Record 83;
      PurchaseQty1@1008 : Decimal;
      PurchaseQty2@1009 : Decimal;
      PurchaseQty2_1@1015 : Decimal;
      PurchaseQty2_2@1016 : Decimal;
      PurchaseQty3@1010 : Decimal;
      PurchaseQty4@1011 : Decimal;
      PurchaseQty5@1012 : Decimal;
    BEGIN
      // Components in first purchase will go entirely into ProdOrder1
      PurchaseQty1 := ROUND(QtyCompInProdOrder1 / 2,ComponentItem."Rounding Precision");
      // Components in second purchase will be split between ProdOrder1 and ProdOrder2
      PurchaseQty2_1 := QtyCompInProdOrder1 - PurchaseQty1;
      PurchaseQty2_2 := ROUND(QtyCompInProdOrder2 / 4,ComponentItem."Rounding Precision");
      PurchaseQty2 := PurchaseQty2_1 + PurchaseQty2_2;
      // Components in third purchase will go entirely into ProdOrder2
      PurchaseQty3 := ROUND(QtyCompInProdOrder2 / 4,ComponentItem."Rounding Precision");
      // Part of components in fourth purchase will go into ProdOrder2, and part will be unused
      PurchaseQty4 := QtyCompInProdOrder2 - PurchaseQty2_2 - PurchaseQty3 + LibraryRandom.RandDecInDecimalRange(1,100,2);
      // Components in fifth purchase will be unused
      PurchaseQty5 := LibraryRandom.RandDecInDecimalRange(1,100,2);

      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatch,ItemJnlBatch."Template Type"::Item);

      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,ComponentItem,'','',PostingDate,ItemJnlLine."Entry Type"::Purchase,PurchaseQty1,UnitCost);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,ComponentItem,'','',PostingDate,ItemJnlLine."Entry Type"::Purchase,PurchaseQty2,UnitCost);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,ComponentItem,'','',PostingDate,ItemJnlLine."Entry Type"::Purchase,PurchaseQty3,UnitCost);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,ComponentItem,'','',PostingDate,ItemJnlLine."Entry Type"::Purchase,PurchaseQty4,UnitCost);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,ComponentItem,'','',PostingDate,ItemJnlLine."Entry Type"::Purchase,PurchaseQty5,UnitCost);
      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);
    END;

    LOCAL PROCEDURE PurchaseItem1Comp1ProdPartialAppln@87(ComponentItem@1000 : Record 27;QtyCompInProdOrder@1007 : Decimal;UnitCost@1014 : Decimal;PostingDate@1013 : Date) TotalPurchQty : Decimal;
    VAR
      ItemJnlBatch@1002 : Record 233;
      ItemJnlLine@1001 : Record 83;
      PurchaseQty1@1008 : Decimal;
      PurchaseQty2@1009 : Decimal;
    BEGIN
      // Components in first purchase will go entirely into ProdOrder
      PurchaseQty1 := ROUND(QtyCompInProdOrder / 2,ComponentItem."Rounding Precision");
      // Part of Components in second purchase go into ProdOrder
      PurchaseQty2 := QtyCompInProdOrder - PurchaseQty1 + LibraryRandom.RandDecInDecimalRange(10,100,2);

      LibraryInventory.CreateItemJournalBatchByType(ItemJnlBatch,ItemJnlBatch."Template Type"::Item);

      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,ComponentItem,'','',PostingDate,ItemJnlLine."Entry Type"::Purchase,PurchaseQty1,UnitCost);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJnlLine,ItemJnlBatch,ComponentItem,'','',PostingDate,ItemJnlLine."Entry Type"::Purchase,PurchaseQty2,UnitCost);
      LibraryInventory.PostItemJournalBatch(ItemJnlBatch);

      TotalPurchQty := PurchaseQty1 + PurchaseQty2;
      EXIT(TotalPurchQty);
    END;

    LOCAL PROCEDURE PostProdOrder1@32(ProductionOrder1@1001 : Record 5405;ComponentItem@1002 : Record 27;ProducedItem1@1006 : Record 27;PostingDate@1004 : Date;QtyCompInProdOrder1@1003 : Decimal;ProdOrder1Qty@1005 : Decimal;ApplyToEntry@1700 : Integer);
    VAR
      ProdOrderLine@1000 : Record 5406;
      ItemJournalBatch@1702 : Record 233;
      ItemJnlLine@1701 : Record 83;
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProductionOrder1.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder1."No.");
      ProdOrderLine.FINDFIRST;

      IF ApplyToEntry = 0 THEN
        LibraryPatterns.POSTConsumption(ProdOrderLine,ComponentItem,'','',QtyCompInProdOrder1,PostingDate,ComponentItem."Unit Cost")
      ELSE BEGIN // Make fixed application before posting consumption
        LibraryPatterns.MAKEConsumptionJournalLine(
          ItemJournalBatch,ProdOrderLine,ComponentItem,PostingDate,'','',QtyCompInProdOrder1,ComponentItem."Unit Cost");
        ItemJnlLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
        ItemJnlLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
        ItemJnlLine.SETRANGE("Order Type",ItemJnlLine."Order Type"::Production);
        ItemJnlLine.SETRANGE("Order No.",ProductionOrder1."No.");
        ItemJnlLine.SETRANGE("Item No.",ComponentItem."No.");
        ItemJnlLine.FINDFIRST;
        ItemJnlLine."Applies-to Entry" := ApplyToEntry;
        ItemJnlLine.MODIFY;
        LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
      END;
      LibraryPatterns.POSTOutput(ProdOrderLine,ProdOrder1Qty,PostingDate,ProducedItem1."Unit Cost");
    END;

    LOCAL PROCEDURE PostProdOrder2@36(ProductionOrder2@1005 : Record 5405;ComponentItem@1004 : Record 27;ProducedItem1@1003 : Record 27;ProducedItem2@1008 : Record 27;PostingDate@1002 : Date;QtyCompInProdOrder2@1001 : Decimal;QtyProdItem1InProdOrder2@1007 : Decimal;ProdOrder2Qty@1000 : Decimal);
    VAR
      ProdOrderLine@1006 : Record 5406;
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProductionOrder2.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder2."No.");
      ProdOrderLine.FINDFIRST;
      LibraryPatterns.POSTConsumption(ProdOrderLine,ComponentItem,'','',QtyCompInProdOrder2,PostingDate,ComponentItem."Unit Cost");
      LibraryPatterns.POSTConsumption(
        ProdOrderLine,ProducedItem1,'','',QtyProdItem1InProdOrder2,PostingDate,ProducedItem1."Unit Cost");
      LibraryPatterns.POSTOutput(ProdOrderLine,ProdOrder2Qty,PostingDate,ProducedItem2."Unit Cost");
    END;

    LOCAL PROCEDURE ExecuteRevalueExistingInventory@63(VAR Item@1000 : Record 27;VAR ItemJnlBatch@1002 : Record 233;PostingDate@1011 : Date;CalculatePer@1009 : Option;ByLocation@1008 : Boolean;ByVariant@1007 : Boolean;UpdStdCost@1006 : Boolean;CalcBase@1005 : Option;LocationFilter@1014 : Code[20];VariantFilter@1004 : Code[20]);
    BEGIN
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
      LibraryCosting.CheckAdjustment(Item);

      LibraryPatterns.CalculateInventoryValueRun(
        ItemJnlBatch,Item,PostingDate,CalculatePer,ByLocation,ByVariant,UpdStdCost,CalcBase,FALSE,LocationFilter,VariantFilter);

      LibraryPatterns.CHECKCalcInvPost(Item,ItemJnlBatch,PostingDate,CalculatePer,ByLocation,ByVariant,LocationFilter,VariantFilter);
    END;

    LOCAL PROCEDURE ModifyRevaluationLine@49(JournalTemplateName@1000 : Code[10];JournalBatchName@1001 : Code[10];LineNo@1002 : Integer;RevaluationFactor@1003 : Decimal;RoundingPrecision@1004 : Decimal);
    VAR
      ItemJnlLine@1005 : Record 83;
    BEGIN
      ItemJnlLine.GET(JournalTemplateName,JournalBatchName,LineNo);
      ItemJnlLine.VALIDATE(
        "Inventory Value (Revalued)",ROUND(ItemJnlLine."Inventory Value (Revalued)" * RevaluationFactor,RoundingPrecision));
      ItemJnlLine.MODIFY;
    END;

    LOCAL PROCEDURE FindFirstILE@1709(VAR ItemLedgEntry@1701 : Record 32;ProductionNo@1121 : Code[20];ItemNo@1700 : Code[20];EntryType@1702 : Option) : Integer;
    BEGIN
      ItemLedgEntry.RESET;
      ItemLedgEntry.SETCURRENTKEY("Order Type","Order No.","Order Line No.","Entry Type");
      ItemLedgEntry.SETRANGE("Order Type",ItemLedgEntry."Order Type"::Production);
      ItemLedgEntry.SETRANGE("Order No.",ProductionNo);
      ItemLedgEntry.SETRANGE("Entry Type",EntryType);
      ItemLedgEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgEntry.FINDFIRST;

      ItemLedgEntry.CALCFIELDS("Cost Amount (Actual)");
      EXIT(ItemLedgEntry."Entry No.");
    END;

    LOCAL PROCEDURE MakeProdOrderCompReservation@1708(ProductionOrder@1700 : Record 5405;ComponentItemNo@1702 : Code[20];ILENo@1707 : Integer;Qty@1706 : Decimal);
    VAR
      ProdOrderLine@1704 : Record 5406;
      ProdOrderComp@1703 : Record 5407;
      ReservEntry@1701 : Record 337;
      EntryNo@1705 : Integer;
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderLine.FINDFIRST;
      ProdOrderComp.INIT;
      ProdOrderComp.Status := ProductionOrder.Status;
      ProdOrderComp."Prod. Order No." := ProductionOrder."No.";
      ProdOrderComp."Prod. Order Line No." := ProdOrderLine."Line No.";
      ProdOrderComp."Line No." := 10000;
      ProdOrderComp.VALIDATE("Due Date",ProductionOrder."Due Date");
      ProdOrderComp.VALIDATE("Item No.",ComponentItemNo);
      ProdOrderComp.VALIDATE("Quantity per",1);
      ProdOrderComp.INSERT;

      EntryNo := 1;
      ReservEntry.RESET;
      IF ReservEntry.FINDLAST THEN
        EntryNo := ReservEntry."Entry No." + 1;
      // Component
      ReservEntry.INIT;
      ReservEntry."Entry No." := EntryNo;
      ReservEntry.Positive := FALSE;
      ReservEntry."Item No." := ComponentItemNo;
      ReservEntry."Source Type" := DATABASE::"Prod. Order Component";
      ReservEntry."Source Subtype" := ProdOrderComp.Status;
      ReservEntry."Source ID" := ProdOrderComp."Prod. Order No.";
      ReservEntry."Source Prod. Order Line" := ProdOrderComp."Prod. Order Line No.";
      ReservEntry."Source Ref. No." := ProdOrderComp."Line No.";
      ReservEntry."Shipment Date" := ProdOrderComp."Due Date";
      ReservEntry."Quantity (Base)" := -Qty;
      ReservEntry.Quantity := ReservEntry."Quantity (Base)";
      ReservEntry."Qty. per Unit of Measure" := 1;
      ReservEntry.INSERT;
      // Inventory
      ReservEntry.INIT;
      ReservEntry."Entry No." := EntryNo;
      ReservEntry.Positive := TRUE;
      ReservEntry."Item No." := ComponentItemNo;
      ReservEntry."Source Type" := DATABASE::"Item Ledger Entry";
      ReservEntry."Source Ref. No." := ILENo;
      ReservEntry."Quantity (Base)" := Qty;
      ReservEntry.Quantity := ReservEntry."Quantity (Base)";
      ReservEntry."Qty. per Unit of Measure" := 1;
      ReservEntry.INSERT;
    END;

    LOCAL PROCEDURE SetupAvgCostPeriod@1713(NewAvgCostPeriod@1700 : Option;VAR OldAvgCostPeriod@1702 : Option);
    VAR
      InventorySetup@1701 : Record 313;
    BEGIN
      InventorySetup.GET;
      OldAvgCostPeriod := InventorySetup."Average Cost Period";

      IF InventorySetup."Average Cost Period" <> NewAvgCostPeriod THEN BEGIN
        InventorySetup.VALIDATE("Average Cost Period",NewAvgCostPeriod);
        InventorySetup.MODIFY
      END ELSE BEGIN
        // For message handler if no change for Average Cost Period
        IF CONFIRM(AnyQst) THEN
          MESSAGE(AnyMsg);
      END;
    END;

    LOCAL PROCEDURE VerifyCost@28(Item1@1000 : Record 27;Item2@1001 : Record 27;Item3@1002 : Record 27;ProdOrder1@1003 : Record 5405;ProdOrder2@1004 : Record 5405;VerifyVariance@1007 : Boolean);
    BEGIN
      IF Item1."No." <> '' THEN
        LibraryCosting.CheckAdjustment(Item1);
      IF Item2."No." <> '' THEN
        LibraryCosting.CheckAdjustment(Item2);
      IF Item3."No." <> '' THEN
        LibraryCosting.CheckAdjustment(Item3);
      IF ProdOrder1."No." <> '' THEN
        LibraryCosting.CheckProductionOrderCost(ProdOrder1,VerifyVariance);
      IF ProdOrder2."No." <> '' THEN
        LibraryCosting.CheckProductionOrderCost(ProdOrder2,VerifyVariance);
    END;

    [MessageHandler]
    PROCEDURE ChangeAvgCostPeriodMessageHndl@2345(Message@1700 : Text[1024]);
    BEGIN
    END;

    [ConfirmHandler]
    PROCEDURE ChangeAvgCostPeriodConfirmHndl@1333(Question@1512 : Text[1024];VAR Reply@1215 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    BEGIN
    {
      // [FEATURE] [Adjust Cost Item Entries] [Revaluation] [SCM]
    }
    END.
  }
}

