OBJECT Codeunit 134264 Applied Payment Entries Test
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      LibraryRandom@1000 : Codeunit 130440;
      LibraryUtility@1001 : Codeunit 131000;
      Assert@1002 : Codeunit 130000;
      LibraryVariableStorage@1003 : Codeunit 131004;
      LibraryERM@1004 : Codeunit 131300;
      isInitialized@1060 : Boolean;

    [Test]
    [HandlerFunctions(MessageHandler,SelectFirstRowPaymentApplicationHandler)]
    PROCEDURE AutomaticApplyToEntry@5();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      TotalAppliedAmount@1010 : Variant;
      TotalRemainingAmount@1011 : Variant;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      // Verify Amount is correctly applied
      VerifyAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry."Customer No.",Amount);

      LibraryVariableStorage.Dequeue(TotalAppliedAmount);
      LibraryVariableStorage.Dequeue(TotalRemainingAmount);
      Assert.AreEqual(Amount,TotalAppliedAmount,'Wrong amount applied.');
      Assert.AreEqual(0,TotalRemainingAmount,'Amount left to apply is incorrect.');
      PaymentReconciliationJournal.CLOSE;

      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(ConfirmHandlerYes,MessageHandler,RejectApplicationPaymentApplicationHandler)]
    PROCEDURE RejectApplication@30();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      BankAccReconciliationLine@1011 : Record 274;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
      ClosePage@1010 : Boolean;
      RejectFromPaymentApplication@1012 : Boolean;
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      ClosePage := FALSE;
      LibraryVariableStorage.Enqueue(ClosePage);
      LibraryVariableStorage.Enqueue(Amount);
      RejectFromPaymentApplication := TRUE;
      LibraryVariableStorage.Enqueue(RejectFromPaymentApplication);
      InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      // Verify application reject functionality
      VerifyNoAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry."Customer No.",Amount);

      Assert.AreEqual(
        FORMAT(BankAccReconciliationLine."Match Confidence"::None),
        PaymentReconciliationJournal."Match Confidence".VALUE,
        'Unexpected match confidence after rejecting the application');

      PaymentReconciliationJournal.CLOSE;
      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,RejectApplicationPaymentApplicationHandler)]
    PROCEDURE RejectApplicationFromPaymentJournal@70();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      BankAccReconciliationLine@1011 : Record 274;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
      RejectFromPaymentApplication@1012 : Boolean;
      ClosePage@1013 : Boolean;
    BEGIN
      // [SCENARIO 372024] After Application Reject from Payment Journal field "Account No." is empty.
      Initialize;

      // [GIVEN] Customer, Cust. Ledger Entry and Bank Account Reconciliation Line.
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // [GIVEN] Applied Payment to Cust. Ledger Entry.
      ClosePage := TRUE;
      LibraryVariableStorage.Enqueue(ClosePage);
      InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      // [WHEN] Reject Applied Payment.
      PaymentReconciliationJournal.Reject.INVOKE;
      ClosePage := FALSE;
      LibraryVariableStorage.Enqueue(ClosePage);
      LibraryVariableStorage.Enqueue(Amount);
      RejectFromPaymentApplication := FALSE;
      LibraryVariableStorage.Enqueue(RejectFromPaymentApplication);
      LibraryVariableStorage.Enqueue(CustLedgEntry."Entry No.");
      PaymentReconciliationJournal.ApplyEntries.INVOKE;

      // [THEN] No Applied Payment Entry exist.
      VerifyNoAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry."Customer No.",Amount);
      // [THEN] Bank Account Reconciliation Line field "Match Confidence" = None
      PaymentReconciliationJournal."Match Confidence".ASSERTEQUALS(FORMAT(BankAccReconciliationLine."Match Confidence"::None));
      // [THEN] Bank Account Reconciliation Line field "Account No." is empty
      PaymentReconciliationJournal."Account No.".ASSERTEQUALS('');
      PaymentReconciliationJournal.CLOSE;
      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,SetAppliedPaymentApplicationHandler)]
    PROCEDURE UnapplyApplication@41();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      BankAccReconciliationLine@1010 : Record 274;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
      Applied@1012 : Boolean;
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      LibraryVariableStorage.Enqueue(Amount);
      Applied := FALSE;
      LibraryVariableStorage.Enqueue(Applied);
      InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      // Verify
      VerifyNoAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry."Customer No.",Amount);

      Assert.AreEqual(
        FORMAT(BankAccReconciliationLine."Match Confidence"::None),
        PaymentReconciliationJournal."Match Confidence".VALUE,
        'Unexpected match confidence after rejecting the application');
      PaymentReconciliationJournal.CLOSE;
      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ChangeAppliedAmountPaymentApplicationHandler)]
    PROCEDURE UnapplyByApplyingZeroAmount@58();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      BankAccReconciliationLine@1010 : Record 274;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      LibraryVariableStorage.Enqueue(Amount);
      LibraryVariableStorage.Enqueue(0);
      InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      // Verify
      VerifyNoAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry."Customer No.",Amount);

      Assert.AreEqual(
        FORMAT(BankAccReconciliationLine."Match Confidence"::None),
        PaymentReconciliationJournal."Match Confidence".VALUE,
        'Unexpected match confidence after rejecting the application');

      PaymentReconciliationJournal.CLOSE;
      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,SetAppliedPaymentApplicationHandler)]
    PROCEDURE ReapplyUnappliedApplication@48();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
      Applied@1011 : Boolean;
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      LibraryVariableStorage.Enqueue(Amount);
      Applied := FALSE;
      LibraryVariableStorage.Enqueue(Applied);
      InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      // Verify
      LibraryVariableStorage.Enqueue(Amount);
      Applied := TRUE;
      LibraryVariableStorage.Enqueue(Applied);
      LibraryVariableStorage.Enqueue(CustLedgEntry."Entry No.");
      PaymentReconciliationJournal.ApplyEntries.INVOKE;

      VerifyAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry."Customer No.",Amount);

      PaymentReconciliationJournal.CLOSE;
      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,AcceptApplicationPaymentApplicationHandler)]
    PROCEDURE AcceptApplication@36();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      BankAccReconciliationLine@1011 : Record 274;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
      ClosePage@1012 : Boolean;
    BEGIN
      Initialize;

      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      ClosePage := FALSE;
      LibraryVariableStorage.Enqueue(ClosePage);

      InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      // Verify
      Assert.AreEqual(
        FORMAT(BankAccReconciliationLine."Match Confidence"::Accepted),
        PaymentReconciliationJournal."Match Confidence".VALUE,
        'Unexpecbted match confidence after accepting the application');

      VerifyAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry."Customer No.",Amount);

      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,AcceptApplicationPaymentApplicationHandler)]
    PROCEDURE AcceptApplicationFromPaymentJournal@67();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      BankAccReconciliationLine@1011 : Record 274;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
      ClosePage@1012 : Boolean;
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      ClosePage := TRUE;
      LibraryVariableStorage.Enqueue(ClosePage);

      InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");
      PaymentReconciliationJournal.Accept.INVOKE;

      // Verify
      Assert.AreEqual(
        FORMAT(BankAccReconciliationLine."Match Confidence"::Accepted),
        PaymentReconciliationJournal."Match Confidence".VALUE,
        'Unexpecbted match confidence after accepting the application');

      VerifyAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry."Customer No.",Amount);

      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ChangeAppliedAmountPaymentApplicationHandler)]
    PROCEDURE ChangeAmountToApply@40();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
      ChangedAmount@1011 : Decimal;
    BEGIN
      Initialize;

      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      ChangedAmount := Amount - LibraryRandom.RandDecInDecimalRange(0.1,Amount / 2,2);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      LibraryVariableStorage.Enqueue(Amount);
      LibraryVariableStorage.Enqueue(ChangedAmount);
      InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      // Verify
      VerifyAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry."Customer No.",ChangedAmount);

      PaymentReconciliationJournal.CLOSE;
      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ApplyToMultipleEntriesPaymentApplicationHandler)]
    PROCEDURE ApplyToMultipleEntries@59();
    VAR
      CustLedgEntry@1000 : Record 21;
      CustLedgEntry2@1011 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      PaymentReconciliationJournal@1010 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
      AmountDelta@1005 : Decimal;
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      AmountDelta := Amount - LibraryRandom.RandDecInDecimalRange(0.1,Amount / 2,2);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",AmountDelta);
      InsertCustLedgerEntry(CustLedgEntry2,Cust."No.",Amount - AmountDelta);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      LibraryVariableStorage.Enqueue(Amount);
      LibraryVariableStorage.Enqueue(Amount - AmountDelta);
      LibraryVariableStorage.Enqueue(CustLedgEntry2."Entry No.");
      InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      VerifyAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry."Customer No.",AmountDelta);
      VerifyAppliedPaymentEntry(BankAccRecon,ExpectedMatchedLineNo,CustLedgEntry2."Entry No.",
        CustLedgEntry."Bal. Account Type"::Customer,CustLedgEntry2."Customer No.",Amount - AmountDelta);

      PaymentReconciliationJournal.CLOSE;
      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ApplyToDifferentEntryPaymentApplicationHandler)]
    PROCEDURE ApplyToDifferentEntry@65();
    VAR
      CustLedgEntry@1000 : Record 21;
      CustLedgEntry2@1011 : Record 21;
      CustLedgEntry3@1005 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      PaymentReconciliationJournal@1010 : TestPage 1290;
      ExpectAmtVariant@1013 : Variant;
      StmtAmt@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ExpectedMatchedLineNo@1001 : Integer;
      ExpectAmt@1012 : Decimal;
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,StmtAmt);
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",ROUND(StmtAmt / 2));
      InsertCustLedgerEntry(CustLedgEntry2,Cust."No.",StmtAmt);
      InsertCustLedgerEntry(CustLedgEntry3,Cust."No.",StmtAmt * 2);

      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      ExpectedMatchedLineNo :=
        CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,StmtAmt);

      // Exercise
      InvokeAutoApply(BankAccRecon,PaymentReconciliationJournal);

      CustLedgEntry.SETRANGE("Entry No.",CustLedgEntry."Entry No.",CustLedgEntry3."Entry No.");
      IF CustLedgEntry.FINDSET THEN
        REPEAT
          LibraryVariableStorage.Enqueue(CustLedgEntry."Entry No.");
          LibraryVariableStorage.Enqueue(StmtAmt);
          PaymentReconciliationJournal.ApplyEntries.INVOKE;
          LibraryVariableStorage.Dequeue(ExpectAmtVariant);
          ExpectAmt := ExpectAmtVariant;

          VerifyAppliedPaymentEntry(
            BankAccRecon,
            ExpectedMatchedLineNo,
            CustLedgEntry."Entry No.",
            CustLedgEntry."Bal. Account Type"::Customer,
            CustLedgEntry."Customer No.",
            ExpectAmt);
        UNTIL CustLedgEntry.NEXT = 0;

      PaymentReconciliationJournal.CLOSE;
      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,WrongApplicationAmountPaymentApplicationHandler)]
    PROCEDURE UnableToApplyAmountWithDifferentSign@77();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      PaymentReconciliationJournal@1005 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ChangedAmount@1011 : Decimal;
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      ChangedAmount := Amount * -1;
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      LibraryVariableStorage.Enqueue(ChangedAmount);
      ASSERTERROR InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,WrongApplicationAmountPaymentApplicationHandler)]
    PROCEDURE UnableToApplyMoreThanRemainingAmount@80();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
      ChangedAmount@1011 : Decimal;
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      ChangedAmount := Amount + 1;
      CreateCustomer(Cust);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);

      // Exercise
      LibraryVariableStorage.Enqueue(ChangedAmount);
      ASSERTERROR InvokeAutoApplyAndOpenPaymentApplicationsPage(BankAccRecon,PaymentReconciliationJournal,CustLedgEntry."Entry No.");

      LibraryVariableStorage.AssertEmpty;
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE TotalsOnPaymentReconciliationJournal@3();
    VAR
      CustLedgEntry@1000 : Record 21;
      Cust@1004 : Record 18;
      BankAccRecon@1002 : Record 273;
      BankAccount@1001 : Record 270;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      CreateCustomer(Cust);

      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);
      CreateBankAccRecLine(BankAccRecon,PostingDate,'',Amount / 2);

      // Exercise
      InvokeAutoApply(BankAccRecon,PaymentReconciliationJournal);

      // make some manual changes - edit statement amount on one line and add one more line
      PaymentReconciliationJournal.FINDFIRSTFIELD("Statement Amount",Amount / 2);
      PaymentReconciliationJournal."Statement Amount".SETVALUE((Amount / 2) + 1);
      PaymentReconciliationJournal.NEW;
      PaymentReconciliationJournal."Statement Amount".SETVALUE(Amount);
      PaymentReconciliationJournal."Statement Amount".SETVALUE(Amount * 2);
      PaymentReconciliationJournal.LAST;

      // Verify totals are correctly calculated
      BankAccount.GET(BankAccNo);
      BankAccount.CALCFIELDS(Balance);
      Assert.AreEqual(BankAccount.Balance,PaymentReconciliationJournal.BalanceOnBankAccount.ASDECIMAL,
        'Unexpected value of ''Balance on Bank Account''');
      Assert.AreEqual(ROUND(Amount + (Amount / 2) + (Amount * 2) + 1,LibraryERM.GetAmountRoundingPrecision),
        PaymentReconciliationJournal.TotalTransactionAmount.ASDECIMAL,
        'Unexpected value of ''Total Statement Amount''');
      Assert.AreEqual(
        PaymentReconciliationJournal.BalanceOnBankAccount.ASDECIMAL + PaymentReconciliationJournal.TotalTransactionAmount.ASDECIMAL,
        PaymentReconciliationJournal.BalanceOnBankAccountAfterPosting.ASDECIMAL,
        'Unexpected value of ''Balance on Bank Account After Posting''');

      // Verify Statement Ending Balance is editable
      PaymentReconciliationJournal.StatementEndingBalance.SETVALUE(Amount * 3);
      Assert.AreEqual(ROUND(Amount * 3,LibraryERM.GetAmountRoundingPrecision),
        PaymentReconciliationJournal.StatementEndingBalance.ASDECIMAL,
        'Unexpected value of ''Statement Ending Balance''');
      PaymentReconciliationJournal.CLOSE;
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE AccountNameOnPaymentReconciliationJournal@15();
    VAR
      CustLedgEntry@1000 : Record 21;
      CustLedgEntry2@1011 : Record 21;
      Cust@1004 : Record 18;
      Cust2@1010 : Record 18;
      BankAccRecon@1002 : Record 273;
      PaymentReconciliationJournal@1006 : TestPage 1290;
      Amount@1003 : Decimal;
      PostingDate@1009 : Date;
      BankAccNo@1008 : Code[20];
      StatementNo@1007 : Code[20];
    BEGIN
      Initialize;
      // Setup
      CreateInputData(PostingDate,BankAccNo,StatementNo,Amount);
      CreateCustomer(Cust);
      CreateCustomer(Cust2);
      InsertCustLedgerEntry(CustLedgEntry,Cust."No.",Amount);
      InsertCustLedgerEntry(CustLedgEntry2,Cust2."No.",Amount * 2);
      CreateBankAccRec(BankAccRecon,BankAccNo,StatementNo);
      CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry."Document No." + Cust.Name,Amount);
      CreateBankAccRecLine(BankAccRecon,PostingDate,CustLedgEntry2."Document No." + Cust2.Name,Amount * 2);

      // Exercise
      InvokeAutoApply(BankAccRecon,PaymentReconciliationJournal);

      // Verify Account Name is displayed and you cann drill down on it
      PaymentReconciliationJournal.LAST;
      VerifyAccountNameField(Cust2,PaymentReconciliationJournal);
      PaymentReconciliationJournal.FIRST;
      VerifyAccountNameField(Cust,PaymentReconciliationJournal);
      Assert.AreEqual(Cust.Name,PaymentReconciliationJournal.AccountName.VALUE,'Unexpected Account Name shown');
      PaymentReconciliationJournal.CLOSE;
    END;

    LOCAL PROCEDURE InvokeAutoApplyAndOpenPaymentApplicationsPage@12(BankAccRecon@1001 : Record 273;VAR PaymentReconciliationJournal@1000 : TestPage 1290;EntryNo@1003 : Integer);
    BEGIN
      InvokeAutoApply(BankAccRecon,PaymentReconciliationJournal);
      LibraryVariableStorage.Enqueue(EntryNo);
      PaymentReconciliationJournal.ApplyEntries.INVOKE;
    END;

    LOCAL PROCEDURE InvokeAutoApply@32(BankAccRecon@1001 : Record 273;VAR PaymentReconciliationJournal@1000 : TestPage 1290);
    VAR
      PmtReconciliationJournals@1002 : TestPage 1294;
    BEGIN
      PmtReconciliationJournals.OPENVIEW;
      PmtReconciliationJournals.GOTORECORD(BankAccRecon);
      PaymentReconciliationJournal.TRAP;
      PmtReconciliationJournals.EditJournal.INVOKE;

      PaymentReconciliationJournal.ApplyAutomatically.INVOKE;
      PaymentReconciliationJournal.FIRST;
    END;

    LOCAL PROCEDURE CreateBankAccRec@56(VAR BankAccRecon@1000 : Record 273;BankAccNo@1001 : Code[20];StatementNo@1002 : Code[20]);
    BEGIN
      WITH BankAccRecon DO BEGIN
        INIT;
        "Bank Account No." := BankAccNo;
        "Statement No." := StatementNo;
        "Statement Date" := WORKDATE;
        "Statement Type" := "Statement Type"::"Payment Application";
        INSERT;
      END;
    END;

    LOCAL PROCEDURE CreateBankAccRecLine@55(VAR BankAccRecon@1000 : Record 273;TransactionDate@1005 : Date;TransactionText@1004 : Text[140];Amount@1006 : Decimal) : Integer;
    VAR
      BankAccReconLine@1007 : Record 274;
    BEGIN
      FillInCommonBankAccRecLineFields(BankAccReconLine,BankAccRecon,TransactionDate,Amount);
      BankAccReconLine."Transaction Text" := TransactionText;
      BankAccReconLine.INSERT;
      EXIT(BankAccReconLine."Statement Line No.");
    END;

    LOCAL PROCEDURE FillInCommonBankAccRecLineFields@7(VAR BankAccReconLine@1000 : Record 274;BankAccRecon@1003 : Record 273;TransactionDate@1001 : Date;Amount@1002 : Decimal);
    BEGIN
      WITH BankAccReconLine DO BEGIN
        SETRANGE("Statement Type",BankAccRecon."Statement Type");
        SETRANGE("Bank Account No.",BankAccRecon."Bank Account No.");
        SETRANGE("Statement No.",BankAccRecon."Statement No.");
        IF FINDLAST THEN
          RESET;

        INIT;
        "Bank Account No." := BankAccRecon."Bank Account No.";
        "Statement Type" := BankAccRecon."Statement Type";
        "Statement No." := BankAccRecon."Statement No.";
        "Statement Line No." += 10000;
        "Transaction Date" := TransactionDate;
        "Statement Amount" := Amount;
        Difference := Amount;
        Type := Type::"Bank Account Ledger Entry";
      END;
    END;

    LOCAL PROCEDURE CreateInputData@52(VAR PostingDate@1005 : Date;VAR BankAccNo@1004 : Code[20];VAR StatementNo@1003 : Code[20];VAR Amount@1000 : Decimal);
    VAR
      BankAccReconLine@1006 : Record 274;
      BankAcc@1001 : Record 270;
    BEGIN
      Amount := LibraryRandom.RandDec(1000,2);
      PostingDate := WORKDATE + LibraryRandom.RandInt(10);

      BankAccNo :=
        LibraryUtility.GenerateRandomCode(
          BankAccReconLine.FIELDNO("Bank Account No."),DATABASE::"Bank Acc. Reconciliation Line");

      WITH BankAcc DO BEGIN
        INIT;
        "No." := BankAccNo;
        "Currency Code" := LibraryERM.GetLCYCode;
        INSERT;
      END;

      StatementNo :=
        LibraryUtility.GenerateRandomCode(
          BankAccReconLine.FIELDNO("Statement No."),DATABASE::"Bank Acc. Reconciliation Line");
    END;

    LOCAL PROCEDURE Initialize@1064();
    BEGIN
      LibraryVariableStorage.Clear;
      CloseExistingEntries;
      IF isInitialized THEN
        EXIT;

      isInitialized := TRUE;
    END;

    LOCAL PROCEDURE InsertCustLedgerEntry@2(VAR CustLedgEntry@1000 : Record 21;CustNo@1003 : Code[20];Amt@1002 : Decimal);
    VAR
      LastEntryNo@1001 : Integer;
    BEGIN
      WITH CustLedgEntry DO BEGIN
        FINDLAST;
        LastEntryNo := "Entry No.";
        InsertDetailedCustLedgerEntry(LastEntryNo + 1,Amt);
        INIT;
        "Entry No." := LastEntryNo + 1;
        "Posting Date" := WORKDATE;
        "Customer No." := CustNo;
        "Document No." := COPYSTR(CREATEGUID,1,20);
        Open := TRUE;
        INSERT;
        CALCFIELDS("Remaining Amount");
      END;
    END;

    LOCAL PROCEDURE InsertDetailedCustLedgerEntry@4(CustLedgerEntryNo@1002 : Integer;Amt@1003 : Decimal);
    VAR
      DetailedCustLedgEntry@1000 : Record 379;
      LastEntryNo@1001 : Integer;
    BEGIN
      WITH DetailedCustLedgEntry DO BEGIN
        FINDLAST;
        LastEntryNo := "Entry No.";
        INIT;
        "Entry No." := LastEntryNo + 1;
        "Cust. Ledger Entry No." := CustLedgerEntryNo;
        Amount := Amt;
        "Amount (LCY)" := Amt;
        INSERT;
      END;
    END;

    LOCAL PROCEDURE CreateCustomer@9(VAR Cust@1001 : Record 18);
    BEGIN
      WITH Cust DO BEGIN
        INIT;
        "No." := LibraryUtility.GenerateRandomCode(FIELDNO("No."),DATABASE::Customer);
        Name := COPYSTR(CREATEGUID,1,50);
        "Payment Terms Code" := CreatePaymentTerms;
        "Payment Method Code" := CreatePaymentMethod;
        City := LibraryUtility.GenerateGUID;
        Address := LibraryUtility.GenerateGUID;
        INSERT;
      END;
    END;

    LOCAL PROCEDURE CreatePaymentTerms@19() : Code[10];
    VAR
      PaymentTerms@1000 : Record 3;
    BEGIN
      WITH PaymentTerms DO BEGIN
        INIT;
        Code := LibraryUtility.GenerateRandomCode(FIELDNO(Code),DATABASE::"Payment Terms");
        INSERT;
        EXIT(Code);
      END;
    END;

    LOCAL PROCEDURE CreatePaymentMethod@1() : Code[10];
    VAR
      PaymentMethod@1000 : Record 289;
    BEGIN
      WITH PaymentMethod DO BEGIN
        INIT;
        Code := LibraryUtility.GenerateRandomCode(FIELDNO(Code),DATABASE::"Payment Method");
        INSERT;
        EXIT(Code);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CloseExistingEntries@1063();
    VAR
      CustLedgEntry@1060 : Record 21;
      VendLedgEntry@1061 : Record 25;
    BEGIN
      CustLedgEntry.SETRANGE(Open,TRUE);
      CustLedgEntry.MODIFYALL(Open,FALSE);
      VendLedgEntry.SETRANGE(Open,TRUE);
      VendLedgEntry.MODIFYALL(Open,FALSE);
    END;

    LOCAL PROCEDURE VerifyAccountNameField@20(Customer@1000 : Record 18;PaymentReconciliationJournal@1001 : TestPage 1290);
    VAR
      CustomerCard@1002 : TestPage 21;
    BEGIN
      Assert.AreEqual(Customer.Name,PaymentReconciliationJournal.AccountName.VALUE,'Unexpected Account Name shown');
      CustomerCard.TRAP;
      PaymentReconciliationJournal.AccountName.DRILLDOWN;
      Assert.AreEqual(Customer."No.",CustomerCard."No.".VALUE,'Unexpected customer shown after drilldown on Account Name');
      CustomerCard.CLOSE;
    END;

    LOCAL PROCEDURE VerifyAppliedPaymentEntryCount@63(BankAccRecon@1000 : Record 273;ExpectedMatchedLineNo@1001 : Integer;ExpectedMatchedEntryNo@1002 : Integer;ExpectedMatchedAccType@1003 : Option;ExpectedMatchedAccNo@1004 : Code[50];ExpectedAppliedAmount@1007 : Decimal;ExpectedCount@1005 : Integer);
    VAR
      AppliedPmtEntry@1006 : Record 1294;
    BEGIN
      WITH AppliedPmtEntry DO BEGIN
        SETRANGE("Statement No.",BankAccRecon."Statement No.");
        SETRANGE("Statement Line No.",ExpectedMatchedLineNo);
        SETRANGE("Statement Type","Statement Type"::"Payment Application");
        SETRANGE("Bank Account No.",BankAccRecon."Bank Account No.");
        SETRANGE("Account Type",ExpectedMatchedAccType);
        SETRANGE("Account No.",ExpectedMatchedAccNo);
        SETRANGE("Applies-to Entry No.",ExpectedMatchedEntryNo);
        IF ExpectedAppliedAmount <> 0 THEN
          SETRANGE("Applied Amount",ExpectedAppliedAmount);
        Assert.AreEqual(ExpectedCount,COUNT,'Unexpected applied payment entry count.');
      END;
    END;

    LOCAL PROCEDURE VerifyAppliedPaymentEntry@66(BankAccRecon@1000 : Record 273;BankAccReconLineNo@1001 : Integer;ExpectedMatchedEntryNo@1002 : Integer;ExpectedMatchedAccType@1003 : Option;ExpectedMatchedAccNo@1004 : Code[50];ExpectedAppliedAmount@1005 : Decimal);
    BEGIN
      VerifyAppliedPaymentEntryCount(
        BankAccRecon,BankAccReconLineNo,
        ExpectedMatchedEntryNo,ExpectedMatchedAccType,ExpectedMatchedAccNo,ExpectedAppliedAmount,1);
    END;

    LOCAL PROCEDURE VerifyNoAppliedPaymentEntry@68(BankAccRecon@1000 : Record 273;BankAccReconLineNo@1001 : Integer;ExpectedMatchedEntryNo@1002 : Integer;ExpectedMatchedAccType@1003 : Option;ExpectedMatchedAccNo@1004 : Code[50];ExpectedMatchedAmount@1005 : Decimal);
    BEGIN
      VerifyAppliedPaymentEntryCount(
        BankAccRecon,BankAccReconLineNo,
        ExpectedMatchedEntryNo,ExpectedMatchedAccType,ExpectedMatchedAccNo,ExpectedMatchedAmount,0);
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@17(Msg@1000 : Text[1024]);
    BEGIN
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandlerYes@6(Question@1001 : Text;VAR Reply@1000 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [ModalPageHandler]
    PROCEDURE SelectFirstRowPaymentApplicationHandler@11(VAR PaymentApplication@1000 : TestPage 1292);
    VAR
      CustomerLedgerEntryNo@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(CustomerLedgerEntryNo);
      PaymentApplication.FINDFIRSTFIELD("Applies-to Entry No.",CustomerLedgerEntryNo);
      LibraryVariableStorage.Enqueue(PaymentApplication.TotalAppliedAmount.ASDECIMAL);
      LibraryVariableStorage.Enqueue(PaymentApplication.TotalRemainingAmount.ASDECIMAL);
    END;

    [ModalPageHandler]
    PROCEDURE RejectApplicationPaymentApplicationHandler@22(VAR PaymentApplication@1001 : TestPage 1292);
    VAR
      CustomerLedgerEntryNo@1000 : Variant;
      Amount@1003 : Variant;
      ClosePageVariant@1004 : Variant;
      RejectVariant@1007 : Variant;
      MatchConfidenceBeforeRejecting@1002 : Variant;
      Reject@1006 : Boolean;
      ClosePage@1005 : Boolean;
    BEGIN
      LibraryVariableStorage.Dequeue(ClosePageVariant);
      ClosePage := ClosePageVariant;
      IF ClosePage THEN BEGIN
        LibraryVariableStorage.Dequeue(CustomerLedgerEntryNo);
        EXIT;
      END;

      LibraryVariableStorage.Dequeue(Amount);
      LibraryVariableStorage.Dequeue(RejectVariant);
      Reject := RejectVariant;
      LibraryVariableStorage.Dequeue(CustomerLedgerEntryNo);

      PaymentApplication.FINDFIRSTFIELD("Applies-to Entry No.",CustomerLedgerEntryNo);

      IF Reject THEN BEGIN
        MatchConfidenceBeforeRejecting := PaymentApplication."Payment-to-Entry Match".MatchConfidence.VALUE;
        PaymentApplication.Reject.INVOKE;
        Assert.AreEqual(
          MatchConfidenceBeforeRejecting,
          PaymentApplication."Payment-to-Entry Match".MatchConfidence.VALUE,
          'Unexpected match confidence after rejecting the application');
      END;

      Assert.IsFalse(PaymentApplication.Applied.ASBOOLEAN,'Applied not set to false when rejecting application.');
      Assert.AreEqual(PaymentApplication.AppliedAmount.ASDECIMAL,0,'Amount not un-applied.');
      Assert.AreEqual(PaymentApplication.RemainingAmountAfterPosting.ASDECIMAL,Amount,'Amount left to apply is incorrect.');
    END;

    [ModalPageHandler]
    PROCEDURE AcceptApplicationPaymentApplicationHandler@31(VAR PaymentApplication@1001 : TestPage 1292);
    VAR
      CustomerLedgerEntryNo@1000 : Variant;
      ClosePageVariant@1004 : Variant;
      ClosePage@1005 : Boolean;
    BEGIN
      LibraryVariableStorage.Dequeue(ClosePageVariant);
      LibraryVariableStorage.Dequeue(CustomerLedgerEntryNo);

      ClosePage := ClosePageVariant;
      IF ClosePage THEN
        EXIT;

      PaymentApplication.Accept.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE SetAppliedPaymentApplicationHandler@46(VAR PaymentApplication@1001 : TestPage 1292);
    VAR
      CustomerLedgerEntryNo@1000 : Variant;
      Amount@1003 : Variant;
      MatchConfidenceBeforeChange@1002 : Variant;
      AppliedVariant@1008 : Variant;
      Applied@1009 : Boolean;
      ExpectedAppliedAmount@1010 : Decimal;
      ExpectedRemainingAmount@1011 : Decimal;
    BEGIN
      LibraryVariableStorage.Dequeue(Amount);
      LibraryVariableStorage.Dequeue(AppliedVariant);
      LibraryVariableStorage.Dequeue(CustomerLedgerEntryNo);
      Applied := AppliedVariant;

      PaymentApplication.FINDFIRSTFIELD("Applies-to Entry No.",CustomerLedgerEntryNo);

      Assert.AreNotEqual(Applied,PaymentApplication.Applied.VALUE,'Value is already set');
      MatchConfidenceBeforeChange := PaymentApplication."Payment-to-Entry Match".MatchConfidence.VALUE;

      PaymentApplication.Applied.SETVALUE(Applied);

      ExpectedAppliedAmount := Amount;
      ExpectedRemainingAmount := Amount;

      IF Applied THEN
        ExpectedRemainingAmount := 0
      ELSE
        ExpectedAppliedAmount := 0;

      Assert.AreEqual(PaymentApplication.AppliedAmount.ASDECIMAL,ExpectedAppliedAmount,'Amount not un-applied.');
      Assert.AreEqual(
        PaymentApplication.RemainingAmountAfterPosting.ASDECIMAL,ExpectedRemainingAmount,'Amount left to apply is incorrect.');
      Assert.AreEqual(
        MatchConfidenceBeforeChange,
        PaymentApplication."Payment-to-Entry Match".MatchConfidence.VALUE,
        'Match Confidence should not be changed');
    END;

    [ModalPageHandler]
    PROCEDURE ChangeAppliedAmountPaymentApplicationHandler@61(VAR PaymentApplication@1001 : TestPage 1292);
    VAR
      CustomerLedgerEntryNo@1000 : Variant;
      AmountVariant@1003 : Variant;
      NewAmountVariant@1008 : Variant;
      MatchConfidenceBeforeUnapplying@1002 : Variant;
      Amount@1010 : Decimal;
      NewAmount@1009 : Decimal;
    BEGIN
      LibraryVariableStorage.Dequeue(AmountVariant);
      LibraryVariableStorage.Dequeue(NewAmountVariant);
      LibraryVariableStorage.Dequeue(CustomerLedgerEntryNo);

      NewAmount := NewAmountVariant;
      Amount := AmountVariant;

      PaymentApplication.FINDFIRSTFIELD("Applies-to Entry No.",CustomerLedgerEntryNo);
      MatchConfidenceBeforeUnapplying := PaymentApplication."Payment-to-Entry Match".MatchConfidence.VALUE;
      PaymentApplication.AppliedAmount.SETVALUE(NewAmount);

      Assert.AreEqual(NewAmount <> 0,PaymentApplication.Applied.ASBOOLEAN,'Applied is not set correctly.');
      Assert.AreEqual(NewAmount,PaymentApplication.AppliedAmount.ASDECIMAL,'Applied Amount is not set correctly.');
      Assert.AreEqual(Amount - NewAmount,PaymentApplication.RemainingAmountAfterPosting.ASDECIMAL,'Remaining Amount is incorrect.');
      Assert.AreEqual(
        MatchConfidenceBeforeUnapplying,
        PaymentApplication."Payment-to-Entry Match".MatchConfidence.VALUE,
        'Unexpected match confidence after rejecting the application');
    END;

    [ModalPageHandler]
    PROCEDURE WrongApplicationAmountPaymentApplicationHandler@45(VAR PaymentApplication@1001 : TestPage 1292);
    VAR
      CustomerLedgerEntryNo@1000 : Variant;
      NewAmountVariant@1008 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(NewAmountVariant);
      LibraryVariableStorage.Dequeue(CustomerLedgerEntryNo);

      PaymentApplication.FINDFIRSTFIELD("Applies-to Entry No.",CustomerLedgerEntryNo);
      ASSERTERROR PaymentApplication.AppliedAmount.SETVALUE(NewAmountVariant);
    END;

    [ModalPageHandler]
    PROCEDURE ApplyToMultipleEntriesPaymentApplicationHandler@74(VAR PaymentApplication@1001 : TestPage 1292);
    VAR
      CustomerLedgerEntryNo@1000 : Variant;
      AmountVariant@1003 : Variant;
      NewAmountVariant@1008 : Variant;
      MatchConfidenceBeforeApplying@1002 : Variant;
      CustomerLedgerEntryNo2@1011 : Variant;
      Amount@1010 : Decimal;
      NewAmount@1009 : Decimal;
    BEGIN
      LibraryVariableStorage.Dequeue(AmountVariant);
      LibraryVariableStorage.Dequeue(NewAmountVariant);
      Amount := AmountVariant;
      NewAmount := NewAmountVariant;
      LibraryVariableStorage.Dequeue(CustomerLedgerEntryNo2);
      LibraryVariableStorage.Dequeue(CustomerLedgerEntryNo);

      PaymentApplication.FINDFIRSTFIELD("Applies-to Entry No.",CustomerLedgerEntryNo2);
      MatchConfidenceBeforeApplying := PaymentApplication."Payment-to-Entry Match".MatchConfidence.VALUE;

      PaymentApplication.AppliedAmount.SETVALUE(NewAmountVariant);

      Assert.AreEqual(NewAmount <> 0,PaymentApplication.Applied.ASBOOLEAN,'Applied is not set correctly.');
      Assert.AreEqual(NewAmount,PaymentApplication.AppliedAmount.ASDECIMAL,'Applied Amount is not set correctly.');
      Assert.AreEqual(
        MatchConfidenceBeforeApplying,
        PaymentApplication."Payment-to-Entry Match".MatchConfidence.VALUE,
        'Unexpected match confidence after rejecting the application');

      Assert.AreEqual(PaymentApplication.TotalAppliedAmount.ASDECIMAL,Amount,'Total applied amount should match the original amount');
      Assert.AreEqual(PaymentApplication.TotalRemainingAmount.ASDECIMAL,0,'Total remaining amount should be zero');
    END;

    [ModalPageHandler]
    PROCEDURE ApplyToDifferentEntryPaymentApplicationHandler@75(VAR PaymentApplication@1001 : TestPage 1292);
    VAR
      CustomerLedgerEntryNo@1000 : Variant;
      StmtAmtVariant@1003 : Variant;
      StmtAmt@1010 : Decimal;
      ExpectAmt@1011 : Decimal;
    BEGIN
      LibraryVariableStorage.Dequeue(CustomerLedgerEntryNo);
      LibraryVariableStorage.Dequeue(StmtAmtVariant);
      StmtAmt := StmtAmtVariant;

      PaymentApplication.Applied.SETVALUE(FALSE);

      PaymentApplication.FINDFIRSTFIELD("Applies-to Entry No.",CustomerLedgerEntryNo);

      IF ABS(StmtAmt) > ABS(PaymentApplication.RemainingAmountAfterPosting.ASDECIMAL) THEN
        ExpectAmt := PaymentApplication.RemainingAmountAfterPosting.ASDECIMAL
      ELSE
        ExpectAmt := StmtAmt;

      PaymentApplication.Applied.SETVALUE(TRUE);

      Assert.AreEqual(ExpectAmt,PaymentApplication.TotalAppliedAmount.ASDECIMAL,'Amount incorrectly applied.');
      Assert.AreEqual(StmtAmt - ExpectAmt,PaymentApplication.TotalRemainingAmount.ASDECIMAL,'Amount left to apply is incorrect.');

      LibraryVariableStorage.Enqueue(ExpectAmt);
    END;

    BEGIN
    {
      // [FEATURE] [Bank Payment Application] [Applied Payment Entry]
    }
    END.
  }
}

