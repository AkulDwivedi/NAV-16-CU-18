OBJECT Codeunit 136137 Service Item Availability
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            IsInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      Assert@1003 : Codeunit 130000;
      LibraryJob@1018 : Codeunit 131920;
      LibraryService@1002 : Codeunit 131902;
      LibraryInventory@1014 : Codeunit 132201;
      LibraryWarehouse@1012 : Codeunit 132204;
      LibraryPurchase@1011 : Codeunit 130512;
      LibraryAssembly@1008 : Codeunit 132207;
      LibrarySales@1019 : Codeunit 130509;
      LibraryPatterns@1021 : Codeunit 132212;
      LibraryRandom@1004 : Codeunit 130440;
      LibraryVariableStorage@1013 : Codeunit 131004;
      ServiceLines@1010 : TestPage 5905;
      SupplyQuantity@1007 : Integer;
      DemandQuantity@1006 : Integer;
      IsInitialized@1005 : Boolean;
      DescriptionText@1016 : TextConst 'ENU=NTF_TEST_NTF_TEST';
      NoDataForExecutionError@1015 : TextConst 'ENU=No service item has a non-blocked customer and non-blocked item. Execution stops.';
      ItemNoNotFound@1000 : TextConst 'ENU=ItemNo not found.';
      RangeErrorMessage@1001 : TextConst 'ENU=RangeMin should be always greater than RangeMax.';
      QtyOnAsmComponentErr@1009 : TextConst 'ENU=Qty. on Asm. Component is not correct.';
      PeriodStartErrorMsg@1017 : TextConst 'ENU=Period Start date does not match';
      SuggestedProjectedInventoryErr@1022 : TextConst 'ENU=Wrong Suggested Projected Inventory Value';

    [Normal]
    LOCAL PROCEDURE Initialize@21();
    VAR
      LibraryERMCountryData@1000 : Codeunit 131305;
    BEGIN
      LibraryVariableStorage.Clear;
      // Clear the needed globals
      ClearGlobals;

      // Lazy Setup.
      IF IsInitialized THEN
        EXIT;

      LibraryService.SetupServiceMgtNoSeries;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.CreateVATData;
      IsInitialized := TRUE;
      COMMIT;
    END;

    [Test]
    [HandlerFunctions(HandleCheckAvailabiltyYes)]
    PROCEDURE ChangeLocationRefresh@1();
    VAR
      Item@1002 : Record 27;
      ItemCard@1007 : TestPage 30;
      ItemAvailabilityByLocation@1004 : TestPage 492;
      FoundFirstLocation@1005 : Boolean;
      FoundSecondLocation@1001 : Boolean;
      ServiceOrderNo@1006 : Code[20];
      SecondLocationName@1003 : Code[10];
      FirstLocationName@1000 : Code[10];
    BEGIN
      // Test case: If supply and demand are calculated and the order is afterwards modified without closing the item availability
      // overview, the overview of availability should be updated when recalculating.

      // Initialize all variables
      Initialize;
      SupplyQuantity := RANDOMRANGE(2,10);
      DemandQuantity := SupplyQuantity - 1;
      CreateItem(Item);
      FirstLocationName := CreateLocation;
      SecondLocationName := CreateLocation;

      // SETUP: Create supply and demand
      CreatePurchaseSupplyAtLocation(Item."No.",SupplyQuantity,FirstLocationName);
      ServiceOrderNo := CreateServiceDemandAtLocation(Item."No.",DemandQuantity,FirstLocationName);
      EditServiceLinesLocation(ServiceOrderNo,SecondLocationName);

      // EXECUTE: Open Item Availability by Location
      ItemCard.OPENVIEW;
      MoveItemCardtoItemNo(ItemCard,Item);
      ItemAvailabilityByLocation.TRAP;
      ItemCard."Page Item Availability by Location".INVOKE;

      // VERIFY: The locations have the right supply and demand numbers
      FoundFirstLocation := FALSE;
      FoundSecondLocation := FALSE;
      REPEAT
        IF ItemAvailabilityByLocation.ItemAvailLocLines.Code.VALUE = FirstLocationName THEN BEGIN
          AssertLocationDemandQuantities(0,SupplyQuantity,SupplyQuantity,ItemAvailabilityByLocation);
          FoundFirstLocation := TRUE;
        END;
        IF ItemAvailabilityByLocation.ItemAvailLocLines.Code.VALUE = SecondLocationName THEN BEGIN
          AssertLocationDemandQuantities(DemandQuantity,0,-DemandQuantity,ItemAvailabilityByLocation);
          FoundSecondLocation := TRUE;
        END;
      UNTIL NOT ItemAvailabilityByLocation.ItemAvailLocLines.NEXT;

      Assert.AreEqual(TRUE,FoundSecondLocation,STRSUBSTNO('Verify that location %1 is found in the grid.',SecondLocationName));
      Assert.AreEqual(TRUE,FoundFirstLocation,STRSUBSTNO('Verify that location %1 is found in the grid.',FirstLocationName));
    END;

    [Test]
    PROCEDURE AvailByLocBasicSupplyDemand@12();
    VAR
      Item@1003 : Record 27;
      ItemAvailabilityByLocation@1004 : TestPage 492;
      ItemCard@1000 : TestPage 30;
      FirstLocationName@1001 : Code[10];
      FoundLocationCount@1002 : Integer;
    BEGIN
      // All initializations go here
      Initialize;
      SupplyQuantity := RANDOM(10);
      DemandQuantity := SupplyQuantity;
      CreateItem(Item);
      FirstLocationName := CreateLocation;

      // SETUP: Create supply and demand to the location
      CreatePurchaseSupplyAtLocation(Item."No.",SupplyQuantity,FirstLocationName);
      CreateJobDemand(Item."No.",SupplyQuantity,FirstLocationName);

      // EXECUTE: Open the item availability by location
      ItemCard.OPENVIEW;
      MoveItemCardtoItemNo(ItemCard,Item);

      ItemAvailabilityByLocation.TRAP;
      ItemCard."Page Item Availability by Location".INVOKE;

      // VERIFY: The demand is reflected in the Item availability by location overview:
      // VERIFY: There should be exactly one line with the correct values of:
      // VERIFY: 1) requirement, 2) receipt and 3) projected balance
      FoundLocationCount := 0;
      REPEAT
        IF ItemAvailabilityByLocation.ItemAvailLocLines.Code.VALUE = FirstLocationName THEN BEGIN
          AssertLocationDemandQuantities(DemandQuantity,SupplyQuantity,DemandQuantity - SupplyQuantity,
            ItemAvailabilityByLocation);
          FoundLocationCount := FoundLocationCount + 1;
        END;
      UNTIL NOT ItemAvailabilityByLocation.ItemAvailLocLines.NEXT;

      Assert.AreEqual(1,FoundLocationCount,'Number of lines with supply and demand for the test location');
    END;

    [Test]
    PROCEDURE DemandFromJobsAndService@13();
    VAR
      Item@1010 : Record 27;
      StockKeepingCard@1002 : TestPage 5700;
      ItemNo@1003 : Code[20];
      FirstLocationName@1009 : Code[10];
      FirstJobQuantity@1000 : Integer;
      SecondJobQuantity@1001 : Integer;
      FirstServiceQuantity@1011 : Integer;
      SecondServiceQuantity@1008 : Integer;
    BEGIN
      // Test Demand from Jobs and Service show up in Stockkeeping Unit Cards.
      // All initializations go here
      Initialize;

      CreateItem(Item);
      FirstLocationName := CreateLocation;
      FirstJobQuantity := -RANDOM(10);
      SecondJobQuantity := RANDOM(30);
      FirstServiceQuantity := RANDOM(40);
      SecondServiceQuantity := RANDOM(100);
      ItemNo := Item."No.";

      // SETUP: Create Job Demand for Item X, Quantity Q1 (Negative).
      // SETUP: Create Job Demand for Item X, Quantity Q2.
      // SETUP: Create Service Demand for Item X, Quantity Q3.
      // SETUP: Create Service Demand for Item X, Quantity Q4.
      // SETUP: Create new Stockkeeping Unit for Item X
      CreateJobDemand(Item."No.",FirstJobQuantity,FirstLocationName);
      CreateJobDemand(Item."No.",SecondJobQuantity,FirstLocationName);
      CreateServiceDemandAtLocation(Item."No.",FirstServiceQuantity,FirstLocationName);
      CreateServiceDemandAtLocation(Item."No.",SecondServiceQuantity,FirstLocationName);
      CreateStockkeepingUnit(ItemNo,FirstLocationName);

      // EXECUTE: Verify the demand is available on the sku page
      StockKeepingCard.OPENEDIT;
      StockKeepingCard.FILTER.SETFILTER("Item No.",ItemNo);
      StockKeepingCard.FIRST;

      // VERIFY: Quantity from Job and Service Demand on Stockkeeping Unit Card Q1+Q2 and Q3+Q4
      Assert.AreEqual(
        ItemNo,StockKeepingCard."Item No.".VALUE,'Itemno was found');
      Assert.AreEqual(
        FirstJobQuantity + SecondJobQuantity,StockKeepingCard."Qty. on Job Order".ASINTEGER,
        'Quantity on Demands from Jobs is not correct');
      Assert.AreEqual(
        FirstServiceQuantity + SecondServiceQuantity,StockKeepingCard."Qty. on Service Order".ASINTEGER,
        'Quantity on Demands from Service is not correct');

      // CLEANUP: Close the sku page
      StockKeepingCard.CLOSE;
    END;

    [Test]
    PROCEDURE AvailByPeriodBasicSupplyDemand@14();
    VAR
      Item@1002 : Record 27;
      ItemCard@1000 : TestPage 30;
      ItemAvailabilityByPeriod@1001 : TestPage 157;
    BEGIN
      // All initializations go here
      Initialize;
      SupplyQuantity := RANDOM(12) + 6;
      DemandQuantity := SupplyQuantity - 5;

      // SETUP: Create supply and demand on the workdate of the system.
      CreateItem(Item);
      CreatePurchaseSupply(Item."No.",SupplyQuantity);
      CreateServiceDemand(Item."No.",DemandQuantity);

      // EXECUTE: Open the Item Availability By Period page.
      ItemCard.OPENVIEW;
      MoveItemCardtoItemNo(ItemCard,Item);
      ItemAvailabilityByPeriod.TRAP;
      ItemCard."Page Item Availability by Periods".INVOKE;
      SetDemandByPeriodFilters(ItemAvailabilityByPeriod,Item."No.",WORKDATE);

      // VERIFY: The quantities in demand by period grid columns for the demand date
      // VERIFY: Gross Requirement, Scheduled Receipt and Projected Available Balance are correct.
      AssertDemandByPeriodQuantities(DemandQuantity,SupplyQuantity,SupplyQuantity - DemandQuantity,ItemAvailabilityByPeriod);
      ItemAvailabilityByPeriod.CLOSE;
    END;

    [Test]
    PROCEDURE AvailByPeriodChangeNeededDate@73();
    VAR
      Item@1002 : Record 27;
      ItemCard@1000 : TestPage 30;
      ItemAvailabilityByPeriod@1001 : TestPage 157;
      ServiceOrderNo@1003 : Code[20];
      NeededByDate@1004 : Date;
    BEGIN
      // All initializations go here
      Initialize;
      SupplyQuantity := RANDOMRANGE(2,12);
      DemandQuantity := RANDOM(SupplyQuantity - 1);

      // SETUP: Create supply and demand on the Workdate of the system.
      // SETUP: Modify the Needed By Date of the demand (service order).
      CreateItem(Item);
      CreatePurchaseSupply(Item."No.",SupplyQuantity);
      ServiceOrderNo := CreateServiceDemand(Item."No.",DemandQuantity);

      // EXECUTE: Open the Item Availability By Period page.
      NeededByDate := CALCDATE('<+1D>',WORKDATE);
      EditServiceLinesNeededDate(ServiceOrderNo,NeededByDate);

      ItemCard.OPENVIEW;
      MoveItemCardtoItemNo(ItemCard,Item);
      ItemAvailabilityByPeriod.TRAP;
      ItemCard."Page Item Availability by Periods".INVOKE;

      // VERIFY: The quantities in demand by period grid columns for demand date and work date
      // VERIFY: Gross Requirement, Scheduled Receipt and Projected Available Balance are correct.
      SetDemandByPeriodFilters(ItemAvailabilityByPeriod,Item."No.",WORKDATE);
      AssertDemandByPeriodQuantities(0,SupplyQuantity,SupplyQuantity,ItemAvailabilityByPeriod);
      SetDemandByPeriodFilters(ItemAvailabilityByPeriod,Item."No.",NeededByDate);
      AssertDemandByPeriodQuantities(DemandQuantity,0,SupplyQuantity - DemandQuantity,ItemAvailabilityByPeriod);
      ItemAvailabilityByPeriod.CLOSE;
    END;

    [Test]
    PROCEDURE AvailByVarianBasicSupplyDemand@93();
    VAR
      Item@1002 : Record 27;
      ItemCard@1000 : TestPage 30;
      ItemAvailabilityByVariant@1001 : TestPage 5414;
      DemandVariantCode@1003 : Code[10];
      FoundVariantCount@1004 : Integer;
    BEGIN
      // All initializations go here
      Initialize;
      SupplyQuantity := RANDOMRANGE(2,12);
      DemandQuantity := RANDOM(SupplyQuantity - 1);

      // SETUP: Create supply and demand on the workdate of the system.
      CreateItemWithVariants(Item);
      DemandVariantCode := GetVariant(Item."No.",1);
      CreatePurchaseSupplyVariant(Item."No.",SupplyQuantity,DemandVariantCode);
      CreateJobDemandVariant(Item."No.",DemandQuantity,DemandVariantCode);

      // EXECUTE: Open the Item Availability By Variant page.
      ItemCard.OPENVIEW;
      MoveItemCardtoItemNo(ItemCard,Item);
      ItemAvailabilityByVariant.TRAP;
      ItemCard."Page Item Availability by Variant".INVOKE;

      // VERIFY: The quantities in demand by Variant grid columns
      // VERIFY: Columns: Gross Requirement, Scheduled Receipt and Projected Available Balance are correct.
      FoundVariantCount := 0;
      REPEAT
        IF ItemAvailabilityByVariant.ItemAvailLocLines.Code.VALUE = DemandVariantCode THEN BEGIN
          AssertVariantDemandQuantities(DemandQuantity,SupplyQuantity,SupplyQuantity - DemandQuantity,ItemAvailabilityByVariant);
          FoundVariantCount := FoundVariantCount + 1;
        END;
      UNTIL NOT ItemAvailabilityByVariant.ItemAvailLocLines.NEXT;

      Assert.AreEqual(1,FoundVariantCount,'Number of lines with supply and demand for the Variant is 1.');
      ItemAvailabilityByVariant.CLOSE;
    END;

    [Test]
    PROCEDURE AvailByVariantChangeVariant@104();
    VAR
      Item@1002 : Record 27;
      ItemCard@1000 : TestPage 30;
      ItemAvailabilityByVariant@1001 : TestPage 5414;
      FirstVariantCode@1003 : Code[10];
      SecondVariantCode@1005 : Code[10];
      FoundFirstVariant@1004 : Boolean;
      FoundSecondVariant@1007 : Boolean;
    BEGIN
      // All initializations go here
      Initialize;
      SupplyQuantity := RANDOMRANGE(2,12);
      DemandQuantity := RANDOM(SupplyQuantity - 1);

      // SETUP: Create supply and demand on the workdate of the system.
      CreateItemWithVariants(Item);
      FirstVariantCode := GetVariant(Item."No.",1);
      SecondVariantCode := GetVariant(Item."No.",2);
      CreatePurchaseSupplyVariant(Item."No.",SupplyQuantity,FirstVariantCode);
      CreateServiceDemandVariant(Item."No.",DemandQuantity,SecondVariantCode);

      // EXECUTE: Open the Item Availability By Variant page.
      ItemCard.OPENVIEW;
      MoveItemCardtoItemNo(ItemCard,Item);
      ItemAvailabilityByVariant.TRAP;
      ItemCard."Page Item Availability by Variant".INVOKE;

      // VERIFY: The quantities in demand by Variant grid columns
      // VERIFY: Columns: Gross Requirement, Scheduled Receipt and Projected Available Balance are correct.
      FoundFirstVariant := FALSE;
      FoundSecondVariant := FALSE;
      REPEAT
        IF ItemAvailabilityByVariant.ItemAvailLocLines.Code.VALUE = FirstVariantCode THEN BEGIN
          AssertVariantDemandQuantities(0,SupplyQuantity,SupplyQuantity,ItemAvailabilityByVariant);
          FoundFirstVariant := TRUE;
        END;
        IF ItemAvailabilityByVariant.ItemAvailLocLines.Code.VALUE = SecondVariantCode THEN BEGIN
          AssertVariantDemandQuantities(DemandQuantity,0,-DemandQuantity,ItemAvailabilityByVariant);
          FoundSecondVariant := TRUE;
        END;
      UNTIL NOT ItemAvailabilityByVariant.ItemAvailLocLines.NEXT;

      Assert.AreEqual(TRUE,FoundFirstVariant,'Found first variant');
      Assert.AreEqual(TRUE,FoundSecondVariant,'Found second variant');
      ItemAvailabilityByVariant.CLOSE;
    END;

    [Test]
    PROCEDURE CheckQtyOnAsmComponentForStockKeepingUnit@2();
    VAR
      ParentItem@1004 : Record 27;
      Item@1000 : Record 27;
      Location@1001 : Record 14;
      AssemblyHeader@1002 : Record 900;
      AssemblyLine@1007 : Record 901;
      StockkeepingUnit@1005 : Record 5700;
      Quantity@1006 : Decimal;
      QuantityPer@1008 : Decimal;
      i@1003 : Integer;
    BEGIN
      // SETUP: Create a new location for 3 items.
      LibraryWarehouse.CreateLocation(Location);

      FOR i := 1 TO 3 DO BEGIN
        LibraryInventory.CreateItem(ParentItem);
        LibraryInventory.CreateItem(Item);

        // SETUP: Create Assembly Order.
        Quantity := LibraryRandom.RandDec(10,2);
        QuantityPer := LibraryRandom.RandDec(10,2);
        LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WORKDATE,ParentItem."No.",Location.Code,Quantity,'');
        LibraryAssembly.CreateAssemblyLine(AssemblyHeader,AssemblyLine,AssemblyLine.Type::Item,Item."No.",'',Quantity,QuantityPer,'');

        // EXECUTE: Create Stockkeeping Unit.
        CreateStockkeepingUnit(Item."No.",Location.Code);

        // VERIFY: Qty. on Asm. Component field is correct when location contains mutiple different items.
        StockkeepingUnit.SETRANGE("Item No.",Item."No.");
        StockkeepingUnit.FINDFIRST;
        StockkeepingUnit.CALCFIELDS("Qty. on Asm. Component");
        Assert.AreEqual(Quantity * QuantityPer,StockkeepingUnit."Qty. on Asm. Component",QtyOnAsmComponentErr);
      END;
    END;

    [Test]
    [HandlerFunctions(ItemAvailByEventHandler)]
    PROCEDURE AvailByEventChangeNeededDate@6();
    VAR
      Item@1002 : Record 27;
      ServiceOrderNo@1003 : Code[20];
      PostingDate@1007 : Date;
      PostingDate1@1004 : Date;
      NeededByDate@1005 : Date;
    BEGIN
      // All initializations go here
      Initialize;
      SupplyQuantity := RANDOMRANGE(2,12);
      DemandQuantity := RANDOM(SupplyQuantity - 1);
      PostingDate := CALCDATE('<-1D>',WORKDATE);
      PostingDate1 := CALCDATE('<-1M>',PostingDate);
      NeededByDate := CALCDATE('<+1Y>',PostingDate1);

      // SETUP: Create supply and demand with Purchase Order and Service Order.
      CreateItem(Item);
      CreatePurchaseSupply(Item."No.",SupplyQuantity);
      CreatePurchaseSupplyBasis(Item."No.",SupplyQuantity,'','',PostingDate);
      CreatePurchaseSupplyBasis(Item."No.",SupplyQuantity,'','',PostingDate1);
      ServiceOrderNo := CreateServiceDemand(Item."No.",DemandQuantity);
      EditServiceLinesNeededDate(ServiceOrderNo,NeededByDate);

      // Enqueue value for ItemAvailByEventHandler.
      LibraryVariableStorage.Enqueue(PostingDate1);
      LibraryVariableStorage.Enqueue(PostingDate);
      LibraryVariableStorage.Enqueue(WORKDATE);
      LibraryVariableStorage.Enqueue(NeededByDate);

      // EXECUTE: Open the Item Availability By Event page.
      // VERIFY: Verify Data is sorting correct by Date through handler.
      OpenItemAvailByEvent(Item);
    END;

    [Test]
    [HandlerFunctions(CheckBlanketItemAvailByEventHandler)]
    PROCEDURE AvailByEventBlanketSalesOrder@8();
    VAR
      Item@1000 : Record 27;
      Customer@1002 : Record 18;
      BlanketSalesHeader@1004 : ARRAY [2] OF Record 36;
      TotalQty@1001 : ARRAY [2] OF Decimal;
      QtyToShip@1005 : ARRAY [2] OF Decimal;
      ShipmentDate@1003 : ARRAY [2] OF Date;
    BEGIN
      // Verify Item Availability By Event in case of several Blanket Orders
      // with several lines and partial Sales Order from Blankets
      Initialize;
      UpdateSalesReceivablesSetup;
      CreateItem(Item);
      LibrarySales.CreateCustomer(Customer);
      ShipmentDate[1] := WORKDATE;
      ShipmentDate[2] := CALCDATE('<1M>',ShipmentDate[1]);

      CreateBlanketSalesOrderWith2Lines(BlanketSalesHeader[1],TotalQty[1],QtyToShip[1],Customer."No.",Item."No.",ShipmentDate);
      CreateBlanketSalesOrderWith2Lines(BlanketSalesHeader[2],TotalQty[2],QtyToShip[2],Customer."No.",Item."No.",ShipmentDate);

      LibraryVariableStorage.Enqueue(ShipmentDate[1]);
      LibraryVariableStorage.Enqueue(ShipmentDate[2]);
      LibraryVariableStorage.Enqueue(BlanketSalesHeader[1]."No.");
      LibraryVariableStorage.Enqueue(BlanketSalesHeader[2]."No.");
      LibraryVariableStorage.Enqueue(LibrarySales.BlanketSalesOrderMakeOrder(BlanketSalesHeader[1]));
      LibraryVariableStorage.Enqueue(LibrarySales.BlanketSalesOrderMakeOrder(BlanketSalesHeader[2]));
      LibraryVariableStorage.Enqueue(-TotalQty[1]);
      LibraryVariableStorage.Enqueue(-TotalQty[2]);
      LibraryVariableStorage.Enqueue(-QtyToShip[1]);
      LibraryVariableStorage.Enqueue(-QtyToShip[2]);

      // Verify Item Availability by Event through handler
      OpenItemAvailByEvent(Item);
    END;

    [Test]
    [HandlerFunctions(ItemAvailabilityByEventHandler)]
    PROCEDURE CheckReservedReceiptOnItemAvailabilityByEventPage@23();
    VAR
      Item@1000 : Record 27;
      Location@1001 : Record 14;
      Customer@1004 : Record 18;
      SalesHeader@1003 : Record 36;
      SalesLine@1005 : Record 37;
      Qty1@1002 : Decimal;
      Qty2@1007 : Decimal;
    BEGIN
      // [FEATURE] [Item Availability by Event] [Reservation]
      // [SCENARIO 364616] "Item Availability by Event" page should sum all reserved quantity from appropriate Item Ledger Entries when calculating "Reserved Receipt"
      Initialize;

      CreateItem(Item);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      LibrarySales.CreateCustomer(Customer);
      Qty1 := LibraryRandom.RandDec(10,2);
      Qty2 := LibraryRandom.RandDec(10,2);

      // [GIVEN] Two Item Ledger Entries for Item "I" on Location "L": "ILE1" and "ILE2"
      LibraryPatterns.POSTPositiveAdjustment(Item,Location.Code,'','',Qty1,WORKDATE,LibraryRandom.RandDec(100,2));
      LibraryPatterns.POSTPositiveAdjustment(Item,Location.Code,'','',Qty2,WORKDATE,LibraryRandom.RandDec(100,2));

      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,Customer."No.");

      // [GIVEN] Sales Order Line "S1" with Reserved Quantity = "X" from "ILE1"
      CreateSalesLineWithReservedQuantity(SalesHeader,SalesLine,Location.Code,Item."No.",Qty1);

      // [GIVEN] Sales Order Line "S2" with Reserved Quantity = "Y" from "ILE2"
      CreateSalesLineWithReservedQuantity(SalesHeader,SalesLine,Location.Code,Item."No.",Qty2);

      // [WHEN] Open "Item Availability by Event" Page
      // [THEN] "Reserved Receipt" = "X" + "Y"
      LibraryVariableStorage.Enqueue(Qty1 + Qty2);
      OpenItemAvailByEvent(Item);
    END;

    [Test]
    PROCEDURE CheckSuggestedProjectedInventory@20();
    VAR
      InventoryPageData@1000 : Record 5531;
      Dummy@1001 : Decimal;
      ExpectedSuggestedProjectedInventory@1002 : Decimal;
    BEGIN
      // [SCENARIO 361049] "Suggested Projected Inventory" consider forecast in "Item Availability By Event"
      Initialize;

      // [GIVEN] Inventory Data with "Action Message Qty." = "W", "Remaining Forecast" = "X", "Gross Requirement" - "Y" and "Scheduled Receipt" = "Z"
      CreateInventoryPageData(InventoryPageData);
      WITH InventoryPageData DO
        ExpectedSuggestedProjectedInventory :=
          "Action Message Qty." + "Remaining Forecast" + "Gross Requirement" + "Scheduled Receipt";

      // [WHEN] Update Inventory on Inventory Page Data
      Dummy := 0.0;
      InventoryPageData.UpdateInventorys(Dummy,Dummy,Dummy);

      // [THEN] Suggested Projected Inventory = W + X + Y + Z
      Assert.AreEqual(ExpectedSuggestedProjectedInventory,InventoryPageData."Suggested Projected Inventory",
        SuggestedProjectedInventoryErr);
    END;

    [Normal]
    LOCAL PROCEDURE ClearGlobals@22();
    BEGIN
      // Clear all global variables
      SupplyQuantity := 0;
      DemandQuantity := 0;
    END;

    LOCAL PROCEDURE UpdateSalesReceivablesSetup@15();
    VAR
      SalesReceivablesSetup@1000 : Record 311;
    BEGIN
      SalesReceivablesSetup.GET;
      SalesReceivablesSetup.VALIDATE("Stockout Warning",FALSE);
      SalesReceivablesSetup.MODIFY;
    END;

    [Normal]
    LOCAL PROCEDURE CreateItem@5(VAR Item@1000 : Record 27);
    BEGIN
      // Creates a new item. Wrapper for the library method.
      LibraryInventory.CreateItem(Item);
    END;

    [Normal]
    LOCAL PROCEDURE CreateItemWithVariants@35(VAR Item@1000 : Record 27);
    VAR
      ItemVariantA@1001 : Record 5401;
      ItemVariantB@1002 : Record 5401;
    BEGIN
      // Creates a new item with a variant.
      CreateItem(Item);
      LibraryInventory.CreateItemVariant(ItemVariantA,Item."No.");
      ItemVariantA.VALIDATE(Description,Item.Description);
      ItemVariantA.MODIFY;
      LibraryInventory.CreateItemVariant(ItemVariantB,Item."No.");
      ItemVariantB.VALIDATE(Description,Item.Description);
      ItemVariantB.MODIFY;
    END;

    [Normal]
    LOCAL PROCEDURE CreateLocation@4() : Code[10];
    VAR
      Location@1001 : Record 14;
    BEGIN
      // Creates a new Location. Wrapper for the library method.
      LibraryWarehouse.CreateLocation(Location);
      EXIT(Location.Code);
    END;

    LOCAL PROCEDURE CreatePurchaseSupplyBasis@36(ItemNo@1008 : Code[20];Quantity@1000 : Integer;LocationCode@1006 : Code[10];VariantCode@1003 : Code[10];ReceiptDate@1001 : Date) : Code[20];
    VAR
      PurchaseHeader@1004 : Record 38;
      PurchaseLine@1005 : Record 39;
    BEGIN
      // Creates a Purchase order for the given item.
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity);
      PurchaseLine.VALIDATE(Quantity,Quantity);
      PurchaseLine.VALIDATE("Location Code",LocationCode);
      PurchaseLine.VALIDATE("Variant Code",VariantCode);
      PurchaseLine.VALIDATE("Expected Receipt Date",ReceiptDate);
      PurchaseLine.MODIFY;
      EXIT(PurchaseHeader."No.");
    END;

    LOCAL PROCEDURE CreatePurchaseSupply@25(ItemNo@1003 : Code[20];ItemQuantity@1002 : Integer) : Code[20];
    BEGIN
      // Creates a Purchase order for the given item.
      EXIT(CreatePurchaseSupplyBasis(ItemNo,ItemQuantity,'','',WORKDATE));
    END;

    LOCAL PROCEDURE CreatePurchaseSupplyAtLocation@3(ItemNo@1003 : Code[20];ItemQuantity@1002 : Integer;LocationCode@1000 : Code[10]) : Code[20];
    BEGIN
      // Creates a Purchase order for the given item at the specified location.
      EXIT(CreatePurchaseSupplyBasis(ItemNo,ItemQuantity,LocationCode,'',WORKDATE));
    END;

    LOCAL PROCEDURE CreatePurchaseSupplyVariant@26(ItemNo@1004 : Code[20];Quantity@1000 : Integer;VariantCode@1001 : Code[10]) : Code[20];
    BEGIN
      // Creates a Purchase order for the given item After a source document date.
      EXIT(CreatePurchaseSupplyBasis(ItemNo,Quantity,'',VariantCode,WORKDATE));
    END;

    LOCAL PROCEDURE CreateSalesLineWithReservedQuantity@27(SalesHeader@1003 : Record 36;VAR SalesLine@1000 : Record 37;LocationCode@1004 : Code[10];ItemNo@1001 : Code[20];Qty@1002 : Decimal);
    BEGIN
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Qty);
      SalesLine.VALIDATE("Location Code",LocationCode);
      SalesLine.MODIFY;
      LibrarySales.AutoReserveSalesLine(SalesLine);
    END;

    LOCAL PROCEDURE CreateServiceDemandBasis@30(ItemNo@1001 : Code[20];ItemQty@1000 : Integer;LocationCode@1009 : Code[10];VariantCode@1010 : Code[10];NeededBy@1008 : Date) : Code[20];
    VAR
      ServiceItem@1007 : Record 5940;
      ServiceHeader@1004 : Record 5900;
      ServiceItemLine@1003 : Record 5901;
      ServiceLine@1002 : Record 5902;
    BEGIN
      FindServiceItem(ServiceItem);
      LibraryService.CreateServiceHeader(ServiceHeader,ServiceHeader."Document Type"::Order,ServiceItem."Customer No.");
      ServiceHeader.VALIDATE("Bill-to Name",DescriptionText);
      ServiceHeader.MODIFY;

      LibraryService.CreateServiceItemLine(ServiceItemLine,ServiceHeader,ServiceItem."No.");
      ServiceItemLine.VALIDATE("Line No.",10000);
      ServiceItemLine.MODIFY;

      LibraryService.CreateServiceLine(ServiceLine,ServiceHeader,ServiceLine.Type::Item,ItemNo);
      ServiceLine.SetHideReplacementDialog(TRUE);
      ServiceLine.VALIDATE(Quantity,ItemQty);
      ServiceLine.VALIDATE("Location Code",LocationCode);
      ServiceLine.VALIDATE("Variant Code",VariantCode);
      ServiceLine.VALIDATE("Needed by Date",NeededBy);
      ServiceLine.VALIDATE("Variant Code",VariantCode);
      ServiceLine.MODIFY;

      EXIT(ServiceHeader."No.");
    END;

    LOCAL PROCEDURE CreateServiceDemand@40(ItemNo@1003 : Code[20];Quantity@1000 : Integer) : Code[20];
    BEGIN
      EXIT(CreateServiceDemandBasis(ItemNo,Quantity,'','',WORKDATE));
    END;

    LOCAL PROCEDURE CreateServiceDemandAtLocation@29(ItemNo@1004 : Code[20];Quantity@1000 : Integer;LocationCode@1001 : Code[10]) : Code[20];
    BEGIN
      EXIT(CreateServiceDemandBasis(ItemNo,Quantity,LocationCode,'',WORKDATE));
    END;

    LOCAL PROCEDURE CreateServiceDemandVariant@71(ItemNo@1004 : Code[20];Quantity@1000 : Integer;VariantCode@1002 : Code[10]) : Code[20];
    BEGIN
      EXIT(CreateServiceDemandBasis(ItemNo,Quantity,'',VariantCode,WORKDATE));
    END;

    LOCAL PROCEDURE CreateStockkeepingUnit@41(ItemNo@1000 : Code[20];LocationCode@1001 : Code[10]);
    VAR
      StockkeepingUnit@1003 : Record 5700;
    BEGIN
      IF StockkeepingUnit.GET(LocationCode,ItemNo,'') THEN
        EXIT;

      StockkeepingUnit.VALIDATE("Item No.",ItemNo);
      StockkeepingUnit.VALIDATE("Location Code",LocationCode);
      StockkeepingUnit.INSERT(TRUE);
    END;

    LOCAL PROCEDURE CreateJobDemandAtBasis@10(ItemNo@1002 : Code[20];ItemQuantity@1001 : Integer;LocationCode@1003 : Code[10];VariantCode@1006 : Code[10]) : Code[20];
    VAR
      Job@1000 : Record 167;
      JobTaskLine@1004 : Record 1001;
      JobPlanningLine@1005 : Record 1003;
      DocNo@1007 : Code[20];
    BEGIN
      // Create Job
      LibraryJob.CreateJob(Job);
      Job.VALIDATE("Apply Usage Link",TRUE);
      Job.VALIDATE("Description 2",DescriptionText);
      Job.MODIFY;

      // Job Task Line:
      LibraryJob.CreateJobTask(Job,JobTaskLine);
      JobTaskLine.MODIFY;

      // Job Planning Line:
      LibraryJob.CreateJobPlanningLine(JobPlanningLine."Line Type"::Schedule,JobPlanningLine.Type::Item,JobTaskLine,JobPlanningLine);

      JobPlanningLine.VALIDATE("Usage Link",TRUE);
      DocNo := DELCHR(FORMAT(TODAY),'=','-/') + '_' + DELCHR(FORMAT(TIME),'=',':');
      JobPlanningLine.VALIDATE("Document No.",DocNo);
      JobPlanningLine.VALIDATE("No.",ItemNo);
      JobPlanningLine.VALIDATE(Quantity,ItemQuantity);
      JobPlanningLine.VALIDATE("Location Code",LocationCode);
      JobPlanningLine.VALIDATE("Variant Code",VariantCode);
      JobPlanningLine.MODIFY;

      EXIT(Job."No.");
    END;

    [Normal]
    LOCAL PROCEDURE CreateJobDemand@88(ItemNo@1003 : Code[20];ItemQuantity@1002 : Integer;LocationCode@1001 : Code[10]) : Code[20];
    BEGIN
      EXIT(CreateJobDemandAtBasis(ItemNo,ItemQuantity,LocationCode,''));
    END;

    [Normal]
    LOCAL PROCEDURE CreateJobDemandVariant@89(ItemNo@1003 : Code[20];ItemQuantity@1002 : Integer;VariantCode@1000 : Code[10]) : Code[20];
    BEGIN
      EXIT(CreateJobDemandAtBasis(ItemNo,ItemQuantity,'',VariantCode));
    END;

    LOCAL PROCEDURE CreateBlanketSalesOrderWith2Lines@16(VAR SalesHeader@1000 : Record 36;VAR TotalQty@1004 : Decimal;VAR QtyToShip@1006 : Decimal;CustNo@1001 : Code[20];ItemNo@1003 : Code[20];ShipmentDate@1005 : ARRAY [2] OF Date);
    VAR
      SalesLine@1002 : Record 37;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::"Blanket Order",CustNo);
      TotalQty := LibraryRandom.RandIntInRange(100,1000);
      QtyToShip := LibraryRandom.RandInt(TotalQty - 1);
      LibrarySales.CreateSalesLineWithShipmentDate(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,ShipmentDate[1],TotalQty);
      LibrarySales.CreateSalesLineWithShipmentDate(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,ShipmentDate[2],TotalQty);
      SalesLine.SETRANGE("Document Type",SalesLine."Document Type"::"Blanket Order");
      SalesLine.SETRANGE("Document No.",SalesHeader."No.");
      SalesLine.MODIFYALL("Qty. to Ship",QtyToShip);
    END;

    LOCAL PROCEDURE CreateInventoryPageData@34(VAR InventoryPageData@1000 : Record 5531);
    BEGIN
      WITH InventoryPageData DO BEGIN
        IF FINDLAST THEN ;

        "Line No." += 1;
        "Action Message Qty." := LibraryRandom.RandDec(100,2);
        "Remaining Forecast" := LibraryRandom.RandDec(100,2);
        "Gross Requirement" := LibraryRandom.RandDec(100,2);
        "Scheduled Receipt" := LibraryRandom.RandDec(100,2);
        INSERT;
      END;
    END;

    [Normal]
    LOCAL PROCEDURE EditServiceLinesLocation@58(ServiceOrderNo@1001 : Code[20];LocationB@1002 : Code[10]);
    VAR
      ServiceLinesToReturn@1000 : TestPage 5905;
    BEGIN
      OpenFirstServiceLines(ServiceLinesToReturn,ServiceOrderNo);
      ServiceLines := ServiceLinesToReturn;
      ServiceLinesToReturn."Location Code".VALUE(LocationB);
    END;

    [Normal]
    LOCAL PROCEDURE EditServiceLinesNeededDate@75(ServiceOrderNo@1001 : Code[20];NeededByDate@1002 : Date);
    VAR
      ServiceLinesToReturn@1000 : TestPage 5905;
    BEGIN
      OpenFirstServiceLines(ServiceLinesToReturn,ServiceOrderNo);
      ServiceLines := ServiceLinesToReturn;
      ServiceLinesToReturn."Needed by Date".VALUE(FORMAT(NeededByDate));
    END;

    LOCAL PROCEDURE FindServiceItem@132(VAR ServiceItem@1000 : Record 5940);
    VAR
      Item@1001 : Record 27;
      Customer@1002 : Record 18;
    BEGIN
      CLEAR(ServiceItem);
      IF ServiceItem.FINDFIRST THEN
        REPEAT
          Customer.GET(ServiceItem."Customer No.");
          Item.GET(ServiceItem."Item No.");
          IF (Customer.Blocked = Customer.Blocked::" ") AND NOT Item.Blocked THEN
            EXIT;
        UNTIL ServiceItem.NEXT = 0;
      ERROR(NoDataForExecutionError);
    END;

    LOCAL PROCEDURE GetVariant@43(ItemNo@1003 : Code[20];VarNo@1000 : Integer) : Code[10];
    VAR
      ItemVariant@1001 : Record 5401;
    BEGIN
      ItemVariant.SETRANGE("Item No.",ItemNo);
      ItemVariant.FIND('-');
      IF VarNo > 1 THEN
        ItemVariant.NEXT(VarNo - 1);
      EXIT(ItemVariant.Code);
    END;

    [Normal]
    LOCAL PROCEDURE MoveItemCardtoItemNo@135(VAR ItemCard@1000 : TestPage 30;Item@1001 : Record 27);
    BEGIN
      // Method is used to move item card to the desired item number.
      IF NOT ItemCard.GOTORECORD(Item) THEN
        ERROR(ItemNoNotFound);
    END;

    [Normal]
    LOCAL PROCEDURE OpenFirstServiceLines@134(ServiceLinesToReturn@1005 : TestPage 5905;ServiceOrderNo@1001 : Code[20]);
    VAR
      ServiceHeader@1004 : Record 5900;
      ServiceLineToSelect@1003 : Record 5902;
    BEGIN
      ServiceHeader.GET(ServiceHeader."Document Type"::Order,ServiceOrderNo);
      ServiceLinesToReturn.OPENEDIT;

      ServiceLineToSelect.SETRANGE("Document Type",ServiceLineToSelect."Document Type"::Order);
      ServiceLineToSelect.SETRANGE("Document No.",ServiceOrderNo);
      ServiceLineToSelect.FINDFIRST;

      ServiceLinesToReturn.FIRST;
      ServiceLinesToReturn.FILTER.SETFILTER("Document Type",'Order');
      ServiceLinesToReturn.FILTER.SETFILTER("Document No.",ServiceOrderNo);
      ServiceLinesToReturn.FILTER.SETFILTER("Line No.",FORMAT(ServiceLineToSelect."Line No."));
      ServiceLinesToReturn.FIRST;
    END;

    LOCAL PROCEDURE OpenItemAvailByEvent@11(Item@1001 : Record 27);
    VAR
      ItemCard@1000 : TestPage 30;
    BEGIN
      COMMIT;
      ItemCard.OPENVIEW;
      MoveItemCardtoItemNo(ItemCard,Item);
      ItemCard."<Action110>".INVOKE; // <Action110> refers to Item Availability By Event.
    END;

    [Normal]
    LOCAL PROCEDURE RANDOMRANGE@7(RangeMin@1000 : Integer;RangeMax@1001 : Integer) : Integer;
    VAR
      RandomNumber@1002 : Integer;
    BEGIN
      // Method returns a random value within a range
      IF RangeMax <= RangeMin THEN
        ERROR(RangeErrorMessage);
      RandomNumber := RangeMin + RANDOM(RangeMax - RangeMin + 1) - 1;
      EXIT(RandomNumber);
    END;

    [Normal]
    LOCAL PROCEDURE SetDemandByPeriodFilters@133(ItemAvailabilityByPeriod@1000 : TestPage 157;ItemNo@1001 : Code[20];FilterDate@1002 : Date);
    VAR
      StartDate@1003 : Date;
    BEGIN
      ItemAvailabilityByPeriod.FILTER.SETFILTER("No.",ItemNo);
      ItemAvailabilityByPeriod.ItemAvailLines.FILTER.SETFILTER("Period Start",FORMAT(FilterDate));
      ItemAvailabilityByPeriod.PeriodType.VALUE := 'Day';
      ItemAvailabilityByPeriod.ItemAvailLines.FIRST;
      EVALUATE(StartDate,ItemAvailabilityByPeriod.ItemAvailLines."Period Start".VALUE);
      Assert.AreEqual(FilterDate,StartDate,'SetFilter returned record with correct date');
    END;

    [Normal]
    LOCAL PROCEDURE AssertDemandByPeriodQuantities@131(Demand@1001 : Integer;Supply@1002 : Integer;Forecasted@1003 : Integer;VAR ItemAvailabilityByPeriod@1005 : TestPage 157);
    BEGIN
      Assert.AreEqual(
        Demand,ItemAvailabilityByPeriod.ItemAvailLines.GrossRequirement.ASINTEGER,'Column Gross Requirement Verified');
      Assert.AreEqual(
        Supply,ItemAvailabilityByPeriod.ItemAvailLines.ScheduledRcpt.ASINTEGER,'Column Scheduled Verified');
      Assert.AreEqual(
        Forecasted,ItemAvailabilityByPeriod.ItemAvailLines.ProjAvailableBalance.ASINTEGER,'Column Projected Available Balance');
    END;

    [Normal]
    LOCAL PROCEDURE AssertLocationDemandQuantities@130(Demand@1001 : Integer;Supply@1002 : Integer;Forecasted@1003 : Integer;VAR ItemAvailabilityByLocation@1005 : TestPage 492);
    BEGIN
      // Quantity assertions for the Item availability by location window
      Assert.AreEqual(
        Demand,ItemAvailabilityByLocation.ItemAvailLocLines.GrossRequirement.ASINTEGER,'Column Gross Requirement Verified');
      Assert.AreEqual(
        Supply,ItemAvailabilityByLocation.ItemAvailLocLines.ScheduledRcpt.ASINTEGER,'Column Scheduled Verified');
      Assert.AreEqual(
        Forecasted,ItemAvailabilityByLocation.ItemAvailLocLines.ProjAvailableBalance.ASINTEGER,'Column Projected Available Balance');
    END;

    [Normal]
    LOCAL PROCEDURE AssertVariantDemandQuantities@129(Demand@1001 : Integer;Supply@1002 : Integer;Forecasted@1003 : Integer;ItemAvailabilityByVariant@1005 : TestPage 5414);
    BEGIN
      // Quantity assertions for Item availability by variant window
      Assert.AreEqual(
        Demand,ItemAvailabilityByVariant.ItemAvailLocLines.GrossRequirement.ASINTEGER,'Column Gross Requirement Verified');
      Assert.AreEqual(
        Supply,ItemAvailabilityByVariant.ItemAvailLocLines.ScheduledRcpt.ASINTEGER,'Column Scheduled Verified');
      Assert.AreEqual(
        Forecasted,ItemAvailabilityByVariant.ItemAvailLocLines.ProjAvailableBalance.ASINTEGER,'Column Projected Available Balance');
    END;

    [ModalPageHandler]
    PROCEDURE HandleCheckAvailabiltyYes@128(VAR CheckAvailability@1000 : TestPage 342);
    BEGIN
      // Perform some basic validations on the page
      Assert.AreEqual(
        ServiceLines."No.".VALUE,CheckAvailability."No.".VALUE,'Verify No. matches');
      Assert.AreEqual(
        ServiceLines.Description.VALUE,CheckAvailability.Description.VALUE,'Verify Description matches');
      Assert.AreEqual(
        ServiceLines.Quantity.VALUE,CheckAvailability.CurrentQuantity.VALUE,'Verify Current Quantity matches');
      Assert.AreEqual(
        ServiceLines."Unit of Measure Code".VALUE,CheckAvailability.UnitOfMeasureCode.VALUE,
        'Verify Unit Of Measure Code matches');
      CheckAvailability.Yes.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemAvailByEventHandler@9(VAR ItemAvailabilityByEvent@1000 : TestPage 5530);
    VAR
      ExpectedPeriodStartDate@1002 : ARRAY [4] OF Variant;
      i@1001 : Integer;
    BEGIN
      FOR i := 1 TO 4 DO BEGIN
        LibraryVariableStorage.Dequeue(ExpectedPeriodStartDate[i]);

        // Verify the Data is sorting correctly by date.
        Assert.AreEqual(ExpectedPeriodStartDate[i],ItemAvailabilityByEvent."Period Start".ASDATE,PeriodStartErrorMsg);
        ItemAvailabilityByEvent.NEXT;
      END;
      ItemAvailabilityByEvent.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemAvailabilityByEventHandler@66(VAR ItemAvailabilityByEvent@1000 : TestPage 5530);
    VAR
      Qty@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(Qty);
      ItemAvailabilityByEvent."Reserved Receipt".ASSERTEQUALS(Qty);
    END;

    [ModalPageHandler]
    PROCEDURE CheckBlanketItemAvailByEventHandler@18(VAR ItemAvailabilityByEvent@1000 : TestPage 5530);
    VAR
      Value@1010 : Variant;
      PeriodStart@1001 : ARRAY [2] OF Variant;
      BlanketOrderDocNo@1003 : ARRAY [2] OF Variant;
      SalesOrderDocNo@1004 : ARRAY [2] OF Variant;
      TotalQty@1005 : ARRAY [2] OF Decimal;
      QtyToShip@1006 : ARRAY [2] OF Decimal;
      QtyToShipBoth@1007 : Decimal;
      QtyToShipTotal@1008 : Decimal;
    BEGIN
      LibraryVariableStorage.Dequeue(PeriodStart[1]);
      LibraryVariableStorage.Dequeue(PeriodStart[2]);
      LibraryVariableStorage.Dequeue(BlanketOrderDocNo[1]);
      LibraryVariableStorage.Dequeue(BlanketOrderDocNo[2]);
      LibraryVariableStorage.Dequeue(SalesOrderDocNo[1]);
      LibraryVariableStorage.Dequeue(SalesOrderDocNo[2]);
      LibraryVariableStorage.Dequeue(Value);
      EVALUATE(TotalQty[1],FORMAT(Value));
      LibraryVariableStorage.Dequeue(Value);
      EVALUATE(TotalQty[2],FORMAT(Value));
      LibraryVariableStorage.Dequeue(Value);
      EVALUATE(QtyToShip[1],FORMAT(Value));
      LibraryVariableStorage.Dequeue(Value);
      EVALUATE(QtyToShip[2],FORMAT(Value));

      QtyToShipBoth := QtyToShip[1] + QtyToShip[2];
      QtyToShipTotal := QtyToShipBoth + QtyToShipBoth;

      ItemAvailabilityByEvent.IncludeBlanketOrders.SETVALUE(TRUE);
      VerifyInvtPagePeriodData(
        ItemAvailabilityByEvent,PeriodStart[1],BlanketOrderDocNo,SalesOrderDocNo,
        QtyToShipBoth,QtyToShipBoth,TotalQty,QtyToShip,QtyToShip[1]);
      VerifyInvtPagePeriodData(
        ItemAvailabilityByEvent,PeriodStart[2],BlanketOrderDocNo,SalesOrderDocNo,
        QtyToShipBoth,QtyToShipTotal,TotalQty,QtyToShip,QtyToShipBoth + QtyToShip[1]);
      ItemAvailabilityByEvent.OK.INVOKE;
    END;

    LOCAL PROCEDURE VerifyInvtPagePeriodData@19(VAR ItemAvailabilityByEvent@1009 : TestPage 5530;PeriodStart@1002 : Variant;BlanketOrderDocNo@1006 : ARRAY [2] OF Variant;SalesOrderDocNo@1005 : ARRAY [2] OF Variant;GrossTotal@1000 : Decimal;ProjectTotal@1001 : Decimal;TotalQty@1004 : ARRAY [2] OF Decimal;QtyToShip@1007 : ARRAY [2] OF Decimal;Projected1@1008 : Decimal);
    VAR
      InventoryPageData@1003 : Record 5531;
    BEGIN
      ItemAvailabilityByEvent.EXPAND(TRUE);
      VerifyInvtPageDataAndStepNext(
        ItemAvailabilityByEvent,PeriodStart,0,'',GrossTotal,ProjectTotal,TotalQty[1] + TotalQty[2]);
      VerifyInvtPageDataAndStepNext(
        ItemAvailabilityByEvent,PeriodStart,InventoryPageData.Type::Sale,SalesOrderDocNo[1],QtyToShip[1],Projected1,0);
      VerifyInvtPageDataAndStepNext(
        ItemAvailabilityByEvent,PeriodStart,InventoryPageData.Type::Sale,SalesOrderDocNo[2],QtyToShip[2],ProjectTotal,0);
      VerifyInvtPageDataAndStepNext(
        ItemAvailabilityByEvent,PeriodStart,InventoryPageData.Type::"Blanket Sales Order",
        BlanketOrderDocNo[1],0,ProjectTotal,TotalQty[1]);
      VerifyInvtPageDataAndStepNext(
        ItemAvailabilityByEvent,PeriodStart,InventoryPageData.Type::"Blanket Sales Order",
        BlanketOrderDocNo[2],0,ProjectTotal,TotalQty[2]);
    END;

    LOCAL PROCEDURE VerifyInvtPageDataAndStepNext@17(VAR ItemAvailabilityByEvent@1000 : TestPage 5530;PeriodStart@1001 : Variant;Type@1002 : Variant;DocumentNo@1003 : Variant;Gross@1004 : Decimal;Projected@1006 : Decimal;Forecast@1005 : Decimal);
    BEGIN
      ItemAvailabilityByEvent."Period Start".ASSERTEQUALS(PeriodStart);
      ItemAvailabilityByEvent.Type.ASSERTEQUALS(Type);
      ItemAvailabilityByEvent."Document No.".ASSERTEQUALS(DocumentNo);
      ItemAvailabilityByEvent."Gross Requirement".ASSERTEQUALS(Gross);
      ItemAvailabilityByEvent."Projected Inventory".ASSERTEQUALS(Projected);
      ItemAvailabilityByEvent.Forecast.ASSERTEQUALS(Forecast);
      ItemAvailabilityByEvent.NEXT;
    END;

    BEGIN
    {
      // [FEATURE] [Item Availability] [Service]
      Tests Availability by location, demand and variant for jobs and services.

      Covered Test cases:
      --------------------------------------------------
      Test Function Name                    TFS ID
      --------------------------------------------------
      ChangeLocationRefresh                 178283
      AvailByLocBasicSupplyDemand           178282
      DemandFromJobsAndService              178301
      AvailByPeriodBasicSupplyDemand        178284
      AvailByPeriodChangeNeededDate         178285
      AvailByVarianBasicSupplyDemand        178286
      AvailByVariantChangeVariant           178287

      --------------------------------------------------
      Test Function Name                         TFS ID
      --------------------------------------------------
      CheckQtyOnAsmComponentForStockKeepingUnit  48093

      Covers Test cases: for WI - 341411
      --------------------------------------------------
      Test Function Name                         TFS ID
      --------------------------------------------------
      AvailByEventChangeNeededDate               341411
      AvailByEventBlanketSalesOrder              97205
    }
    END.
  }
}

