OBJECT Codeunit 137096 SCM Kitting - ATO
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      ItemJournalTemplate@1006 : Record 82;
      ItemJournalBatch@1001 : Record 233;
      LocationBlue@1008 : Record 14;
      GLSetup@1035 : Record 98;
      LibraryERM@1007 : Codeunit 131300;
      LibraryUtility@1004 : Codeunit 131000;
      LibraryCosting@1026 : Codeunit 132200;
      LibraryInventory@1003 : Codeunit 132201;
      LibraryPurchase@1025 : Codeunit 130512;
      LibrarySales@1020 : Codeunit 130509;
      LibraryManufacturing@1014 : Codeunit 132202;
      LibraryWarehouse@1013 : Codeunit 132204;
      LibraryAssembly@1005 : Codeunit 132207;
      LibraryPatterns@1024 : Codeunit 132212;
      LibrarySetupStorage@1055 : Codeunit 131009;
      LibraryVariableStorage@1028 : Codeunit 131004;
      LibraryResource@1054 : Codeunit 130511;
      Assert@1002 : Codeunit 130000;
      LibraryRandom@1012 : Codeunit 130440;
      GenProdPostingGr@1019 : Code[10];
      AsmInvtPostingGr@1018 : Code[10];
      CompInvtPostingGr@1017 : Code[10];
      isInitialized@1000 : Boolean;
      ERR_POST_AOT@1009 : TextConst 'ENU=Assemble to Order must be equal to ''No''';
      MSG_BEEN_POSTED@1011 : TextConst 'ENU=have now been posted.';
      MSG_UPDATE@1015 : TextConst 'ENU="Do you want to update the "';
      ERR_NOT_ENOUGH@1010 : TextConst 'ENU=on inventory.';
      DocTypeNotSupportedErr@1016 : TextConst 'ENU=Sales document type not supported in ATO relation.';
      SelectSNFromEntries@1029 : Boolean;
      WorkDate2@1021 : Date;
      CONFIRM_ROLLUP_COST@1022 : TextConst 'ENU=Do you want to roll up the cost from the assembly components?';
      ERR_SKU_NOT_CREATED@1023 : TextConst 'ENU=SKU not created.';
      WrongWhseQtyErr@1030 : TextConst 'ENU=Wrong total quantity in warehouse entries for document %1.';
      ItemMsg@1032 : TextConst 'ENU=Item';
      WrongTakeBinErr@1031 : TextConst 'ENU=Item is taken from wrong Bin.';
      AssemblyOrderCountErr@1034 : TextConst 'ENU=Additional Assembly Orders must not be created';
      ReservationConflictErr@1027 : TextConst 'ENU=The change leads to a date conflict with existing reservations';
      TestValidationErrorTok@1033 : TextConst 'ENU=TestValidation';
      WrongValueOnAsmOrderLineMsg@1037 : TextConst '@@@=%1: FieldCaption, %2:GetFilters;ENU=Wrong %1 on Assembly Order Line %2.';
      NoAssemblyInFilterMsg@1038 : TextConst '@@@=%1: NoOfLines, %2: TableCaption, %2: GetFilters;ENU="There are no %1 %2 within the filter %3. "';
      DiffEntryNoInReservEntriesMsg@1040 : TextConst 'ENU=Reservation Entries created for AO and SOL do not have same Entry No.';
      WrongDateOnAssemblyMsg@1039 : TextConst '@@@=%1: Field(Date), %2: TableCaption, %3: Field(DocumentNo);ENU=Wrong %1 in %2 %3.';
      OneAsmOrderCreateMsg@1041 : TextConst 'ENU=One Assembly Order should be created.';
      TwoAsmOrdersCreateMsg@1042 : TextConst 'ENU=Two Assembly Orders should be created.';
      NoAsmOrderCreateMsg@1043 : TextConst 'ENU=No new Assembly should be created.';
      NoReservEntryCreateMsg@1045 : TextConst 'ENU=No new reservation entries should be created.';
      NoHardLinkCreateMsg@1046 : TextConst 'ENU=No new hard link entries should be created.';
      OneAsmOrderDeleteMsg@1044 : TextConst 'ENU=One Assembly Order should be deleted.';
      NoQtyPostedMsg@1047 : TextConst 'ENU=No Quantity should have been posted from the ATO order.';
      AsmOrderReUsedMsg@1048 : TextConst 'ENU=Assembly Orders for first ATO item should have been reused for second ATO item.';
      OneAsmOrderPostedMsg@1049 : TextConst 'ENU=One Assembly Order should be posted.';
      BothAsmOrdersPostedMsg@1050 : TextConst 'ENU=Both Assembly Orders should be posted.';
      WrongUnitValueMsg@1051 : TextConst '@@@=%1: Field(Unit Cost) or Field(Unit Price);ENU=Wrong %1.';
      LowerQtysPropagatedMsg@1052 : TextConst 'ENU=Lower quantities are propagated to the lines.';
      GreaterQtysPropagatedMsg@1053 : TextConst 'ENU=Greater quantities are propagated to the lines.';
      NumberAsmOrderFromSalesHeaderMsg@1036 : TextConst 'ENU=Number of assembly orders when getting assembly orders from a sales header.';
      DifferentNumberAsmLinesInOrderAndQuoteErr@1056 : TextConst 'ENU=Number of assembly lines in Sales Order and Sales Quote are different.';

    LOCAL PROCEDURE Initialize@8();
    VAR
      LibraryERMCountryData@1001 : Codeunit 131305;
    BEGIN
      LibraryVariableStorage.Clear;
      LibrarySetupStorage.Restore;
      SelectSNFromEntries := FALSE;

      IF isInitialized THEN
        EXIT;

      GLSetup.GET;
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateSalesReceivablesSetup;
      LibraryERMCountryData.UpdatePurchasesPayablesSetup;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      GlobalSetup;

      LibrarySetupStorage.Save(DATABASE::"Sales & Receivables Setup");
      LibrarySetupStorage.Save(DATABASE::"Assembly Setup");

      isInitialized := TRUE;

      COMMIT;
    END;

    LOCAL PROCEDURE GlobalSetup@1();
    BEGIN
      SetupAssembly;
      SetupItemJournal;
      SetupManufacturingSetup;
      SetupSalesAndReceivablesSetup;
      SetupLocation(LocationBlue,FALSE);
      LibraryAssembly.SetupPostingToGL(GenProdPostingGr,AsmInvtPostingGr,CompInvtPostingGr,'');
    END;

    LOCAL PROCEDURE SetupAssembly@127();
    VAR
      PurchasesPayablesSetup@1006 : Record 312;
      SalesSetup@1005 : Record 311;
    BEGIN
      UpdateAssemblySetup('');

      SalesSetup.GET;
      SalesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Return Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Blanket Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Quote Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Customer Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Invoice Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Posted Invoice Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.VALIDATE("Posted Shipment Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesSetup.MODIFY(TRUE);

      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      PurchasesPayablesSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateAssemblySetup@360(DefaultLocationCode@1001 : Code[10]);
    VAR
      AssemblySetup@1000 : Record 905;
    BEGIN
      WITH AssemblySetup DO BEGIN
        GET;
        VALIDATE("Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
        VALIDATE("Posted Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
        VALIDATE("Assembly Quote Nos.",LibraryUtility.GetGlobalNoSeriesCode);
        VALIDATE("Blanket Assembly Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
        VALIDATE("Default Location for Orders",DefaultLocationCode);
        VALIDATE("Stockout Warning",TRUE);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE SetupItemJournal@138();
    BEGIN
      CLEAR(ItemJournalTemplate);
      ItemJournalTemplate.INIT;
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      ItemJournalTemplate.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      ItemJournalTemplate.MODIFY(TRUE);

      CLEAR(ItemJournalBatch);
      ItemJournalBatch.INIT;
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      ItemJournalBatch.VALIDATE("No. Series",LibraryUtility.GetGlobalNoSeriesCode);
      ItemJournalBatch.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE SetupBinLocationInAssemblySetup@255() : Code[10];
    VAR
      Location@1000 : Record 14;
    BEGIN
      SetupLocation(Location,FALSE);
      Location.VALIDATE("Bin Mandatory",TRUE);
      Location.MODIFY(TRUE);
      UpdateAssemblySetup(Location.Code);
      EXIT(Location.Code);
    END;

    LOCAL PROCEDURE SetupLocation@2(VAR Location@1000 : Record 14;UseAsInTransit@1001 : Boolean);
    VAR
      WarehouseEmployee@1004 : Record 7301;
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      IF UseAsInTransit THEN BEGIN
        Location.VALIDATE("Use As In-Transit",TRUE);
        Location.MODIFY(TRUE);
        EXIT;
      END;
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,Location.Code,FALSE);
    END;

    LOCAL PROCEDURE CreateItemWithCategoryAndProductCode@237(VAR Item@1000 : Record 27);
    VAR
      ProductGroup@1002 : Record 5723;
      ItemCategory@1001 : Record 5722;
    BEGIN
      LibraryInventory.CreateItemCategory(ItemCategory);
      LibraryInventory.CreateProductGroup(ProductGroup,ItemCategory.Code);
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Item Category Code",ItemCategory.Code);
      Item.VALIDATE("Product Group Code",ProductGroup.Code);
      Item.MODIFY;
    END;

    LOCAL PROCEDURE SetupSNTrackingAndDefaultBinContent@266(LocationCode@1002 : Code[10];Item@1003 : Record 27);
    VAR
      TempItem@1004 : TEMPORARY Record 27;
      Bin@1005 : Record 7354;
      BinContent@1000 : Record 7302;
    BEGIN
      TempItem := Item;
      TempItem.INSERT;
      CollectSetupBOMComponent(TempItem,Item."No.");

      LibraryWarehouse.CreateBin(Bin,LocationCode,'','','');
      TempItem.FINDSET;
      REPEAT
        LibraryWarehouse.CreateBinContent(BinContent,LocationCode,'',Bin.Code,TempItem."No.",'',TempItem."Base Unit of Measure");
        BinContent.VALIDATE(Default,TRUE);
        BinContent.MODIFY(TRUE);
      UNTIL TempItem.NEXT = 0;
    END;

    LOCAL PROCEDURE UpdateAutomaticCostPosting@238(VAR OldAutomaticCostPosting@1000 : Boolean;NewAutomaticCostPosting@1003 : Boolean);
    VAR
      InventorySetup@1001 : Record 313;
    BEGIN
      WITH InventorySetup DO BEGIN
        GET;
        OldAutomaticCostPosting := "Automatic Cost Posting";
        VALIDATE("Automatic Cost Posting",NewAutomaticCostPosting);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE ClearJournal@134(ItemJournalTemplate@1002 : Record 82;ItemJournalBatch@1001 : Record 233);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CLEAR(ItemJournalLine);
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalTemplate.Name);
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.DELETEALL;
    END;

    LOCAL PROCEDURE SetupManufacturingSetup@168();
    VAR
      ManufacturingSetup@1000 : Record 99000765;
    BEGIN
      CLEAR(ManufacturingSetup);
      ManufacturingSetup.GET;
      EVALUATE(ManufacturingSetup."Default Safety Lead Time",'<1D>');
      ManufacturingSetup.MODIFY(TRUE);

      WorkDate2 := CALCDATE(ManufacturingSetup."Default Safety Lead Time",WORKDATE); // to avoid Due Date Before Work Date message.
    END;

    LOCAL PROCEDURE SetupSalesAndReceivablesSetup@222();
    VAR
      SalesReceivablesSetup@1000 : Record 311;
    BEGIN
      SalesReceivablesSetup.GET;
      SalesReceivablesSetup.VALIDATE("Stockout Warning",FALSE);
      SalesReceivablesSetup.VALIDATE("Credit Warnings",SalesReceivablesSetup."Credit Warnings"::"No Warning");
      SalesReceivablesSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAssemblyList@20(ParentItem@1000 : Record 27;CompCostingMethod@1005 : Option;NoOfComponents@1001 : Integer;NoOfResources@1002 : Integer;NoOfTexts@1003 : Integer;QtyPer@1004 : Integer);
    VAR
      Item@1008 : Record 27;
      Resource@1009 : Record 156;
      BOMComponent@1006 : Record 90;
      VATPostingSetup@1010 : Record 325;
      CompCount@1007 : Integer;
    BEGIN
      // Add components - qty per is increasing same as no of components
      FOR CompCount := 1 TO NoOfComponents DO BEGIN
        CLEAR(Item);
        LibraryInventory.CreateItem(Item);
        Item.VALIDATE("Costing Method",CompCostingMethod);
        Item.MODIFY;
        AddComponentToAssemblyList(
          BOMComponent,BOMComponent.Type::Item,Item."No.",ParentItem."No.",'',
          BOMComponent."Resource Usage Type"::Direct,Item."Base Unit of Measure",QtyPer);
      END;

      // Add resources - qty per is increasing same as no of components
      FOR CompCount := 1 TO NoOfResources DO BEGIN
        LibraryAssembly.CreateResource(Resource,TRUE,GenProdPostingGr);
        LibraryERM.FindVATPostingSetup(VATPostingSetup,VATPostingSetup."VAT Calculation Type"::"Normal VAT");
        Resource.VALIDATE("VAT Prod. Posting Group",VATPostingSetup."VAT Prod. Posting Group");
        Resource.MODIFY;
        AddComponentToAssemblyList(
          BOMComponent,BOMComponent.Type::Resource,Resource."No.",ParentItem."No.",'',
          BOMComponent."Resource Usage Type"::Direct,Resource."Base Unit of Measure",QtyPer);
      END;

      // Add simple text
      FOR CompCount := 1 TO NoOfTexts DO
        AddComponentToAssemblyList(BOMComponent,BOMComponent.Type::" ",'',ParentItem."No.",'',
          BOMComponent."Resource Usage Type"::Direct,'',QtyPer);
    END;

    LOCAL PROCEDURE AddItemUOM@171(VAR Item@1000 : Record 27;QtyPerUOM@1001 : Integer;UOMCode@1003 : Code[10]);
    VAR
      ItemUnitOfMeasure@1002 : Record 5404;
    BEGIN
      LibraryInventory.CreateItemUnitOfMeasure(ItemUnitOfMeasure,Item."No.",UOMCode,QtyPerUOM);
    END;

    LOCAL PROCEDURE AddComponentToAssemblyList@12(VAR BOMComponent@1008 : Record 90;ComponentType@1000 : Option;ComponentNo@1001 : Code[20];ParentItemNo@1005 : Code[20];VariantCode@1007 : Code[10];ResourceUsage@1006 : Option;UOM@1003 : Code[10];QuantityPer@1002 : Decimal);
    BEGIN
      LibraryManufacturing.CreateBOMComponent(BOMComponent,ParentItemNo,ComponentType,ComponentNo,QuantityPer,UOM);
      IF ComponentType = BOMComponent.Type::Resource THEN
        BOMComponent.VALIDATE("Resource Usage Type",ResourceUsage);
      BOMComponent.VALIDATE("Variant Code",VariantCode);
      BOMComponent.VALIDATE("Quantity per",QuantityPer);
      BOMComponent.VALIDATE("Unit of Measure Code",UOM);
      IF ComponentNo = '' THEN
        BOMComponent.VALIDATE(Description,
          LibraryUtility.GenerateRandomCode(BOMComponent.FIELDNO(Description),DATABASE::"BOM Component"));
      BOMComponent.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAssemblyOrder@9(VAR AssemblyHeader@1001 : Record 900;ParentItem@1000 : Record 27;LocationCode@1002 : Code[10];VariantCode@1005 : Code[10];DueDate@1004 : Date;Quantity@1003 : Decimal);
    BEGIN
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,DueDate,ParentItem."No.",LocationCode,Quantity,VariantCode);
    END;

    LOCAL PROCEDURE CreateAssembledItem@10(VAR Item@1000 : Record 27;AssemblyPolicy@1001 : Option;NoOfComponents@1005 : Integer;NoOfResources@1004 : Integer;NoOfTexts@1003 : Integer;QtyPer@1002 : Integer;CostingMethod@1006 : Option);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::Assembly);
      Item.VALIDATE("Costing Method",CostingMethod);
      Item.VALIDATE("Assembly Policy",AssemblyPolicy);
      Item.MODIFY(TRUE);
      CreateAssemblyList(Item,CostingMethod,NoOfComponents,NoOfResources,NoOfTexts,QtyPer);
    END;

    LOCAL PROCEDURE CreateATOItemWithSNTracking@253(VAR AssembledItem@1000 : Record 27);
    BEGIN
      CreateAssembledItem(
        AssembledItem,AssembledItem."Assembly Policy"::"Assemble-to-Order",2,0,0,1,AssembledItem."Costing Method"::FIFO);
      AssembledItem.VALIDATE("Item Tracking Code",FindItemTrackingLikeSNALL);
      AssembledItem.VALIDATE("Serial Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      AssembledItem.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAssembledItemWithAssemblyPolicy@260(VAR AssembledItem@1000 : Record 27;AssemblyPolicy@1001 : Option);
    BEGIN
      LibraryAssembly.SetupAssemblyItem(
        AssembledItem,AssembledItem."Costing Method"::Standard,AssembledItem."Costing Method"::Standard,
        AssembledItem."Replenishment System"::Assembly,'',FALSE,LibraryRandom.RandInt(5),
        LibraryRandom.RandInt(5),LibraryRandom.RandInt(5),LibraryRandom.RandInt(5));
      AssembledItem.VALIDATE("Assembly Policy",AssemblyPolicy);
      AssembledItem.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE AddSalesOrderLine@56(VAR SalesHeader@1000 : Record 36;VAR SalesLine@1001 : Record 37;ItemNo@1004 : Code[20];LocationCode@1005 : Code[10];VariantCode@1006 : Code[10];SalesQty@1003 : Integer;ShipmentDate@1002 : Date);
    BEGIN
      LibrarySales.CreateSalesLineWithShipmentDate(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,ShipmentDate,SalesQty);
      IF LocationCode <> '' THEN
        SalesLine.VALIDATE("Location Code",LocationCode);
      IF VariantCode <> '' THEN
        SalesLine.VALIDATE("Variant Code",VariantCode);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CopyAsmLinesToTemp@137(AssemblyHeader@1000 : Record 900;VAR TempAssemblyLine@1001 : TEMPORARY Record 901);
    VAR
      AssemblyLine@1002 : Record 901;
    BEGIN
      TempAssemblyLine.DELETEALL(TRUE);
      CLEAR(AssemblyLine);
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      IF NOT AssemblyLine.FINDSET THEN
        EXIT;

      REPEAT
        TempAssemblyLine := AssemblyLine;
        TempAssemblyLine.INSERT(TRUE);
      UNTIL AssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE SetupInventoryAndTrackingForAssemblyOrder@271(AssemblyItem@1000 : Record 27;LocationCode@1001 : Code[10];OrderQty@1002 : Decimal) : Code[20];
    VAR
      AssemblyHeader@1003 : Record 900;
    BEGIN
      FindAssemblyHeader(
        AssemblyHeader,AssemblyHeader."Document Type"::Order,AssemblyItem,'',LocationCode,
        WORKDATE,AssemblyItem."Base Unit of Measure",OrderQty);

      PostCompInventory(AssemblyHeader);
      AssignSNItemTracking(AssemblyHeader,OrderQty);
      EXIT(AssemblyHeader."No.");
    END;

    LOCAL PROCEDURE PostCompInventory@263(AssemblyHeader@1000 : Record 900);
    VAR
      ItemJournalLine@1001 : Record 83;
      AssemblyLine@1005 : Record 901;
      QtySupplement@1004 : Decimal;
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.FINDSET;
      QtySupplement := LibraryRandom.RandInt(50);
      REPEAT
        LibraryInventory.FindItemJournalTemplate(ItemJournalTemplate);
        LibraryInventory.CreateItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Name);
        LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,
          ItemJournalLine."Entry Type"::"Positive Adjmt.",AssemblyLine."No.",AssemblyLine.Quantity + QtySupplement);
        ItemJournalLine.VALIDATE("Unit of Measure Code",AssemblyLine."Unit of Measure Code");
        ItemJournalLine.VALIDATE("Variant Code",AssemblyLine."Variant Code");
        ItemJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(50,2));
        ItemJournalLine.VALIDATE("Location Code",AssemblyLine."Location Code");
        ItemJournalLine.VALIDATE("Bin Code",AssemblyLine."Bin Code");
        ItemJournalLine.MODIFY(TRUE);
        LibraryVariableStorage.Enqueue(ItemJournalLine."Quantity (Base)");
        ItemJournalLine.OpenItemTrackingLines(FALSE);
        LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
      UNTIL AssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE CreateSaleLineWithShptDate@65(VAR SalesHeader@1000 : Record 36;DocumentType@1005 : Option;ItemNo@1006 : Code[20];VariantCode@1003 : Code[10];SalesQty@1002 : Integer;ShipmentDate@1001 : Date;LocationCode@1007 : Code[10]);
    VAR
      SalesLine@1004 : Record 37;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,DocumentType,'');
      SalesHeader.VALIDATE("Shipment Date",ShipmentDate);
      SalesHeader.VALIDATE("Location Code",LocationCode);
      SalesHeader.MODIFY(TRUE);
      LibrarySales.CreateSalesLineWithShipmentDate(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,ShipmentDate,SalesQty);
      SalesLine.VALIDATE("Variant Code",VariantCode);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateSalesOrder@77(VAR SalesHeader@1000 : Record 36;ItemNo@1001 : Code[20];VariantCode@1004 : Code[10];SalesQty@1003 : Integer;ShipmentDate@1002 : Date;LocationCode@1006 : Code[10]);
    BEGIN
      CreateSaleLineWithShptDate(SalesHeader,SalesHeader."Document Type"::Order,ItemNo,VariantCode,SalesQty,ShipmentDate,LocationCode);
    END;

    LOCAL PROCEDURE CreateSalesOrderWithTwoLines@239(VAR SalesHeader@1000 : Record 36;AssemblyItemNo@1001 : Code[20];ItemNo@1007 : Code[20];VariantCode@1004 : Code[10];SalesQty@1003 : Integer;ShipmentDate@1002 : Date;LocationCode@1006 : Code[10]);
    VAR
      SalesLine@1005 : Record 37;
    BEGIN
      CreateSaleLineWithShptDate(
        SalesHeader,SalesHeader."Document Type"::Order,AssemblyItemNo,VariantCode,SalesQty,ShipmentDate,LocationCode);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,SalesQty);
    END;

    LOCAL PROCEDURE AssignSNItemTracking@254(VAR AssemblyHeader@1000 : Record 900;OrderQty@1001 : Decimal);
    VAR
      AssemblyOrderPage@1003 : TestPage 900;
    BEGIN
      COMMIT;
      AssemblyOrderPage.OPENEDIT;
      AssemblyOrderPage.FILTER.SETFILTER("No.",AssemblyHeader."No.");
      AssemblyOrderPage.GOTORECORD(AssemblyHeader);

      LibraryVariableStorage.Enqueue(OrderQty);
      AssemblyOrderPage."Item Tracking Lines".INVOKE;

      SelectSNFromEntries := TRUE;
      REPEAT
        IF AssemblyOrderPage.Lines.Type.VALUE = ItemMsg THEN BEGIN
          LibraryVariableStorage.Enqueue(OrderQty);
          AssemblyOrderPage.Lines."Item Tracking Lines".INVOKE;
        END;
      UNTIL NOT AssemblyOrderPage.Lines.NEXT;

      AssemblyOrderPage.OK.INVOKE;
    END;

    LOCAL PROCEDURE GetLeadTimesItemOrSKU@195(VAR LeadTimeCalculation@1003 : DateFormula;VAR SafetyLeadTime@1004 : DateFormula;ItemNo@1000 : Code[20];LocationCode@1001 : Code[10];VariantCode@1002 : Code[10]);
    VAR
      SKU@1005 : Record 5700;
      Item@1006 : Record 27;
      ManufacturingSetup@1007 : Record 99000765;
    BEGIN
      // IF SKU exist take values from SKU
      IF FindSKU(SKU,ItemNo,LocationCode,VariantCode) THEN BEGIN
        LeadTimeCalculation := SKU."Lead Time Calculation";
        SafetyLeadTime := SKU."Safety Lead Time";
      END ELSE BEGIN // otherwise take values from Item card
        Item.GET(ItemNo);
        LeadTimeCalculation := Item."Lead Time Calculation";
        SafetyLeadTime := Item."Safety Lead Time";
        IF FORMAT(SafetyLeadTime) = '' THEN BEGIN // if safety lead time is empty consider the manuf setup one
          ManufacturingSetup.GET;
          SafetyLeadTime := ManufacturingSetup."Default Safety Lead Time";
        END;
      END;
    END;

    LOCAL PROCEDURE GetRollupCost@186(AssemblyHeader@1001 : Record 900) : Decimal;
    VAR
      AssemblyLine@1000 : Record 901;
      UnitCost@1002 : Decimal;
    BEGIN
      UnitCost := 0;
      CLEAR(AssemblyLine);
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      IF NOT AssemblyLine.FINDSET THEN
        EXIT(UnitCost);

      REPEAT
        UnitCost += AssemblyLine."Cost Amount";
      UNTIL AssemblyLine.NEXT = 0;

      EXIT(UnitCost);
    END;

    LOCAL PROCEDURE GetRollupPrice@287(AssemblyHeader@1001 : Record 900) Price : Decimal;
    VAR
      AssemblyLine@1000 : Record 901;
    BEGIN
      Price := 0;

      WITH AssemblyLine DO BEGIN
        SETRANGE("Document Type",AssemblyHeader."Document Type");
        SETRANGE("Document No.",AssemblyHeader."No.");
        FINDSET;

        REPEAT
          CASE Type OF
            Type::Item:
              Price += Quantity * GetSalesPrice("No.","Variant Code");
            Type::Resource:
              Price += Quantity * GetResourcePrice("No.");
          END;
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE FindSOL@15(SalesHeader@1004 : Record 36;VAR SalesLine@1005 : Record 37;SOLIndex@1003 : Integer);
    BEGIN
      CLEAR(SalesLine);
      SalesLine.SETRANGE("Document Type",SalesHeader."Document Type");
      SalesLine.SETRANGE("Document No.",SalesHeader."No.");
      SalesLine.FINDSET(TRUE);

      IF SOLIndex > 1 THEN
        SalesLine.NEXT(SOLIndex - 1);
    END;

    LOCAL PROCEDURE FindSKU@189(VAR SKU@1000 : Record 5700;ItemNo@1001 : Code[20];LocationCode@1003 : Code[10];VariantCode@1002 : Code[10]) : Boolean;
    BEGIN
      CLEAR(SKU);
      SKU.SETRANGE("Item No.",ItemNo);
      IF LocationCode <> '' THEN
        SKU.SETRANGE("Location Code",LocationCode);
      IF VariantCode <> '' THEN
        SKU.SETRANGE("Variant Code",VariantCode);

      EXIT(SKU.FINDFIRST);
    END;

    LOCAL PROCEDURE ChangeCostAndPriceOnCompList@193(ItemNo@1001 : Code[20]);
    VAR
      BOMComponent@1000 : Record 90;
      Item@1002 : Record 27;
      Resource@1003 : Record 156;
    BEGIN
      CLEAR(BOMComponent);
      BOMComponent.SETRANGE("Parent Item No.",ItemNo);
      BOMComponent.FINDSET;

      // Iterate through components of and update cost and price
      REPEAT
        CASE BOMComponent.Type OF
          BOMComponent.Type::Item:
            BEGIN
              Item.GET(BOMComponent."No.");
              Item.VALIDATE("Unit Price",LibraryRandom.RandDec(1000,2));
              Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(1000,2));
              Item.MODIFY(TRUE);
            END;
          BOMComponent.Type::Resource:
            BEGIN
              Resource.GET(BOMComponent."No.");
              Resource.VALIDATE("Unit Price",LibraryRandom.RandDec(1000,2));
              Resource.VALIDATE("Unit Cost",LibraryRandom.RandDec(1000,2));
              Resource.VALIDATE("Direct Unit Cost",Resource."Unit Cost");
              Resource.MODIFY(TRUE);
            END;
        END;
      UNTIL BOMComponent.NEXT = 0;
    END;

    LOCAL PROCEDURE ChangeLeadTimeOffsetOnCompList@177(ItemNo@1001 : Code[20]);
    VAR
      BOMComponent@1000 : Record 90;
    BEGIN
      CLEAR(BOMComponent);
      BOMComponent.SETRANGE("Parent Item No.",ItemNo);
      IF BOMComponent.COUNT <= 0 THEN
        EXIT;

      // Iterate through components of type items and update offset
      REPEAT
        IF BOMComponent.Type = BOMComponent.Type::Item THEN BEGIN
          EVALUATE(BOMComponent."Lead-Time Offset",'<' + FORMAT(LibraryRandom.RandInt(10)) + 'D>');
          BOMComponent.MODIFY(TRUE);
        END;
      UNTIL BOMComponent.NEXT = 0;
    END;

    LOCAL PROCEDURE ChangeLeadTimesOnSKU@191(SKU@1001 : Record 5700);
    BEGIN
      EVALUATE(SKU."Lead Time Calculation",'<' + FORMAT(LibraryRandom.RandInt(10)) + 'D>');
      EVALUATE(SKU."Safety Lead Time",'<' + FORMAT(LibraryRandom.RandInt(10)) + 'D>');
      SKU.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE GetAsmTypeForSalesType@57(SalesDocumentType@1001 : Option) : Integer;
    VAR
      AsmHeader@1002 : Record 900;
      SalesHeader@1003 : Record 36;
    BEGIN
      CASE SalesDocumentType OF
        SalesHeader."Document Type"::Quote:
          EXIT(AsmHeader."Document Type"::Quote);
        SalesHeader."Document Type"::Order:
          EXIT(AsmHeader."Document Type"::Order);
        SalesHeader."Document Type"::"Blanket Order":
          EXIT(AsmHeader."Document Type"::"Blanket Order");
        ELSE
          ERROR(DocTypeNotSupportedErr);
      END;
    END;

    LOCAL PROCEDURE SelectAssemblyLines@172(AssemblyHeader@1001 : Record 900;VAR AssemblyLine@1000 : Record 901;LineType@1005 : Option;ItemNo@1002 : Code[20];LocationCode@1004 : Code[20];VariantCode@1003 : Code[10]);
    BEGIN
      CLEAR(AssemblyLine);

      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE("No.",ItemNo);
      IF LineType = AssemblyLine.Type::Item THEN BEGIN
        AssemblyLine.SETFILTER("Variant Code",'%1',VariantCode);
        AssemblyLine.SETFILTER("Location Code",'%1',LocationCode);
      END;
    END;

    LOCAL PROCEDURE AddInventoryNonDirectLocation@5(ItemNo@1003 : Code[20];LocationCode@1000 : Code[10];VariantCode@1001 : Code[10];Qty@1004 : Integer);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      ClearJournal(ItemJournalTemplate,ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Qty);
      ItemJournalLine.VALIDATE("Variant Code",VariantCode);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE AddInvNonDirectLocAllComponent@139(AssemblyHeader@1003 : Record 900;QtyPercentage@1000 : Integer);
    VAR
      AssemblyLine@1002 : Record 901;
    BEGIN
      CLEAR(AssemblyLine);
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      IF NOT AssemblyLine.FINDSET THEN
        EXIT;

      REPEAT
        AddInventoryNonDirectLocation(AssemblyLine."No.",AssemblyLine."Location Code",AssemblyLine."Variant Code",
          QtyPercentage / 100 * AssemblyLine."Quantity per" *
          LibraryInventory.GetQtyPerForItemUOM(AssemblyHeader."Item No.",AssemblyHeader."Unit of Measure Code") *
          AssemblyHeader.Quantity);
      UNTIL AssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE PostPositiveAdjmtOnBin@258(ItemNo@1003 : Code[20];LocationCode@1000 : Code[10];BinCode@1001 : Code[20];Qty@1004 : Integer);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      ClearJournal(ItemJournalTemplate,ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Qty);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.VALIDATE("Bin Code",BinCode);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CountAssemblyOrders@31(DocumentType@1001 : Option) : Integer;
    VAR
      AssemblyHeader@1000 : Record 900;
    BEGIN
      AssemblyHeader.RESET;
      AssemblyHeader.SETRANGE("Document Type",DocumentType);
      EXIT(AssemblyHeader.COUNT);
    END;

    LOCAL PROCEDURE CountReservationEntries@83() : Integer;
    VAR
      ReservationEntry@1000 : Record 337;
    BEGIN
      CLEAR(ReservationEntry);
      EXIT(ReservationEntry.COUNT);
    END;

    LOCAL PROCEDURE CountHardLinkEntries@82() : Integer;
    VAR
      ATOLink@1000 : Record 904;
    BEGIN
      CLEAR(ATOLink);
      EXIT(ATOLink.COUNT);
    END;

    LOCAL PROCEDURE FindItemTrackingLikeSNALL@257() : Code[10];
    VAR
      ItemTrackingCode@1000 : Record 6502;
    BEGIN
      WITH ItemTrackingCode DO BEGIN
        SETRANGE("SN Specific Tracking",TRUE);
        SETRANGE("Man. Expir. Date Entry Reqd.",FALSE);
        FINDFIRST;
        EXIT(Code);
      END;
    END;

    LOCAL PROCEDURE FindAssemblyHeader@22(VAR AssemblyHeader@1007 : Record 900;DocumentType@1006 : Option;Item@1005 : Record 27;VariantCode@1004 : Code[10];LocationCode@1003 : Code[10];DueDate@1002 : Date;UOM@1001 : Code[10];Qty@1000 : Decimal);
    BEGIN
      CLEAR(AssemblyHeader);
      AssemblyHeader.SETRANGE("Document Type",DocumentType);
      AssemblyHeader.SETRANGE("Item No.",Item."No.");
      IF VariantCode = '' THEN
        AssemblyHeader.SETRANGE(Description,Item.Description)
      ELSE
        AssemblyHeader.SETRANGE(Description,VariantCode);
      AssemblyHeader.SETFILTER("Variant Code",'%1',VariantCode);
      AssemblyHeader.SETFILTER("Location Code",'%1',LocationCode);
      AssemblyHeader.SETRANGE("Due Date",DueDate);
      AssemblyHeader.SETRANGE("Unit of Measure Code",UOM);
      AssemblyHeader.SETRANGE(Quantity,Qty);
      AssemblyHeader.SETRANGE("Quantity (Base)",Qty * LibraryInventory.GetQtyPerForItemUOM(Item."No.",UOM));

      AssemblyHeader.FINDSET;
    END;

    LOCAL PROCEDURE FindItemAssemblyHeader@174(VAR AssemblyHeader@1000 : Record 900;ItemNo@1003 : Code[20];Index@1001 : Integer);
    BEGIN
      AssemblyHeader.RESET;
      AssemblyHeader.SETRANGE("Item No.",ItemNo);
      AssemblyHeader.FINDSET;
      IF Index > 1 THEN
        AssemblyHeader.NEXT(Index - 1);
    END;

    LOCAL PROCEDURE FindLinkedAssemblyOrder@276(VAR AssemblyHeader@1000 : Record 900;SalesDocumentType@1001 : Option;SalesDocumentNo@1003 : Code[20]);
    VAR
      ATOLink@1002 : Record 904;
    BEGIN
      ATOLink.SETRANGE("Document Type",SalesDocumentType);
      ATOLink.SETRANGE("Document No.",SalesDocumentNo);
      ATOLink.FINDFIRST;
      AssemblyHeader.GET(ATOLink."Assembly Document Type",ATOLink."Assembly Document No.");
    END;

    LOCAL PROCEDURE FindSalesLine@223(SalesHeader@1007 : Record 36;VAR SalesLine@1008 : Record 37;ItemNo@1005 : Code[20]);
    BEGIN
      CLEAR(SalesLine);
      SalesLine.SETRANGE("Document Type",SalesHeader."Document Type");
      SalesLine.SETRANGE("Document No.",SalesHeader."No.");
      SalesLine.SETRANGE("No.",ItemNo);
      SalesLine.FINDFIRST;
    END;

    LOCAL PROCEDURE CollectSetupBOMComponent@350(VAR ItemBuf@1000 : Record 27;ParentItemNo@1001 : Code[20]);
    VAR
      Item@1002 : Record 27;
      BOMComponent@1003 : Record 90;
      ItemTrackingCode@1005 : Code[10];
    BEGIN
      WITH BOMComponent DO BEGIN
        SETRANGE("Parent Item No.",ParentItemNo);
        SETRANGE(Type,Type::Item);
        FINDSET;
        ItemTrackingCode := FindItemTrackingLikeSNALL;
        REPEAT
          Item.GET("No.");
          Item.VALIDATE("Item Tracking Code",ItemTrackingCode);
          Item.VALIDATE("Serial Nos.",LibraryUtility.GetGlobalNoSeriesCode);
          Item.MODIFY(TRUE);
          ItemBuf := Item;
          ItemBuf.INSERT;
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE AssertAssemblyLinesDefaultBOM@180(AssemblyHeader@1017 : Record 900;BOMComponent@1004 : Record 90;LocationCode@1001 : Code[20];NoOfLines@1002 : Integer);
    VAR
      AssemblyLine@1000 : Record 901;
    BEGIN
      SelectAssemblyLines(AssemblyHeader,AssemblyLine,BOMComponent.Type,BOMComponent."No.",LocationCode,BOMComponent."Variant Code");

      Assert.AreEqual(
        NoOfLines,AssemblyLine.COUNT,
        STRSUBSTNO(NoAssemblyInFilterMsg,NoOfLines,AssemblyLine.TABLECAPTION,AssemblyLine.GETFILTERS));

      IF NoOfLines > 0 THEN BEGIN
        AssemblyLine.FINDFIRST;
        // Assert fields on the Assembly order line (first one of this kind only)
        Assert.AreEqual(
          BOMComponent.Description,AssemblyLine.Description,
          STRSUBSTNO(WrongValueOnAsmOrderLineMsg,AssemblyLine.FIELDCAPTION(Description),AssemblyLine.GETFILTERS));
        Assert.AreEqual(
          BOMComponent."Unit of Measure Code",AssemblyLine."Unit of Measure Code",
          STRSUBSTNO(WrongValueOnAsmOrderLineMsg,AssemblyLine.FIELDCAPTION("Unit of Measure Code"),AssemblyLine.GETFILTERS));
        Assert.AreEqual(
          BOMComponent."Quantity per",AssemblyLine."Quantity per" / AssemblyHeader."Qty. per Unit of Measure",
          STRSUBSTNO(WrongValueOnAsmOrderLineMsg,AssemblyLine.FIELDCAPTION("Qty. per Unit of Measure"),AssemblyLine.GETFILTERS));
        Assert.AreEqual(
          LibraryInventory.GetQtyPerForItemUOM(AssemblyHeader."Item No.",AssemblyHeader."Unit of Measure Code") *
          BOMComponent."Quantity per" * AssemblyHeader.Quantity,AssemblyLine.Quantity,
          STRSUBSTNO(WrongValueOnAsmOrderLineMsg,AssemblyLine.FIELDCAPTION(Quantity),AssemblyLine.GETFILTERS));
        IF AssemblyLine.Type = AssemblyLine.Type::Item THEN
          Assert.AreEqual(
            LibraryInventory.GetQtyPerForItemUOM(AssemblyLine."No.",AssemblyLine."Unit of Measure Code") *
            BOMComponent."Quantity per" * AssemblyHeader."Quantity (Base)",AssemblyLine."Quantity (Base)",
            STRSUBSTNO(WrongValueOnAsmOrderLineMsg,AssemblyLine.FIELDCAPTION("Quantity (Base)"),AssemblyLine.GETFILTERS));
        Assert.IsTrue(
          BOMComponent."Lead-Time Offset" = AssemblyLine."Lead-Time Offset",
          STRSUBSTNO(WrongValueOnAsmOrderLineMsg,AssemblyLine.FIELDCAPTION("Lead-Time Offset"),AssemblyLine.GETFILTERS));
      END;
    END;

    LOCAL PROCEDURE AssertNumberOfAssemblyLines@37(AssemblyHeader@1017 : Record 900;NoOfLines@1012 : Integer);
    VAR
      AssemblyLine@1000 : Record 901;
    BEGIN
      CLEAR(AssemblyLine);

      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");

      Assert.AreEqual(
        NoOfLines,AssemblyLine.COUNT,STRSUBSTNO(NoAssemblyInFilterMsg,NoOfLines,AssemblyLine.TABLECAPTION,AssemblyLine.GETFILTERS));
    END;

    LOCAL PROCEDURE AssertAssemblyHeader@26(VAR AssemblyHeader@1007 : Record 900;DocumentType@1006 : Option;Item@1005 : Record 27;VariantCode@1004 : Code[10];LocationCode@1003 : Code[10];DueDate@1002 : Date;UOM@1001 : Code[10];Qty@1000 : Decimal;NoOfHeaders@1008 : Integer);
    BEGIN
      FindAssemblyHeader(AssemblyHeader,DocumentType,Item,VariantCode,LocationCode,DueDate,UOM,Qty);

      Assert.AreEqual(
        NoOfHeaders,AssemblyHeader.COUNT,
        STRSUBSTNO(NoAssemblyInFilterMsg,NoOfHeaders,AssemblyHeader.TABLECAPTION,AssemblyHeader.GETFILTERS));
    END;

    LOCAL PROCEDURE AssertNoAssemblyHeader@28(DocumentType@1000 : Option;DocumentNo@1001 : Code[20]);
    VAR
      AssemblyHeader@1002 : Record 900;
    BEGIN
      CLEAR(AssemblyHeader);
      COMMIT;
      ASSERTERROR AssemblyHeader.GET(DocumentType,DocumentNo);
    END;

    LOCAL PROCEDURE AssertAsmOrderForDefaultBOM@35(VAR AssemblyHeader@1010 : Record 900;DocumentType@1001 : Option;Item@1009 : Record 27;VariantCode@1007 : Code[10];LocationCode@1006 : Code[10];DueDate@1005 : Date;UOM@1004 : Code[10];Qty@1003 : Decimal;NoOfHeaders@1002 : Integer);
    VAR
      BOMComponent@1000 : Record 90;
    BEGIN
      // Verify - assembly header
      AssertAssemblyHeader(AssemblyHeader,DocumentType,Item,VariantCode,LocationCode,DueDate,UOM,Qty,NoOfHeaders);

      // Assert number of AO lines matches BOM list
      CLEAR(BOMComponent);
      BOMComponent.SETRANGE("Parent Item No.",Item."No.");
      IF BOMComponent.COUNT <= 0 THEN
        EXIT;
      AssertNumberOfAssemblyLines(AssemblyHeader,BOMComponent.COUNT);

      // Iterate through components
      // Verify - Lines
      REPEAT
        CASE BOMComponent.Type OF
          // Text only - ignore
          BOMComponent.Type::" ":
            ;
          ELSE
            AssertAssemblyLinesDefaultBOM(AssemblyHeader,BOMComponent,LocationCode,1);
        END;
      UNTIL BOMComponent.NEXT = 0;
    END;

    LOCAL PROCEDURE AssertReservationEntries@36(SalesLine@1001 : Record 37;AssemblyHeader@1002 : Record 900) : Integer;
    VAR
      EntryNo@1003 : Integer;
    BEGIN
      EntryNo := LibraryAssembly.VerifySaleReservationEntryATO(SalesLine);
      Assert.AreEqual(EntryNo,LibraryAssembly.VerifytAsmReservationEntryATO(AssemblyHeader),DiffEntryNoInReservEntriesMsg);

      EXIT(EntryNo);
    END;

    LOCAL PROCEDURE AssertReservationEntryDeleted@58(EntryNo@1000 : Integer);
    VAR
      ReservationEntry@1001 : Record 337;
    BEGIN
      CLEAR(ReservationEntry);
      ReservationEntry.SETRANGE("Entry No.",EntryNo);

      COMMIT;
      ASSERTERROR ReservationEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE AssertDatesOnAsmOrder@194(AssemblyHeader@1000 : Record 900);
    VAR
      AssemblyLine@1005 : Record 901;
      LeadTimeCalculation@1002 : DateFormula;
      SafetyLeadTime@1001 : DateFormula;
      EndingDate@1003 : Date;
      StartingDate@1004 : Date;
    BEGIN
      // Assert on header
      GetLeadTimesItemOrSKU(
        LeadTimeCalculation,SafetyLeadTime,AssemblyHeader."Item No.",AssemblyHeader."Location Code",AssemblyHeader."Variant Code");
      IF FORMAT(SafetyLeadTime) = '' THEN
        EndingDate := AssemblyHeader."Due Date"
      ELSE
        EndingDate := CALCDATE('<-' + FORMAT(SafetyLeadTime) + '>',AssemblyHeader."Due Date");
      IF FORMAT(LeadTimeCalculation) = '' THEN
        StartingDate := EndingDate
      ELSE
        StartingDate := CALCDATE('<-' + FORMAT(LeadTimeCalculation) + '>',EndingDate);
      Assert.AreEqual(
        EndingDate,AssemblyHeader."Ending Date",
        STRSUBSTNO(WrongDateOnAssemblyMsg,AssemblyHeader.FIELDCAPTION("Ending Date"),AssemblyHeader.TABLECAPTION,AssemblyHeader."No."));
      Assert.AreEqual(
        StartingDate,AssemblyHeader."Starting Date",
        STRSUBSTNO(WrongDateOnAssemblyMsg,
          AssemblyHeader.FIELDCAPTION("Starting Date"),AssemblyHeader.TABLECAPTION,AssemblyHeader."No."));

      // Assert on lines
      CLEAR(AssemblyLine);
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      REPEAT
        IF AssemblyLine.Type = AssemblyLine.Type::Item THEN
          IF FORMAT(AssemblyLine."Lead-Time Offset") = '' THEN
            Assert.AreEqual(
              StartingDate,AssemblyLine."Due Date",
              STRSUBSTNO(WrongDateOnAssemblyMsg,AssemblyLine.FIELDCAPTION("Due Date"),AssemblyLine.TABLECAPTION,AssemblyLine."No."))
          ELSE
            Assert.AreEqual(
              CALCDATE('<-' + FORMAT(AssemblyLine."Lead-Time Offset") + '>',StartingDate),AssemblyLine."Due Date",
              STRSUBSTNO(WrongDateOnAssemblyMsg,AssemblyLine.FIELDCAPTION("Due Date"),AssemblyLine.TABLECAPTION,AssemblyLine."No."));
      UNTIL AssemblyLine.NEXT = 0;
    END;

    [ModalPageHandler]
    PROCEDURE AssemblyAvailabilityFormHandler@176(VAR AvailPage@1000 : TestPage 908);
    BEGIN
      AvailPage.Yes.INVOKE;
    END;

    [ConfirmHandler]
    PROCEDURE RollUpCostConfirm@181(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,CONFIRM_ROLLUP_COST) > 0,Question);
      Reply := TRUE;
    END;

    [Test]
    PROCEDURE ATOCheckAsmOrder@125();
    VAR
      Item@1001 : Record 27;
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      TCXATOSunshineCheckAsm(Item,'','',DocumentType::Order,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOCheckAsmOrderVariant@6();
    VAR
      Item@1001 : Record 27;
      ItemVariant@1000 : Record 5401;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      DocumentType@1003 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      LibraryInventory.CreateItemVariant(ItemVariant,Item."No.");
      TCXATOSunshineCheckAsm(Item,ItemVariant.Code,'',DocumentType::Order,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOCheckAsmOrderReservation@78();
    VAR
      Item@1001 : Record 27;
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      TCXATOSunshineCheckAsm(Item,'','',DocumentType::Order,AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATOCheckHardLinkAsmOrder@63();
    VAR
      Item@1001 : Record 27;
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      TCXATOSunshineCheckAsm(Item,'','',DocumentType::Order,AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOCheckAsmQuote@94();
    VAR
      Item@1001 : Record 27;
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      TCXATOSunshineCheckAsm(Item,'','',DocumentType::Quote,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOCheckAsmQuoteVariant@76();
    VAR
      Item@1001 : Record 27;
      ItemVariant@1000 : Record 5401;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      DocumentType@1003 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      LibraryInventory.CreateItemVariant(ItemVariant,Item."No.");
      TCXATOSunshineCheckAsm(Item,ItemVariant.Code,'',DocumentType::Quote,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOCheckHardLinkAsmQuote@7();
    VAR
      Item@1001 : Record 27;
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      TCXATOSunshineCheckAsm(Item,'','',DocumentType::Quote,AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOCheckAsmBlanketOrder@142();
    VAR
      Item@1001 : Record 27;
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      TCXATOSunshineCheckAsm(Item,'','',DocumentType::"Blanket Order",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOCheckAsmBlanketOrderVar@141();
    VAR
      Item@1001 : Record 27;
      ItemVariant@1000 : Record 5401;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      DocumentType@1003 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      LibraryInventory.CreateItemVariant(ItemVariant,Item."No.");
      TCXATOSunshineCheckAsm(Item,ItemVariant.Code,'',DocumentType::"Blanket Order",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOCheckAsmBlanketOrderHardLnk@136();
    VAR
      Item@1001 : Record 27;
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      TCXATOSunshineCheckAsm(Item,'','',DocumentType::"Blanket Order",AssertOption::"Hard link");
    END;

    LOCAL PROCEDURE TCXATOSunshineCheckAsm@4(Item@1010 : Record 27;VariantCode@1011 : Code[10];LocationCode@1003 : Code[10];SalesDocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';AssertOption@1004 : 'Orders,Reservation,Hard link');
    VAR
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1008 : Record 37;
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
      NoOfAssemblyOrders@1000 : Integer;
      AsmDocumentType@1009 : Integer;
    BEGIN
      // TC11, TC12, TC115 and TC124 from the TDS - see Documentation

      AsmDocumentType := GetAsmTypeForSalesType(SalesDocumentType);
      NoOfAssemblyOrders := CountAssemblyOrders(AsmDocumentType);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,Item."No.",VariantCode,OrderQty,DueDate,LocationCode);
      FindSOL(SalesHeader,SalesLine,1);

      FindAssemblyHeader(AssemblyHeader,AsmDocumentType,Item,VariantCode,LocationCode,DueDate,Item."Base Unit of Measure",OrderQty);

      CASE AssertOption OF
        // Assert Assembly doc created
        AssertOption::Orders:
          BEGIN
            // Assert that 1 assembly doc is created for the ATO items placed on sales line
            Assert.AreEqual(NoOfAssemblyOrders + 1,CountAssemblyOrders(AsmDocumentType),OneAsmOrderCreateMsg);

            // Verify - assembly doc
            AssertAsmOrderForDefaultBOM(AssemblyHeader,AsmDocumentType,Item,VariantCode,LocationCode,DueDate,
              Item."Base Unit of Measure",OrderQty,1);
          END;
        // Assert reservation entries
        AssertOption::Reservation:
          AssertReservationEntries(SalesLine,AssemblyHeader);
        // Assert hard link entry
        AssertOption::"Hard link":
          LibraryAssembly.VerifyHardLinkEntry(SalesLine,AssemblyHeader,1);
      END;
    END;

    [Test]
    [HandlerFunctions(ATOLinesPageHandler,CheckAvailPageHandler)]
    PROCEDURE TestATOLinesPage@232();
    VAR
      Item@1007 : Record 27;
      AssemblyHeader@1006 : Record 900;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      SalesOrder@1008 : TestPage 42;
      OrderQty@1003 : Integer;
      DueDate@1002 : Date;
    BEGIN
      // Setup. Create ATO Assembly item and Sales Order.
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := WorkDate2 + LibraryRandom.RandInt(30);
      CreateSaleLineWithShptDate(SalesHeader,SalesHeader."Document Type"::Order,Item."No.",'',OrderQty,DueDate,'');
      FindSOL(SalesHeader,SalesLine,1);
      FindAssemblyHeader(AssemblyHeader,1,Item,'','',DueDate,Item."Base Unit of Measure",OrderQty);

      // Add enough inventory for comp
      AddInvNonDirectLocAllComponent(AssemblyHeader,100);

      // Personalize ATO Lines.
      SalesOrder.OPENEDIT;
      SalesOrder.FILTER.SETFILTER("No.",SalesHeader."No.");
      SalesOrder.GOTORECORD(SalesHeader);
      SalesOrder.SalesLines.AssembleToOrderLines.INVOKE;

      // Add ATO line in page handler.

      // Exercise: Post Sales Order.
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify - AO is posted
      AssertNoAssemblyHeader(AssemblyHeader."Document Type",AssemblyHeader."No.");
    END;

    [Test]
    PROCEDURE ATOCheckDeleteSOLOrder@14();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Order,DeleteOption::"Delete SOL",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOCheckZeroQtySOLOrder@41();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Order,DeleteOption::"Zero Quantity on SOL",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATODeleteSOOrder@47();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Order,DeleteOption::"Delete SO",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATODeleteSOLCheckReserv@62();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Order,DeleteOption::"Delete SOL",AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATOZeroQtySOLChkReserv@55();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Order,DeleteOption::"Zero Quantity on SOL",AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATODeleteSOCheckReserv@53();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Order,DeleteOption::"Delete SO",AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATODeleteSOLCheckHardLinkOrder@72();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Order,DeleteOption::"Delete SOL",AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOZeroQtySOLChkHardLinkOrder@70();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Order,DeleteOption::"Zero Quantity on SOL",AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOZeroQtySOLChkHardLinkOrderWithEntries@290();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAOWithEntries('',DocumentType::Order,DeleteOption::"Zero Quantity on SOL",AssertOption::"Hard link",TRUE);
    END;

    [Test]
    PROCEDURE ATODeleteSOCheckHardLinkOrder@68();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Order,DeleteOption::"Delete SO",AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOCheckDeleteSOLQuote@145();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Quote,DeleteOption::"Delete SOL",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOCheckZeroQtySOLQuote@144();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Quote,DeleteOption::"Zero Quantity on SOL",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATODeleteSOQuote@143();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Quote,DeleteOption::"Delete SO",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATODeleteSOLCheckHardLinkQuote@140();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Quote,DeleteOption::"Delete SOL",AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOZeroQtySOLChkHardLinkQuote@95();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Quote,DeleteOption::"Zero Quantity on SOL",AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATODeleteSOCheckHardLinkQuote@23();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::Quote,DeleteOption::"Delete SO",AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOCheckDeleteSOLBlanket@152();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::"Blanket Order",DeleteOption::"Delete SOL",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOCheckZeroQtySOLBlanket@151();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::"Blanket Order",DeleteOption::"Zero Quantity on SOL",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATODeleteSOBlanket@150();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::"Blanket Order",DeleteOption::"Delete SO",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATODeleteSOLChkHardLinkBlanket@149();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::"Blanket Order",DeleteOption::"Delete SOL",AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOZeroQtySOLChkHardLnkBlanket@148();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::"Blanket Order",DeleteOption::"Zero Quantity on SOL",AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATODeleteSOCheckHardLnkBlanket@147();
    VAR
      DeleteOption@1000 : 'Zero Quantity on SOL,Delete SOL,Delete SO';
      AssertOption@1001 : 'Orders,Reservation,Hard link';
      DocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATODeleteAO('',DocumentType::"Blanket Order",DeleteOption::"Delete SO",AssertOption::"Hard link");
    END;

    LOCAL PROCEDURE TCXATODeleteAO@11(LocationCode@1003 : Code[10];SalesDocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';DeleteOption@1010 : 'Zero Quantity on SOL,Delete SOL,Delete SO';AssertOption@1008 : 'Orders,Reservation,Hard link');
    BEGIN
      TCXATODeleteAOWithEntries(LocationCode,SalesDocumentType,DeleteOption,AssertOption,FALSE);
    END;

    LOCAL PROCEDURE TCXATODeleteAOWithEntries@296(LocationCode@1003 : Code[10];SalesDocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';DeleteOption@1010 : 'Zero Quantity on SOL,Delete SOL,Delete SO';AssertOption@1008 : 'Orders,Reservation,Hard link';WithEntries@1013 : Boolean);
    VAR
      AssemblyHeader@1005 : Record 900;
      Item@1004 : Record 27;
      SalesLine@1000 : Record 37;
      SalesHeader@1001 : Record 36;
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
      EntryNo@1009 : Integer;
      NoOfAssemblyOrders@1011 : Integer;
    BEGIN
      // TC13, TC14, TC16, TC116, TC117, TC118, TC125, TC126 and TC127 from the TDS - see Documentation
      // Create the "assembled" Item
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      NoOfAssemblyOrders := CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType));

      // Create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,Item."No.",'',OrderQty,DueDate,LocationCode);
      FindSOL(SalesHeader,SalesLine,1);

      FindAssemblyHeader(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,'',LocationCode,DueDate,
        Item."Base Unit of Measure",OrderQty);

      MockInvtAdjmtEntryOrder(AssemblyHeader."No.",WithEntries);

      // Initial assert
      CASE AssertOption OF
        // Verify - assembly order
        AssertOption::Orders:
          BEGIN
            AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,'',LocationCode,DueDate,
              Item."Base Unit of Measure",OrderQty,1);
            // Assert that 1 assembly orders is created for the ATO items placed on sales order line
            Assert.AreEqual(NoOfAssemblyOrders + 1,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),
              OneAsmOrderCreateMsg);
          END;
        // Assert reservation entries
        AssertOption::Reservation:
          EntryNo := AssertReservationEntries(SalesLine,AssemblyHeader);
        // Assert hard link entry
        AssertOption::"Hard link":
          LibraryAssembly.VerifyHardLinkEntry(SalesLine,AssemblyHeader,1);
      END;

      // exercise - delete/set zero qty
      CASE DeleteOption OF
        DeleteOption::"Delete SOL":
          // Exercise - delete SOL
          SalesLine.DELETE(TRUE);
        DeleteOption::"Zero Quantity on SOL":
          BEGIN
            // Exercise - zero SOL
            SalesLine.VALIDATE(Quantity,0);
            SalesLine.MODIFY(TRUE);
          END;
        DeleteOption::"Delete SO":
          // Exercise - delete SO
          SalesHeader.DELETE(TRUE);
      END;

      // Assert
      CASE AssertOption OF
        // Assert asm order deleted
        AssertOption::Orders:
          AssertNoAssemblyHeader(AssemblyHeader."Document Type",AssemblyHeader."No.");
        // Assert reservation entries deleted
        AssertOption::Reservation:
          AssertReservationEntryDeleted(EntryNo);
        // Assert hard link entry
        AssertOption::"Hard link":
          IF DeleteOption = DeleteOption::"Zero Quantity on SOL" THEN
            IF (SalesDocumentType = SalesDocumentType::Order) AND NOT WithEntries THEN
              // If Qty is 0 on SOL in Order and no entries then hard link is deleted
              LibraryAssembly.VerifyHardLinkEntry(SalesLine,AssemblyHeader,0)
            ELSE
              LibraryAssembly.VerifyHardLinkEntry(SalesLine,AssemblyHeader,1) // Hard link is not deleted
          ELSE
            // Deleted in all other cases
            LibraryAssembly.VerifyHardLinkEntry(SalesLine,AssemblyHeader,0);
      END;
    END;

    LOCAL PROCEDURE MockInvtAdjmtEntryOrder@294(AssemblyOrderNo@1001 : Code[20];WithEntries@1002 : Boolean);
    VAR
      InvtAdjmtEntryOrder@1000 : Record 5896;
    BEGIN
      IF WithEntries THEN
        WITH InvtAdjmtEntryOrder DO BEGIN
          INIT;
          "Order Type" := "Order Type"::Assembly;
          "Order No." := AssemblyOrderNo;
          INSERT;
        END;
    END;

    [Test]
    PROCEDURE ATOMultipleAO@27();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOMultipleAO('',DocumentType::Order,FALSE,TRUE);
    END;

    [Test]
    PROCEDURE ATOATSMixAO@29();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOMultipleAO('',DocumentType::Order,TRUE,FALSE);
    END;

    [Test]
    PROCEDURE ATOMultipleQuotes@155();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOMultipleAO('',DocumentType::Quote,FALSE,FALSE);
    END;

    [Test]
    PROCEDURE ATOATSMixQuotes@154();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOMultipleAO('',DocumentType::Quote,TRUE,FALSE);
    END;

    [Test]
    PROCEDURE ATOMultipleBlanketOrders@157();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOMultipleAO('',DocumentType::"Blanket Order",FALSE,FALSE);
    END;

    [Test]
    PROCEDURE ATOATSMixBlanketOrders@156();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOMultipleAO('',DocumentType::"Blanket Order",TRUE,FALSE);
    END;

    LOCAL PROCEDURE TCXATOMultipleAO@19(LocationCode@1003 : Code[10];SalesDocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';UseATS@1016 : Boolean;GetAsmOrdersFromSalesHeader@1008 : Boolean);
    VAR
      Item1@1000 : Record 27;
      Item2@1004 : Record 27;
      ItemATS@1017 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1015 : Record 37;
      OrderQty1@1006 : Integer;
      DueDate1@1007 : Date;
      OrderQty2@1014 : Integer;
      DueDate2@1013 : Date;
      NoOfAssemblyOrders@1018 : Integer;
    BEGIN
      // TC15 and TC17 from the TDS - see Documentation
      // Create the "assembled" Items
      CreateAssembledItem(Item1,Item1."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item1."Costing Method"::FIFO);
      CreateAssembledItem(Item2,Item2."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item2."Costing Method"::FIFO);
      CreateAssembledItem(ItemATS,ItemATS."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        ItemATS."Costing Method"::FIFO);

      NoOfAssemblyOrders := CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType));

      // Exercise - create SOLs with ATO items
      OrderQty1 := LibraryRandom.RandInt(1000);
      DueDate1 := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,Item1."No.",'',OrderQty1,DueDate1,LocationCode);
      OrderQty2 := LibraryRandom.RandInt(1000);
      DueDate2 := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      AddSalesOrderLine(SalesHeader,SalesLine,Item2."No.",LocationCode,'',OrderQty2,DueDate2);

      // ATS, ATO mix scenario - add ATS SO line
      IF UseATS THEN
        AddSalesOrderLine(SalesHeader,SalesLine,ItemATS."No.",LocationCode,'',LibraryRandom.RandInt(1000),
          CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2));

      // Assert that 2 assembly orders are created for the 2 ATO items placed on sales order lines
      Assert.AreEqual(NoOfAssemblyOrders + 2,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),TwoAsmOrdersCreateMsg);

      IF GetAsmOrdersFromSalesHeader THEN
        CheckGetAsmOrdersFromSalesHeader(SalesHeader,2);

      // Verify - assembly order 1
      AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item1,'',LocationCode,DueDate1,
        Item1."Base Unit of Measure",OrderQty1,1);

      // Verify - assembly order 2
      AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item2,'',LocationCode,DueDate2,
        Item2."Base Unit of Measure",OrderQty2,1);
    END;

    [Test]
    PROCEDURE ATOReadOnlyAO@30();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC18ATOReadOnlyAO('',LocationBlue.Code,DocumentType::Order);
    END;

    [Test]
    PROCEDURE ATOReadOnlyQuote@162();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC18ATOReadOnlyAO('',LocationBlue.Code,DocumentType::Quote);
    END;

    [Test]
    PROCEDURE ATOReadOnlyBlanketOrder@161();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC18ATOReadOnlyAO('',LocationBlue.Code,DocumentType::"Blanket Order");
    END;

    LOCAL PROCEDURE TC18ATOReadOnlyAO@32(LocationCode@1003 : Code[10];NewLocationCode@1010 : Code[10];SalesDocumentType@1011 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order');
    VAR
      Item@1004 : Record 27;
      TestItem@1007 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      UnitOfMeasure@1008 : Record 204;
      ItemVariant@1009 : Record 5401;
      NoOfAssemblyOrders@1000 : Integer;
      OrderQty@1002 : Integer;
      DueDate@1006 : Date;
    BEGIN
      // TC18 from the TDS - see Documentation
      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      LibraryInventory.CreateItemVariant(ItemVariant,Item."No.");
      LibraryInventory.CreateItem(TestItem);

      // Create the "assembled" Item
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      AddItemUOM(Item,LibraryRandom.RandInt(1000),UnitOfMeasure.Code);

      NoOfAssemblyOrders := CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType));

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,Item."No.",'',OrderQty,DueDate,LocationCode);

      // Assert that 1 assembly orders is created for the ATO items placed on sales order line
      Assert.AreEqual(NoOfAssemblyOrders + 1,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),OneAsmOrderCreateMsg);

      // Verify - assembly order
      AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,'',LocationCode,DueDate,
        Item."Base Unit of Measure",OrderQty,1);

      // commit as there are several consecutive assert errors.
      COMMIT;

      // Try to change fields on assembly header
      ASSERTERROR AssemblyHeader.VALIDATE("Item No.",TestItem."No.");
      ASSERTERROR AssemblyHeader.VALIDATE(Quantity,OrderQty + 1);
      ASSERTERROR AssemblyHeader.VALIDATE("Due Date",CALCDATE('<+1D>',DueDate));
      ASSERTERROR AssemblyHeader.DELETE(TRUE);
      ASSERTERROR AssemblyHeader.VALIDATE("Unit of Measure Code",UnitOfMeasure.Code);
      ASSERTERROR AssemblyHeader.VALIDATE("Variant Code",ItemVariant.Code);
      ASSERTERROR AssemblyHeader.VALIDATE("Location Code",NewLocationCode);
    END;

    [Test]
    PROCEDURE ATOSameItemAO@34();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC110ATOMultipleSameItemAO('',DocumentType::Order);
    END;

    [Test]
    PROCEDURE ATOSameItemQuote@153();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC110ATOMultipleSameItemAO('',DocumentType::Quote);
    END;

    [Test]
    PROCEDURE ATOSameItemBlanketOrder@146();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC110ATOMultipleSameItemAO('',DocumentType::"Blanket Order");
    END;

    LOCAL PROCEDURE TC110ATOMultipleSameItemAO@16(LocationCode@1003 : Code[10];SalesDocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order');
    VAR
      Item@1000 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1015 : Record 37;
      OrderQty1@1006 : Integer;
      DueDate1@1007 : Date;
      OrderQty2@1008 : Integer;
      DueDate2@1004 : Date;
      NoOfAssemblyOrders@1018 : Integer;
    BEGIN
      // TC110 from the TDS - see Documentation

      // Create the "assembled" Items
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      NoOfAssemblyOrders := CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType));

      // Exercise - create SOLs with ATO items
      OrderQty1 := LibraryRandom.RandInt(1000);
      DueDate1 := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,Item."No.",'',OrderQty1,DueDate1,LocationCode);
      OrderQty2 := LibraryRandom.RandInt(1000);
      DueDate2 := CALCDATE('<+1D>',DueDate1);
      AddSalesOrderLine(SalesHeader,SalesLine,Item."No.",LocationCode,'',OrderQty2,DueDate2);

      // Assert that 2 assembly orders are created for the 2 ATO item placed on sales order lines
      Assert.AreEqual(NoOfAssemblyOrders + 2,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),TwoAsmOrdersCreateMsg);

      // Verify - assembly order AO1
      AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,'',LocationCode,DueDate1,
        Item."Base Unit of Measure",OrderQty1,1);

      // Verify - assembly order AO2
      AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,'',LocationCode,DueDate2,
        Item."Base Unit of Measure",OrderQty2,1);
    END;

    [Test]
    PROCEDURE KitInAKitAO@48();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC111ATOKitInAKitAO('',DocumentType::Order);
    END;

    [Test]
    PROCEDURE KitInAKitQuote@160();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC111ATOKitInAKitAO('',DocumentType::Quote);
    END;

    [Test]
    PROCEDURE KitInAKitBlanketOrder@159();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC111ATOKitInAKitAO('',DocumentType::"Blanket Order");
    END;

    LOCAL PROCEDURE TC111ATOKitInAKitAO@44(LocationCode@1003 : Code[10];SalesDocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order');
    VAR
      Item@1000 : Record 27;
      ChildItem@1009 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      BOMComponent@1012 : Record 90;
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
      NoOfAssemblyOrders@1018 : Integer;
    BEGIN
      // TC111 from the TDS - see Documentation

      // Create the "assembled" Items
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      CreateAssembledItem(ChildItem,ChildItem."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Create the kit in a kit
      AddComponentToAssemblyList(BOMComponent,BOMComponent.Type::Item,ChildItem."No.",Item."No.",'',
        BOMComponent."Resource Usage Type"::Direct,ChildItem."Base Unit of Measure",LibraryRandom.RandInt(1000));

      NoOfAssemblyOrders := CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType));

      // Exercise - create SOLs with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,Item."No.",'',OrderQty,DueDate,LocationCode);

      // Assert that one assembly order is created for the ATO item placed on sales order lines
      Assert.AreEqual(NoOfAssemblyOrders + 1,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),OneAsmOrderCreateMsg);

      // Verify - assembly order including additional comp
      AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,'',LocationCode,DueDate,
        Item."Base Unit of Measure",OrderQty,1);
      AssertAssemblyLinesDefaultBOM(AssemblyHeader,BOMComponent,LocationCode,1);
    END;

    [Test]
    PROCEDURE ATOToATSOrder@50();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOToATSAO('',DocumentType::Order,TRUE);
    END;

    [Test]
    PROCEDURE ATSToATOOrder@52();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOToATSAO('',DocumentType::Order,FALSE);
    END;

    [Test]
    PROCEDURE ATOToATSQuote@61();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOToATSAO('',DocumentType::Quote,TRUE);
    END;

    [Test]
    PROCEDURE ATSToATOQuote@60();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOToATSAO('',DocumentType::Quote,FALSE);
    END;

    [Test]
    PROCEDURE ATOToATSBlanketOrder@86();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOToATSAO('',DocumentType::"Blanket Order",TRUE);
    END;

    [Test]
    PROCEDURE ATSToATOBlanketOrder@75();
    VAR
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOToATSAO('',DocumentType::"Blanket Order",FALSE);
    END;

    LOCAL PROCEDURE TCXATOToATSAO@43(LocationCode@1003 : Code[10];SalesDocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';StartwithATO@1004 : Boolean);
    VAR
      ItemATO@1000 : Record 27;
      ItemATS@1008 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1015 : Record 37;
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
      ItemNo@1013 : Code[20];
      NoOfAssemblyOrders@1018 : Integer;
    BEGIN
      // TC113 and TC114 from the TDS - see Documentation

      // Create the "assembled" Items
      CreateAssembledItem(ItemATO,ItemATO."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        ItemATO."Costing Method"::FIFO);
      CreateAssembledItem(ItemATS,ItemATS."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        ItemATS."Costing Method"::FIFO);
      IF StartwithATO THEN
        ItemNo := ItemATO."No."
      ELSE
        ItemNo := ItemATS."No.";

      NoOfAssemblyOrders := CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType));

      // Exercise - create SOL with ATO/ATS item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,ItemNo,'',OrderQty,DueDate,LocationCode);
      FindSOL(SalesHeader,SalesLine,1);

      // Assert that one assembly order is created for the ATO item placed on sales order lines
      // And no new one for ATS item
      IF StartwithATO THEN BEGIN
        Assert.AreEqual(NoOfAssemblyOrders + 1,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),OneAsmOrderCreateMsg);
        AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),ItemATO,'',LocationCode,
          DueDate,ItemATO."Base Unit of Measure",OrderQty,1);
        ItemNo := ItemATS."No.";
      END
      ELSE BEGIN
        Assert.AreEqual(NoOfAssemblyOrders,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),NoAsmOrderCreateMsg);
        ItemNo := ItemATO."No.";
      END;

      IF StartwithATO THEN BEGIN
        // Exercise check item no cannot be switched if Qty to asm <>0
        COMMIT;
        ASSERTERROR SalesLine.VALIDATE("No.",ItemNo);

        // Exercise - Change Qty to asm to 0 and then item no
        SalesLine.VALIDATE("Qty. to Assemble to Order",0);
        SalesLine.VALIDATE("No.",ItemNo);
        SalesLine.MODIFY(TRUE);
      END
      ELSE BEGIN
        SalesLine.VALIDATE("No.",ItemNo);
        // Shipment date gets "reseted" when changing item no
        SalesLine.VALIDATE("Shipment Date",DueDate);
        SalesLine.MODIFY(TRUE);
      END;

      // Assert that after switch assembly order is created when ATS to ATO switch is done
      // And new ATO is deleted from ATO to ATS switch
      IF StartwithATO THEN BEGIN
        Assert.AreEqual(NoOfAssemblyOrders,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),OneAsmOrderDeleteMsg);
      END
      ELSE BEGIN
        Assert.AreEqual(NoOfAssemblyOrders + 1,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),OneAsmOrderCreateMsg);
        AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),ItemATO,'',LocationCode,DueDate,
          ItemATO."Base Unit of Measure",OrderQty,1);
      END;
    END;

    [Test]
    PROCEDURE ATSCheckNoAO@25();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
    BEGIN
      Initialize;
      TCxATSNoATO(Item."Assembly Policy"::"Assemble-to-Stock",'',AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSCheckNoReserv@73();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
    BEGIN
      Initialize;
      TCxATSNoATO(Item."Assembly Policy"::"Assemble-to-Stock",'',AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATSCheckNoHardLink@64();
    VAR
      Item@1002 : Record 27;
      AssertOption@1000 : 'Orders,Reservation,Hard link';
    BEGIN
      Initialize;
      TCxATSNoATO(Item."Assembly Policy"::"Assemble-to-Stock",'',AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATONegativeNoAO@92();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
    BEGIN
      Initialize;
      TCxATSNoATO(Item."Assembly Policy"::"Assemble-to-Order",'',AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATONegativeNoReserv@91();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
    BEGIN
      Initialize;
      TCxATSNoATO(Item."Assembly Policy"::"Assemble-to-Order",'',AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATONegativeNoHardLink@90();
    VAR
      Item@1002 : Record 27;
      AssertOption@1000 : 'Orders,Reservation,Hard link';
    BEGIN
      Initialize;
      TCxATSNoATO(Item."Assembly Policy"::"Assemble-to-Order",'',AssertOption::"Hard link");
    END;

    LOCAL PROCEDURE TCxATSNoATO@66(AssemblyPolicy@1003 : 'Assemble-to-Stock,Assemble-to-Order';LocationCode@1002 : Code[10];AssertOption@1004 : 'Orders,Reservation,Hard link');
    VAR
      Item@1011 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1008 : Record 37;
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
      NoOfAssemblyOrders@1000 : Integer;
      NoOfResEntries@1009 : Integer;
      NoOfHardLinkEntries@1010 : Integer;
    BEGIN
      // TC128 and TC141 from the TDS - see Documentation

      NoOfAssemblyOrders := CountAssemblyOrders(AssemblyHeader."Document Type"::Order);
      NoOfResEntries := CountReservationEntries;
      NoOfHardLinkEntries := CountHardLinkEntries;

      CreateAssembledItem(Item,AssemblyPolicy,LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATS item or with ATO item and negative qty
      OrderQty := LibraryRandom.RandInt(1000);
      IF AssemblyPolicy = Item."Assembly Policy"::"Assemble-to-Order" THEN
        OrderQty := -OrderQty;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,LocationCode);
      FindSOL(SalesHeader,SalesLine,1);

      CASE AssertOption OF
        // Assert Assembly order created
        AssertOption::Orders:
          // Assert that no assembly order is created for the ATO items placed on sales order line
          Assert.AreEqual(NoOfAssemblyOrders,CountAssemblyOrders(AssemblyHeader."Document Type"::Order),NoAsmOrderCreateMsg);
        // Assert no new reservation entries
        AssertOption::Reservation:
          Assert.AreEqual(NoOfResEntries,CountReservationEntries,NoReservEntryCreateMsg);
        // Assert hard link entry
        AssertOption::"Hard link":
          Assert.AreEqual(NoOfHardLinkEntries,NoOfHardLinkEntries,NoHardLinkCreateMsg);
      END;
    END;

    [Test]
    PROCEDURE ATSInATOCheckAO@74();
    VAR
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATSInATOCheck('',DocumentType::Order,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOCheckResEntry@85();
    VAR
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATSInATOCheck('',DocumentType::Order,AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATSInATOCheckHardLinkOrder@84();
    VAR
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATSInATOCheck('',DocumentType::Order,AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATSInATOCheckQuote@163();
    VAR
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATSInATOCheck('',DocumentType::Quote,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOCheckHardLinkQuote@89();
    VAR
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATSInATOCheck('',DocumentType::Quote,AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATSInATOCheckBlanketOrder@165();
    VAR
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATSInATOCheck('',DocumentType::"Blanket Order",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOChkHardLinkBlnktOrder@164();
    VAR
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      DocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATSInATOCheck('',DocumentType::"Blanket Order",AssertOption::"Hard link");
    END;

    LOCAL PROCEDURE TCXATSInATOCheck@18(LocationCode@1003 : Code[10];SalesDocumentType@1009 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';AssertOption@1004 : 'Orders,Reservation,Hard link');
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1008 : Record 37;
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
      NoOfAssemblyOrders@1000 : Integer;
    BEGIN
      // TC133, TC134, TC135 from the TDS - see Documentation
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      NoOfAssemblyOrders := CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType));

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,Item."No.",'',OrderQty,DueDate,LocationCode);
      FindSOL(SalesHeader,SalesLine,1);

      // Make ATS as ATO
      SetQtyToAssembleToOrder(SalesLine,OrderQty);

      // Assert
      FindAssemblyHeader(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,'',LocationCode,DueDate,
        Item."Base Unit of Measure",OrderQty);
      CASE AssertOption OF
        // Assert Assembly order created
        AssertOption::Orders:
          BEGIN
            // Assert that 1 assembly order is created for the ATO items placed on sales order line
            Assert.AreEqual(
              NoOfAssemblyOrders + 1,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),OneAsmOrderCreateMsg);

            // Verify - assembly order
            AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,'',LocationCode,DueDate,
              Item."Base Unit of Measure",OrderQty,1);
          END;
        // Assert reservation entries
        AssertOption::Reservation:
          AssertReservationEntries(SalesLine,AssemblyHeader);
        // Assert hard link entry
        AssertOption::"Hard link":
          LibraryAssembly.VerifyHardLinkEntry(SalesLine,AssemblyHeader,1);
      END;
    END;

    [Test]
    PROCEDURE ATOSyncQtyCheckAO@80();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::Quantity,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncQtyToAsmCheckAO@104();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Quantity to Assemble",
        AssertOption::Orders);
    END;

    [Test]
    [HandlerFunctions(LocationCodeConfirm)]
    PROCEDURE ATOSyncLocationCodeCheckAO@103();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Location Code",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncVariantCodeCheckAO@102();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Variant Code",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncUOMCheckAO@105();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::UOM,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncDueDateCheckAO@106();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Due Date",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncQtyCheckReservation@40();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::Quantity,AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATOSyncQtyToAsmCheckReserv@39();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Quantity to Assemble",
        AssertOption::Reservation);
    END;

    LOCAL PROCEDURE CalculateDateUsingDefaultSafetyLeadTime@279() : Date;
    VAR
      ManufacturingSetup@1000 : Record 99000765;
    BEGIN
      ManufacturingSetup.GET;
      EXIT(CALCDATE(ManufacturingSetup."Default Safety Lead Time",WORKDATE));
    END;

    [Test]
    [HandlerFunctions(LocationCodeConfirm)]
    PROCEDURE ATOSyncLocationCodeCheckReserv@38();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Location Code",
        AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATOSyncVariantCodeCheckReserv@33();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Variant Code",
        AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATOSyncUOMCheckReservation@21();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::UOM,AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATOSyncDueDateCheckReservation@17();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Due Date",AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATOSyncQtyCheckHardLink@67();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::Quantity,AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOSyncQtyToAsmCheckHardLink@59();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Quantity to Assemble",
        AssertOption::"Hard link");
    END;

    [Test]
    [HandlerFunctions(LocationCodeConfirm)]
    PROCEDURE ATOSyncLocationCodeChkHardLink@54();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Location Code",
        AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOSyncVariantCodeChkHardLink@51();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Variant Code",
        AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOSyncUOMCheckHardLink@49();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::UOM,AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOSyncDueDateCheckHardLink@46();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Order,ChangeOption::"Due Date",AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATSInATOSyncQtyCheckAO@131();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::Quantity,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncQtyToAsmCheckAO@130();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Quantity to Assemble",
        AssertOption::Orders);
    END;

    [Test]
    [HandlerFunctions(LocationCodeConfirm)]
    PROCEDURE ATSInATOSyncLocCodeCheckAO@129();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Location Code",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncVariantCodeCheckAO@128();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Variant Code",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncUOMCheckAO@126();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::UOM,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncDueDateCheckAO@124();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Due Date",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncQtyChkReservation@123();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::Quantity,AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATSInATOSyncQtyToAsmChkReserv@122();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Quantity to Assemble",
        AssertOption::Reservation);
    END;

    [Test]
    [HandlerFunctions(LocationCodeConfirm)]
    PROCEDURE ATSInATOSyncLocCodeChkReserv@121();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Location Code",
        AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATSInATOSyncVarCodeChkReserv@120();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Variant Code",
        AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATSInATOSyncUOMChkReservation@119();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::UOM,AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATSInATOSyncDueDateChkReserv@118();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Due Date",AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATSInATOSyncQtyCheckHardLink@117();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::Quantity,AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATSInATOSyncQtyToAsmChkHardLnk@116();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Quantity to Assemble",
        AssertOption::"Hard link");
    END;

    [Test]
    [HandlerFunctions(LocationCodeConfirm)]
    PROCEDURE ATSInATOSyncLocCodeChkHardLink@115();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Location Code",
        AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATSInATOSyncVarCodeChkHardLink@111();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Variant Code",
        AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATSInATOSyncUOMCheckHardLink@110();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::UOM,AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATSInATOSyncDueDateChkHardLink@109();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Order,ChangeOption::"Due Date",AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOSyncQtyCheckQuote@205();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Quote,ChangeOption::Quantity,AssertOption::Orders);
    END;

    [Test]
    [HandlerFunctions(LocationCodeConfirm)]
    PROCEDURE ATOSyncLocationCodeCheckQuote@203();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Quote,ChangeOption::"Location Code",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncVariantCodeCheckQuote@202();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Quote,ChangeOption::"Variant Code",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncUOMCheckQuote@201();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Quote,ChangeOption::UOM,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncDueDateCheckQuote@200();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::Quote,ChangeOption::"Due Date",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncQtyCheckQuote@187();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Quote,ChangeOption::Quantity,AssertOption::Orders);
    END;

    [Test]
    [HandlerFunctions(LocationCodeConfirm)]
    PROCEDURE ATSInATOSyncLocCodeCheckQuote@185();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Quote,ChangeOption::"Location Code",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncVariantCodeCheckQ@184();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Quote,ChangeOption::"Variant Code",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncUOMCheckQuote@183();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Quote,ChangeOption::UOM,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncDueDateCheckQuote@182();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::Quote,ChangeOption::"Due Date",AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncQtyCheckBlanketOrder@217();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(
        Item."Assembly Policy"::"Assemble-to-Order",DocumentType::"Blanket Order",ChangeOption::Quantity,AssertOption::Orders);
    END;

    [Test]
    [HandlerFunctions(LocationCodeConfirm)]
    PROCEDURE ATOSyncLocationCodeCheckBlnktO@215();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::"Blanket Order",ChangeOption::"Location Code",
        AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncVariantCodeCheckBlnktOr@214();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::"Blanket Order",ChangeOption::"Variant Code",
        AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncUOMCheckBlnktOrdr@213();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::"Blanket Order",ChangeOption::UOM,
        AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOSyncDueDateCheckBlnktOrdr@212();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Order",DocumentType::"Blanket Order",ChangeOption::"Due Date",
        AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ItemCategoryAndProductGroupCodeAfterPostingAssemblyOrder@249();
    VAR
      ComponentItem@1000 : Record 27;
      ParentItem@1001 : Record 27;
      AssemblyHeader@1002 : Record 900;
      AssemblyLine@1005 : Record 901;
      Location@1007 : Record 14;
    BEGIN
      // [FEATURE] [Assembly] [Item Ledger Entry]
      // [SCENARIO 376029] Item Category Code and Product Group Code should be replicated on Item Ledger Entry after Posting Assembly Order
      Initialize;

      // [GIVEN] Parent Item with Item Category Code = "X1" and Product Group Code = "Y1"
      CreateItemWithCategoryAndProductCode(ParentItem);

      // [GIVEN] Component Item with Item Category Code = "X2" and Product Group Code = "Y2"
      CreateItemWithCategoryAndProductCode(ComponentItem);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      LibraryPatterns.POSTPositiveAdjustment(
        ComponentItem,Location.Code,'','',LibraryRandom.RandIntInRange(10,100),WORKDATE,LibraryRandom.RandInt(10));

      // [GIVEN] Assembly Order for Parent Item
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,CalculateDateUsingDefaultSafetyLeadTime,ParentItem."No.",Location.Code,LibraryRandom.RandInt(9),'');
      LibraryAssembly.CreateAssemblyLine(AssemblyHeader,AssemblyLine,AssemblyLine.Type::Item,ComponentItem."No.",
        ComponentItem."Base Unit of Measure",LibraryRandom.RandInt(5),LibraryRandom.RandInt(5),'');

      // [WHEN] Post Assembly Order
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // [THEN] Item Ledger Entry is created for Parent Item with Item Category Code = "X1" and Product Group Code = "Y1"
      VerifyItemLedgerEntryCategoryAndGroupCode(ParentItem,AssemblyHeader."No.");

      // [THEN] Item Ledger Entry is created for Component Item with Item Category Code = "X2" and Product Group Code = "Y2"
      VerifyItemLedgerEntryCategoryAndGroupCode(ComponentItem,AssemblyHeader."No.");
    END;

    [Test]
    PROCEDURE ATSInATOSyncQtyCheckBlnktOrdr@211();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(
        Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::"Blanket Order",ChangeOption::Quantity,AssertOption::Orders);
    END;

    [Test]
    [HandlerFunctions(LocationCodeConfirm)]
    PROCEDURE ATSInATOSyncLocCodeCheckBlnktO@209();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::"Blanket Order",ChangeOption::"Location Code",
        AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncVariantCodeChkBlnk@208();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::"Blanket Order",ChangeOption::"Variant Code",
        AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncUOMCheckBlnktOrder@207();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::"Blanket Order",ChangeOption::UOM,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATSInATOSyncDueDateCheckBlnktO@206();
    VAR
      Item@1000 : Record 27;
      AssertOption@1002 : 'Orders,Reservation,Hard link';
      ChangeOption@1003 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCXATOSync(Item."Assembly Policy"::"Assemble-to-Stock",DocumentType::"Blanket Order",ChangeOption::"Due Date",
        AssertOption::Orders);
    END;

    LOCAL PROCEDURE TCXATOSync@79(AssemblyPolicy@1014 : 'Assemble-to-Stock,Assemble-to-Order';SalesDocumentType@1015 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';ChangeOption@1002 : 'Quantity,Quantity to Assemble,Location Code,Variant Code,UOM,Due Date';AssertOption@1004 : 'Orders,Reservation,Hard link');
    VAR
      Item@1010 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1008 : Record 37;
      ItemVariant@1011 : Record 5401;
      UnitOfMeasure@1013 : Record 204;
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
      LocationCode@1003 : Code[10];
      VariantCode@1009 : Code[10];
      UOMCode@1012 : Code[10];
      NoOfAssemblyOrders@1000 : Integer;
    BEGIN
      // TC21, TC22, TC23, TC24, TC25, TC120, TC121, TC122, TC123, TC130, TC133, TC134 from the TDS - see Documentation

      NoOfAssemblyOrders := CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType));

      // Create the assembled item
      CreateAssembledItem(Item,AssemblyPolicy,LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      UOMCode := Item."Base Unit of Measure";
      LocationCode := '';
      VariantCode := '';

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,Item."No.",VariantCode,OrderQty,DueDate,LocationCode);
      FindSOL(SalesHeader,SalesLine,1);

      // IF ATS then "transform" ATS into ATO item
      IF AssemblyPolicy = Item."Assembly Policy"::"Assemble-to-Stock" THEN
        SetQtyToAssembleToOrder(SalesLine,OrderQty);

      // exercise - change field
      CASE ChangeOption OF
        ChangeOption::Quantity:
          BEGIN
            OrderQty := OrderQty - 1;
            SalesLine.VALIDATE(Quantity,OrderQty);
            SalesLine.MODIFY(TRUE);
          END;
        ChangeOption::"Quantity to Assemble":
          BEGIN
            OrderQty := OrderQty - 1;
            SetQtyToAssembleToOrder(SalesLine,OrderQty);
          END;
        ChangeOption::"Location Code":
          BEGIN
            LocationCode := LocationBlue.Code;
            SalesLine.VALIDATE("Location Code",LocationCode);
            // When changing location code, the shipment date gets reseted so "redo" the shipment date
            SalesLine.VALIDATE("Shipment Date",DueDate);
            SalesLine.MODIFY(TRUE);
          END;
        ChangeOption::"Variant Code":
          BEGIN
            LibraryInventory.CreateItemVariant(ItemVariant,Item."No.");
            VariantCode := ItemVariant.Code;
            SalesLine.VALIDATE("Variant Code",VariantCode);
            SalesLine.MODIFY(TRUE);
          END;
        ChangeOption::UOM:
          BEGIN
            LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
            AddItemUOM(Item,LibraryRandom.RandInt(1000),UnitOfMeasure.Code);
            UOMCode := UnitOfMeasure.Code;
            SalesLine.VALIDATE("Unit of Measure Code",UOMCode);
            SalesLine.MODIFY(TRUE);
          END;
        ChangeOption::"Due Date":
          BEGIN
            DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(3)) + 'D>',DueDate);
            SalesLine.VALIDATE("Shipment Date",DueDate);
            SalesLine.MODIFY(TRUE);
          END;
      END;

      // assert that sync was ok
      FindAssemblyHeader(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,VariantCode,LocationCode,DueDate,
        UOMCode,OrderQty);

      CASE AssertOption OF
        // Assert Assembly order created
        AssertOption::Orders:
          BEGIN
            // Assert that 1 assembly order is created for the ATO items placed on sales order line
            Assert.AreEqual(
              NoOfAssemblyOrders + 1,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),OneAsmOrderCreateMsg);
            // Verify - assembly order
            AssertAsmOrderForDefaultBOM(
              AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,VariantCode,LocationCode,DueDate,
              UOMCode,OrderQty,1);
          END;
        // Assert reservation entries
        AssertOption::Reservation:
          AssertReservationEntries(SalesLine,AssemblyHeader);
        // Assert hard link entry
        AssertOption::"Hard link":
          LibraryAssembly.VerifyHardLinkEntry(SalesLine,AssemblyHeader,1);
      END;
    END;

    [Test]
    PROCEDURE ATONegativePostAOAlone@69();
    BEGIN
      Initialize;
      TC136PostAOAlone('');
    END;

    LOCAL PROCEDURE TC136PostAOAlone@45(LocationCode@1011 : Code[10]);
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
    BEGIN
      // TC136 from the TDS - see Documentation

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,LocationCode);

      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,Item,'',LocationCode,DueDate,
        Item."Base Unit of Measure",OrderQty);

      // Exercise & verify - try to post AO - error
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,ERR_POST_AOT);
    END;

    [Test]
    [HandlerFunctions(MsgHandlerPostedAOs,AvailabilityWindowHandler)]
    PROCEDURE ATOBatchPostAO@13();
    BEGIN
      Initialize;
      TC137BatchPostAO('');
    END;

    LOCAL PROCEDURE TC137BatchPostAO@3(LocationCode@1011 : Code[10]);
    VAR
      Item@1002 : Record 27;
      AssemblyHeaderRegular@1005 : Record 900;
      AssemblyHeaderATO@1003 : Record 900;
      AssemblyHeader@1009 : Record 900;
      SalesHeader@1001 : Record 36;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      // TC137 from the TDS - see Documentation

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,LocationCode);
      FindAssemblyHeader(AssemblyHeaderATO,AssemblyHeader."Document Type"::Order,Item,'',LocationCode,
        DueDate,Item."Base Unit of Measure",OrderQty);

      // Create manually an AO for ATO item
      CreateAssemblyOrder(AssemblyHeaderRegular,Item,LocationCode,'',DueDate,OrderQty);
      AddInvNonDirectLocAllComponent(AssemblyHeaderRegular,100);

      // Exercise - batch post AOs - for the ATO item
      CLEAR(AssemblyHeader);
      AssemblyHeader.SETRANGE("Item No.",Item."No.");
      LibraryAssembly.BatchPostAssemblyHeaders(AssemblyHeader,0D,FALSE,'');

      // Verify - only manually created AO is posted
      AssertNoAssemblyHeader(AssemblyHeaderRegular."Document Type",AssemblyHeaderRegular."No.");
      AssemblyHeaderATO.GET(AssemblyHeaderATO."Document Type",AssemblyHeaderATO."No.");
      Assert.AreEqual(0,AssemblyHeaderATO."Assembled Quantity",NoQtyPostedMsg);
    END;

    [Test]
    PROCEDURE ATOShipSO@81();
    BEGIN
      Initialize;
      TC145PostSO('');
    END;

    LOCAL PROCEDURE TC145PostSO@93(LocationCode@1011 : Code[10]);
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1009 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1005 : Record 37;
      TempAssemblyLine@1004 : TEMPORARY Record 901;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      // TC145 from the TDS - see Documentation

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,LocationCode);
      FindSOL(SalesHeader,SalesLine,1);
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,Item,'',LocationCode,
        DueDate,Item."Base Unit of Measure",OrderQty);
      CopyAsmLinesToTemp(AssemblyHeader,TempAssemblyLine);

      // Add enough inventory for comp
      AddInvNonDirectLocAllComponent(AssemblyHeader,100);

      // Exercise - post SOs
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify - AO is posted
      AssertNoAssemblyHeader(AssemblyHeader."Document Type",AssemblyHeader."No.");
      LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine,AssemblyHeader,OrderQty);
    END;

    [Test]
    PROCEDURE ATOToATOOrder@114();
    VAR
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC119ATOChangetoATO('',DocumentType::Order,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOToATOReservationEntries@113();
    VAR
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC119ATOChangetoATO('',DocumentType::Order,AssertOption::Reservation);
    END;

    [Test]
    PROCEDURE ATOToATOCheckHardLink@112();
    VAR
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC119ATOChangetoATO('',DocumentType::Order,AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOToATOQuote@158();
    VAR
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC119ATOChangetoATO('',DocumentType::Order,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOToATOCheckHardLinkQuote@42();
    VAR
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC119ATOChangetoATO('',DocumentType::Order,AssertOption::"Hard link");
    END;

    [Test]
    PROCEDURE ATOToATOBlanketOrder@167();
    VAR
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC119ATOChangetoATO('',DocumentType::Order,AssertOption::Orders);
    END;

    [Test]
    PROCEDURE ATOToATOCheckHardLinkBlanketO@166();
    VAR
      AssertOption@1000 : 'Orders,Reservation,Hard link';
      DocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TC119ATOChangetoATO('',DocumentType::Order,AssertOption::"Hard link");
    END;

    LOCAL PROCEDURE TC119ATOChangetoATO@99(LocationCode@1003 : Code[10];SalesDocumentType@1004 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';AssertOption@1002 : 'Orders,Reservation,Hard link');
    VAR
      ItemATO1@1000 : Record 27;
      ItemATO2@1008 : Record 27;
      AssemblyHeader@1005 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1015 : Record 37;
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
      NoOfAssemblyOrders@1018 : Integer;
    BEGIN
      // TC119 from the TDS - see Documentation

      // Create the "assembled" Items
      CreateAssembledItem(ItemATO1,ItemATO1."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        ItemATO1."Costing Method"::FIFO);
      CreateAssembledItem(ItemATO2,ItemATO2."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        ItemATO2."Costing Method"::FIFO);

      NoOfAssemblyOrders := CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType));

      // Exercise - create SOL with first ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,ItemATO1."No.",'',OrderQty,DueDate,LocationCode);
      FindSOL(SalesHeader,SalesLine,1);

      // Assert that one assembly order is created for the ATO item placed on sales order lines
      Assert.AreEqual(NoOfAssemblyOrders + 1,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),
        'One new Assembly Order should be created');

      // Exercise - Change item to second ATO item
      SalesLine.VALIDATE("Qty. to Assemble to Order",0);
      SalesLine.VALIDATE("No.",ItemATO2."No.");
      // Shipment date gets "reseted" when changing item no
      SalesLine.VALIDATE("Shipment Date",DueDate);
      SalesLine.MODIFY(TRUE);

      // Assert that after switch entries are updated as per second ATO item
      FindAssemblyHeader(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),ItemATO2,'',LocationCode,DueDate,
        ItemATO2."Base Unit of Measure",OrderQty);

      CASE AssertOption OF
        // Assert Assembly order created
        AssertOption::Orders:
          BEGIN
            // Assert that no new assembly order is created comparing to previous step
            Assert.AreEqual(NoOfAssemblyOrders + 1,CountAssemblyOrders(GetAsmTypeForSalesType(SalesDocumentType)),AsmOrderReUsedMsg);
            // Verify - assembly order
            AssertAsmOrderForDefaultBOM(AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),ItemATO2,'',LocationCode,DueDate,
              ItemATO2."Base Unit of Measure",OrderQty,1);
          END;
        // Assert reservation entries
        AssertOption::Reservation:
          AssertReservationEntries(SalesLine,AssemblyHeader);
        // Assert hard link entry
        AssertOption::"Hard link":
          LibraryAssembly.VerifyHardLinkEntry(SalesLine,AssemblyHeader,1);
      END;
    END;

    [MessageHandler]
    PROCEDURE MsgHandlerPostedAOs@71(Msg@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(STRPOS(Msg,MSG_BEEN_POSTED) > 0,Msg);
    END;

    [ConfirmHandler]
    PROCEDURE LocationCodeConfirm@97(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,MSG_UPDATE) > 0,Question);

      Reply := TRUE;
    END;

    [Test]
    PROCEDURE ATOShipSONotEnoughComp@100();
    BEGIN
      Initialize;
      TC146PostSONotEnoughComp('');
    END;

    LOCAL PROCEDURE TC146PostSONotEnoughComp@98(LocationCode@1011 : Code[10]);
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1009 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1005 : Record 37;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      // TC146 from the TDS - see Documentation

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,LocationCode);
      FindSOL(SalesHeader,SalesLine,1);
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,Item,'',LocationCode,
        DueDate,Item."Base Unit of Measure",OrderQty);

      // Add not enough inventory for comp
      AddInvNonDirectLocAllComponent(AssemblyHeader,50);

      // Exercise - post SOs and see it doesn't post
      ASSERTERROR LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      Assert.ExpectedError(ERR_NOT_ENOUGH);
    END;

    [Test]
    PROCEDURE ATOPostFullSO2Steps@107();
    BEGIN
      Initialize;
      TCPostFullSO2Steps('');
    END;

    LOCAL PROCEDURE TCPostFullSO2Steps@101(LocationCode@1011 : Code[10]);
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1009 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1005 : Record 37;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,LocationCode);
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,Item,'',LocationCode,DueDate,
        Item."Base Unit of Measure",OrderQty);
      FindSOL(SalesHeader,SalesLine,1);

      // Add enough inventory for comp
      AddInvNonDirectLocAllComponent(AssemblyHeader,100);

      // set order to be posted partially
      SalesLine.VALIDATE("Qty. to Ship",OrderQty / 2);
      SalesLine.MODIFY(TRUE);

      // Exercise - post
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      // Refresh lines as posting is changing them
      SalesLine.GET(SalesLine."Document Type",SalesLine."Document No.",SalesLine."Line No.");
      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");

      // Verify - AO is posted partially
      AssemblyHeader.TESTFIELD("Assembled Quantity",OrderQty / 2);
      AssemblyHeader.TESTFIELD("Remaining Quantity",OrderQty / 2);

      // post rest - before save lines to temp
      SalesLine.VALIDATE("Qty. to Ship",OrderQty / 2);
      SalesLine.MODIFY(TRUE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify - AO is posted fully
      AssertNoAssemblyHeader(AssemblyHeader."Document Type",AssemblyHeader."No.");
    END;

    [Test]
    PROCEDURE ATOPost2SOL2Steps@173();
    BEGIN
      Initialize;
      TCPost2SOL2Steps('');
    END;

    LOCAL PROCEDURE TCPost2SOL2Steps@169(LocationCode@1011 : Code[10]);
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1009 : Record 900;
      PostedAssemblyHeader@1003 : Record 910;
      SalesHeader@1001 : Record 36;
      SalesLine@1005 : Record 37;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create 2 SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,LocationCode);
      AddSalesOrderLine(SalesHeader,SalesLine,Item."No.",LocationCode,'',OrderQty,DueDate);

      // Verify 2 AOs created
      AssertAssemblyHeader(
        AssemblyHeader,AssemblyHeader."Document Type"::Order,Item,'',LocationCode,DueDate,Item."Base Unit of Measure",OrderQty,2);

      // Add enough inventory for comp for both AOs
      AddInvNonDirectLocAllComponent(AssemblyHeader,200);

      // set order to be posted partially (1 line)
      SalesLine.VALIDATE("Qty. to Ship",0);
      SalesLine.MODIFY(TRUE);

      // Exercise - post SO
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // VERIFY: Exactly one Posted Assembly Headers for Item
      CLEAR(PostedAssemblyHeader);
      PostedAssemblyHeader.SETRANGE("Item No.",Item."No.");
      Assert.AreEqual(1,PostedAssemblyHeader.COUNT,OneAsmOrderPostedMsg);

      // post rest - 2nd line - first refetch sales line from DB as it changed during posting
      SalesLine.GET(SalesLine."Document Type",SalesLine."Document No.",SalesLine."Line No.");
      SalesLine.VALIDATE("Qty. to Ship",OrderQty);
      SalesLine.MODIFY(TRUE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify - AOs are posted
      CLEAR(PostedAssemblyHeader);
      PostedAssemblyHeader.SETRANGE("Item No.",Item."No.");
      Assert.AreEqual(2,PostedAssemblyHeader.COUNT,BothAsmOrdersPostedMsg);
    END;

    [Test]
    [HandlerFunctions(MsgHandlerPostedAOs)]
    PROCEDURE ATOBatchPostSO@132();
    BEGIN
      Initialize;
      TCBatchPostSO('');
    END;

    LOCAL PROCEDURE TCBatchPostSO@108(LocationCode@1011 : Code[10]);
    VAR
      ItemATO@1002 : Record 27;
      ItemATS@1008 : Record 27;
      RegularItem@1007 : Record 27;
      AssemblyHeader1@1005 : Record 900;
      AssemblyHeader2@1003 : Record 900;
      SalesHeader@1014 : Record 36;
      SalesHeader1@1001 : Record 36;
      SalesHeader2@1013 : Record 36;
      SalesLine@1012 : Record 37;
      TempAssemblyLine1@1004 : TEMPORARY Record 901;
      TempAssemblyLine2@1009 : TEMPORARY Record 901;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      CreateAssembledItem(ItemATO,ItemATO."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        ItemATO."Costing Method"::FIFO);
      CreateAssembledItem(ItemATS,ItemATS."Assembly Policy"::"Assemble-to-Stock",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        ItemATS."Costing Method"::FIFO);
      LibraryInventory.CreateItem(RegularItem);

      // create SOs with ATO/ATS/Regular item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader1,ItemATS."No.",'',OrderQty,DueDate,LocationCode);
      AddSalesOrderLine(SalesHeader1,SalesLine,ItemATO."No.",LocationCode,'',OrderQty,DueDate);
      AddSalesOrderLine(SalesHeader1,SalesLine,RegularItem."No.",LocationCode,'',OrderQty,DueDate);
      CreateSalesOrder(SalesHeader2,ItemATS."No.",'',OrderQty,DueDate,LocationCode);
      AddSalesOrderLine(SalesHeader2,SalesLine,ItemATO."No.",LocationCode,'',OrderQty + 1,DueDate);
      AddSalesOrderLine(SalesHeader2,SalesLine,RegularItem."No.",LocationCode,'',OrderQty,DueDate);

      // Find created AOs
      FindAssemblyHeader(AssemblyHeader1,AssemblyHeader1."Document Type"::Order,ItemATO,'',LocationCode,DueDate,
        ItemATO."Base Unit of Measure",OrderQty);
      CopyAsmLinesToTemp(AssemblyHeader1,TempAssemblyLine1);
      FindAssemblyHeader(AssemblyHeader2,AssemblyHeader2."Document Type"::Order,ItemATO,'',LocationCode,DueDate,
        ItemATO."Base Unit of Measure",OrderQty + 1);
      CopyAsmLinesToTemp(AssemblyHeader2,TempAssemblyLine2);

      // Add enough inventory for components and regular item
      AddInvNonDirectLocAllComponent(AssemblyHeader1,100);
      AddInvNonDirectLocAllComponent(AssemblyHeader2,100);
      AddInventoryNonDirectLocation(RegularItem."No.",LocationCode,'',3 * OrderQty);
      AddInventoryNonDirectLocation(ItemATS."No.",LocationCode,'',3 * OrderQty);

      // Exercise - batch post SOs
      CLEAR(SalesHeader);
      SalesHeader.SETRANGE("Document Type",SalesHeader."Document Type"::Order);
      SalesHeader.SETFILTER("No.",SalesHeader1."No." + '|' + SalesHeader2."No.");
      LibrarySales.BatchPostSalesHeaders(SalesHeader,TRUE,TRUE,0D,FALSE,FALSE,FALSE);

      // Verify - SOs posted and invoiced - no SOs
      // No ATO headers - posted
      COMMIT;
      ASSERTERROR SalesHeader.GET(SalesHeader1."Document Type",SalesHeader1."No.");
      ASSERTERROR SalesHeader.GET(SalesHeader2."Document Type",SalesHeader2."No.");
      AssertNoAssemblyHeader(AssemblyHeader1."Document Type",AssemblyHeader1."No.");
      AssertNoAssemblyHeader(AssemblyHeader2."Document Type",AssemblyHeader2."No.");
      LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine1,AssemblyHeader1,OrderQty);
      LibraryAssembly.VerifyPostedAssemblyHeader(TempAssemblyLine2,AssemblyHeader2,OrderQty + 1);
    END;

    [Test]
    PROCEDURE ATOPostSOVerifyEntries@135();
    BEGIN
      Initialize;
      TCPostSOVerifyEntries('');
    END;

    LOCAL PROCEDURE TCPostSOVerifyEntries@229(LocationCode@1011 : Code[10]);
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1009 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1005 : Record 37;
      TempAssemblyLine@1007 : TEMPORARY Record 901;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,LocationCode);
      FindSOL(SalesHeader,SalesLine,1);
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,Item,'',LocationCode,
        DueDate,Item."Base Unit of Measure",OrderQty);
      CopyAsmLinesToTemp(AssemblyHeader,TempAssemblyLine);

      // Add enough inventory for comp
      AddInvNonDirectLocAllComponent(AssemblyHeader,100);

      // Exercise - post SOs
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify - entries
      LibraryAssembly.VerifyILEsForAsmOnATO(TempAssemblyLine,AssemblyHeader,AssemblyHeader.Quantity);
      LibraryAssembly.VerifyValueEntriesATO(TempAssemblyLine,SalesHeader,AssemblyHeader,AssemblyHeader.Quantity);
      LibraryAssembly.VerifyResEntriesATO(TempAssemblyLine,AssemblyHeader);
      LibraryAssembly.VerifyCapEntriesATO(TempAssemblyLine,AssemblyHeader);
    END;

    [ModalPageHandler]
    PROCEDURE AvailabilityWindowHandler@87(VAR AsmAvailability@1000 : Page 908;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::Yes; // always confirm
    END;

    [Test]
    PROCEDURE ATOMixVerifyEntries@133();
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1009 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1005 : Record 37;
      TempAssemblyLine@1007 : TEMPORARY Record 901;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      Initialize;

      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000) + 1;
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,'');
      FindSOL(SalesHeader,SalesLine,1);
      // Make ATO mix with ATS
      SetQtyToAssembleToOrder(SalesLine,SalesLine.Quantity / 2);

      SalesLine.AsmToOrderExists(AssemblyHeader);
      CopyAsmLinesToTemp(AssemblyHeader,TempAssemblyLine);

      // Add enough inventory for comp
      AddInvNonDirectLocAllComponent(AssemblyHeader,100);

      // Exercise - post SOs
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify - entries
      LibraryAssembly.VerifyILEsForAsmOnATO(TempAssemblyLine,AssemblyHeader,AssemblyHeader.Quantity);
      LibraryAssembly.VerifyResEntriesATO(TempAssemblyLine,AssemblyHeader);
      LibraryAssembly.VerifyCapEntriesATO(TempAssemblyLine,AssemblyHeader);
    END;

    [Test]
    [HandlerFunctions(AssemblyAvailabilityFormHandler)]
    PROCEDURE AOVerifyDates@175();
    BEGIN
      Initialize;
      TCVerifyDates('');
    END;

    LOCAL PROCEDURE TCVerifyDates@170(LocationCode@1011 : Code[10]);
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1009 : Record 900;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      ChangeLeadTimeOffsetOnCompList(Item."No.");

      // Exercise - create AO
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+100D>',WORKDATE);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,'',DueDate,OrderQty);

      // Verify
      AssertDatesOnAsmOrder(AssemblyHeader);
    END;

    [Test]
    PROCEDURE ATOVerifyDates@196();
    VAR
      SalesDocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCATOVerifyDates('',SalesDocumentType::Order);
    END;

    [Test]
    PROCEDURE ATOVerifyDatesQuote@220();
    VAR
      SalesDocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCATOVerifyDates('',SalesDocumentType::Order);
    END;

    [Test]
    PROCEDURE ATOVerifyDatesBlanketOrder@219();
    VAR
      SalesDocumentType@1000 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
    BEGIN
      Initialize;
      TCATOVerifyDates('',SalesDocumentType::Order);
    END;

    LOCAL PROCEDURE TCATOVerifyDates@188(LocationCode@1011 : Code[10];SalesDocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order');
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1009 : Record 900;
      SalesHeader@1003 : Record 36;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      ChangeLeadTimeOffsetOnCompList(Item."No.");

      // Exercise - create ATO
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+100D>',WORKDATE);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,Item."No.",'',OrderQty,DueDate,LocationCode);
      FindAssemblyHeader(
        AssemblyHeader,GetAsmTypeForSalesType(SalesDocumentType),Item,'',LocationCode,DueDate,Item."Base Unit of Measure",OrderQty);

      // Verify
      AssertDatesOnAsmOrder(AssemblyHeader);
    END;

    [Test]
    [HandlerFunctions(AssemblyAvailabilityFormHandler)]
    PROCEDURE AOVerifyDatesWithVariantSKU@179();
    VAR
      CreatePerOption@1000 : 'Location,Variant,Location & Variant';
    BEGIN
      Initialize;
      TCVerifyDatesWithSKU('',CreatePerOption::Variant);
    END;

    [Test]
    [HandlerFunctions(AssemblyAvailabilityFormHandler)]
    PROCEDURE AOVerifyDatesWithLocationSKU@198();
    VAR
      CreatePerOption@1000 : 'Location,Variant,Location & Variant';
    BEGIN
      Initialize;
      TCVerifyDatesWithSKU(LocationBlue.Code,CreatePerOption::Location);
    END;

    [Test]
    [HandlerFunctions(AssemblyAvailabilityFormHandler)]
    PROCEDURE AOVerifyDatesWithLocAndVariantSKU@199();
    VAR
      CreatePerOption@1000 : 'Location,Variant,Location & Variant';
    BEGIN
      Initialize;
      TCVerifyDatesWithSKU(LocationBlue.Code,CreatePerOption::"Location & Variant");
    END;

    LOCAL PROCEDURE TCVerifyDatesWithSKU@178(LocationCode@1011 : Code[10];CreatePerOption@1003 : 'Location,Variant,Location & Variant');
    VAR
      Item@1002 : Record 27;
      ItemVariant@1001 : Record 5401;
      SKU@1004 : Record 5700;
      AssemblyHeader@1009 : Record 900;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      IF CreatePerOption <> CreatePerOption::Location THEN
        LibraryInventory.CreateItemVariant(ItemVariant,Item."No.");
      LibraryInventory.CreateStockKeepingUnit(Item,CreatePerOption,FALSE,TRUE);
      IF NOT FindSKU(SKU,Item."No.",LocationCode,ItemVariant.Code) THEN
        ERROR(ERR_SKU_NOT_CREATED);
      ChangeLeadTimesOnSKU(SKU);
      ChangeLeadTimeOffsetOnCompList(Item."No.");

      // Exercise - create AO
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+100D>',WORKDATE);
      CreateAssemblyOrder(AssemblyHeader,Item,LocationCode,ItemVariant.Code,DueDate,OrderQty);

      // Verify
      AssertDatesOnAsmOrder(AssemblyHeader);
    END;

    [Test]
    [HandlerFunctions(RollUpCostConfirm)]
    PROCEDURE ATORollupCost@192();
    VAR
      Item@1005 : Record 27;
      SalesLine@1003 : Record 37;
      AssemblyHeader@1004 : Record 900;
      SalesDocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
      QtyToAssembleToOrder@1002 : Integer;
      OrderQty@1000 : Integer;
    BEGIN
      // [FEATURE] [Sales Order]
      // [SCENARIO 379342] Unit Cost in Sales Order Line after the RollupCost function is run should be calculated on Assembly Lines only.
      Initialize;

      // [GIVEN] Assembled Item with Assembly Policy = Assemble-to-Order.
      // [GIVEN] List of BOM Components with costs.
      // [GIVEN] Sales Order Line with Quantity > "Qty. Assemble to Order".
      QtyToAssembleToOrder := LibraryRandom.RandInt(1000);
      OrderQty := QtyToAssembleToOrder + LibraryRandom.RandInt(1000);
      CreateAssembledItemAndBOMComponentsWithUnitCostAndUnitPrice(Item);
      TCRollupCost(Item,SalesLine,AssemblyHeader,'',SalesDocumentType::Order,QtyToAssembleToOrder,OrderQty);

      // [WHEN] Run Roll-up Cost function.
      LibraryAssembly.RollUpAsmCost(SalesLine);

      // [THEN] Unit Cost in Sales Line is nearly equal to Unit Cost of Assembled Item.
      Assert.AreNearlyEqual(
        SalesLine."Unit Cost",GetRollupCost(AssemblyHeader) / AssemblyHeader.Quantity,GLSetup."Unit-Amount Rounding Precision",
        STRSUBSTNO(WrongUnitValueMsg,SalesLine.FIELDCAPTION("Unit Cost")));
    END;

    [Test]
    [HandlerFunctions(RollUpCostConfirm)]
    PROCEDURE ATORollupQuote@204();
    VAR
      Item@1005 : Record 27;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1003 : Record 900;
      SalesDocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
      QtyToAssembleToOrder@1002 : Integer;
      OrderQty@1000 : Integer;
    BEGIN
      // [FEATURE] [Sales Quote]
      // [SCENARIO 379342] Unit Cost in Sales Quote Line after the RollupCost function is run should be calculated on Assembly Lines only.
      Initialize;

      // [GIVEN] Assembled Item with Assembly Policy = Assemble-to-Order.
      // [GIVEN] List of BOM Components with costs.
      // [GIVEN] Sales Quote Line with Quantity = "Qty. Assemble to Order". Difference between Quantity and "Qty. Assemble to Order" in Sales Quote is not allowed by design.
      QtyToAssembleToOrder := LibraryRandom.RandInt(1000);
      OrderQty := QtyToAssembleToOrder;
      CreateAssembledItemAndBOMComponentsWithUnitCostAndUnitPrice(Item);
      TCRollupCost(Item,SalesLine,AssemblyHeader,'',SalesDocumentType::Quote,QtyToAssembleToOrder,OrderQty);

      // [WHEN] Run Roll-up Cost function.
      LibraryAssembly.RollUpAsmCost(SalesLine);

      // [THEN] Unit Cost in Sales Line is nearly equal to Unit Cost of Assembled Item.
      Assert.AreNearlyEqual(
        SalesLine."Unit Cost",GetRollupCost(AssemblyHeader) / AssemblyHeader.Quantity,GLSetup."Unit-Amount Rounding Precision",
        STRSUBSTNO(WrongUnitValueMsg,SalesLine.FIELDCAPTION("Unit Cost")));
    END;

    [Test]
    [HandlerFunctions(RollUpCostConfirm)]
    PROCEDURE ATORollupBlanket@197();
    VAR
      Item@1005 : Record 27;
      SalesLine@1004 : Record 37;
      AssemblyHeader@1003 : Record 900;
      SalesDocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
      QtyToAssembleToOrder@1002 : Integer;
      OrderQty@1000 : Integer;
    BEGIN
      // [FEATURE] [Sales Blanket Order]
      // [SCENARIO 379342] Unit Cost in Sales Blanket Order Line after the RollupCost function is run should be calculated on Assembly Lines only.
      Initialize;

      // [GIVEN] Assembled Item with Assembly Policy = Assemble-to-Order.
      // [GIVEN] List of BOM Components with costs.
      // [GIVEN] Sales Blanket Order Line with Quantity = "Qty. Assemble to Order". Difference between Quantity and "Qty. Assemble to Order" in Sales Blanket Order is not allowed by design.
      QtyToAssembleToOrder := LibraryRandom.RandInt(1000);
      OrderQty := QtyToAssembleToOrder;
      CreateAssembledItemAndBOMComponentsWithUnitCostAndUnitPrice(Item);
      TCRollupCost(Item,SalesLine,AssemblyHeader,'',SalesDocumentType::"Blanket Order",QtyToAssembleToOrder,OrderQty);

      // [WHEN] Run Roll-up Cost function.
      LibraryAssembly.RollUpAsmCost(SalesLine);

      // [THEN] Unit Cost in Sales Line is nearly equal to Unit Cost of Assembled Item.
      Assert.AreNearlyEqual(
        SalesLine."Unit Cost",GetRollupCost(AssemblyHeader) / AssemblyHeader.Quantity,GLSetup."Unit-Amount Rounding Precision",
        STRSUBSTNO(WrongUnitValueMsg,SalesLine.FIELDCAPTION("Unit Cost")));
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler)]
    PROCEDURE ATORollupPrice@289();
    VAR
      Item@1005 : Record 27;
      SalesLine@1003 : Record 37;
      AssemblyHeader@1004 : Record 900;
      SalesDocumentType@1001 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';
      QtyToAssembleToOrder@1002 : Integer;
      OrderQty@1000 : Integer;
    BEGIN
      // [FEATURE] [Sales Order]
      // [SCENARIO 379342] Unit Price in Sales Order Line after the RollupPrice function is run should be calculated on Assembly Lines only.
      Initialize;

      // [GIVEN] Assembled Item with Assembly Policy = Assemble-to-Order.
      // [GIVEN] List of BOM Components with Sales and Resource prices.
      // [GIVEN] Sales Order Line with Quantity > "Qty. Assemble to Order".
      QtyToAssembleToOrder := LibraryRandom.RandInt(1000);
      OrderQty := QtyToAssembleToOrder + LibraryRandom.RandInt(1000);
      CreateAssembledItemAndBOMComponentsWithUnitCostAndUnitPrice(Item);
      CreateSalesAndResourcePricesOnCompList(Item."No.");
      TCRollupCost(Item,SalesLine,AssemblyHeader,'',SalesDocumentType::Order,QtyToAssembleToOrder,OrderQty);

      // [WHEN] Run Roll-up Price function.
      LibraryAssembly.RollUpAsmPrice(SalesLine);

      // [THEN] Unit Price in Sales Line is nearly equal to Unit Price of Assembled Item.
      Assert.AreNearlyEqual(
        SalesLine."Unit Price",GetRollupPrice(AssemblyHeader) / AssemblyHeader.Quantity,GLSetup."Unit-Amount Rounding Precision",
        STRSUBSTNO(WrongUnitValueMsg,SalesLine.FIELDCAPTION("Unit Price")));
    END;

    LOCAL PROCEDURE TCRollupCost@190(VAR Item@1005 : Record 27;VAR SalesLine@1006 : Record 37;VAR AssemblyHeader@1009 : Record 900;LocationCode@1000 : Code[10];SalesDocumentType@1002 : 'Quote,Order,Invoice,Credit Memo,Blanket Order,Return Order';QtyToAssembleToOrder@1004 : Integer;OrderQty@1003 : Integer);
    VAR
      SalesHeader@1001 : Record 36;
      DueDate@1007 : Date;
    BEGIN
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesDocumentType,Item."No.",'',OrderQty,DueDate,LocationCode);

      FindSOL(SalesHeader,SalesLine,1);
      SalesLine.VALIDATE("Qty. to Assemble to Order",QtyToAssembleToOrder);
      SalesLine.MODIFY(TRUE);

      FindAssemblyHeader(
        AssemblyHeader,
        GetAsmTypeForSalesType(SalesDocumentType),Item,'',LocationCode,DueDate,Item."Base Unit of Measure",QtyToAssembleToOrder);
    END;

    [Test]
    PROCEDURE AsmLinesOnSalesOrderMatchAsmLinesOnQuote@297();
    VAR
      Item@1002 : Record 27;
      Location@1000 : Record 14;
      SalesHeader@1001 : Record 36;
      AssemblyHeader@1003 : Record 900;
      TempQuoteAssemblyLine@1005 : TEMPORARY Record 901;
      SalesOrderNo@1006 : Code[20];
    BEGIN
      // [FEATURE] [Sales Quote]
      // [SCENARIO 380918] Modifications on Assembly Lines for Sales Quote on Location with "Require Shipment" = TRUE, are respected when a Sales Order is created from the Quote.
      Initialize;

      // [GIVEN] Location "L" with "Require Shipment" = TRUE.
      LibraryWarehouse.CreateLocationWMS(Location,FALSE,FALSE,FALSE,FALSE,TRUE);

      // [GIVEN] Sales Quote for Assembled Item on Location "L".
      // [GIVEN] The quantity of a component in the Assembly Line is changed, thus the Assembly does not match BOM.
      CreateSalesDocToMakeOrder(SalesHeader,SalesHeader."Document Type"::Quote,Item,Location.Code);
      FindLinkedAssemblyOrder(AssemblyHeader,SalesHeader."Document Type",SalesHeader."No.");
      UpdateAssemblyLine(AssemblyHeader);
      CopyAsmLinesToTemp(AssemblyHeader,TempQuoteAssemblyLine);

      // [WHEN] Make Sales Order from the Sales Quote.
      SalesOrderNo := LibrarySales.QuoteMakeOrder(SalesHeader);

      // [THEN] Assembly Lines on the Order and the Quote are identical.
      VerifyAssemblyLinesSalesOrderAgainstQuote(SalesOrderNo,TempQuoteAssemblyLine);
    END;

    [Test]
    PROCEDURE ATOMakeOrderQuoteCheckOrders@226();
    VAR
      AssemblyHeader@1003 : Record 900;
      Item@1004 : Record 27;
      SalesHeader@1001 : Record 36;
      SalesLine@1002 : Record 37;
      ExpectedOrderNo@1000 : Code[20];
    BEGIN
      // [SCENARIO] Correct Assembly Order is created when Sales Order made from Sales Quote
      Initialize;

      // [GIVEN] Create Quote with Assembled Item
      CreateSalesDocToMakeOrder(SalesHeader,SalesHeader."Document Type"::Quote,Item,'');

      // [WHEN] Make Order from Quote
      ExpectedOrderNo := LibrarySales.QuoteMakeOrder(SalesHeader);

      // [THEN] Verify Assembly Order fields are copied from source Sales Line
      FindAsmHeaderFromSalesOrder(ExpectedOrderNo,Item,SalesLine,AssemblyHeader);
      AssertAsmOrderForDefaultBOM(
        AssemblyHeader,SalesHeader."Document Type"::Order,Item,'','',SalesLine."Shipment Date",
        Item."Base Unit of Measure",SalesLine.Quantity,1);
    END;

    [Test]
    PROCEDURE ATOMakeOrderQuoteCheckReservation@225();
    VAR
      AssemblyHeader@1003 : Record 900;
      Item@1004 : Record 27;
      SalesHeader@1001 : Record 36;
      SalesLine@1002 : Record 37;
      ExpectedOrderNo@1000 : Code[20];
    BEGIN
      // [SCENARIO] Assembly Order and Sales Order made from Sales Quote share reservation
      Initialize;

      // [GIVEN] Create Quote with Assembled Item
      CreateSalesDocToMakeOrder(SalesHeader,SalesHeader."Document Type"::Quote,Item,'');

      // [WHEN] Make Order from Quote
      ExpectedOrderNo := LibrarySales.QuoteMakeOrder(SalesHeader);

      // [THEN] Verify reservation entries
      FindAsmHeaderFromSalesOrder(ExpectedOrderNo,Item,SalesLine,AssemblyHeader);
      AssertReservationEntries(SalesLine,AssemblyHeader);
    END;

    [Test]
    PROCEDURE ATOMakeOrderQuoteCheckHardLink@224();
    VAR
      AssemblyHeader@1003 : Record 900;
      Item@1004 : Record 27;
      SalesHeader@1001 : Record 36;
      SalesLine@1002 : Record 37;
      ExpectedOrderNo@1000 : Code[20];
    BEGIN
      // [SCENARIO] Assembly Order and Sales Order made from Sales Quote are linked
      Initialize;

      // [GIVEN] Create Quote with Assembled Item
      CreateSalesDocToMakeOrder(SalesHeader,SalesHeader."Document Type"::Quote,Item,'');

      // [WHEN] Make Order from Quote
      ExpectedOrderNo := LibrarySales.QuoteMakeOrder(SalesHeader);

      // [THEN] Verify hard link between Sales Order and Assembly Order
      FindAsmHeaderFromSalesOrder(ExpectedOrderNo,Item,SalesLine,AssemblyHeader);
      LibraryAssembly.VerifyHardLinkEntry(SalesLine,AssemblyHeader,1);
    END;

    [Test]
    PROCEDURE ATOMakeOrderBlanketOrderCheckOrders@221();
    VAR
      AssemblyHeader@1003 : Record 900;
      Item@1004 : Record 27;
      SalesHeader@1001 : Record 36;
      SalesLine@1002 : Record 37;
      ExpectedOrderNo@1000 : Code[20];
    BEGIN
      // [SCENARIO] Correct Assembly Order is created when Sales Order made from Blanket Sales Order
      Initialize;

      // [GIVEN] Create Blanket Order with Assembled Item
      CreateSalesDocToMakeOrder(SalesHeader,SalesHeader."Document Type"::"Blanket Order",Item,'');

      // [WHEN] Make Order from Blanket Order
      ExpectedOrderNo := LibrarySales.BlanketSalesOrderMakeOrder(SalesHeader);

      // [THEN] Verify Assembly order fields are copied from source Sales Line
      FindAsmHeaderFromSalesOrder(ExpectedOrderNo,Item,SalesLine,AssemblyHeader);
      AssertAsmOrderForDefaultBOM(
        AssemblyHeader,SalesHeader."Document Type"::Order,Item,'','',SalesLine."Shipment Date",
        Item."Base Unit of Measure",SalesLine.Quantity,1);
    END;

    [Test]
    PROCEDURE ATOMakeOrderBlanketOrderCheckReservation@218();
    VAR
      AssemblyHeader@1003 : Record 900;
      Item@1004 : Record 27;
      SalesHeader@1000 : Record 36;
      SalesLine@1002 : Record 37;
      ExpectedOrderNo@1001 : Code[20];
    BEGIN
      // [SCENARIO] Assembly Order and Sales Order made from Blanket Sales Order share reservation
      Initialize;

      // [GIVEN] Create Blanket Order with Assembled Item
      CreateSalesDocToMakeOrder(SalesHeader,SalesHeader."Document Type"::"Blanket Order",Item,'');

      // [WHEN] Make Order from Blanket Order
      ExpectedOrderNo := LibrarySales.BlanketSalesOrderMakeOrder(SalesHeader);

      // [THEN] Verify reservation entries
      FindAsmHeaderFromSalesOrder(ExpectedOrderNo,Item,SalesLine,AssemblyHeader);
      AssertReservationEntries(SalesLine,AssemblyHeader);
    END;

    [Test]
    PROCEDURE ATOMakeOrderBlanketOrderCheckHardLink@216();
    VAR
      AssemblyHeader@1000 : Record 900;
      Item@1002 : Record 27;
      SalesHeader@1004 : Record 36;
      SalesLine@1001 : Record 37;
      ExpectedOrderNo@1003 : Code[20];
    BEGIN
      // [SCENARIO] Assembly Order and Sales Order made from Blanket Sales Order are linked
      Initialize;

      // [GIVEN] Create Blanket Order with Assembled Item
      CreateSalesDocToMakeOrder(SalesHeader,SalesHeader."Document Type"::"Blanket Order",Item,'');

      // [WHEN] Make Order from Blanket Order
      ExpectedOrderNo := LibrarySales.BlanketSalesOrderMakeOrder(SalesHeader);

      // [THEN] Verify hard link between Sales Order and Assembly Order
      FindAsmHeaderFromSalesOrder(ExpectedOrderNo,Item,SalesLine,AssemblyHeader);
      LibraryAssembly.VerifyHardLinkEntry(SalesLine,AssemblyHeader,1);
    END;

    [Test]
    [HandlerFunctions(ExplodeBOMOptionDialog)]
    PROCEDURE BlanketAsmOrderUpdatedWhenShippedOrder@270();
    VAR
      AssemblyHeader@1005 : Record 900;
      Item@1004 : Record 27;
      SalesOrderHeader@1000 : Record 36;
      QtyToShip@1007 : Decimal;
    BEGIN
      // [SCENARIO 359881.1] Blanket Assembly Order is updated when shipped Sales Order made from Blanket Sales Order
      Initialize;

      // [GIVEN] Make Order from Blanket Order with Assembled Item
      MakeOrderFromSalesBlanketOrder(Item,SalesOrderHeader);
      // [GIVEN] Decrease 'Quantity to Ship' to make partial shipment
      QtyToShip := DecreaseQtyToShipInAsmOrder(SalesOrderHeader,Item."No.",LibraryRandom.RandInt(5));

      // [WHEN] Partially Ship created Sales Order
      LibrarySales.PostSalesDocument(SalesOrderHeader,TRUE,FALSE);

      // [THEN] Blanket Assembly Order Header and Lines (Remaining Quantity, Assembled/Consumed Quantity) are updated
      VerifyAssembledQtyOnAsmOrder(AssemblyHeader."Document Type"::"Blanket Order",Item."No.",QtyToShip);
    END;

    [Test]
    [HandlerFunctions(ExplodeBOMOptionDialog,ConfirmHandler)]
    PROCEDURE BlanketAsmOrderUpdatedWhenUndoShippedOrder@321();
    VAR
      AssemblyHeader@1005 : Record 900;
      Item@1004 : Record 27;
      SalesOrderHeader@1000 : Record 36;
      SalesShipmentLine@1006 : Record 111;
      QtyToShip@1007 : Decimal;
    BEGIN
      // [SCENARIO 359881.2] Blanket Assembly Order is updated when Undo the shipped Sales Order made from Blanket Sales Order
      Initialize;

      // [GIVEN] Make Order from Blanket Order with Assembled Item
      MakeOrderFromSalesBlanketOrder(Item,SalesOrderHeader);
      // [GIVEN] Partially Ship created Sales Order
      QtyToShip := DecreaseQtyToShipInAsmOrder(SalesOrderHeader,Item."No.",LibraryRandom.RandInt(5));
      LibrarySales.PostSalesDocument(SalesOrderHeader,TRUE,FALSE);
      // [GIVEN] Fully Ship created Sales Order
      LibrarySales.PostSalesDocument(SalesOrderHeader,TRUE,FALSE);

      // [WHEN] Undo the last shipment
      SalesShipmentLine.SETRANGE("Document No.",SalesOrderHeader."Last Shipping No.");
      LibrarySales.UndoSalesShipmentLine(SalesShipmentLine);

      // [THEN] Blanket Assembly Order Header and Lines are in the state as if after first shipment
      VerifyAssembledQtyOnAsmOrder(AssemblyHeader."Document Type"::"Blanket Order",Item."No.",QtyToShip);
    END;

    LOCAL PROCEDURE DecreaseQtyToShipInAsmOrder@316(SalesHeader@1001 : Record 36;ItemNo@1002 : Code[20];Divider@1003 : Decimal) : Decimal;
    VAR
      SalesLine@1000 : Record 37;
    BEGIN
      WITH SalesLine DO BEGIN
        SETRANGE("Document Type",SalesHeader."Document Type");
        SETRANGE("Document No.",SalesHeader."No.");
        SETRANGE("No.",ItemNo);
        FINDFIRST;
        VALIDATE("Qty. to Ship",Quantity DIV Divider);
        MODIFY(TRUE);
        EXIT("Qty. to Ship");
      END;
    END;

    LOCAL PROCEDURE FindAsmHeaderFromSalesOrder@262(SalesOrderNo@1000 : Code[20];Item@1004 : Record 27;VAR SalesLine@1001 : Record 37;VAR AssemblyHeader@1002 : Record 900);
    VAR
      SalesHeader@1003 : Record 36;
    BEGIN
      SalesHeader.GET(SalesHeader."Document Type"::Order,SalesOrderNo);
      FindSalesLine(SalesHeader,SalesLine,Item."No.");
      FindAssemblyHeader(
        AssemblyHeader,SalesHeader."Document Type"::Order,Item,'','',
        SalesLine."Shipment Date",Item."Base Unit of Measure",SalesLine.Quantity);
    END;

    LOCAL PROCEDURE MakeOrderFromSalesBlanketOrder@286(VAR Item@1001 : Record 27;VAR SalesOrderHeader@1002 : Record 36);
    VAR
      SalesHeader@1000 : Record 36;
      SalesOrderNo@1003 : Code[20];
    BEGIN
      CreateSalesDocToMakeOrder(SalesHeader,SalesHeader."Document Type"::"Blanket Order",Item,'');
      PurchaseAssembledItem(Item,1000);
      SalesOrderNo := LibrarySales.BlanketSalesOrderMakeOrder(SalesHeader);
      SalesOrderHeader.GET(SalesHeader."Document Type"::Order,SalesOrderNo);
    END;

    LOCAL PROCEDURE CreateSalesDocToMakeOrder@210(VAR SalesHeader@1000 : Record 36;DocumentType@1009 : Option;VAR Item@1001 : Record 27;LocationCode@1002 : Code[10]);
    VAR
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,DocumentType,Item."No.",'',OrderQty,DueDate,LocationCode);
    END;

    LOCAL PROCEDURE PurchaseAssembledItem@274(Item@1000 : Record 27;Quantity@1004 : Decimal);
    VAR
      ItemJnlLine@1001 : Record 83;
    BEGIN
      LibraryInventory.CreateItemJournalLine(
        ItemJnlLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,ItemJnlLine."Entry Type"::Purchase,Item."No.",Quantity);
      CODEUNIT.RUN(CODEUNIT::"Item Jnl.-Explode BOM",ItemJnlLine);
      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE VerifyAssembledQtyOnAsmOrder@309(DocumentType@1002 : Option;ItemNo@1003 : Code[20];AssembledQty@1004 : Decimal);
    VAR
      AssemblyHeader@1001 : Record 900;
      AssemblyLine@1000 : Record 901;
    BEGIN
      WITH AssemblyHeader DO BEGIN
        SETRANGE("Document Type",DocumentType);
        SETRANGE("Item No.",ItemNo);
        FINDLAST;
        Assert.AreEqual(AssembledQty,"Assembled Quantity",FIELDNAME("Assembled Quantity"));
        Assert.AreEqual(
          AssembledQty * "Qty. per Unit of Measure",
          "Assembled Quantity (Base)",FIELDNAME("Assembled Quantity (Base)"));
        Assert.AreEqual(
          Quantity - AssembledQty,"Remaining Quantity",FIELDNAME("Remaining Quantity"));
        Assert.AreEqual(
          "Quantity (Base)" - "Assembled Quantity (Base)",
          "Remaining Quantity (Base)",FIELDNAME("Remaining Quantity (Base)"));
      END;

      WITH AssemblyLine DO BEGIN
        SETRANGE("Document Type",AssemblyHeader."Document Type");
        SETRANGE("Document No.",AssemblyHeader."No.");
        FINDSET;
        REPEAT
          Assert.AreEqual(
            AssembledQty * "Quantity per","Consumed Quantity",FIELDNAME("Consumed Quantity"));
          Assert.AreEqual(
            "Consumed Quantity" * "Qty. per Unit of Measure",
            "Consumed Quantity (Base)",FIELDNAME("Consumed Quantity (Base)"));
          Assert.AreEqual(
            Quantity - "Quantity per" * AssembledQty,"Remaining Quantity",FIELDNAME("Remaining Quantity"));
          Assert.AreEqual(
            "Quantity (Base)" - "Consumed Quantity (Base)",
            "Remaining Quantity (Base)",FIELDNAME("Remaining Quantity (Base)"));
        UNTIL NEXT = 0;
      END;
    END;

    [Test]
    PROCEDURE ATOFixedApplication@230();
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1009 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1005 : Record 37;
      TempAssemblyLine@1004 : TEMPORARY Record 901;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,'');
      FindSOL(SalesHeader,SalesLine,1);
      SalesLine.AsmToOrderExists(AssemblyHeader);
      CopyAsmLinesToTemp(AssemblyHeader,TempAssemblyLine);

      // Add enough inventory for comp
      AddInvNonDirectLocAllComponent(AssemblyHeader,100);

      // Exercise - post SOs
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify - fixed application AO and SOL
      LibraryAssembly.VerifyILEATOAndSale(AssemblyHeader,SalesLine,OrderQty,TRUE,1);
    END;

    [Test]
    PROCEDURE MixATOFixedApplication@227();
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1009 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1005 : Record 37;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,'');
      FindSOL(SalesHeader,SalesLine,1);
      SalesLine.VALIDATE("Qty. to Assemble to Order",OrderQty / 2);
      SalesLine.VALIDATE("Qty. to Ship",OrderQty / 2);
      SalesLine.MODIFY(TRUE);
      SalesLine.AsmToOrderExists(AssemblyHeader);

      // Add enough inventory for comp
      AddInvNonDirectLocAllComponent(AssemblyHeader,100);

      // Exercise - post SOs - ATO first and ATS after
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);

      // Verify - fixed application AO and SOL
      LibraryAssembly.VerifyILEATOAndSale(AssemblyHeader,SalesLine,OrderQty / 2,FALSE,1);

      // post the rest - ATS
      SalesHeader.GET(SalesHeader."Document Type",SalesHeader."No.");
      FindSOL(SalesHeader,SalesLine,1);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify - ATS sale
      LibraryCosting.CheckAdjustment(Item);
      LibraryAssembly.VerifyILESale(SalesLine,OrderQty / 2,0,FALSE,TRUE);
    END;

    [Test]
    PROCEDURE MixATOPartialShipAndInvoice@231();
    VAR
      Item@1003 : Record 27;
      AssemblyHeader@1009 : Record 900;
      SalesHeader@1001 : Record 36;
      SalesLine@1005 : Record 37;
      OrderQty@1006 : Integer;
      i@1000 : Integer;
    BEGIN
      Initialize;
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandInt(1000);
      CreateSalesOrder(
        SalesHeader,Item."No.",'',OrderQty,CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2),'');
      FindSOL(SalesHeader,SalesLine,1);
      SalesLine.AsmToOrderExists(AssemblyHeader);

      // Add enough inventory for comp
      AddInvNonDirectLocAllComponent(AssemblyHeader,100);

      // ATO is 1/2 and post ship in 4 partial posts
      SetQtyToAssembleToOrder(SalesLine,OrderQty / 2);

      FOR i := 1 TO 3 DO BEGIN
        SalesLine.GET(SalesLine."Document Type",SalesLine."Document No.",SalesLine."Line No.");
        SalesLine.VALIDATE("Qty. to Ship",OrderQty / 3);
        SalesLine.MODIFY(TRUE);
        // Exercise - post SOs - ATO first and ATS after
        LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);
      END;

      // Verify - ATO post separatelly
      LibraryAssembly.VerifyILEATOAndSale(AssemblyHeader,SalesLine,OrderQty / 3,FALSE,1);
      LibraryAssembly.VerifyILEATOAndSale(AssemblyHeader,SalesLine,OrderQty / 6,FALSE,1);
      LibraryAssembly.VerifyILESale(SalesLine,OrderQty / 6,0,FALSE,FALSE);
      LibraryAssembly.VerifyILESale(SalesLine,OrderQty / 3,0,FALSE,FALSE);

      // Post invoice
      LibrarySales.PostSalesDocument(SalesHeader,FALSE,TRUE);

      // Verify - after invoice
      LibraryCosting.CheckAdjustment(Item);
      LibraryAssembly.VerifyILEATOAndSale(AssemblyHeader,SalesLine,OrderQty / 3,TRUE,1);
      LibraryAssembly.VerifyILEATOAndSale(AssemblyHeader,SalesLine,OrderQty / 6,TRUE,1);
      LibraryAssembly.VerifyILESale(SalesLine,OrderQty / 6,0,FALSE,TRUE);
      LibraryAssembly.VerifyILESale(SalesLine,OrderQty / 3,0,FALSE,TRUE);
    END;

    LOCAL PROCEDURE TFS341553@88(CostingMethod@1012 : Option);
    VAR
      InventorySetup@1014 : Record 313;
      BOMComponent@1010 : Record 90;
      PurchRcptHeader@1011 : Record 120;
      PurchRcptLine@1008 : Record 121;
      PurchaseHeader@1004 : Record 38;
      PurchaseLine@1007 : Record 39;
      Item@1002 : Record 27;
      CompItem@1013 : Record 27;
      AssemblyHeader@1009 : Record 900;
      AssemblyLine@1003 : Record 901;
      SalesHeader@1001 : Record 36;
      SalesLine@1005 : Record 37;
      Vendor@1015 : Record 23;
      OrderQty@1006 : Integer;
      DueDate@1000 : Date;
    BEGIN
      // TFS: 341553 - [NAV 2013] Item Charge cost not rolling up to Assembly BOM
      Initialize;
      InventorySetup.GET;
      MESSAGE(''); // cover for unexpected messages from inventory setup update.
      LibraryInventory.UpdateInventorySetup(InventorySetup,
        InventorySetup."Automatic Cost Posting",InventorySetup."Expected Cost Posting to G/L",
        InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");

      // Setup.
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",1,0,0,1,CostingMethod);

      // Exercise - create SOL with ATO item
      OrderQty := LibraryRandom.RandIntInRange(5,100);
      DueDate := WorkDate2 + LibraryRandom.RandIntInRange(1,30);
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,'');
      FindSOL(SalesHeader,SalesLine,1);
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,Item,'','',
        DueDate,Item."Base Unit of Measure",OrderQty);

      // Add inventory for comp.
      LibraryPurchase.CreateVendor(Vendor);
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,Vendor."No.");
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      IF AssemblyLine.FINDSET THEN
        REPEAT
          LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,
            AssemblyLine."No.",2 * AssemblyLine.Quantity);
          PurchaseLine.VALIDATE("Unit Cost (LCY)",LibraryRandom.RandDec(100,2));
          PurchaseLine.MODIFY(TRUE);
        UNTIL AssemblyLine.NEXT = 0;
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      PurchRcptHeader.FINDLAST;

      // Post Sales Order.
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Add charge to the purchase.
      CLEAR(PurchaseHeader);
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,Vendor."No.");
      PurchRcptLine.SETRANGE("Document No.",PurchRcptHeader."No.");
      IF PurchRcptLine.FINDSET THEN
        REPEAT
          LibraryPatterns.ASSIGNPurchChargeToPurchRcptLine(PurchaseHeader,PurchRcptLine,LibraryRandom.RandDec(100,2),
            LibraryRandom.RandDec(100,2));
        UNTIL PurchRcptLine.NEXT = 0;

      // Exercise - post the charges.
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // Verify: Adjustment.
      LibraryCosting.CheckAdjustment(Item);
      BOMComponent.SETRANGE("Parent Item No.",Item."No.");
      BOMComponent.SETRANGE(Type,BOMComponent.Type::Item);
      IF BOMComponent.FINDSET THEN
        REPEAT
          CompItem.GET(BOMComponent."No.");
          LibraryCosting.CheckAdjustment(CompItem);
        UNTIL BOMComponent.NEXT = 0;

      // Appendix: Perform ATS afterwards.
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WORKDATE,Item."No.",'',OrderQty,'');
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
      CreateSalesOrder(SalesHeader,Item."No.",'',OrderQty,DueDate,'');
      FindSOL(SalesHeader,SalesLine,1);
      SetQtyToAssembleToOrder(SalesLine,0);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify: Check adjustment.
      LibraryCosting.CheckAdjustment(Item);

      // Teardown.
      LibraryInventory.UpdateInventorySetup(InventorySetup,
        InventorySetup."Automatic Cost Posting",InventorySetup."Expected Cost Posting to G/L",
        InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MsgHandler)]
    PROCEDURE TFS341553_FIFO@240();
    VAR
      Item@1000 : Record 27;
    BEGIN
      TFS341553(Item."Costing Method"::FIFO);
    END;

    [Test]
    [HandlerFunctions(MsgHandler)]
    PROCEDURE TFS341553_LIFO@244();
    VAR
      Item@1000 : Record 27;
    BEGIN
      TFS341553(Item."Costing Method"::LIFO);
    END;

    [Test]
    [HandlerFunctions(MsgHandler)]
    PROCEDURE TFS341553_Average@245();
    VAR
      Item@1000 : Record 27;
    BEGIN
      TFS341553(Item."Costing Method"::Average);
    END;

    [Test]
    [HandlerFunctions(MsgHandler)]
    PROCEDURE TFS341553_Std@246();
    VAR
      Item@1000 : Record 27;
    BEGIN
      TFS341553(Item."Costing Method"::Standard);
    END;

    [Test]
    [HandlerFunctions(MsgHandler)]
    PROCEDURE PostShippedSalesOrderAsInvoiceCheckAutomaticCostPosting@241();
    BEGIN
      // Test shipped Sales Order can be posted as Invoice with Automatic Cost Posting checked.
      Initialize;
      PostShippedSalesOrderAsInvoice(TRUE);
    END;

    [Test]
    [HandlerFunctions(MsgHandler)]
    PROCEDURE PostShippedSalesOrderAsInvoiceUncheckAutomaticCostPosting@248();
    BEGIN
      // Test shipped Sales Order can be posted as Invoice with Automatic Cost Posting unchecked.
      Initialize;
      PostShippedSalesOrderAsInvoice(FALSE);
    END;

    [Test]
    [HandlerFunctions(MsgHandler,ItemTrackingLinesHandler,EnterQtyHandler,ItemTrackingSummaryHandler)]
    PROCEDURE PostSalerOrderAsShipWithSNItemTracking@247();
    VAR
      AssembledItem@1000 : Record 27;
      SalesHeader@1001 : Record 36;
      LocationCode@1002 : Code[10];
      OrderNo@1004 : Code[20];
      OrderQty@1003 : Decimal;
    BEGIN
      Initialize;
      LocationCode := SetupBinLocationInAssemblySetup;
      CreateATOItemWithSNTracking(AssembledItem);
      SetupSNTrackingAndDefaultBinContent(LocationCode,AssembledItem);

      OrderQty := LibraryRandom.RandIntInRange(5,10);
      CreateSalesOrder(SalesHeader,AssembledItem."No.",'',OrderQty,WORKDATE,LocationCode);
      OrderNo := SetupInventoryAndTrackingForAssemblyOrder(AssembledItem,LocationCode,OrderQty);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);
      VerifyWhseEntriesOfAssembly(OrderNo,OrderQty);
    END;

    [Test]
    [HandlerFunctions(MsgHandler)]
    PROCEDURE VerifyCorrectBinATOSalesOrder@256();
    VAR
      AssembledItem@1000 : Record 27;
      AssemblyHeader@1006 : Record 900;
      LocationCode@1002 : Code[10];
      BinCodes@1005 : ARRAY [3] OF Code[20];
      TakeBinCode@1007 : Code[20];
      OrderQty@1003 : Decimal;
    BEGIN
      // Verify that Assembly components cannot be Taken twice if Bin is empty after first Take.

      // Setup.
      Initialize;
      LocationCode := SetupBinLocationInAssemblySetup;
      SetupBinsForLocation(LocationCode,BinCodes);
      SetupToAssemblyBin(LocationCode,BinCodes[ARRAYLEN(BinCodes)]);

      CreateAssembledItem(
        AssembledItem,AssembledItem."Assembly Policy"::"Assemble-to-Order",1,0,0,1,AssembledItem."Costing Method"::FIFO);

      OrderQty := LibraryRandom.RandIntInRange(5,10);
      PlaceComponentsToBins(AssembledItem."No.",LocationCode,BinCodes,1,ARRAYLEN(BinCodes) - 1,OrderQty);

      // Exercise.
      CreateSalesOrderAndAssemblyAndPick(AssemblyHeader,1,AssembledItem."No.",OrderQty,LocationCode);
      TakeBinCode := GetPickTakeBinCode(AssemblyHeader."Document Type",AssemblyHeader."No.");
      CreateSalesOrderAndAssemblyAndPick(AssemblyHeader,2,AssembledItem."No.",OrderQty,LocationCode);

      // Verify.
      Assert.AreNotEqual(
        TakeBinCode,GetPickTakeBinCode(AssemblyHeader."Document Type",AssemblyHeader."No."),WrongTakeBinErr);
    END;

    [Test]
    [HandlerFunctions(MsgHandler,ConfirmHandler)]
    PROCEDURE AssemblyOrdersFromSalesLineWithChangedLineNo@275();
    VAR
      Item@1000 : Record 27;
      SalesHeader@1001 : Record 36;
      AssemblyHeader@1005 : Record 900;
    BEGIN
      // [FEATURE] [Assembly] [Assembly to Order] [Sales Order]
      // [SCENARIO 378720] Validating "Sell-to Customer No." in Sales Header should not lead to duplicating Assembly Orders
      Initialize;

      // [GIVEN] Assembled Item
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),
        Item."Costing Method"::FIFO);

      // [GIVEN] Sales Header for Customer "C1" with two lines
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,LibrarySales.CreateCustomerNo);

      // [GIVEN] Sales Line "L1" with "Line No." = "N1" and Assembly Order for that line
      CreateSalesLineWithLineNo(SalesHeader,Item."No.",LibraryRandom.RandIntInRange(5001,10000));

      // [GIVEN] Sales Line "L2" with "Line No." = "N2", "N2" < "N1" and Assembly Order for that line
      CreateSalesLineWithLineNo(SalesHeader,Item."No.",LibraryRandom.RandInt(5000));

      // [WHEN] Set "Sell-to Customer No." on Sales Header to "C2"
      SalesHeader.VALIDATE("Sell-to Customer No.",LibrarySales.CreateCustomerNo);

      // [THEN] No additional Assembly Orders are created
      AssemblyHeader.SETRANGE("Item No.",Item."No.");
      Assert.AreEqual(2,AssemblyHeader.COUNT,AssemblyOrderCountErr);
    END;

    LOCAL PROCEDURE CreateSalesLineWithLineNo@280(SalesHeader@1000 : Record 36;ItemNo@1002 : Code[20];LineNo@1003 : Integer);
    VAR
      SalesLine@1001 : Record 37;
    BEGIN
      WITH SalesLine DO BEGIN
        INIT;
        VALIDATE("Document Type",SalesHeader."Document Type");
        VALIDATE("Document No.",SalesHeader."No.");
        VALIDATE("Line No.",LineNo);
        INSERT(TRUE);

        VALIDATE(Type,Type::Item);
        VALIDATE("No.",ItemNo);
        VALIDATE(Quantity,LibraryRandom.RandInt(10));
        VALIDATE("Qty. to Assemble to Order",Quantity);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE PostShippedSalesOrderAsInvoice@252(AutomaticCostPosting@1002 : Boolean);
    VAR
      AssembledItem@1000 : Record 27;
      AssemblyHeader@1004 : Record 900;
      Item@1001 : Record 27;
      SalesHeader@1008 : Record 36;
      OldAutomaticCostPosting@1003 : Boolean;
      OrderQty@1005 : Decimal;
    BEGIN
      // Setup: Update Automatic Cost Posting in Inventory setup. Create Assembled Item.
      UpdateAutomaticCostPosting(OldAutomaticCostPosting,AutomaticCostPosting);
      CreateAssembledItemWithAssemblyPolicy(AssembledItem,AssembledItem."Assembly Policy"::"Assemble-to-Order");

      // Create Sales Order with two lines for Item and Assembled Item.
      OrderQty := LibraryRandom.RandInt(5);
      LibraryInventory.CreateItem(Item);
      CreateSalesOrderWithTwoLines(SalesHeader,AssembledItem."No.",Item."No.",'',OrderQty,WORKDATE,'');

      // Add inventory for components to allow posting.
      FindAssemblyHeader(
        AssemblyHeader,AssemblyHeader."Document Type"::Order,AssembledItem,'','',
        WORKDATE,AssembledItem."Base Unit of Measure",OrderQty);
      LibraryAssembly.AddCompInventory(AssemblyHeader,WORKDATE,LibraryRandom.RandDecInRange(5,10,2));

      LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE); // Post sales order as Ship.

      // Exercise & Verify: Sales order can be posted as invoice after shipped.
      LibrarySales.PostSalesDocument(SalesHeader,FALSE,TRUE); // Post as Invoice.

      // Tear down: Rollback modified Setup.
      UpdateAutomaticCostPosting(OldAutomaticCostPosting,OldAutomaticCostPosting);
    END;

    [ModalPageHandler]
    PROCEDURE ATOLinesPageHandler@236(VAR AssembleToOrderLines@1000 : TestPage 914);
    VAR
      Item@1001 : Record 27;
      AssemblyLine@1002 : Record 901;
      QtyToConsume@1003 : Decimal;
    BEGIN
      LibraryInventory.CreateItem(Item);
      QtyToConsume := LibraryRandom.RandInt(100);
      AddInventoryNonDirectLocation(Item."No.",'','',QtyToConsume);

      AssembleToOrderLines.LAST;
      AssembleToOrderLines.Type.SETVALUE(AssemblyLine.Type::Item);
      AssembleToOrderLines."No.".SETVALUE(Item."No.");
      AssembleToOrderLines.Quantity.SETVALUE(QtyToConsume);

      AssembleToOrderLines.ShowWarning.INVOKE;
      AssembleToOrderLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE CheckAvailPageHandler@243(VAR CheckAvailability@1000 : Page 342;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::Yes;
    END;

    LOCAL PROCEDURE FindAssemblyLine@234(AssemblyHeader@1001 : Record 900;VAR AssemblyLine@1000 : Record 901);
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.FINDFIRST;
    END;

    LOCAL PROCEDURE UpdateAssemblyLine@300(AssemblyHeader@1000 : Record 900);
    VAR
      AssemblyLine@1001 : Record 901;
    BEGIN
      FindAssemblyLine(AssemblyHeader,AssemblyLine);
      AssemblyLine.VALIDATE("Quantity per",AssemblyLine."Quantity per" + LibraryRandom.RandInt(10));
      AssemblyLine.MODIFY(TRUE);
    END;

    [Test]
    [HandlerFunctions(MsgHandler,ModalPageHandler)]
    PROCEDURE UpdatedQtyInAssemblyHeaderPropagatesToLines@24();
    VAR
      AssemblyItem@1000 : Record 27;
      Location@1003 : Record 14;
      AssemblyHeader@1005 : Record 900;
      AssemblyLine@1006 : Record 901;
      TotalQty@1004 : Decimal;
      PartialQty@1007 : Decimal;
    BEGIN
      // Sicily VSTF 1
      Initialize;

      // Setup: Create assembly item (Assembly BOM = 1 child; qty-per = 1) and an assembly order for it
      CreateAssembledItem(AssemblyItem,AssemblyItem."Assembly Policy"::"Assemble-to-Order",1,LibraryRandom.RandInt(5),
        LibraryRandom.RandInt(5),1,AssemblyItem."Costing Method"::FIFO);
      LibraryWarehouse.CreateLocation(Location);

      TotalQty := LibraryRandom.RandDecInRange(5,10,2);
      PartialQty := LibraryRandom.RandDecInRange(1,4,2);
      CreateAssemblyOrder(AssemblyHeader,AssemblyItem,Location.Code,'',WORKDATE,TotalQty);

      FindItemAssemblyHeader(AssemblyHeader,AssemblyItem."No.",1);

      // Exercise & verify
      AssemblyHeader.VALIDATE(Quantity,PartialQty);
      AssemblyHeader.MODIFY(TRUE);
      FindAssemblyLine(AssemblyHeader,AssemblyLine);
      Assert.AreNearlyEqual(
        AssemblyLine."Quantity to Consume",PartialQty,GLSetup."Amount Rounding Precision",LowerQtysPropagatedMsg);

      AssemblyHeader.VALIDATE(Quantity,TotalQty);
      AssemblyHeader.MODIFY(TRUE);
      FindAssemblyLine(AssemblyHeader,AssemblyLine);
      Assert.AreNearlyEqual(
        AssemblyLine."Quantity to Consume",TotalQty,GLSetup."Amount Rounding Precision",GreaterQtysPropagatedMsg);
    END;

    [Test]
    [HandlerFunctions(MsgHandler,CheckAvailabilityHandler)]
    PROCEDURE SalesLineSetQtyWithExistingLateShippedATO@228();
    VAR
      AssembledItem@1005 : Record 27;
      AssemblyHeader@1004 : Record 900;
      SalesHeader@1002 : Record 36;
      DueDate@1007 : Date;
      DaysBack@1003 : Integer;
    BEGIN
      // [FEATURE] [Stockout Warning] [Requested Delivery Date] [Assembly to Order]
      // [SCENARIO] Assembly Order is not shifted after Quantity validation for a Sales Line with an Item being Assembled to a Sales Order with "Shipment Date" > "Promised Delivery Date".

      // [GIVEN] Stockout Warning set to TRUE, Assembled Item.
      Initialize;
      LibrarySales.SetStockoutWarning(TRUE);
      CreateAssembledItemWithAssemblyPolicy(AssembledItem,AssembledItem."Assembly Policy"::"Assemble-to-Stock");

      // [GIVEN] Sales Order with Requested/Promised Delivery Date.
      // [GIVEN] The line with Shipment Date: "SD1" > Requested Delivery Date, set full quantity assemble to order.
      DaysBack := CreateSalesOrderATOWithDeliveryDate(SalesHeader,AssembledItem."No.");
      FindItemAssemblyHeader(AssemblyHeader,AssembledItem."No.",1);
      DueDate := AssemblyHeader."Due Date";

      // [WHEN] Create second line with Shipment Date "SD2" < Requested Delivery Date.
      AddSalesOrderLineOnPage(SalesHeader,AssembledItem."No.",WORKDATE - DaysBack);

      // [THEN] Created successfully, Assembly Order has "Due Date" = "SD1".
      AssemblyHeader.FIND;
      Assert.AreEqual(DueDate,AssemblyHeader."Due Date",AssemblyHeader.FIELDCAPTION("Due Date"));
    END;

    [Test]
    [HandlerFunctions(MsgHandler,AssemblyAvailabilityFormHandler,ReservationHander)]
    PROCEDURE AssemblyOrderValidateDueDateFailsOnConflictingReservationDate@272();
    VAR
      Item@1000 : Record 27;
      SalesHeader@1001 : Record 36;
      SalesLine@1002 : Record 37;
      AssemblyHeader@1004 : Record 900;
      AssemblyOrder@1003 : TestPage 900;
      Qty@1005 : Decimal;
    BEGIN
      // [FEATURE] [Assembly] [Reservation]
      // [SCENARIO 376780] Validation of Due Date in assembly order fails if the new date conflicts with existing reservation.

      Initialize;
      // [GIVEN] Item "I" with linked assembly list and "Assemble-to-Stock" replenishment
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",1,0,0,1,Item."Costing Method"::Standard);

      // [GIVEN] Create sales order and assembly order for item "I", and reserve sales against assembly
      Qty := LibraryRandom.RandDec(100,2);
      LibrarySales.CreateSalesDocumentWithItem(SalesHeader,SalesLine,SalesHeader."Document Type"::Order,'',Item."No.",Qty,'',WORKDATE);
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WORKDATE,Item."No.",'',Qty,'');
      SalesLine.ShowReservation;

      // Date must be changed in a page, as validation relies on CurrFieldNo
      AssemblyOrder.OPENEDIT;
      AssemblyOrder.GOTORECORD(AssemblyHeader);

      // [WHEN] Change "Due Date" in assembly order
      ASSERTERROR AssemblyOrder."Due Date".SETVALUE(AssemblyOrder."Due Date".ASDATE + 1);

      // [THEN] Validation error: "The change leads to a date conflict with existing reservations"
      Assert.ExpectedErrorCode(TestValidationErrorTok);
      Assert.ExpectedError(ReservationConflictErr);
    END;

    [Test]
    [HandlerFunctions(MsgHandler,AssemblyAvailabilityFormHandler)]
    PROCEDURE AssemblyOrderDueDateNotChangedWhenValidatingUnrelatedSalesOrder@259();
    VAR
      Customer@1000 : Record 18;
      Item@1002 : Record 27;
      SalesHeader@1001 : Record 36;
      SalesLine@1003 : Record 37;
      AssemblyHeader@1007 : Record 900;
      SalesOrder@1006 : TestPage 42;
      OrderShipmentDate@1008 : Date;
    BEGIN
      // [SCENARIO 376713] Validation of shipment date on sales order does not change due date on assembly orders linked to other sales orders

      Initialize;
      LibrarySales.SetStockoutWarning(TRUE);

      // [GIVEN] Item "I" with assembly BOM
      LibrarySales.CreateCustomer(Customer);
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Stock",1,0,0,1,Item."Costing Method"::Standard);

      // [GIVEN] Create sales order "SO1" for item "I" and set "Qty. to Assemble to Order" to create a linked assembly order. Set requested delivery date to WORKDATE + 1 week
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,Customer."No.");
      SalesHeader.VALIDATE("Requested Delivery Date",CALCDATE('<1W>',WORKDATE));
      SalesHeader.MODIFY(TRUE);

      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,Item."No.",LibraryRandom.RandDec(100,2));
      SetQtyToAssembleToOrder(SalesLine,SalesLine.Quantity);

      OrderShipmentDate := SalesHeader."Shipment Date";
      FindLinkedAssemblyOrder(AssemblyHeader,SalesHeader."Document Type",SalesHeader."No.");

      // [GIVEN] Create sales order "SO2" with the same item and set requested delivery date = WORKDATE + 4 weeks
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,Customer."No.");
      SalesHeader.VALIDATE("Requested Delivery Date",CALCDATE('<4W>',WORKDATE));
      SalesHeader.MODIFY(TRUE);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,Item."No.",LibraryRandom.RandDec(100,2));
      SetQtyToAssembleToOrder(SalesLine,SalesLine.Quantity);

      // [WHEN] Change shipment date on order "SO2"
      SalesOrder.OPENEDIT;
      SalesOrder.GOTORECORD(SalesHeader);
      SalesOrder.SalesLines."Shipment Date".SETVALUE(SalesLine."Shipment Date" - 1);

      // [THEN] Due date on the assembly order linked to "SO1" has not changed
      AssemblyHeader.FIND;
      AssemblyHeader.TESTFIELD("Due Date",OrderShipmentDate);
    END;

    [Test]
    [HandlerFunctions(MsgHandler,ExplodeBOMOptionDialog)]
    PROCEDURE SalesOrderWithATOPreviewPosting@298();
    VAR
      Item@1000 : Record 27;
      SalesHeader@1001 : Record 36;
      AssemblyHeader@1006 : Record 900;
      SalesPostYesNo@1003 : Codeunit 81;
      GLPostingPreview@1002 : TestPage 115;
      NoOfItems@1004 : Integer;
      SalesQty@1005 : Decimal;
    BEGIN
      // [FEATURE] [Assembly] [Assembly to Order] [Sales Order] [Preview Posting]
      // [SCENARIO 209211] Preview posting of Sales Order with assembled-to-order item should show a result page after it is completed. Posting No. and Status of the assembly order should not be changed.
      Initialize;

      // [GIVEN] Assembly-to-Order item "I" with "X" components.
      NoOfItems := LibraryRandom.RandIntInRange(2,5);
      CreateAssembledItem(
        Item,Item."Assembly Policy"::"Assemble-to-Order",NoOfItems,0,0,LibraryRandom.RandInt(10),
        Item."Costing Method"::Standard);
      PurchaseAssembledItem(Item,LibraryRandom.RandIntInRange(20,40));

      // [GIVEN] Sales order for "I".
      // [GIVEN] Assembly Order "ATO" is automatically created and linked to the sales line.
      SalesQty := LibraryRandom.RandInt(10);
      CreateSalesOrder(SalesHeader,Item."No.",'',SalesQty,WORKDATE,'');

      // [WHEN] Run preview posting of the sales order.
      COMMIT;
      GLPostingPreview.TRAP;
      ASSERTERROR SalesPostYesNo.Preview(SalesHeader);

      // [THEN] Empty error is thrown.
      Assert.ExpectedError('');

      // [THEN] Posting preview result page shows ("X" + 2) item ledger entries, these are "X" consumed components, 1 assembled item, 1 sold item.
      GLPostingPreview.FILTER.SETFILTER("Table ID",FORMAT(DATABASE::"Item Ledger Entry"));
      GLPostingPreview."No. of Records".ASSERTEQUALS(NoOfItems + 2);

      // [THEN] "ATO"."Posting No." = ''.
      // [THEN] "ATO".Status = "Open".
      FindAssemblyHeader(AssemblyHeader,AssemblyHeader."Document Type"::Order,Item,'','',WORKDATE,
        Item."Base Unit of Measure",SalesQty);
      AssemblyHeader.TESTFIELD("Posting No.",'');
      AssemblyHeader.TESTFIELD(Status,AssemblyHeader.Status::Open);
    END;

    LOCAL PROCEDURE SetQtyToAssembleToOrder@282(VAR SalesLine@1000 : Record 37;Quantity@1001 : Decimal);
    BEGIN
      SalesLine.VALIDATE("Qty. to Assemble to Order",Quantity);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE SetupToAssemblyBin@269(LocationCode@1000 : Code[10];BinCode@1001 : Code[20]);
    VAR
      Location@1002 : Record 14;
    BEGIN
      WITH Location DO BEGIN
        GET(LocationCode);
        "To-Assembly Bin Code" := BinCode;
        MODIFY;
      END;
    END;

    LOCAL PROCEDURE SetupBinsForLocation@277(LocationCode@1000 : Code[10];VAR BinCodes@1001 : ARRAY [3] OF Code[20]);
    VAR
      Bin@1002 : Record 7354;
      Counter@1003 : Integer;
    BEGIN
      PrepareLocationForBins(LocationCode);
      FOR Counter := 1 TO ARRAYLEN(BinCodes) DO BEGIN
        BinCodes[Counter] := LibraryUtility.GenerateGUID;
        LibraryWarehouse.CreateBin(Bin,LocationCode,BinCodes[Counter],'','');
      END;
    END;

    LOCAL PROCEDURE PrepareLocationForBins@293(LocationCode@1000 : Code[10]);
    VAR
      Location@1001 : Record 14;
    BEGIN
      WITH Location DO BEGIN
        GET(LocationCode);
        VALIDATE("Require Receive",TRUE);
        VALIDATE("Require Shipment",TRUE);
        VALIDATE("Require Put-away",TRUE);
        VALIDATE("Require Pick",TRUE);
        MODIFY;
      END;
    END;

    LOCAL PROCEDURE PlaceComponentsToBins@283(ParentItemNo@1000 : Code[20];LocationCode@1008 : Code[10];BinCodes@1001 : ARRAY [3] OF Code[20];FromBinIndex@1002 : Integer;ToBinIndex@1003 : Integer;Qty@1004 : Decimal);
    VAR
      BOMComponent@1006 : Record 90;
      ItemNo@1007 : Code[20];
      Counter@1005 : Integer;
    BEGIN
      WITH BOMComponent DO BEGIN
        SETRANGE("Parent Item No.",ParentItemNo);
        SETRANGE(Type,Type::Item);
        FINDFIRST;
        ItemNo := "No.";
      END;

      FOR Counter := FromBinIndex TO ToBinIndex DO
        PostPositiveAdjmtOnBin(ItemNo,LocationCode,BinCodes[Counter],Qty);
    END;

    LOCAL PROCEDURE GetPickTakeBinCode@305(AssemblyType@1000 : Option;AssemblyNo@1001 : Code[20]) : Code[20];
    VAR
      WarehouseActivityLine@1002 : Record 5767;
    BEGIN
      WITH WarehouseActivityLine DO BEGIN
        SETRANGE("Action Type","Action Type"::Take);
        SETRANGE("Source Type",DATABASE::"Assembly Line");
        SETRANGE("Source Subtype",AssemblyType);
        SETRANGE("Source No.",AssemblyNo);
        FINDFIRST;
        EXIT("Bin Code");
      END;
    END;

    LOCAL PROCEDURE CreateSalesOrderAndAssemblyAndPick@261(VAR AssemblyHeader@1000 : Record 900;ExpectedIndex@1005 : Integer;AssembledItemNo@1001 : Code[20];OrderQty@1002 : Decimal;LocationCode@1003 : Code[10]);
    VAR
      SalesHeader@1004 : Record 36;
    BEGIN
      CreateSalesOrder(SalesHeader,AssembledItemNo,'',OrderQty,WORKDATE,LocationCode);
      FindItemAssemblyHeader(AssemblyHeader,AssembledItemNo,ExpectedIndex);
      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);
      AssemblyHeader.CreatePick(FALSE,USERID,0,FALSE,FALSE,FALSE);
    END;

    LOCAL PROCEDURE CreateSalesOrderATOWithDeliveryDate@268(VAR SalesHeader@1000 : Record 36;ItemNo@1005 : Code[20]) DaysBack : Integer;
    VAR
      SalesLine@1004 : Record 37;
    BEGIN
      DaysBack := LibraryRandom.RandIntInRange(10,20);
      WITH SalesHeader DO BEGIN
        LibrarySales.CreateSalesHeader(SalesHeader,"Document Type"::Order,'');
        VALIDATE("Location Code",LocationBlue.Code);
        VALIDATE("Requested Delivery Date",WORKDATE - DaysBack);
        VALIDATE("Promised Delivery Date",WORKDATE - DaysBack);
        MODIFY(TRUE);
      END;

      WITH SalesLine DO BEGIN
        LibrarySales.CreateSalesLineWithShipmentDate(
          SalesLine,SalesHeader,Type::Item,ItemNo,WORKDATE - (DaysBack - 1),
          LibraryRandom.RandIntInRange(100,1000));
        SetQtyToAssembleToOrder(SalesLine,Quantity);
      END;
      DaysBack += 1;
    END;

    LOCAL PROCEDURE AddSalesOrderLineOnPage@273(VAR SalesHeader@1000 : Record 36;ItemNo@1004 : Code[20];ShipmentDate@1002 : Date);
    VAR
      SalesLine@1001 : Record 37;
      SalesOrderPage@1005 : TestPage 42;
    BEGIN
      SalesOrderPage.TRAP;
      SalesOrderPage.OPENEDIT;
      SalesOrderPage.GOTORECORD(SalesHeader);
      SalesOrderPage.SalesLines.NEW;
      SalesOrderPage.SalesLines.Type.SETVALUE(SalesLine.Type::Item);
      SalesOrderPage.SalesLines."No.".SETVALUE(ItemNo);
      SalesOrderPage.SalesLines."Shipment Date".SETVALUE(ShipmentDate);
      SalesOrderPage.SalesLines.Quantity.SETVALUE(LibraryRandom.RandIntInRange(100,1000));
      SalesOrderPage.CLOSE;
    END;

    LOCAL PROCEDURE CreateAssembledItemAndBOMComponentsWithUnitCostAndUnitPrice@303(VAR Item@1000 : Record 27);
    BEGIN
      CreateAssembledItem(Item,Item."Assembly Policy"::"Assemble-to-Order",LibraryRandom.RandInt(10),
        LibraryRandom.RandInt(10),LibraryRandom.RandInt(10),LibraryRandom.RandInt(1000),
        Item."Costing Method"::FIFO);
      ChangeCostAndPriceOnCompList(Item."No.");
    END;

    LOCAL PROCEDURE CreateSalesAndResourcePricesOnCompList@307(ItemNo@1000 : Code[20]);
    VAR
      BOMComponent@1003 : Record 90;
    BEGIN
      WITH BOMComponent DO BEGIN
        SETRANGE("Parent Item No.",ItemNo);
        FINDSET;

        REPEAT
          CASE Type OF
            Type::Item:
              CreateSalesPrice("No.");
            Type::Resource:
              CreateResourcePrice("No.");
          END;
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE GetSalesPrice@284(ItemNo@1000 : Code[20];VariantCode@1001 : Code[10]) : Decimal;
    VAR
      TempSalesPrice@1003 : TEMPORARY Record 7002;
      SalesPriceCalcMgt@1002 : Codeunit 7000;
    BEGIN
      SalesPriceCalcMgt.FindSalesPrice(TempSalesPrice,'','','','',ItemNo,VariantCode,'','',WORKDATE,FALSE);
      EXIT(TempSalesPrice."Unit Price");
    END;

    LOCAL PROCEDURE CreateSalesPrice@295(ItemNo@1001 : Code[20]);
    VAR
      SalesPrice@1000 : Record 7002;
    BEGIN
      LibraryCosting.CreateSalesPrice(
        SalesPrice,SalesPrice."Sales Type"::"All Customers",'',ItemNo,WORKDATE,'','','',0);
      SalesPrice.VALIDATE("Unit Price",LibraryRandom.RandDec(100,2));
      SalesPrice.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE GetResourcePrice@285(ResourceNo@1000 : Code[20]) : Decimal;
    VAR
      ResourcePrice@1001 : Record 201;
    BEGIN
      ResourcePrice.Code := ResourceNo;
      CODEUNIT.RUN(CODEUNIT::"Resource-Find Price",ResourcePrice);
      EXIT(ResourcePrice."Unit Price");
    END;

    LOCAL PROCEDURE CreateResourcePrice@299(ResourceNo@1000 : Code[20]);
    VAR
      ResourcePrice@1001 : Record 201;
    BEGIN
      LibraryResource.CreateResourcePrice(ResourcePrice,ResourcePrice.Type::Resource,ResourceNo,'','');
      ResourcePrice.VALIDATE("Unit Price",LibraryRandom.RandDec(100,2));
      ResourcePrice.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CheckGetAsmOrdersFromSalesHeader@233(SalesHeader@1000 : Record 36;NoOfAsmOrders@1001 : Integer);
    VAR
      AssembleToOrderLink@1002 : Record 904;
      AssemblyOrders@1003 : TestPage 902;
      i@1004 : Integer;
    BEGIN
      AssemblyOrders.TRAP;
      AssembleToOrderLink.ShowAsmOrders(SalesHeader);
      AssemblyOrders.FIRST;
      i := 1;
      WHILE AssemblyOrders.NEXT DO
        i += 1;
      Assert.AreEqual(NoOfAsmOrders,i,NumberAsmOrderFromSalesHeaderMsg);
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntryCategoryAndGroupCode@278(Item@1001 : Record 27;OrderNo@1002 : Code[20]);
    VAR
      ItemLedgerEntry@1000 : Record 32;
    BEGIN
      WITH ItemLedgerEntry DO BEGIN
        SETRANGE("Item No.",Item."No.");
        SETRANGE("Order No.",OrderNo);
        FINDFIRST;
        TESTFIELD("Item Category Code",Item."Item Category Code");
        TESTFIELD("Product Group Code",Item."Product Group Code");
      END;
    END;

    LOCAL PROCEDURE VerifyWhseEntriesOfAssembly@251(AssemblyOrderNo@1000 : Code[20];OrderQty@1001 : Decimal);
    VAR
      PostedAssemblyHeader@1002 : Record 910;
      PostedAssemblyLine@1003 : Record 911;
      WarehouseEntry@1004 : Record 7312;
    BEGIN
      PostedAssemblyHeader.SETRANGE("Order No.",AssemblyOrderNo);
      PostedAssemblyHeader.FINDLAST;
      VerifyAssemblyQtyOnWhseEntry(
        PostedAssemblyHeader."Item No.",DATABASE::"Assembly Header",
        WarehouseEntry."Source Document"::"Assembly Order",AssemblyOrderNo,OrderQty);

      PostedAssemblyLine.SETRANGE("Document No.",PostedAssemblyHeader."No.");
      PostedAssemblyLine.SETRANGE(Type,PostedAssemblyLine.Type::Item);
      PostedAssemblyLine.FINDSET;
      REPEAT
        VerifyAssemblyQtyOnWhseEntry(
          PostedAssemblyLine."No.",DATABASE::"Assembly Line",
          WarehouseEntry."Source Document"::"Assembly Consumption",AssemblyOrderNo,-OrderQty);
      UNTIL PostedAssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyAssemblyQtyOnWhseEntry@267(ItemNo@1000 : Code[20];SourceType@1003 : Integer;SourceDocument@1001 : Option;SourceNo@1002 : Code[20];OrderQty@1004 : Decimal);
    VAR
      WarehouseEntry@1005 : Record 7312;
      TotalQty@1006 : Decimal;
    BEGIN
      WarehouseEntry.SETRANGE("Item No.",ItemNo);
      WarehouseEntry.SETRANGE("Source Type",SourceType);
      WarehouseEntry.SETRANGE("Source Document",SourceDocument);
      WarehouseEntry.SETRANGE("Source No.",SourceNo);
      WarehouseEntry.FINDSET;
      REPEAT
        TotalQty += WarehouseEntry.Quantity;
      UNTIL WarehouseEntry.NEXT = 0;
      Assert.AreEqual(OrderQty,TotalQty,STRSUBSTNO(WrongWhseQtyErr,SourceNo));
    END;

    LOCAL PROCEDURE VerifyAssemblyLinesSalesOrderAgainstQuote@302(SalesOrderNo@1007 : Code[20];VAR TempQuoteAssemblyLine@1008 : TEMPORARY Record 901);
    VAR
      SalesHeader@1000 : Record 36;
      AssemblyHeader@1003 : Record 900;
      AssemblyLine@1002 : Record 901;
    BEGIN
      FindLinkedAssemblyOrder(AssemblyHeader,SalesHeader."Document Type"::Order,SalesOrderNo);
      FindAssemblyLine(AssemblyHeader,AssemblyLine);

      Assert.AreEqual(TempQuoteAssemblyLine.COUNT,AssemblyLine.COUNT,DifferentNumberAsmLinesInOrderAndQuoteErr);
      TempQuoteAssemblyLine.FINDSET;
      WITH AssemblyLine DO
        REPEAT
          TESTFIELD("Line No.",TempQuoteAssemblyLine."Line No.");
          TESTFIELD(Type,TempQuoteAssemblyLine.Type);
          TESTFIELD("No.",TempQuoteAssemblyLine."No.");
          TESTFIELD("Quantity per",TempQuoteAssemblyLine."Quantity per");
          TESTFIELD(Quantity,TempQuoteAssemblyLine.Quantity);
          TESTFIELD("Remaining Quantity",TempQuoteAssemblyLine."Remaining Quantity");
        UNTIL (NEXT = 0) AND (TempQuoteAssemblyLine.NEXT = 0);
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@323(Question@1000 : Text;VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [MessageHandler]
    PROCEDURE MsgHandler@96(Message@1000 : Text[1024]);
    BEGIN
    END;

    [ModalPageHandler]
    PROCEDURE ModalPageHandler@242(VAR AssemblyAvailabilityPage@1000 : Page 908;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::Yes;     // Ignore not enough qty in inventory
    END;

    [Test]
    [HandlerFunctions(TFS6766_ATOLinesPageHandlerQuotesNoWarning)]
    PROCEDURE TFS6766_NoAvailabilityWarningOnQuote@250();
    VAR
      Item@1010 : Record 27;
      SalesHeader@1001 : Record 36;
      SalesLine@1008 : Record 37;
      SalesQuote@1000 : TestPage 41;
      OrderQty@1006 : Integer;
      DueDate@1007 : Date;
    BEGIN
      Initialize;

      LibraryInventory.CreateItem(Item);

      // create sales quote
      OrderQty := LibraryRandom.RandInt(1000);
      DueDate := CALCDATE('<+' + FORMAT(LibraryRandom.RandInt(30)) + 'D>',WorkDate2);
      CreateSaleLineWithShptDate(SalesHeader,SalesHeader."Document Type"::Quote,Item."No.",'',OrderQty,DueDate,'');
      FindSOL(SalesHeader,SalesLine,1);
      SetQtyToAssembleToOrder(SalesLine,OrderQty);

      // open Sales Quote
      SalesQuote.OPENEDIT;
      SalesQuote.GOTORECORD(SalesHeader);

      SalesQuote.SalesLines.LAST;
      SalesQuote.SalesLines."Qty. to Assemble to Order".DRILLDOWN;
    END;

    [ModalPageHandler]
    PROCEDURE TFS6766_ATOLinesPageHandlerQuotesNoWarning@235(VAR AssembleToOrderLines@1001 : TestPage 914);
    VAR
      Item@1000 : Record 27;
      AssemblyLine@1002 : Record 901;
    BEGIN
      LibraryInventory.CreateItem(Item);

      AssembleToOrderLines.LAST;
      AssembleToOrderLines.Type.SETVALUE(AssemblyLine.Type::Item);
      AssembleToOrderLines."No.".SETVALUE(Item."No.");
      AssembleToOrderLines."Quantity per".SETVALUE(LibraryRandom.RandInt(100));
    END;

    [ModalPageHandler]
    [HandlerFunctions(EnterQtyHandler)]
    PROCEDURE ItemTrackingLinesHandler@264(VAR ItemTrackingLines@1000 : TestPage 6510);
    BEGIN
      IF SelectSNFromEntries THEN
        ItemTrackingLines."Select Entries".INVOKE
      ELSE
        ItemTrackingLines."Assign Serial No.".INVOKE;
      ItemTrackingLines.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE EnterQtyHandler@265(VAR EnterQuantity@1000 : TestPage 6513);
    VAR
      Qty@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(Qty);
      EnterQuantity.QtyToCreate.VALUE := FORMAT(Qty);
      EnterQuantity.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ItemTrackingSummaryHandler@335(VAR ItemTrackingSummary@1000 : TestPage 6500);
    BEGIN
      ItemTrackingSummary.OK.INVOKE;
    END;

    [StrMenuHandler]
    PROCEDURE ExplodeBOMOptionDialog@281(Options@1000 : Text;VAR Choice@1001 : Integer;Instruction@1002 : Text);
    BEGIN
      Choice := 1;  // Use 1 for Copy Dimensions from BOM.
    END;

    [ModalPageHandler]
    PROCEDURE CheckAvailabilityHandler@292(VAR CheckAvailabilityPage@1000 : TestPage 342);
    BEGIN
      CheckAvailabilityPage.Yes.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ReservationHander@291(VAR Reservation@1000 : TestPage 498);
    BEGIN
      Reservation."Auto Reserve".INVOKE;
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [Assembly to Order] [SCM]
      This CU is covering the chapter 3.1.4 in the Test Design Specification of Kitting - Assembly to Order, as per the following
      TFS id:
       1. Test shipped Sales Order can be posted as Invoice with Automatic Cost Posting checked.
       2. Test shipped Sales Order can be posted as Invoice with Automatic Cost Posting unchecked.
       3. PostSalerOrderAsShipWithSNItemTracking
       4. Verify that Assembly components cannot be Taken twice if Bin is empty after first Take.
       5. Assembly Order is not shifted after Quantity validation for a Sales Line with an Item being Assembled to a Sales Order with "Shipment Date" > "Promised Delivery Date".

      Covers Test Cases for WI - 343481
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      PostShippedSalesOrderAsInvoiceCheckAutomaticCostPosting                                            343481
      PostShippedSalesOrderAsInvoiceUncheckAutomaticCostPosting                                          343481
      PostSalerOrderAsShipWithSNItemTracking                                                             346858

      Covers Test Cases for TFS - 105750
      ---------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      ---------------------------------------------------------------------------------------------------------
      VerifyCorrectBinATOSalesOrder                                                                      105750
      SalesLineSetQtyWithExistingLateShippedATO                                                          364331
    }
    END.
  }
}

