OBJECT Codeunit 137404 SCM Manufacturing
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      Assert@1005 : Codeunit 130000;
      CalendarAbsenceManagement@1016 : Codeunit 99000759;
      CalendarManagement@1024 : Codeunit 99000755;
      LibraryInventory@1002 : Codeunit 132201;
      LibraryItemTracking@1053 : Codeunit 130502;
      LibraryManufacturing@1001 : Codeunit 132202;
      LibraryPlanning@1042 : Codeunit 132203;
      LibraryUtility@1004 : Codeunit 131000;
      LibrarySales@1006 : Codeunit 130509;
      LibraryWarehouse@1051 : Codeunit 132204;
      LibraryDimension@1055 : Codeunit 131001;
      LibraryVariableStorage@1008 : Codeunit 131004;
      LibraryRandom@1003 : Codeunit 130440;
      ExchangeNo@1033 : Code[20];
      ItemNo2@1028 : Code[20];
      LocationCode2@1029 : Code[10];
      ProductionForecastName2@1027 : Code[20];
      ProductionOrderNo@1013 : Code[20];
      WithNo@1034 : Code[20];
      WorkCenterNo2@1025 : Code[20];
      CreateNewVersion@1035 : Boolean;
      isInitialized@1000 : Boolean;
      ShowError@1007 : Boolean;
      BlankDeleteBeforeDateError@1039 : TextConst 'ENU=You must enter the date to delete before.';
      CopyDocumentError@1014 : TextConst 'ENU=Production Order was not copied successfully.';
      MustNotExistError@1009 : TextConst 'ENU=%1 must not exist.';
      ProductionBOMStatusError@1038 : TextConst '@@@="%1 = Max. Level Value, %2 = Item No. Value, %3 = Bom Header No. Value, %4 = Level Value";ENU=The maximum number of BOM levels, %1, was exceeded. The process stopped at item number %2, BOM header number %3, BOM level %4.';
      StartingDateError@1017 : TextConst 'ENU=The Starting Date field must not be blank.';
      StartingDateError2@1032 : TextConst 'ENU=You must enter a Starting Date.';
      StartingDateError3@1037 : TextConst 'ENU=You must fill in the starting date field.';
      TimeError@1022 : TextConst 'ENU="Validation error for Field: EndingTime,  Message = ''The ending time must be later than the starting time.''"';
      UnknownError@1011 : TextConst 'ENU=Unknown Error.';
      EndingTimeError@1023 : Boolean;
      OverWrite@1021 : Boolean;
      StartingTime@1019 : Time;
      EndingTime@1020 : Time;
      CapacityValue@1018 : Decimal;
      Capacity2@1026 : Decimal;
      ProductionOrderStatus@1012 : Option;
      DateChangeFormula@1030 : DateFormula;
      GLB_ItemTrackingQty@1040 : Integer;
      GLB_SerialNo@1041 : Code[20];
      DocumentNoError@1010 : TextConst 'ENU=Document No. %1 does not exist.';
      ExpectedQuantityError@1015 : TextConst 'ENU=Quantity must be %1.';
      ModifyRtngErr@1031 : TextConst 'ENU=You cannot modify Routing No. %1 because there is at least one %2 associated with it.';
      DeleteRtngErr@1044 : TextConst 'ENU=You cannot delete Prod. Order Line %1 because there is at least one %2 associated with it.';
      CapLedgEntryCap@1036 : TextConst 'ENU=Capacity Ledger Entry';
      ItemLedgEntryCap@1046 : TextConst 'ENU=Item Ledger Entry';
      ReservationDateConflictTxt@1066 : TextConst 'ENU=The change causes a date conflict with an existing reservation';
      ReservDateConflictErr@1065 : TextConst 'ENU=The change leads to a date conflict with existing reservations.';
      ProdOrdRtngLnExistErr@1043 : TextConst 'ENU=Production Order Routing Lines exist, contrary to the expected result.';
      ProdOrdRtngLnNotExistErr@1045 : TextConst 'ENU=Production Order Routing Lines do not exist, contrary to the expected result.';
      WorkShiftShouldExistErr@1047 : TextConst 'ENU=The work shift start from %1 with allocated time %2 on %3 should exist';
      WorkShiftShouldNotExistErr@1049 : TextConst 'ENU=The work shift for non-working day should not exist';
      ProdOrderStartingDateErr@1048 : TextConst 'ENU="The Production Order''s Starting Date is wrong with Forward refreshing when setup time ends at Midnight "';
      ItemShouldExistErr@1050 : TextConst 'ENU=Item %1 should exist in Production Forecast Matrix';
      ProdOrderLineBinCodeErr@1052 : TextConst 'ENU=Wrong "Prod. Order Line" BinCode value';
      IsNotOnInventoryErr@1054 : TextConst 'ENU=You have insufficient quantity of Item %1 on inventory.';
      WrongDateTimeErr@1057 : TextConst 'ENU=Wrong %1 in Prod. Order Line.';
      ProdBOMVersionMustExistErr@1059 : TextConst 'ENU=''Exchange Production BOM Item'' batch job must create one Production BOM Version';
      ProdBOMVersionMustNotExistErr@1060 : TextConst 'ENU=Production BOM Version must not have been created';
      StartingDateTimeErr@1061 : TextConst 'ENU=Starting Date-Time is incorrect';
      EndingDateTimeErr@1062 : TextConst 'ENU=Ending Date-Time is incorrect';
      EntryOfTypeNotFoundErr@1058 : TextConst '@@@="%1 = Item Ledger Entry Type";ENU=Not found Item Ledger Entry of type %1';
      InsufficientQuantityErr@1063 : TextConst 'ENU=You have insufficient quantity';
      WrongNumberOfMessagesErr@1056 : TextConst 'ENU=Only one warning should be raised.';
      CannotDeleteItemIfProdBOMVersionExistsErr@1064 : TextConst '@@@=%1 - Tablecaption, %2 - No.;ENU=You cannot delete %1 %2 because there are one or more certified production BOM version that include this item.';
      WrongProdOrderLinesCountErr@1067 : TextConst 'ENU=Wrong number of production order lines created';

    [Test]
    [HandlerFunctions(ConfirmHandlerTrue,OutputJournalItemtrackingPageHandler,MessageHandler)]
    PROCEDURE OutputJournalApplyUnapply@120();
    VAR
      ProductionOrder@1008 : Record 5405;
      ItemLedgerEntryPositive@1002 : Record 32;
      ItemLedgerEntryNegative@1003 : Record 32;
      OutputQuantity@1000 : Integer;
    BEGIN
      // Setup: Production Order with serial tracked item
      Initialize;
      OutputQuantity := RANDOM(6);
      CreateReleasedProductionOrder(ProductionOrder);
      SetQuantity(ProductionOrder,OutputQuantity);
      SetItemTrackingCodeSerialSpecific(ProductionOrder."Source No.");

      // Exercise: Post- and reverse posting in Output Journal
      PostOutputJournalWithIT(ProductionOrder,OutputQuantity);
      PostOutputJournalWithIT(ProductionOrder,-OutputQuantity);
      PostOutputJournalWithIT(ProductionOrder,OutputQuantity);
      PostOutputJournalWithIT(ProductionOrder,-OutputQuantity);

      // Verify: Correct number of positive Item Ledger Entries from posting
      VerifyILEs(ItemLedgerEntryPositive,ProductionOrder."Source No.",1,'=0',OutputQuantity * 2);

      // Verify: Correct number of negative Item Ledger Entries from reverse posting
      VerifyILEs(ItemLedgerEntryPositive,ProductionOrder."Source No.",-1,'<>0',OutputQuantity * 2);

      REPEAT
        // Verify: Positive ILE has negative one applied to it
        ItemLedgerEntryNegative.SETRANGE("Serial No.",ItemLedgerEntryPositive."Serial No.");
        ItemLedgerEntryNegative.SETRANGE("Applies-to Entry",ItemLedgerEntryPositive."Entry No.");
        Assert.IsTrue(ItemLedgerEntryNegative.ISEMPTY,
          STRSUBSTNO('Expected ILE within filter %1 after posting/reverse posting to output journal',
            ItemLedgerEntryNegative.GETFILTERS));
      UNTIL ItemLedgerEntryPositive.NEXT = 0;
    END;

    [Test]
    [HandlerFunctions(CopyProductionOrderDocumentHandler)]
    PROCEDURE CopyPlannedProductionOrder@16();
    VAR
      ProductionOrder@1001 : Record 5405;
    BEGIN
      // Verify that a Planned Production Order can be copied into a Released Production Order.
      Initialize;
      CopyProductionOrder(ProductionOrder.Status::Planned);
    END;

    [Test]
    [HandlerFunctions(CopyProductionOrderDocumentHandler)]
    PROCEDURE CopyFirmPlannedProductionOrder@19();
    VAR
      ProductionOrder@1001 : Record 5405;
    BEGIN
      // Verify that a Firm Planned Production Order can be copied into a Released Production Order.
      Initialize;
      CopyProductionOrder(ProductionOrder.Status::"Firm Planned");
    END;

    [Test]
    [HandlerFunctions(CopyProductionOrderDocumentHandler)]
    PROCEDURE CopyReleasedProductionOrder@22();
    VAR
      ProductionOrder@1001 : Record 5405;
    BEGIN
      // Verify that a Released Production Order can be copied into a Released Production Order.
      Initialize;
      CopyProductionOrder(ProductionOrder.Status::Released);
    END;

    LOCAL PROCEDURE CopyProductionOrder@14(Status@1000 : Option);
    VAR
      ProductionOrder@1001 : Record 5405;
      NoOfRowsBeforeCopy@1004 : Integer;
    BEGIN
      // Setup: Create a Production Order and create a Released Production Order in which previous Production Order is to be copied.
      ProductionOrderNo := CreateAndRefreshProductionOrder(ProductionOrder,Status);  // ProductionOrderNo is made global as it is used in the Handler.
      ProductionOrderStatus := ProductionOrder.Status;  // ProductionOrderStatus is made global as it is used in the Handler.
      NoOfRowsBeforeCopy := CreateReleasedProductionOrder(ProductionOrder);

      // Exercise: Run Copy Production Order and Copy previously created Production Order into Released Production Order.
      ProductionOrder.GET(ProductionOrder.Status,ProductionOrder."No.");
      RunCopyProductionDocument(ProductionOrder);

      // Verify: Verify that No. of rows in the Released Production Order Lines gets increased.
      VerifyProdOrderLinesIncreaseAfterCopy(ProductionOrder,NoOfRowsBeforeCopy);
    END;

    [Test]
    [HandlerFunctions(CopyProductionOrderDocumentHandler,ConfirmHandlerTrue)]
    PROCEDURE CopyFinishedProductionOrder@12();
    VAR
      ProductionOrder@1001 : Record 5405;
      NoOfRowsBeforeCopy@1004 : Integer;
    BEGIN
      // Verify that a Finished Production Order can be copied into a Released Production Order.

      // Setup: Create a Finished Production Order and create a Released Production Order in which Finished Production Order is to be copied.
      Initialize;
      ProductionOrderNo := CreateAndRefreshProductionOrder(ProductionOrder,ProductionOrder.Status::Released);  // ProductionOrderNo is made global as it is used in the Handler.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrderNo);
      ProductionOrderStatus := ProductionOrder.Status::Finished;  // ProductionOrderStatus is made global as it is used in the Handler.
      NoOfRowsBeforeCopy := CreateReleasedProductionOrder(ProductionOrder);

      // Exercise: Run Copy Production Order and Copy Finished Production Order.
      ProductionOrder.GET(ProductionOrder.Status,ProductionOrder."No.");
      RunCopyProductionDocument(ProductionOrder);

      // Verify: Verify that No. of rows in the Released Production Order Lines gets increased.
      VerifyProdOrderLinesIncreaseAfterCopy(ProductionOrder,NoOfRowsBeforeCopy);
    END;

    [Test]
    [HandlerFunctions(ImplementRegisteredAbsenceHandler)]
    PROCEDURE ImplementRegisteredAbsenceReport@24();
    VAR
      RegisteredAbsence@1000 : Record 99000848;
      WorkCenter@1001 : Record 99000754;
    BEGIN
      // Check the functionality of Report Implement Registered Absence.

      // Setup: Create Work Center Group, Work Center and Registered Absence for the new Work Center.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,'');
      LibraryManufacturing.CreateRegisteredAbsence(
        RegisteredAbsence,RegisteredAbsence."Capacity Type"::"Work Center",WorkCenter."No.",WORKDATE,GetRoundedTime(WORKDATE),
        GetRoundedTime(WORKDATE));
      RegisteredAbsence.VALIDATE(Capacity,LibraryRandom.RandDec(10,2));  // Taking Random value for Capacity.
      RegisteredAbsence.MODIFY(TRUE);

      // Exercise: Run the Report Implement Registered Absence using the Handler.
      RunImplementRegisteredAbsenceReport(RegisteredAbsence);

      // Verify: Verify that the Calendar Absence entry gets created for the new Work Center.
      VerifyCalendarAbsenceEntry(WorkCenter."No.",RegisteredAbsence);
    END;

    [Test]
    [HandlerFunctions(OptionDialog)]
    PROCEDURE ItemReclassJournal@31();
    VAR
      SalesReceivablesSetup@1007 : Record 311;
      ItemJournalLine@1009 : Record 83;
      ItemNo@1000 : Code[20];
      ComponentNo@1001 : Code[20];
      ItemQuantity@1002 : Decimal;
      ComponentQuantity@1003 : Decimal;
      OldStockoutWarning@1006 : Boolean;
      OldCreditWarnings@1005 : Option;
    BEGIN
      // Test Explode BOM functionality on Item Reclass Journal.

      // Setup: Update Sales and Receivable Setup. Create Item and Component. Create BOM Component.
      Initialize;
      UpdateSalesReceivableSetup(OldCreditWarnings,OldStockoutWarning,SalesReceivablesSetup."Credit Warnings"::"No Warning",FALSE);
      CreateItemAndItemComponent(ItemNo,ComponentNo);
      SetItemAndComponentQuantity(ItemQuantity,ComponentQuantity);
      CreateBOMComponent(ItemNo,ComponentNo,ComponentQuantity);

      // Exercise: Create Item Reclass Journal Line and perform Explode BOM functionality.
      CreateItemReclassJournalLine(ItemJournalLine,ItemNo,ItemQuantity);
      CODEUNIT.RUN(CODEUNIT::"Item Jnl.-Explode BOM",ItemJournalLine);

      // Verify: Verify data on Item Reclass Journal.
      VerifyComponentOnItemReclassJournal(ComponentNo,ItemQuantity * ComponentQuantity);

      // Teardown: Rollback Sales and Receivable Setup.
      UpdateSalesReceivableSetup(OldCreditWarnings,OldStockoutWarning,OldCreditWarnings,OldStockoutWarning);
    END;

    [Test]
    PROCEDURE WorkCenterAbsenceUpdate@61();
    VAR
      CalendarAbsenceEntry@1002 : Record 99000760;
      WorkCenter@1000 : Record 99000754;
    BEGIN
      // Verify that the Updated field becomes True when we perform Update action on Absence entry invoked by Work Center.

      // Setup: Create a Work Center with new Work Center Group and a Calendar Absence entry for the new Work Center taking Random value for Capacity.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,'');

      // Generating Random value for StartingTime and EndingTime as their value is not important for the test.Taking Random value for Capacity.
      LibraryManufacturing.CreateCalendarAbsenceEntry(
        CalendarAbsenceEntry,CalendarAbsenceEntry."Capacity Type"::"Work Center",WorkCenter."No.",WORKDATE,TIME,TIME,
        LibraryRandom.RandDec(10,2));

      // Exercise: Perform action Update for the Calendar Absence entry created.
      CalendarAbsenceManagement.UpdateAbsence(CalendarAbsenceEntry);

      // Verify: Verify that the Updated field becomes True in the Calendar Absence entry.
      CalendarAbsenceEntry.TESTFIELD(Updated,TRUE);
    END;

    [Test]
    [HandlerFunctions(RecalculateCalendarReportHandler)]
    PROCEDURE RecalculateWorkCenterCalendarWithAbsence@60();
    VAR
      CalendarEntry@1002 : Record 99000757;
      CalendarAbsenceEntry@1009 : Record 99000760;
      ShopCalendarWorkingDays@1005 : Record 99000752;
      WorkCenter@1000 : Record 99000754;
      ExpectedCapacityTotal@1001 : Decimal;
    BEGIN
      // Verify Capacity(Total) field on Calendar entry after recalculating Work Center Calendar with Absence entry.

      // Setup: Create a Shop Calendar, a Work Center and an Absence entry for the Work Center.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));
      LibraryManufacturing.CreateCalendarAbsenceEntry(
        CalendarAbsenceEntry,CalendarAbsenceEntry."Capacity Type"::"Work Center",WorkCenter."No.",WORKDATE,
        ShopCalendarWorkingDays."Starting Time",
        ShopCalendarWorkingDays."Ending Time",LibraryRandom.RandDec(10,2));  // Taking Random value for Capacity.
      CalendarAbsenceManagement.UpdateAbsence(CalendarAbsenceEntry);

      // Update the new Work Center with important values and Calculate the Work Center Calendar.
      ModifyWorkCenterAndCalculateCalendar(WorkCenter,CalendarAbsenceEntry.Capacity);

      // Exercise: Run Report Recalculate Calendar.
      ExpectedCapacityTotal :=
        ((ShopCalendarWorkingDays."Ending Time" - ShopCalendarWorkingDays."Starting Time") /
         CalendarManagement.TimeFactor(WorkCenter."Unit of Measure Code")) * (WorkCenter.Capacity - CalendarAbsenceEntry.Capacity);
      GetCalendarEntry(CalendarEntry,CalendarEntry."Capacity Type"::"Work Center",WorkCenter."No.");
      RunRecalculateCalendarReport(CalendarEntry);

      // Verify: Verify the value of Capacity(Total) on Calendar entry.
      VerifyCalendarEntry(WorkCenter."No.",ExpectedCapacityTotal);
    END;

    [Test]
    [HandlerFunctions(RecalculateCalendarReportHandler)]
    PROCEDURE RecalculateWorkCenterCalendarWithNullStaringTimeInAbsence@44();
    VAR
      CalendarEntry@1002 : Record 99000757;
      CalendarAbsenceEntry@1009 : Record 99000760;
      CalendarAbsenceEntry2@1010 : Record 99000760;
      ShopCalendarWorkingDays@1005 : Record 99000752;
      WorkCenter@1001 : Record 99000754;
      ExpectedCapacityTotal@1000 : Decimal;
    BEGIN
      // Verify that Capacity(Total) on Calendar entry is calculated based on Absence entry having Starting and Ending Time and it ignores the Absence entry where Starting Time is null.

      // Setup: Create a Shop Calendar, a Work Center and two Absence entries for the Work Center.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));
      LibraryManufacturing.CreateCalendarAbsenceEntry(
        CalendarAbsenceEntry,CalendarAbsenceEntry."Capacity Type"::"Work Center",WorkCenter."No.",WORKDATE,
        ShopCalendarWorkingDays."Starting Time",ShopCalendarWorkingDays."Ending Time",
        LibraryRandom.RandDec(10,2));  // Taking Random value for Capacity.
      LibraryManufacturing.CreateCalendarAbsenceEntry(
        CalendarAbsenceEntry2,CalendarAbsenceEntry."Capacity Type"::"Work Center",WorkCenter."No.",WORKDATE,0T,
        ShopCalendarWorkingDays."Ending Time",
        LibraryRandom.RandDec(10,2));  // Taking Random value for Capacity.

      // Update the new Work Center with important values and Calculate the Work Center Calendar.
      ModifyWorkCenterAndCalculateCalendar(WorkCenter,CalendarAbsenceEntry.Capacity);
      ExpectedCapacityTotal :=
        ((ShopCalendarWorkingDays."Ending Time" - ShopCalendarWorkingDays."Starting Time") /
         CalendarManagement.TimeFactor(WorkCenter."Unit of Measure Code")) * (WorkCenter.Capacity - CalendarAbsenceEntry.Capacity);

      // Exercise: Run Report Recalculate Calendar.
      GetCalendarEntry(CalendarEntry,CalendarEntry."Capacity Type"::"Work Center",WorkCenter."No.");
      RunRecalculateCalendarReport(CalendarEntry);

      // Verify: Verify the value of Capacity(Total) on Calendar entry.
      VerifyCalendarEntry(WorkCenter."No.",ExpectedCapacityTotal);
    END;

    [Test]
    [HandlerFunctions(RegAbsFromWorkCenterReportHandler)]
    PROCEDURE RegisteredAbsenceFromWorkCenterReportWithBlankData@43();
    VAR
      RegAbsFromWorkCenter@1000 : Report 99003805;
    BEGIN
      // Check that the Error message is generated when Registered Absence From Work Center Report is run with blank data.

      // Setup: Set ShowError as True so that it does not enters data in the Handler.
      Initialize;
      ShowError := TRUE;  // This variable is made Global as it is used in the Handler.

      // Exercise: Run the Registered Absence From Work Center Report with blank data and catch the Error.
      CLEAR(RegAbsFromWorkCenter);
      ASSERTERROR RegAbsFromWorkCenter.RUN;

      // Verify: Verify the error message.
      Assert.AreEqual(STRSUBSTNO(StartingDateError),GETLASTERRORTEXT,UnknownError);
    END;

    [Test]
    [HandlerFunctions(RegAbsFromWorkCenterReportHandler)]
    PROCEDURE RegisteredAbsenceFromWorkCenterReportWithOverwriteFalse@66();
    VAR
      RegisteredAbsence@1003 : Record 99000848;
      WorkCenter@1002 : Record 99000754;
      Capacity@1000 : Decimal;
      Date@1001 : Date;
    BEGIN
      // Check that the Registered Absence does not gets overwritten when Registered Absence From Work Center Report is run with Overwrite = False.

      // Setup: Create a Work Center with Work Center Group and create a Registered Absence.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,'');

      // These variables are made Global as they are used in the Handler and CreateRegisteredAbsence helper method.
      OverWrite := FALSE;
      StartingTime := CalculateRandomTime;
      EndingTime := CalculateEndingTime(WorkCenter,StartingTime);
      CapacityValue := LibraryRandom.RandDec(10,2);  // Taking Random value for Capacity.
      Date := CALCDATE('<' + FORMAT(LibraryRandom.RandInt(-10)) + 'D>',WORKDATE);
      Capacity := CreateRegisteredAbsence(RegisteredAbsence."Capacity Type"::"Work Center",WorkCenter."No.",Date);

      // Exercise: Run Registered Absence From Work Center Report with Overwrite as False.
      RunRegAbsFromWorkCenterReport(WorkCenter."No.");

      // Verify: Verify that the previous Registered Absence does not gets Overwritten with the new Absence created by running the Report.
      VerifyEntryInRegisteredAbsence(WorkCenter."No.",Date,Capacity);
      VerifyEntryInRegisteredAbsence(WorkCenter."No.",WORKDATE,CapacityValue);
    END;

    [Test]
    [HandlerFunctions(RegAbsFromWorkCenterReportHandler)]
    PROCEDURE RegisteredAbsenceFromWorkCenterReportWithOverwriteTrue@67();
    VAR
      RegisteredAbsence@1002 : Record 99000848;
      WorkCenter@1000 : Record 99000754;
      Date@1001 : Date;
    BEGIN
      // Check that the Registered Absence gets overwritten when Registered Absence From Work Center Report is run with Overwrite = True.

      // Setup: Create a Work Center with Work Center Group and create a Registered Absence.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,'');

      // These variables are made Global as they are used in the Handler and CreateRegisteredAbsence helper method.
      OverWrite := TRUE;
      StartingTime := CalculateRandomTime;
      EndingTime := CalculateEndingTime(WorkCenter,StartingTime);
      CapacityValue := LibraryRandom.RandDec(10,2);  // Taking Random value for Capacity.
      Date := CALCDATE('<' + FORMAT(LibraryRandom.RandInt(-10)) + 'D>',WORKDATE);
      CreateRegisteredAbsence(RegisteredAbsence."Capacity Type"::"Work Center",WorkCenter."No.",Date);

      // Exercise: Run Registered Absence From Work Center Report with Overwrite as True.
      RunRegAbsFromWorkCenterReport(WorkCenter."No.");

      // Verify: Verify that the previous Registered Absence gets Overwritten with the new Absence created by running the Report.
      VerifyEntryInRegisteredAbsence(WorkCenter."No.",WORKDATE,CapacityValue);
    END;

    [Test]
    [HandlerFunctions(RegAbsFromMachineCenterReportHandler)]
    PROCEDURE RegisteredAbsenceFromMachineCenterReportWithStartingDateError@42();
    VAR
      RegAbsFromMachineCtr@1000 : Report 99003800;
    BEGIN
      // Check that the Error message is generated when Registered Absence From Machine Center Report is run with blank Starting Date.

      // Setup: Set ShowError as True so that it does not enters data in the Handler.
      Initialize;
      ShowError := TRUE;  // This variable is made Global as it is used in the Handler.
      EndingTimeError := TRUE;  // This variable is made Global as it is used in the Handler.

      // Exercise: Run the Registered Absence From Machine Center report with blank data and catch the Error.
      CLEAR(RegAbsFromMachineCtr);
      ASSERTERROR RegAbsFromMachineCtr.RUN;

      // Verify: Verify the error message.
      Assert.AreEqual(STRSUBSTNO(StartingDateError),GETLASTERRORTEXT,UnknownError);
    END;

    [Test]
    [HandlerFunctions(RegAbsFromMachineCenterReportHandler)]
    PROCEDURE RegisteredAbsenceFromMachineCenterReportWithTimeError@45();
    VAR
      WorkCenter@1001 : Record 99000754;
      RegAbsFromMachineCtr@1000 : Report 99003800;
    BEGIN
      // Check that the Error message is generated when Registered Absence From Machine Center Report is run with Starting Time later than the Ending Time.

      // Setup: Create a Work Center with Work Center Group. Set EndingTimeError as True so that it does not enters other values besides Times in the handler. Set Ending Time and Starting Time.
      Initialize;
      ShowError := FALSE;  // This variable is made Global as it is used in the Handler.
      EndingTimeError := TRUE;  // This variable is made Global as it is used in the Handler.
      WorkCenter.INIT;  // Required to initialize the Variable.
      EndingTime := CalculateRandomTime;
      StartingTime := CalculateEndingTime(WorkCenter,EndingTime + 10000);  // StartingTime must be Greater than EndingTime to Generate the Error.

      // Exercise: Run the Registered Absence From Machine Center report and catch the Error.
      CLEAR(RegAbsFromMachineCtr);
      ASSERTERROR RegAbsFromMachineCtr.RUN;

      // Verify: Verify the error message.
      Assert.AreEqual(STRSUBSTNO(TimeError),GETLASTERRORTEXT,UnknownError);
    END;

    [Test]
    [HandlerFunctions(RegAbsFromMachineCenterReportHandler)]
    PROCEDURE RegisteredAbsenceFromMachineCenterReportWithOverwriteFalse@50();
    VAR
      RegisteredAbsence@1001 : Record 99000848;
      WorkCenter@1003 : Record 99000754;
      MachineCenterNo@1002 : Code[20];
      Capacity@1000 : Decimal;
      Date@1004 : Date;
    BEGIN
      // Check that the Registered Absence does not gets overwritten when Registered Absence From Machine Center Report is run with Overwrite = False.

      // Setup: Create a Machine Center with Work Center Group and create a Registered Absence.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,'');
      MachineCenterNo := CreateMachineCenter(WorkCenter."No.");

      // These variables are made Global as they are used in the Handler and CreateRegisteredAbsence helper method.
      OverWrite := FALSE;
      StartingTime := CalculateRandomTime;
      EndingTime := CalculateEndingTime(WorkCenter,StartingTime);
      CapacityValue := LibraryRandom.RandDec(10,2);  // Taking Random value for Capacity.
      Date := CALCDATE('<' + FORMAT(LibraryRandom.RandInt(-10)) + 'D>',WORKDATE);
      Capacity := CreateRegisteredAbsence(RegisteredAbsence."Capacity Type"::"Machine Center",MachineCenterNo,Date);

      // Exercise: Run Registered Absence From Machine Center Report with Overwrite as False.
      RunRegAbsFromMachineCenterReport(MachineCenterNo);

      // Verify: Verify that the previous Registered Absence does not gets Overwritten with the new Absence created by running the Report.
      VerifyEntryInRegisteredAbsence(MachineCenterNo,Date,Capacity);
      VerifyEntryInRegisteredAbsence(MachineCenterNo,WORKDATE,CapacityValue);
    END;

    [Test]
    [HandlerFunctions(RegAbsFromMachineCenterReportHandler)]
    PROCEDURE RegisteredAbsenceFromMachineCenterReportWithOverwriteTrue@52();
    VAR
      RegisteredAbsence@1001 : Record 99000848;
      WorkCenter@1000 : Record 99000754;
      MachineCenterNo@1002 : Code[20];
      Date@1003 : Date;
    BEGIN
      // Check that the Registered Absence gets overwritten when Registered Absence From Machine Center Report is run with Overwrite = True.

      // Setup: Create a Machine Center with Work Center Group and create a Registered Absence.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,'');
      MachineCenterNo := CreateMachineCenter(WorkCenter."No.");

      // These variables are made Global as they are used in the Handler and CreateRegisteredAbsence helper method.
      OverWrite := TRUE;
      StartingTime := CalculateRandomTime;
      EndingTime := CalculateEndingTime(WorkCenter,StartingTime);
      CapacityValue := LibraryRandom.RandDec(10,2);  // Taking Random value for Capacity.
      Date := CALCDATE('<' + FORMAT(LibraryRandom.RandInt(-10)) + 'D>',WORKDATE);
      CreateRegisteredAbsence(RegisteredAbsence."Capacity Type"::"Machine Center",MachineCenterNo,Date);

      // Exercise: Run Registered Absence From Machine Center Report with Overwrite as True.
      RunRegAbsFromMachineCenterReport(MachineCenterNo);

      // Verify: Verify that the previous Registered Absence gets Overwritten with the new Absence created by running the Report.
      VerifyEntryInRegisteredAbsence(MachineCenterNo,WORKDATE,CapacityValue);
    END;

    [Test]
    [HandlerFunctions(RecalculateCalendarReportHandler)]
    PROCEDURE RecalculateMachineCenterCalendarReport@55();
    VAR
      CalendarEntry@1006 : Record 99000757;
      MachineCenter@1000 : Record 99000758;
      ShopCalendar@1004 : Record 99000751;
      WorkCenter@1003 : Record 99000754;
      Capacity@1001 : Decimal;
      ExpectedCapacityTotal@1002 : Decimal;
    BEGIN
      // Check the functionality of Recalculate Calendar for Machine Center.

      // Setup: Create a Work Center and Machine Center. Calculate Calendar for Machine Center and modify the Capacity value for it.
      Initialize;
      ShopCalendar.FINDFIRST;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,ShopCalendar.Code);
      MachineCenter.GET(CreateMachineCenter(WorkCenter."No."));
      Capacity := ModifyCapacityOfMachineCenter(MachineCenter."No.");
      LibraryManufacturing.CalculateMachCenterCalendar(
        MachineCenter,WORKDATE,CALCDATE('<' + FORMAT(LibraryRandom.RandInt(5)) + 'Y>',WORKDATE));

      // Exercise: Run Report Recalculate Calendar for the new Machine Center.
      GetCalendarEntry(CalendarEntry,CalendarEntry."Capacity Type"::"Machine Center",MachineCenter."No.");

      // Capacity(Total) is the multiplication of Capacity with the Shift Time.
      ExpectedCapacityTotal :=
        ((CalendarEntry."Ending Time" - CalendarEntry."Starting Time") /
         CalendarManagement.TimeFactor(WorkCenter."Unit of Measure Code")) * Capacity;
      RunRecalculateCalendarReport(CalendarEntry);

      // Verify: Verify that Recalculate Calendar report updates the Calandar Entry according to the modified Capacity value.
      GetCalendarEntry(CalendarEntry,CalendarEntry."Capacity Type"::"Machine Center",MachineCenter."No.");
      CalendarEntry.TESTFIELD("Capacity (Total)",ExpectedCapacityTotal);
    END;

    [Test]
    [HandlerFunctions(WorkCenterCalendarMatrixHandler)]
    PROCEDURE CalculatedCapacityOnWorkCenterCalendarMatrix@79();
    VAR
      WorkCenter@1000 : Record 99000754;
      ShopCalendarWorkingDays@1001 : Record 99000752;
    BEGIN
      // Test and Verify Calculated Capacity on Work Center Calendar Matrix Page.

      // Setup: Create Work Center with Work Center Group.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));

      // Exercise: Calculate Work Center Calendar.
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,WORKDATE,WORKDATE);
      WorkCenterNo2 := WorkCenter."No.";  // Use WorkCenterNo2 as global for Handler.

      // Verify: Verify Calculated Capacity on WorkCenterCalendarMatrixHandler function and verification is done in Handler.
      VerifyCalculatedCapacity;
    END;

    [Test]
    [HandlerFunctions(ProductionJournalHandler,ConfirmHandlerTrue,MessageHandler)]
    PROCEDURE ExpectedCapacityNeedOnProductionOrderStatistics@77();
    VAR
      ProductionOrder@1000 : Record 5405;
      ProdOrderComponent@1002 : Record 5407;
      ProductionJournalMgt@1001 : Codeunit 5510;
    BEGIN
      // Test and Verify Expected Capacity Need on Production Order Statistics.

      // Setup: Create Initial Setup for Released Production Order.
      Initialize;
      CreateInitialSetupForReleasedProductionOrder(ProductionOrder,ProdOrderComponent);

      // Exercise: Open and post Production Journal. Posting is done in ProductionJournalHandler function.
      ProductionJournalMgt.Handling(ProductionOrder,ProdOrderComponent."Prod. Order Line No.");

      // Verify: Verify Expected Capacity Need on Production Order Statistics.
      VerifyProductionOrderStatistics;
    END;

    [Test]
    [HandlerFunctions(ProductionJournalHandler,ConfirmHandlerTrue,MessageHandler)]
    PROCEDURE ConsumptionPostedByProductionJournal@76();
    VAR
      ProductionOrder@1000 : Record 5405;
      ProdOrderComponent@1002 : Record 5407;
      ItemLedgerEntry@1003 : Record 32;
      ProductionJournalMgt@1001 : Codeunit 5510;
    BEGIN
      // Test and Verify Consumption posted by Production Journal.

      // Setup: Create Initial Setup for Released Production Order.
      Initialize;
      CreateInitialSetupForReleasedProductionOrder(ProductionOrder,ProdOrderComponent);

      // Exercise: Open and post Production Journal. Posting is done in ProductionJournalHandler function.
      ProductionJournalMgt.Handling(ProductionOrder,ProdOrderComponent."Prod. Order Line No.");

      // Verify: Verify Consumption Entry on Item Ledger.
      VerifyItemLedgerEntry(
        ProdOrderComponent."Item No.",ItemLedgerEntry."Entry Type"::Consumption,-ProdOrderComponent."Expected Quantity");
    END;

    [Test]
    PROCEDURE CapacityLedgerEntryAfterPostingCapacityJournal@87();
    VAR
      ShopCalendarWorkingDays@1000 : Record 99000752;
      WorkCenter@1003 : Record 99000754;
      Quantity@1004 : Decimal;
    BEGIN
      // Verify Capacity Ledger Entry after posting Capacity Journal Line.

      // Setup: Create Work Center with Work Center Group.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));
      Quantity := LibraryRandom.RandInt(5); // Use random value for Quantity.

      // Exercise: Create and post Capacity Journal.
      CreateAndPostCapacityJournal(Quantity,WorkCenter."No.");

      // Verify: Verify Capacity Ledger Entry.
      VerifyCapacityLedgerEntry(WorkCenter."No.",Quantity);
    END;

    [Test]
    [HandlerFunctions(CopyProductionForecastHandler,ConfirmHandlerTrue)]
    PROCEDURE CopyProductionForecastNameWithBlankDescription@90();
    VAR
      ProductionForecastEntry@1002 : Record 99000852;
    BEGIN
      // Test and verify functionality of Copy Production Forecast report with blank Production Forecast Name.

      // Setup.
      Initialize;

      // Exercise: Run Copy Production Forecast report with blank Production Forecast Name.
      RunCopyProductionForecast(ProductionForecastEntry);

      // Verify: Verify that new lines comes with Blank Name and Description.
      VerifyProductionForecastName;
    END;

    [Test]
    [HandlerFunctions(CopyProductionForecastHandler,ConfirmHandlerTrue)]
    PROCEDURE CopyProductionForecastEntry@101();
    VAR
      ProductionForecastName@1001 : Record 99000851;
      ProductionForecastEntry@1002 : Record 99000852;
    BEGIN
      // Test and verify functionality of Copy Production Forecast report with Production Forecast Entry.

      // Setup: Create Production Forecast Name and Production Forecast Entry.
      Initialize;
      LibraryManufacturing.CreateProductionForecastName(ProductionForecastName);
      CreateProductionForecastEntry(ProductionForecastEntry,ProductionForecastName.Name);
      LibraryManufacturing.CreateProductionForecastName(ProductionForecastName);
      ProductionForecastName2 := ProductionForecastName.Name;  // Use ProductionForecastName2 as global for handler.
      ItemNo2 := ProductionForecastEntry."Item No.";  // Use ItemNo2 as global for handler.
      LocationCode2 := ProductionForecastEntry."Location Code";  // Use LocationCode2 as global for handler.
      EVALUATE(DateChangeFormula,'<' + FORMAT(LibraryRandom.RandInt(5)) + 'D>');  // Use DateChangeFormula as global for handler and taking random value.

      // Exercise: Run Copy Production Forecast report.
      ProductionForecastEntry.SETRANGE("Production Forecast Name",ProductionForecastEntry."Production Forecast Name");
      RunCopyProductionForecast(ProductionForecastEntry);

      // Verify: Verify Production Forecast Entry must be copied.
      VerifyProductionForecastEntry(ProductionForecastEntry);
    END;

    [Test]
    [HandlerFunctions(ExchangeProductionBOMItemHandler)]
    PROCEDURE ExchangeProductionBOMItemError@127();
    BEGIN
      // [FEATURE] [Production BOM] [Exchange Production BOM Item]
      // [SCENARIO] Exchange Production BOM Item report throws an error when executed with the blank "Starting Date"

      Initialize;

      // [WHEN] Run Exchange Production BOM Item report with blank Starting Date.
      ShowError := TRUE;
      ASSERTERROR RunExchangeProductionBOMItemReport;

      // [THEN] Error message: "You must enter a Starting Date."
      Assert.AreEqual(STRSUBSTNO(StartingDateError2),GETLASTERRORTEXT,UnknownError);
    END;

    [Test]
    [HandlerFunctions(ExchangeProductionBOMItemHandler)]
    PROCEDURE ExchangeProductionBOMItemWithCreateNewVersion@94();
    VAR
      Item@1000 : Record 27;
      Item2@1001 : Record 27;
    BEGIN
      // [FEATURE] [Production BOM] [Exchange Production BOM Item]
      // [SCENARIO] Item must be exchanged by Exchange Production BOM Item report, where "Create New Version" is Yes, "Delete Exchanged Component" is No

      // [GIVEN] Create two Items with Routing and Production BOM.
      Initialize;
      Item.GET(CreateItemWithRoutingAndProductionBOM);
      Item2.GET(CreateItemWithRoutingAndProductionBOM);
      ExchangeNo := FindProductionBOMComponent(Item."Production BOM No.");  // Use ExchangeNo as global for handler.
      WithNo := FindProductionBOMComponent(Item2."Production BOM No.");  // Use WithNo as global for handler.
      CreateNewVersion := TRUE;  // Use CreateNewVersion as global for handler.

      // [WHEN] Run Exchange Production BOM Item report with Create New Version as true and Delete Exchanged Component as false.
      RunExchangeProductionBOMItemReport;

      // [THEN] Item has been exchanged.
      VerifyProductionBOMLineNotExists(Item."Production BOM No.",FindLastBOMVersionCode(Item."Production BOM No."),ExchangeNo);
      VerifyProductionBOMLineExists(Item."Production BOM No.",FindLastBOMVersionCode(Item."Production BOM No."),WithNo);
    END;

    [Test]
    [HandlerFunctions(ExchangeProductionBOMItemHandler)]
    PROCEDURE ExchangeProductionBOMItemWithDeleteExchangedComponent@96();
    VAR
      Item@1000 : Record 27;
      Item2@1001 : Record 27;
    BEGIN
      // [FEATURE] [Production BOM] [Exchange Production BOM Item]
      // [SCENARIO] Item must be removed from BOM by Exchange Production BOM Item report, where "Create New Version" is No, "Delete Exchanged Component" is Yes

      // [GIVEN] Create two Items with Routing and Production BOM. Run Exchange Production BOM Item report with Create New Version as true and Delete Exchanged Component as false.
      Initialize;
      Item.GET(CreateItemWithRoutingAndProductionBOM);
      Item2.GET(CreateItemWithRoutingAndProductionBOM);
      ExchangeNo := FindProductionBOMComponent(Item."Production BOM No.");  // Use ExchangeNo as global for handler.
      WithNo := FindProductionBOMComponent(Item2."Production BOM No.");  // Use WithNo as global for handler.
      // BOM Comment is required for IN localization
      CreateCommentLineForProductionBOM(Item."Production BOM No.");

      // [WHEN] Run Exchange Production BOM Item report with Create New Version as false and Delete Exchanged Component as true.
      CreateNewVersion := FALSE;  // Use CreateNewVersion as global for handler.
      RunExchangeProductionBOMItemReport;

      // [THEN] Exchanged Item has been removed from the BOM.
      VerifyProductionBOMLineNotExists(Item."Production BOM No.",'',ExchangeNo);
      VerifyProductionBOMLineExists(Item."Production BOM No.",'',WithNo);
    END;

    [Test]
    [HandlerFunctions(ExchangeProductionBOMItemHandler)]
    PROCEDURE ExchangeProductionBOMRollback@46();
    VAR
      ParentItemNoRouting@1002 : Record 27;
      ParentItemWithRouting@1009 : Record 27;
      ComponentItem@1003 : ARRAY [10] OF Record 27;
      ExchangeItem@1006 : Record 27;
      RoutingHeader@1007 : Record 99000763;
      RoutingLine@1001 : Record 99000764;
      ProductionBOMHeaderNoRouting@1004 : Record 99000771;
      ProductionBOMHeaderWithRouting@1008 : Record 99000771;
      RoutingLinkCode@1005 : ARRAY [10] OF Code[10];
      RoutingNo@1000 : Code[20];
    BEGIN
      // [FEATURE] [Production BOM] [Exchange Production BOM Item]
      // [SCENARIO] Changes are rolled back if the Exchange Production BOM Item report encounters an error

      Initialize;

      // [GIVEN] Create Routing
      RoutingNo := CreateRoutingWithRoutingLinkCode;
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      RoutingLine.FINDFIRST;

      // [GIVEN] Create Items and Production BOM
      LibraryInventory.CreateItem(ParentItemNoRouting);
      LibraryInventory.CreateItem(ParentItemWithRouting);
      LibraryInventory.CreateItem(ComponentItem[1]);
      LibraryInventory.CreateItem(ComponentItem[2]);
      LibraryInventory.CreateItem(ExchangeItem);

      // [GIVEN] Assign Production BOM and Routing to Parent
      // [GIVEN] Create first Production BOM without Routing Link
      RoutingLinkCode[1] := '';
      CreateProdBOMMultipleLinesRoutingLink(
        ProductionBOMHeaderNoRouting,ComponentItem,RoutingLinkCode,ParentItemNoRouting."Base Unit of Measure");
      // [GIVEN] Create second Production BOM with Routing Link for first line only
      RoutingLinkCode[1] := RoutingLine."Routing Link Code";
      CreateProdBOMMultipleLinesRoutingLink(
        ProductionBOMHeaderWithRouting,ComponentItem,RoutingLinkCode,ParentItemWithRouting."Base Unit of Measure");
      ParentItemNoRouting.VALIDATE("Production BOM No.",ProductionBOMHeaderNoRouting."No.");
      ParentItemNoRouting.MODIFY(TRUE);
      ParentItemWithRouting.VALIDATE("Routing No.",RoutingNo);
      ParentItemWithRouting.VALIDATE("Production BOM No.",ProductionBOMHeaderWithRouting."No.");
      ParentItemWithRouting.MODIFY(TRUE);

      // [GIVEN] Remove Routing Link from Routing Line to enforce error in ProductionBOMHeaderWithRouting
      RoutingHeader.GET(RoutingNo);
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::"Under Development");
      RoutingLine.VALIDATE("Routing Link Code",'');
      RoutingLine.MODIFY(TRUE);
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::Certified);

      // Define Parameters for RequestPageHandler
      // [GIVEN] Exchange second ComponentItem with ExchangeItem in Production BOM
      ExchangeNo := ComponentItem[2]."No.";
      WithNo := ExchangeItem."No.";
      CreateNewVersion := FALSE;

      // [WHEN] Run Exchange Production BOM Item report
      ASSERTERROR RunExchangeProductionBOMItemReport;

      // [THEN] Production Order Status is Certified, the previous component lines have been restored and the lines for exchange item have been rolled back
      ProductionBOMHeaderNoRouting.FIND('=');
      ProductionBOMHeaderNoRouting.TESTFIELD(Status,ProductionBOMHeaderNoRouting.Status::Certified);
      VerifyProductionBOMLineExists(ProductionBOMHeaderNoRouting."No.",'',ComponentItem[1]."No.");
      VerifyProductionBOMLineExists(ProductionBOMHeaderNoRouting."No.",'',ComponentItem[2]."No.");
      VerifyProductionBOMLineNotExists(ProductionBOMHeaderNoRouting."No.",'',ExchangeItem."No.");
      ProductionBOMHeaderWithRouting.FIND('=');
      ProductionBOMHeaderWithRouting.TESTFIELD(Status,ProductionBOMHeaderWithRouting.Status::Certified);
      VerifyProductionBOMLineExists(ProductionBOMHeaderWithRouting."No.",'',ComponentItem[1]."No.");
      VerifyProductionBOMLineExists(ProductionBOMHeaderWithRouting."No.",'',ComponentItem[2]."No.");
      VerifyProductionBOMLineNotExists(ProductionBOMHeaderWithRouting."No.",'',ExchangeItem."No.");
    END;

    [Test]
    PROCEDURE ParentItemInProductionBOMLineError@103();
    VAR
      Item@1000 : Record 27;
      ProductionBOMHeader@1005 : Record 99000771;
      ProductionBOMLine@1001 : Record 99000772;
    BEGIN
      // Validate error message when Status is set to Certified in Production BOM on adding Parent Item in BOM Line.

      // Setup: Create Item and Production BOM. Add Parent Item as a Component in BOM.
      Initialize;
      Item.GET(CreateItemWithRoutingAndProductionBOM);
      AddParentItemAsBOMComponent(ProductionBOMHeader,ProductionBOMLine,Item);

      // Exercise: Change the Status of Production BOM and catch the error.
      ASSERTERROR ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);

      // Verify: Status error in Production BOM when Status is set to Certified.
      Assert.AreEqual(STRSUBSTNO(ProductionBOMStatusError,50,'',Item."No.",1),GETLASTERRORTEXT,UnknownError);
    END;

    [Test]
    PROCEDURE ParentItemInProductionBOMLineUnderDevelopment@100();
    VAR
      Item@1001 : Record 27;
      ProductionBOMHeader@1005 : Record 99000771;
      ProductionBOMLine@1000 : Record 99000772;
    BEGIN
      // Validate Status can be set to Under Development on adding Parent Item in BOM Line and Certified on deleting the Parent Item from BOM Line.

      // Setup: Create Item and Production BOM. Add Parent Item in Production BOM Line and set Status as Under Development.
      Initialize;
      Item.GET(CreateItemWithRoutingAndProductionBOM);
      AddParentItemAsBOMComponent(ProductionBOMHeader,ProductionBOMLine,Item);
      CreateCommentLineForItem(Item."No.");
      // Exercise: Delete Production BOM Line with Parent Item and set Production BOM status as Certified.
      ProductionBOMLine.DELETE(TRUE);
      ModifyStatusInProductionBOM(ProductionBOMHeader,ProductionBOMHeader.Status::Certified);

      // Verify: Verify that the Status in Production BOM is Certified.
      ProductionBOMHeader.TESTFIELD(Status,ProductionBOMHeader.Status::Certified);
    END;

    [Test]
    PROCEDURE CalculateWorkCenterCalendarReportWithBlankStartingDate@109();
    VAR
      ShopCalendarWorkingDays@1000 : Record 99000752;
      WorkCenter@1001 : Record 99000754;
    BEGIN
      // Test to verify error message on running Calculate Work Center Calendar report with blank Starting date.

      // Setup: Create Work Center with Work Center Group.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));

      // Exercise: Run Calculate Work Center Calendar Report with blank Starting date.
      ASSERTERROR LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,0D,WORKDATE);

      // Verify: Error message that Starting Date must have a value.
      Assert.AreEqual(STRSUBSTNO(StartingDateError3),GETLASTERRORTEXT,UnknownError);
    END;

    [Test]
    PROCEDURE CalculateWorkCenterCalendarReport@108();
    VAR
      CalendarEntry@1004 : Record 99000757;
      ShopCalendarWorkingDays@1000 : Record 99000752;
      WorkCenter@1002 : Record 99000754;
      ExpectedCapacityTotal@1003 : Decimal;
    BEGIN
      // Test to verify the functionality of Calculate Work Center Calendar report.

      // Setup: Create Work Center with Work Center Group.
      Initialize;
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));
      ModifyCapacityOfWorkCenter(WorkCenter);

      // Exercise: Calculate Work Center Calendar. Store the expected value for Capacity Total in a variable.
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,WORKDATE,WORKDATE);
      GetCalendarEntry(CalendarEntry,CalendarEntry."Capacity Type"::"Work Center",WorkCenter."No.");
      ExpectedCapacityTotal :=
        ((CalendarEntry."Ending Time" - CalendarEntry."Starting Time") /
         CalendarManagement.TimeFactor(WorkCenter."Unit of Measure Code")) * WorkCenter.Capacity;

      // Verify: Capacity Total on Calendar entry.
      VerifyCalendarEntry(WorkCenter."No.",ExpectedCapacityTotal);
    END;

    [Test]
    [HandlerFunctions(DeleteExpiredComponentsHandler)]
    PROCEDURE DeleteExpiredComponentsReportWithError@110();
    VAR
      ProductionBOMHeader@1000 : Record 99000771;
    BEGIN
      // Test the functionality of Delete Expired Components report with blank Delete Before Date.

      // Setup.
      Initialize;

      // Exercise: Run Delete Expired Components report with blank Delete Before Date.
      ShowError := TRUE;  // This variable is made Global as it is used in the Handler.
      ASSERTERROR RunDeleteExpiredComponentsReport(ProductionBOMHeader);

      // Verify: Verify blank Delete Before Date error message.
      Assert.AreEqual(STRSUBSTNO(BlankDeleteBeforeDateError),GETLASTERRORTEXT,UnknownError);
    END;

    [Test]
    [HandlerFunctions(DeleteExpiredComponentsHandler)]
    PROCEDURE DeleteExpiredComponentsReport@95();
    VAR
      ProductionBOMHeader@1000 : Record 99000771;
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      // Test the functionality of Delete Expired Components report.

      // Setup: Create and modify Production BOM.
      Initialize;
      CreateAndModifyProductionBOM(ProductionBOMHeader);

      // Exercise:  Run Delete Expired Components report.
      ProductionBOMHeader.SETRANGE("No.",ProductionBOMHeader."No.");
      RunDeleteExpiredComponentsReport(ProductionBOMHeader);

      // Verify: Verify expired component must not exist.
      Assert.IsFalse(
        FindProductionBOMLine(ProductionBOMLine,ProductionBOMHeader."No."),STRSUBSTNO(MustNotExistError,ProductionBOMLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE RefreshPlanningLine@125();
    VAR
      RequisitionLine@1001 : Record 246;
      Direction@1003 : 'Forward,Backward';
    BEGIN
      // Test and verify Starting Date and Ending Date after refreshing Planning Line.

      // Setup: Create Requisition Line.
      Initialize;
      CreateRequisitionLine(RequisitionLine);

      // Exercise: Refresh Planning Line.
      LibraryPlanning.RefreshPlanningLine(RequisitionLine,Direction::Backward,TRUE,TRUE);

      // Verify: Verify Starting Date and Ending Date after refreshing Planning Line.
      RequisitionLine.FIND;
      RequisitionLine.TESTFIELD("Starting Date",WORKDATE);
      RequisitionLine.TESTFIELD("Ending Date",WORKDATE);
    END;

    [Test]
    PROCEDURE DeletePlanningWorksheetLines@130();
    VAR
      Item@1000 : Record 27;
      RequisitionLine@1001 : Record 246;
    BEGIN
      // Test and verify Delete Planning Worksheet Lines functionality after Calculate Regenerative Plan.

      // Setup: Create Item with Lot for Lot Reordering Policy and Safety Stock Quantity.
      Initialize;
      CreateItemWithLotForLotReorderingPolicyAndSafetyStockQuantity(Item);
      LibraryPlanning.CalcRegenPlanForPlanWksh(Item,WORKDATE,WORKDATE);
      RequisitionLine.SETRANGE("No.",Item."No.");
      RequisitionLine.FINDFIRST;

      // Exercise: Delete all Planning Worksheet Lines.
      RequisitionLine.DELETEALL(TRUE);

      // Verify: Verify all Planning Worksheet Lines must be deleted.
      Assert.AreEqual(0,RequisitionLine.COUNT,STRSUBSTNO(MustNotExistError,RequisitionLine.TABLECAPTION));
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandlerTrue)]
    PROCEDURE CalculateConsumptionAfterRefreshProductionOrder@1018();
    VAR
      InventorySetup@1001 : Record 313;
      ProductionOrder@1002 : Record 5405;
      ProdOrderComponent@1003 : Record 5407;
      ItemJournalBatch@1004 : Record 233;
    BEGIN
      // Test to validate Consumption Journal After release Production Order and calculate Consumption.

      // Setup : Create and Release Production Order.
      InventorySetup.GET;
      UpdateInventorySetup(TRUE,TRUE);
      CreateInitialSetupForReleasedProductionOrder(ProductionOrder,ProdOrderComponent);

      // Exercise: Run Calculate Consumption report.
      CalculateConsumptionJournal(ItemJournalBatch,ProductionOrder."No.");

      // Verify : Consumption Journal.
      VerifyItemJournalLine(
        ItemJournalBatch,ProductionOrder."No.",ProdOrderComponent."Item No.",ProdOrderComponent."Expected Quantity");

      // Tear Down : Set Default value of Inventory Setup.
      UpdateInventorySetup(InventorySetup."Expected Cost Posting to G/L",InventorySetup."Automatic Cost Posting");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandlerTrue)]
    PROCEDURE OutputJournalAfterCalculateConsumption@1017();
    VAR
      InventorySetup@1005 : Record 313;
      ProductionOrder@1006 : Record 5405;
      ProdOrderComponent@1007 : Record 5407;
      ItemJournalBatch@1008 : Record 233;
    BEGIN
      // Test to validate Output Journal after Posting Consumption Journal.

      // Setup : Create and Release Production Order and Calculate Consumption Journal.
      InventorySetup.GET;
      UpdateInventorySetup(TRUE,TRUE);
      CreateInitialSetupForReleasedProductionOrder(ProductionOrder,ProdOrderComponent);
      CreateAndPostConsumptionJournal(ProductionOrder."No.");

      // Exercise: Create Output Journal with Explode Routing.
      OutputJournalExplodeRouting(ItemJournalBatch,ProductionOrder);

      // Verify : Output Journal.
      VerifyItemJournalLine(ItemJournalBatch,ProductionOrder."No.",ProductionOrder."Source No.",ProductionOrder.Quantity);

      // Tear Down : Set Default value of Inventory Setup.
      UpdateInventorySetup(InventorySetup."Expected Cost Posting to G/L",InventorySetup."Automatic Cost Posting");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandlerTrue)]
    PROCEDURE GLEntryAfterPostOutputJournal@1016();
    VAR
      InventorySetup@1010 : Record 313;
      ProductionOrder@1011 : Record 5405;
      ProdOrderComponent@1012 : Record 5407;
      ItemJournalBatch@1013 : Record 233;
    BEGIN
      // Test to validate G/L Entry after posting output Journal.

      // Setup : Create and Release Production Order, Calculate Consumption Journal and create Output Journal.
      InventorySetup.GET;
      UpdateInventorySetup(TRUE,TRUE);
      CreateInitialSetupForReleasedProductionOrder(ProductionOrder,ProdOrderComponent);
      CreateAndPostConsumptionJournal(ProductionOrder."No.");
      OutputJournalExplodeRouting(ItemJournalBatch,ProductionOrder);

      // Exercise : Post Output Journal.
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);

      // Verify : G/L Entry.
      VerifyGLEntry(ProductionOrder."Inventory Posting Group",ProductionOrder."No.");

      // Tear Down : Set Default value of Inventory Setup.
      UpdateInventorySetup(InventorySetup."Expected Cost Posting to G/L",InventorySetup."Automatic Cost Posting");
    END;

    [Test]
    [HandlerFunctions(ProductionJournalHandler,ConfirmHandlerTrue,MessageHandler,ViewAppliedEntriesPageHandler)]
    PROCEDURE QuantityOnAppliedEntriesAfterApplicationWorkSheet@1();
    VAR
      ProductionOrder@1000 : Record 5405;
      ProdOrderComponent@1001 : Record 5407;
      SalesHeader@1002 : Record 36;
      ProductionJournalMgt@1003 : Codeunit 5510;
      ApplicationWorksheet@1004 : TestPage 521;
      Quantity@1005 : Decimal;
    BEGIN
      // Check the Quantity on View Applied Item Entries After Application Worksheet.

      // Setup : Create and Release Production Order, Open and post Production Journal using ProductionJournalHandler.
      Initialize;
      CreateInitialSetupForReleasedProductionOrder(ProductionOrder,ProdOrderComponent);
      ProductionJournalMgt.Handling(ProductionOrder,ProdOrderComponent."Prod. Order Line No.");
      Quantity := LibraryRandom.RandDec(10,2);
      CreateAndPostSalesOrder(SalesHeader,ProductionOrder."Source No.",Quantity);
      LibraryVariableStorage.Enqueue(ProductionOrder."Source No.");
      LibraryVariableStorage.Enqueue(-1 * Quantity);
      ApplicationWorksheet.OPENEDIT;
      ApplicationWorksheet.FILTER.SETFILTER("Item No.",ProductionOrder."Source No.");

      // Exercise: Open View Applied Entries Page.
      ApplicationWorksheet.AppliedEntries.INVOKE;

      // Verify: Verification done in ViewAppliedEntriesPageHandler.
    END;

    [Test]
    PROCEDURE DocumentNoOnItemLedgerEntry@9();
    VAR
      Item@1001 : Record 27;
      Item2@1002 : Record 27;
      ItemJournalLine@1003 : Record 83;
      ProductionOrder@1007 : Record 5405;
      DocumentNo@1000 : Code[20];
      Quantity@1009 : Decimal;
      OldDocNoIsProdOrderNo@1010 : Boolean;
    BEGIN
      // Check Document No. on Item Ledger Entry when Field Doc. No. Is Prod. Order No. is False on Manufacturing Setup.

      // Setup : Create and Release Production Order, Update Manufacturing Setup and Production Order Component.
      Initialize;
      OldDocNoIsProdOrderNo := UpdateManufacturingSetup(FALSE);
      Quantity := LibraryRandom.RandDec(10,2);
      CreateMultipleItemsWithReorderingPolicy(Item,Item2,Quantity);
      CreateAndPostItemJournalLine(
        ItemJournalLine,ItemJournalLine."Entry Type"::"Positive Adjmt.",Item."No.",LibraryRandom.RandDec(1000,2),WORKDATE,'');
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,Item2."No.",Quantity);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      UpdateProductionOrderComponent(ProductionOrder."No.",Item."No.");

      // Exercise : Create and Post Output Journal.
      DocumentNo := CreateAndPostOutputJournal(ProductionOrder."No.");

      // Verify: Verify Document No. exist on Item ledger Entry.
      VerifyDocumentNoExistOnItemLedgerEntry(DocumentNo);

      // Tear Down.
      RestoreManufacturingSetup(OldDocNoIsProdOrderNo);
    END;

    [Test]
    PROCEDURE QuantityOnProductionOrderLine@134();
    VAR
      Item@1000 : Record 27;
      Item2@1001 : Record 27;
      Item3@1006 : Record 27;
      Item4@1003 : Record 27;
      ProductionOrder@1002 : Record 5405;
      InvtPostingGroupCode@1004 : Code[10];
    BEGIN
      // Check Quantity on Prod. Order Line equal to Qty. on Component Lines.

      // Setup.
      Initialize;
      InvtPostingGroupCode :=
        CreateItemWithReorderingPolicyAndInventoryPostingGroup(
          Item,Item."Replenishment System"::"Prod. Order",Item."Manufacturing Policy"::"Make-to-Order");
      CreateItemWithReorderingPolicy(
        Item2,Item2."Replenishment System"::"Prod. Order",Item2."Manufacturing Policy"::"Make-to-Order",InvtPostingGroupCode,
        CreateProductionBOMForSingleItem(LibraryInventory.CreateItem(Item3),Item."Base Unit of Measure"),'');
      CreateItemWithReorderingPolicy(
        Item4,Item4."Replenishment System"::"Prod. Order",Item4."Manufacturing Policy"::"Make-to-Order",InvtPostingGroupCode,
        CreateProductionBOMForSingleItem(Item2."No.",Item2."Base Unit of Measure"),'');
      UpdateProductionBOMOnParentItem(Item,Item2."No.",Item4."No.");

      // Exercise:  Create and refresh Production Order.
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,Item."No.",
        LibraryRandom.RandDec(10,2));
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // Verify: Verify Quantity on Prod. Order Line.
      Item4.CALCFIELDS("Qty. on Component Lines");
      VerifyQuantityOnProdOrderLine(ProductionOrder.Status,ProductionOrder."No.",Item4."No.",Item4."Qty. on Component Lines");
    END;

    [Test]
    PROCEDURE ExpectedQuantityOnProductionOrderComponenent@133();
    VAR
      Item@1002 : Record 27;
      Item2@1003 : Record 27;
      Item3@1007 : Record 27;
      Item4@1000 : Record 27;
      ProductionOrder@1006 : Record 5405;
      ProdOrderLine@1004 : Record 5406;
      InvtPostingGroupCode@1001 : Code[10];
    BEGIN
      // Check Expected Quantity and Remaining Quantity on Prod. Order Component.

      // Setup: Create and refresh Production Order.
      Initialize;
      InvtPostingGroupCode :=
        CreateItemWithReorderingPolicyAndInventoryPostingGroup(
          Item,Item."Replenishment System"::"Prod. Order",Item."Manufacturing Policy"::"Make-to-Order");
      CreateItemWithReorderingPolicy(
        Item2,Item2."Replenishment System"::"Prod. Order",Item2."Manufacturing Policy"::"Make-to-Order",InvtPostingGroupCode,
        CreateProductionBOMForSingleItem(LibraryInventory.CreateItem(Item3),Item."Base Unit of Measure"),'');
      CreateItemWithReorderingPolicy(
        Item4,Item4."Replenishment System"::"Prod. Order",Item4."Manufacturing Policy"::"Make-to-Order",InvtPostingGroupCode,
        CreateProductionBOMForSingleItem(Item2."No.",Item2."Base Unit of Measure"),'');
      UpdateProductionBOMOnParentItem(Item,Item2."No.",Item4."No.");
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,Item."No.",
        LibraryRandom.RandDec(10,2));
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // Exercise: Delete Component on Prod. Order Line.
      FindProductionOrderLine(ProdOrderLine,ProductionOrder.Status,ProductionOrder."No.",Item4."No.");
      ProdOrderLine.DELETE(TRUE);

      // Verify: Verify Quantity on Prod. Order Line.Expected Quantity and Remaining Quantity on Prod. Order Component.
      FindProductionOrderLine(ProdOrderLine,ProductionOrder.Status,ProductionOrder."No.",Item2."No.");
      VerifyExpectedQuantityOnProdOrderComponent(Item3,ProductionOrder."No.",ProdOrderLine.Quantity);
    END;

    [Test]
    [HandlerFunctions(ProductionJournalHandler,ConfirmHandlerTrue,MessageHandler)]
    PROCEDURE ChangeRtngOnProdOrdLnWithPostedOutput@137();
    VAR
      ProdOrdLn@1002 : Record 5406;
    BEGIN
      // Check error when modifying routing No. on posted Prod. Order line
      // Setup: Create 2 released prod. order lines, post output for the first line
      Initialize;
      SetupProdOrdLnWithPostedOutput(ProdOrdLn);

      // Get the first Prod. order line
      ProdOrdLn.GET(ProdOrdLn.Status,ProdOrdLn."Prod. Order No.",ProdOrdLn."Line No.");

      // Exercise
      ASSERTERROR ProdOrdLn.VALIDATE("Routing No.",CreateRouting);

      // Verify: Existing Error Message
      Assert.AreEqual(STRSUBSTNO(ModifyRtngErr,ProdOrdLn."Routing No.",CapLedgEntryCap),GETLASTERRORTEXT,'');
    END;

    [Test]
    [HandlerFunctions(ProductionJournalHandler,ConfirmHandlerTrue,MessageHandler)]
    PROCEDURE DeleteProdOrdLnWithPostedOutput@136();
    VAR
      ProdOrdLn@1000 : Record 5406;
    BEGIN
      // Check error when deleting posted Prod. Order line
      // Setup: Create 2 released prod. order lines, post output for the first line
      Initialize;
      SetupProdOrdLnWithPostedOutput(ProdOrdLn);

      // Get the first Prod. order line
      ProdOrdLn.GET(ProdOrdLn.Status,ProdOrdLn."Prod. Order No.",ProdOrdLn."Line No.");

      // Exercise
      ASSERTERROR ProdOrdLn.DELETE(TRUE);

      // Verify: Existing Error Message
      Assert.AreEqual(STRSUBSTNO(DeleteRtngErr,ProdOrdLn."Line No.",ItemLedgEntryCap),GETLASTERRORTEXT,'');
    END;

    [Test]
    PROCEDURE ChangeRtngOnProdOrdLn@138();
    VAR
      Item@1000 : Record 27;
      ProdOrdLn@1002 : Record 5406;
      ProdOrd@1001 : Record 5405;
      ProdOrdRtngLn@1004 : Record 5409;
    BEGIN
      // Verify Production Order Routing Lines will be deleted for the specific production order line when the Routing No. is changed
      // Setup
      Initialize;
      Item.GET(CreateItemWithRoutingAndProductionBOM);

      // Create a released Prod. Order, create 2 Prod. Order lines, calculate routings
      SetupProdOrdWithRtng(ProdOrd,Item."No.");

      // Find the first Prod. Order Line
      FindProductionOrderLine(ProdOrdLn,ProdOrd.Status,ProdOrd."No.",Item."No.");

      // Check Table 5409 (Prod. Order Routing Line) has Routing Lines for the first Prod. Order Line
      Assert.IsTrue(FindProductionOrderRoutingLine(ProdOrdRtngLn,ProdOrdLn),ProdOrdRtngLnNotExistErr);

      // Exercise: Change the Routing No. of the first Prod. Order line
      ProdOrdLn.VALIDATE("Routing No.",CreateRouting);

      // Verify: Table 5409 (Prod. Order Routing Line) has no Routing Lines for the first Prod. Order Line
      Assert.IsFalse(FindProductionOrderRoutingLine(ProdOrdRtngLn,ProdOrdLn),ProdOrdRtngLnExistErr);
    END;

    [Test]
    PROCEDURE CalculateWaitingTimeIncludingWeekendWithMultipleCalendars@139();
    VAR
      WorkCenter@1002 : Record 99000754;
      Item@1008 : Record 27;
      ProductionOrder@1010 : Record 5405;
      DueDate@1017 : Date;
      WaitTime@1015 : Integer;
    BEGIN
      // Check Starting Date Time is calculated correctly for the Prod. Order Routing Line in a backward calculated Scenario
      // if the prior Prod. Order Routing Line is scheduled at non-Working Day for the calculated Prod. Order Routing Line with waiting time >= 5 Days
      Initialize;

      // Setup: Get the Waiting Days for routing line
      WaitTime := LibraryRandom.RandIntInRange(5,9);

      // Create 2 Work Centers, one with all days working Calender, the other with Monday ~ Friday working Calender
      // Create Routing with 2 routing Lines, using the 2 created work centers. Create Production Item, calculate Prod. Order Due Date
      DueDate := SetupForCalculateWaitingTimeWithMultipleCalendars(Item,WorkCenter,WaitTime);

      // Exercise: Create Released Production Order, set Due Date and Refresh Production Order
      CreateAndRefreshProdOrderWithSpecificDueDate(ProductionOrder,Item."No.",DueDate);

      // Verify: Find the routing line with Monday ~ Friday working days and check the start Date-Time and Ending Date-time,
      // because WaitTime >= 5 DAYS, then duration between starting date and ending date will include weekend
      VerifyDateTimeOnProdOrderRoutingLine(ProductionOrder,Item."Routing No.",WorkCenter."No.",WaitTime);
    END;

    [Test]
    PROCEDURE CalculateWaitingTimeWithMultipleCalendars@145();
    VAR
      WorkCenter@1002 : Record 99000754;
      Item@1008 : Record 27;
      ProductionOrder@1010 : Record 5405;
      DueDate@1017 : Date;
      WaitTime@1015 : Integer;
    BEGIN
      // Check Starting Date Time is calculated correctly for the Prod. Order Routing Line in a backward calculated Scenario
      // if the prior Prod. Order Routing Line is scheduled at non-Working Day for the calculated Prod. Order Routing Line with waiting time < 5 Days
      Initialize;

      // Setup: Get the Waiting Days for routing line
      WaitTime := LibraryRandom.RandInt(4); // Get the Wait Days for routing line

      // Create 2 Work Centers, one with all days working Calender, the other with Monday ~ Friday working Calender
      // Create Routing with 2 routing Lines, using the 2 created work centers. Create Production Item, calculate Prod. Order Due Date
      DueDate := SetupForCalculateWaitingTimeWithMultipleCalendars(Item,WorkCenter,WaitTime);

      // Exercise: Create Released Production Order, set Due Date and Refresh Production Order
      CreateAndRefreshProdOrderWithSpecificDueDate(ProductionOrder,Item."No.",DueDate);

      // Verify: Find the routing line with Monday ~ Friday working days and check the start Date-Time and Ending Date-time,
      VerifyDateTimeOnProdOrderRoutingLine(ProductionOrder,Item."Routing No.",WorkCenter."No.",WaitTime);
    END;

    [Test]
    PROCEDURE CalculateProdOrderCapactiyNeedWithWorkShiftEndAtMidnight@161();
    VAR
      WorkCenter@1002 : Record 99000754;
      Item@1006 : Record 27;
      ProductionOrder@1007 : Record 5405;
      ProdOrderCapacityNeed@1008 : Record 5410;
      RoutingLine@1000 : Record 99000764;
      FirstDate@1009 : Date;
      StartingTime@1014 : Time;
      ChangeShiftTime@1010 : Time;
      EndingTime@1011 : Time;
      MinutesFactor@1012 : Integer;
      Precision@1013 : Decimal;
    BEGIN
      // Check Prod. Order Capactiy Need is calculated correctly when there is work shift ending at midnight

      // Setup: Define the starting time and ending time for work shift
      Initialize;
      StartingTime := 083000T; // 8:30 AM is not important, just define the starting time for the first work shift
      ChangeShiftTime := 130000T; // 1:00 PM is not important, just define the ending time for the first work shift and the starting time for the second work shift
      EndingTime := 235959T; // Define the ending time for the second work shift, it needs to be very close to midnight

      // Create shop calendar, working days starts from Monday to Friday with 2 work shifts every day
      // Create Work Center, use the shop calendar created above
      // Update Calendar Rounding Precision for the work center to 0.1, otherwise the ending time in Prod. Order Capacity Need cannot reach 12:00:00,
      // then the issue mentioned in NAVSE TFS342243 cannot be reproed
      Precision := 0.1;
      CreateWorkCenterWithCalendarCodeAndRoundingPrecision(
        WorkCenter,CreateShopCalendarWithTwoWorkShifts(StartingTime,ChangeShiftTime,EndingTime),Precision);

      // Create Production Item with Routing, use the work center created above in routing line and set run time
      CreateProductionItemWithRouting(Item,RoutingLine,WorkCenter."No.");

      MinutesFactor := 60000; // Converting milliseconds to minutes needs to divide milliseconds with this factor

      // Exercise: Create Released Production Order, Refresh Production Order with Forward Direction
      // Since Unit Of Measure for Run Time on routing line is Minutes, thus change the unit of time that can
      // be allocated every day (EndingTime - StartingTime) to Minutes by dividing MinutesFactor.
      // Set the item quantity to make it needs capacity allocated in work center for more than 1 week
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,Item."No.",
        ROUND((EndingTime - StartingTime) / MinutesFactor / RoutingLine."Run Time") * LibraryRandom.RandIntInRange(5,15));
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,TRUE,TRUE,TRUE,TRUE,FALSE);
      FirstDate := GetProdOrderCapacityNeedDate(WorkCenter."No.");

      // Verify: Verify Prod. Order Capactiy Need is correct
      // Verify the 2nd work shift starting from 1:00:00 PM is allocated for the first working day
      Assert.IsTrue(
        ProdOrderCapacityNeedExist(
          WorkCenter."No.",FirstDate,ChangeShiftTime,ROUND((EndingTime - ChangeShiftTime) / MinutesFactor,Precision)),
        STRSUBSTNO(WorkShiftShouldExistErr,ChangeShiftTime,ROUND((EndingTime - ChangeShiftTime) / MinutesFactor,Precision),FirstDate));

      // Verify no work time is allocated for next Saturday
      FilteringOnProdOrderCapacityNeed(ProdOrderCapacityNeed,WorkCenter."No.",CALCDATE('<WD6>',FirstDate));
      Assert.IsTrue(ProdOrderCapacityNeed.ISEMPTY,WorkShiftShouldNotExistErr);
    END;

    [Test]
    PROCEDURE CalculateProdOrderCapactiyNeedWithWorkShiftEndAtMidnightInPlanningRoutingLine@164();
    VAR
      WorkCenter@1002 : Record 99000754;
      Item@1006 : Record 27;
      SalesHeader@1001 : Record 36;
      ProdOrderCapacityNeed@1008 : Record 5410;
      RoutingLine@1000 : Record 99000764;
      RequisitionLine@1003 : Record 246;
      PlanningRoutingLine@1004 : Record 99000830;
      FirstDate@1009 : Date;
      StartingTime@1014 : Time;
      ChangeShiftTime@1010 : Time;
      EndingTime@1011 : Time;
      MinutesFactor@1012 : Integer;
      Precision@1013 : Decimal;
    BEGIN
      // Check Prod. Order Capactiy Need is calculated correctly when modifying Starting time in Planning Routing Line with work shift ending at midnight

      // Setup: Define the starting time and ending time for work shift
      Initialize;
      StartingTime := 083000T; // 8:30 AM is not important, just define the starting time for the first work shift
      ChangeShiftTime := 130000T; // 1:00 PM is not important, just define the ending time for the first work shift and the starting time for the second work shift
      EndingTime := 235959T; // Define the ending time for the second work shift, it needs to be very close to midnight

      // Create shop calendar, working days starts from Monday to Friday with 2 work shifts every day
      // Create Work Center, use the shop calendar created above
      // Update Calendar Rounding Precision for the work center to 0.1, otherwise the ending time in Prod. Order Capacity Need cannot reach 12:00:00,
      // then the issue mentioned in NAVSE TFS342243 cannot be reproed
      Precision := 0.1;
      CreateWorkCenterWithCalendarCodeAndRoundingPrecision(
        WorkCenter,CreateShopCalendarWithTwoWorkShifts(StartingTime,ChangeShiftTime,EndingTime),Precision);

      // Create Production Item with Routing, use the work center created above in routing line and set run time
      CreateProductionItemWithRouting(Item,RoutingLine,WorkCenter."No.");
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::"Prod. Order"); // Modify the replenishment system for calculating Order Planning
      Item.MODIFY(TRUE);

      MinutesFactor := 60000; // Converting milliseconds to minutes needs to divide milliseconds with this factor

      // Create a Sales Order for the item, set the item quantity to make it needs capacity allocated in work center for more than 1 week
      CreateSalesOrder(
        SalesHeader,Item."No.",
        ROUND((EndingTime - StartingTime) / MinutesFactor / RoutingLine."Run Time",Precision) *
        LibraryRandom.RandIntInRange(5,15));

      // Calculate Order Planning for Sales Demand, that will generate Planning Routing Line for the item
      LibraryPlanning.CalculateOrderPlanSales(RequisitionLine);
      FindPlanningRoutingLine(PlanningRoutingLine,WorkCenter."No.",RoutingLine."Operation No.");

      // Exercise: Modify the starting time on Planning Routing Line to make it in the first work shift
      PlanningRoutingLine.VALIDATE("Starting Time",StartingTime + LibraryRandom.RandInt(ChangeShiftTime - StartingTime));
      PlanningRoutingLine.MODIFY(TRUE);

      FirstDate := GetProdOrderCapacityNeedDate(WorkCenter."No.");

      // Verify: Verify Prod. Order Capactiy Need is correct
      // Verify the 2nd work shift starting from 1:00:00 PM is allocated for the first working day
      Assert.IsTrue(
        ProdOrderCapacityNeedExist(
          WorkCenter."No.",FirstDate,ChangeShiftTime,ROUND((EndingTime - ChangeShiftTime) / MinutesFactor,Precision)),
        STRSUBSTNO(WorkShiftShouldExistErr,ChangeShiftTime,ROUND((EndingTime - ChangeShiftTime) / MinutesFactor,Precision),FirstDate));

      // Verify no work time is allocated for next Saturday
      FilteringOnProdOrderCapacityNeed(ProdOrderCapacityNeed,WorkCenter."No.",CALCDATE('<WD6>',FirstDate));
      Assert.IsTrue(ProdOrderCapacityNeed.ISEMPTY,WorkShiftShouldNotExistErr);
    END;

    [Test]
    PROCEDURE CalculateProdOrderStartingDateWithRoutingSetupTimeEndAtMidnight@149();
    VAR
      WorkCenter@1002 : Record 99000754;
      Item@1006 : Record 27;
      ProductionOrder@1007 : Record 5405;
      RoutingLine@1000 : Record 99000764;
      ProdOrderLine@1001 : Record 5406;
      ManufacturingSetup@1003 : Record 99000765;
      DueDate@1009 : Date;
      StartingTime@1014 : Time;
      EndingTime@1011 : Time;
      Precision@1013 : Decimal;
      ShopCalendarCode@1008 : Code[10];
    BEGIN
      // Check the Starting Date on Prod. Order Line is calculated correctly when routing's setup time ends at midnight

      // Setup: Define the starting time and ending time for work shift
      Initialize;

      StartingTime := 083000T; // 8:30 AM is not important, just define the starting time for the work shift
      EndingTime := 235959T; // Define the ending time for work shift, it needs to be very close to midnight

      // Create shop calendar, working days starts from Monday to Friday with 1 work shift every day
      // Create Work Center, use the shop calendar created above
      // Update Calendar Rounding Precision for the work center to 0.1, otherwise the setup ending time in Prod. Order Capacity Need cannot reach 12:00:00,
      Precision := 0.1;
      ShopCalendarCode := CreateShopCalendar(StartingTime,EndingTime);

      // Create working days in weekend so that after Forward refreshing Prod. Order, the Starting Date on Prod. Orde Line plus
      // ManufacturingSetup."Default Safety Lead Time" will equal the original Due Date of Prod. Order
      CreateShopCalendarWeekendWorkingDays(ShopCalendarCode,StartingTime,EndingTime);
      CreateWorkCenterWithCalendarCodeAndRoundingPrecision(WorkCenter,ShopCalendarCode,Precision);

      // Create Production Item with Routing, use the work center created above in routing line and modify setup time
      // The setup time equals the work time that can be allocated in a day with minuites unit of measure
      CreateProductionItemWithRouting(Item,RoutingLine,WorkCenter."No.");
      ModifySetupTimeOnRoutingLine(RoutingLine,ROUND((EndingTime - StartingTime) / (60 * 1000),Precision)); // Divisor 60 * 1000 is for converting millisecond to minute

      // Create Released Production Order
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,Item."No.",
        LibraryRandom.RandInt(10));
      DueDate := ProductionOrder."Due Date";

      // Exercise: Refresh Production Order with Forward Direction
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,TRUE,TRUE,TRUE,TRUE,FALSE);

      // Find the Prod. Order Line calculated by refreshing the production order
      FindProductionOrderLine(ProdOrderLine,ProductionOrder.Status::Released,ProductionOrder."No.",Item."No.");
      ManufacturingSetup.GET;

      // Verify: The Starting Date on Prod. Orde Line should be ahead of the original Due Date of Prod. Order by Default Safety Lead Time
      Assert.AreEqual(
        DueDate,CALCDATE(ManufacturingSetup."Default Safety Lead Time",ProdOrderLine."Starting Date"),
        ProdOrderStartingDateErr);
    END;

    [Test]
    PROCEDURE CheckWaitTimeOnProdOrderRoutingLineWithoutCapacityConstrained@174();
    VAR
      RoutingLine@1000 : Record 99000764;
      RoutingLine2@1004 : Record 99000764;
      ProdOrderRoutingLine@1001 : Record 5409;
      ProdOrderRoutingLine2@1005 : Record 5409;
      ShopCalendarWorkingDays@1003 : Record 99000752;
    BEGIN
      // Check Wait Time on Prod. Order Routing Line is not Capacity constrained.

      // Setup: Create Production item, 1 routing header with 2 routing lines, set the wait time of the
      // first routing line to 1 ~ 2 days so that the second routing line will start on Monday if first routing line starts on Friday.
      // Create and Refresh Released Production Order, 2 Prod. Order Routing Lines will be generated
      Initialize;
      SetupWaitTimeOnProdOrderRtngLnWithoutCapactityConstrained(RoutingLine,RoutingLine2);

      // Exercise: Find the 1st Prod. Order Routing Line and modify the Starting Date to Friday
      FindProdOrderRoutingLine(ProdOrderRoutingLine,RoutingLine."Work Center No.",RoutingLine."Operation No.");
      ModifyStartingDateOnProdOrderRtngLn(ProdOrderRoutingLine,CALCDATE('<WD5>',WORKDATE));

      // Verify: Verify Ending Date Time on the 1st Prod. Order Routing Line
      ProdOrderRoutingLine.TESTFIELD(
        "Ending Date-Time",ProdOrderRoutingLine."Starting Date-Time" + ProdOrderRoutingLine."Wait Time" * 60 * 1000); // Wait Time is not capacity contrained

      FindProdOrderRoutingLine(ProdOrderRoutingLine2,RoutingLine2."Work Center No.",RoutingLine2."Operation No."); // Find the second Prod. Order Routing Line

      // Find ShopCalendarWorkingDays of Monday for the work center on the 2nd routing line
      FindShopCalendarWorkingDaysForWorkCenter(
        ShopCalendarWorkingDays,ProdOrderRoutingLine2."Work Center No.",ShopCalendarWorkingDays.Day::Monday);

      // Verify Starting Date Time on the 2nd Prod. Order Routing Line, it should be in the next working day (Monday) at its starting time
      ProdOrderRoutingLine2.TESTFIELD(
        "Starting Date-Time",
        CREATEDATETIME(CALCDATE('<WD1>',ProdOrderRoutingLine."Ending Date"),ShopCalendarWorkingDays."Starting Time"));
    END;

    [Test]
    PROCEDURE CheckWaitTimeOnPlanningRoutingLineWithoutCapacityConstrained@190();
    VAR
      RoutingLine@1000 : Record 99000764;
      RoutingLine2@1001 : Record 99000764;
      ShopCalendarWorkingDays@1003 : Record 99000752;
      PlanningRoutingLine@1009 : Record 99000830;
      PlanningRoutingLine2@1011 : Record 99000830;
    BEGIN
      // Check Wait Time on Planning Routing Line is not Capacity constrained.

      // Setup: Create Production item, 1 routing header with 2 routing lines, set the wait time of the
      // first routing line to 1 ~ 2 days so that the second routing line will start on Monday if first routing line starts on Friday.
      // Create a Sales Order for the item. Calculate Order Planning for Sales Demand, that will generate Planning Routing Line for the item
      Initialize;
      SetupWaitTimeOnPlanningRtngLnWithoutCapactityConstrained(RoutingLine,RoutingLine2);

      // Exercise: Find the 1st Planning Routing Line and modify the starting Date to Friday
      FindPlanningRoutingLine(PlanningRoutingLine,RoutingLine."Work Center No.",RoutingLine."Operation No.");
      ModifyStartingDateOnPlanningRtngLn(PlanningRoutingLine,CALCDATE('<WD5>',WORKDATE));

      // Verify: Verify Ending Date Time on the 1st Planning Routing Line
      PlanningRoutingLine.TESTFIELD(
        "Ending Date-Time",PlanningRoutingLine."Starting Date-Time" + PlanningRoutingLine."Wait Time" * 60 * 1000); // Wait Time is not capacity contrained

      FindPlanningRoutingLine(PlanningRoutingLine2,RoutingLine2."Work Center No.",RoutingLine2."Operation No."); // Find the second Planning Routing Line

      // Find ShopCalendarWorkingDays of Monday for the work center on the 2nd routing line
      FindShopCalendarWorkingDaysForWorkCenter(
        ShopCalendarWorkingDays,PlanningRoutingLine2."Work Center No.",ShopCalendarWorkingDays.Day::Monday);

      // Verify Starting Date Time on the 2nd Planning Routing Line, it should be in the next working day (Monday) at its starting time
      PlanningRoutingLine2.TESTFIELD(
        "Starting Date-Time",
        CREATEDATETIME(CALCDATE('<WD1>',PlanningRoutingLine."Ending Date"),ShopCalendarWorkingDays."Starting Time"));
    END;

    [Test]
    PROCEDURE CheckWaitTimeStartingOnWeekendOnProdOrdRtngLnWithoutCapConstrained@180();
    VAR
      RoutingLine@1000 : Record 99000764;
      RoutingLine2@1001 : Record 99000764;
      ProdOrderRoutingLine@1004 : Record 5409;
      ProdOrderRoutingLine2@1005 : Record 5409;
      ShopCalendarWorkingDays@1006 : Record 99000752;
    BEGIN
      // Check Wait Time on Prod. Order Routing Line is not Capacity constrained with backward calculation when multiple routing lines exist.

      // Setup: Create Production item, 1 routing header with 2 routing lines, set the wait time of the second
      // routing line to 1 ~ 2 days so that the first routing line will end on Friday if second routing line starts on Monday.
      // Create and Refresh Released Production Order, 2 Prod. Order Routing Lines will be generated.
      Initialize;
      SetupWaitTimeOnProdOrderRtngLnForBackwardCalculation(RoutingLine,RoutingLine2);
      FindProdOrderRoutingLine(ProdOrderRoutingLine2,RoutingLine2."Work Center No.",RoutingLine2."Operation No."); // Find the 2nd Prod. Order Routing Line

      // Exercise: Modify the Ending Date to Monday
      ModifyEndingDateOnProdOrderRtngLn(ProdOrderRoutingLine2,CALCDATE('<WD1>',WORKDATE));

      // Verify: Verify Starting Date Time on the 2nd Prod. Order Routing Line, the Starting Date is weekend since the Wait Time is 1 ~ 2 days
      ProdOrderRoutingLine2.TESTFIELD(
        "Starting Date-Time",ProdOrderRoutingLine2."Ending Date-Time" - ProdOrderRoutingLine2."Wait Time" * 60 * 1000); // Wait Time is not capacity contrained

      FindProdOrderRoutingLine(ProdOrderRoutingLine,RoutingLine."Work Center No.",RoutingLine."Operation No."); // Find the 1st Prod. Order Routing Line

      // Find ShopCalendarWorkingDays of Friday for the work center on the 1st routing line
      FindShopCalendarWorkingDaysForWorkCenter(
        ShopCalendarWorkingDays,ProdOrderRoutingLine."Work Center No.",ShopCalendarWorkingDays.Day::Friday);

      // Verify Ending Date Time on the 1st Prod. Order Routing Line, it should be in the last working day (Friday) at its ending time
      ProdOrderRoutingLine.TESTFIELD(
        "Ending Date-Time",
        CREATEDATETIME(CALCDATE('<-WD5>',ProdOrderRoutingLine2."Starting Date"),ShopCalendarWorkingDays."Ending Time"));
    END;

    [Test]
    PROCEDURE CheckWaitTimeStartingOnWeekendOnPlanningRtngLnWithoutCapConstrained@179();
    VAR
      RoutingLine@1000 : Record 99000764;
      RoutingLine2@1001 : Record 99000764;
      PlanningRoutingLine@1004 : Record 99000830;
      PlanningRoutingLine2@1005 : Record 99000830;
      ShopCalendarWorkingDays@1006 : Record 99000752;
    BEGIN
      // Check Wait Time on Planning Routing Line is not Capacity constrained with backward calculation when multiple routing lines exist.

      // Setup: Create Production item, 1 routing header with 2 routing lines, set the wait time of the second
      // routing line to 1 ~ 2 days so that the first routing line will end on Friday if second routing line starts on Monday.
      // Create a Sales Order for the item. Calculate Order Planning for Sales Demand, that will generate Planning Routing Line for the item.
      Initialize;
      SetupWaitTimeOnPlanningRtngLnForBackwardCalculation(RoutingLine,RoutingLine2);
      FindPlanningRoutingLine(PlanningRoutingLine2,RoutingLine2."Work Center No.",RoutingLine2."Operation No."); // Find the 2nd Planning Routing Line

      // Exercise: Modify the Ending Date to Monday
      ModifyEndingDateOnPlanningRtngLn(PlanningRoutingLine2,CALCDATE('<WD1>',WORKDATE));

      // Verify: Verify Starting Date on the 2nd Planning Routing Line, the Starting Date is weekend since the Wait Time is 1 ~ 2 days
      PlanningRoutingLine2.TESTFIELD(
        "Starting Date",DT2DATE(PlanningRoutingLine2."Ending Date-Time" - PlanningRoutingLine2."Wait Time" * 60 * 1000)); // Wait Time is not capacity contrained
      PlanningRoutingLine2.TESTFIELD("Starting Time",000000T); // When routing starts in non-working day, the starting time is 12:00:00 AM

      FindPlanningRoutingLine(PlanningRoutingLine,RoutingLine."Work Center No.",RoutingLine."Operation No."); // Find the 1st Planning Routing Line

      // Find ShopCalendarWorkingDays of Friday for the work center on the 1st routing line
      FindShopCalendarWorkingDaysForWorkCenter(
        ShopCalendarWorkingDays,PlanningRoutingLine."Work Center No.",ShopCalendarWorkingDays.Day::Friday);

      // Verify Ending Date Time on the 1st Planning Routing Line, it should be in the last working day (Friday) at its ending time
      PlanningRoutingLine.TESTFIELD(
        "Ending Date-Time",
        CREATEDATETIME(CALCDATE('<-WD5>',PlanningRoutingLine2."Starting Date"),ShopCalendarWorkingDays."Ending Time"));
    END;

    [Test]
    PROCEDURE CheckBackwardCalculatedWaitTimeOnProdOrdRtngLnWithoutCapConstrained@177();
    VAR
      RoutingLine@1000 : Record 99000764;
      Item@1002 : Record 27;
      ProductionOrder@1003 : Record 5405;
      ProdOrderRoutingLine@1004 : Record 5409;
    BEGIN
      // Check Wait Time on Prod. Order Routing Line is not Capacity constrained with backward calculation when wait time exceeds 1 week.

      // Setup: Create Work Center and Production item, set wait time on routing line to 1 ~ 2 weeks.
      Initialize;
      CreateWorkCenterAndProductionItem(Item,RoutingLine);

      // Exercise: Create and Refresh Released Production Order.
      CreateAndRefreshProdOrderWithSpecificItem(ProductionOrder,Item."No.",FALSE);
      FindProdOrderRoutingLine(ProdOrderRoutingLine,RoutingLine."Work Center No.",RoutingLine."Operation No."); // Find the Prod. Order Routing Line

      // Verify: Verify Starting Date Time on the Prod. Order Routing Line
      ProdOrderRoutingLine.TESTFIELD(
        "Starting Date-Time",ProdOrderRoutingLine."Ending Date-Time" - ProdOrderRoutingLine."Wait Time" * 60 * 1000); // Wait Time is not capacity contrained
    END;

    [Test]
    PROCEDURE CheckBackwardCalculatedWaitTimeOnPlanningRtngLnWithoutCapConstrained@175();
    VAR
      Item@1001 : Record 27;
      RoutingLine@1000 : Record 99000764;
      PlanningRoutingLine@1004 : Record 99000830;
    BEGIN
      // Check Wait Time on Planning Routing Line is not Capacity constrained with backward calculation when wait time exceeds 1 week.

      // Setup: Create Work Center and Production item, set wait time on routing line to 1 ~ 2 weeks.
      Initialize;
      CreateWorkCenterAndProductionItem(Item,RoutingLine);

      // Exercise: Create Sales Order and calculate order planning
      CreateSalesOrderAndCalculateOrderPlan(Item,Item."Replenishment System"::"Prod. Order");
      FindPlanningRoutingLine(PlanningRoutingLine,RoutingLine."Work Center No.",RoutingLine."Operation No."); // Find the Planning Routing Line

      // Verify: Verify Starting Date Time on the Prod. Order Routing Line
      PlanningRoutingLine.TESTFIELD(
        "Starting Date-Time",PlanningRoutingLine."Ending Date-Time" - PlanningRoutingLine."Wait Time" * 60 * 1000); // Wait Time is not capacity contrained
    END;

    [Test]
    [HandlerFunctions(MachineCenterPageHandler)]
    PROCEDURE CheckProdOrderLineBinCodeFromMachineCenterThroughWorkCenter@197();
    VAR
      ProdOrderLine@1000 : Record 5406;
      WorkCenter@1004 : Record 99000754;
      MachineCenter@1005 : Record 99000758;
      ProdOrderRtngLine@1002 : Record 5409;
      CalculateProdOrder@1003 : Codeunit 99000773;
      RoutingRefNo@1001 : Integer;
    BEGIN
      // [SCENARIO 360750.2] Move Job from Work Center To Machine Center with different Bin Code
      Initialize;

      // [GIVEN] Create ProdOrderLine for White Location, Routing Line with Bin Code and Update Work Center With another Bin Code
      CreateProdOrderLineWithWhiteLocationAndUpdateWorkCenterBinCode(ProdOrderLine,WorkCenter,RoutingRefNo);
      // [GIVEN] Create Machine Center with Different Bin Code and update Prod ORder Routing Line
      CreateMachineCenterAndUpdateProdOderRtngLine(MachineCenter,ProdOrderRtngLine,WorkCenter,ProdOrderLine,RoutingRefNo);

      // [WHEN] Find and set ProdOrderLine Bin Code from Work Center through Routing Line
      CalculateProdOrder.AssignProdOrderLineBinCodeFromProdRtngLineMachineCenter(ProdOrderRtngLine);

      // [THEN] ProdOrderLine's BinCode is same as Machine Center's Bin Code
      VerifyProdOrderLineBinCode(ProdOrderLine,MachineCenter."From-Production Bin Code");
    END;

    [Test]
    PROCEDURE CheckProdOrderLineBinCodeFromWorkCenterThroughRoutingLine@200();
    VAR
      ProdOrderLine@1000 : Record 5406;
      WorkCenter@1004 : Record 99000754;
      CalculateProdOrder@1003 : Codeunit 99000773;
      RoutingRefNo@1001 : Integer;
    BEGIN
      // [SCENARIO 360750.3] ProdOrderLine gets BinCode from Work Center thorugh Routing Line with different Bin Code
      Initialize;

      // [GIVEN] Create ProdOrderLine for White Location, Routing Line with Bin Code and Update Work Center With another Bin Code
      CreateProdOrderLineWithWhiteLocationAndUpdateWorkCenterBinCode(ProdOrderLine,WorkCenter,RoutingRefNo);

      // [WHEN] Find and set ProdOrderLine Bin Code from Work Center through Routing Line
      CalculateProdOrder.FindAndSetProdOrderLineBinCodeFromProdRtngLines(
        ProdOrderLine.Status,ProdOrderLine."Prod. Order No.",RoutingRefNo);

      // [THEN] ProdOrderLine's BinCode is same as Work Center's Bin Code
      VerifyProdOrderLineBinCode(ProdOrderLine,WorkCenter."From-Production Bin Code");
    END;

    [Test]
    PROCEDURE FilterOnProductionForecast@188();
    VAR
      ProductionForecastName@1000 : Record 99000851;
      ProductionForecastEntry@1001 : Record 99000852;
      Item@1004 : Record 27;
      ProductionForecast@1002 : TestPage 99000919;
      ForecastType@1003 : 'Sales Item,Component,Both';
    BEGIN
      // Check filtering on Production Forecast can provide expected results.

      // Setup: Create Production Forecast Name, create Production Forecast Entry.
      // Open Production Forecast Page, set filters related to the Production Forecast Entry.
      Initialize;
      LibraryManufacturing.CreateProductionForecastName(ProductionForecastName);
      CreateProductionForecastEntry(ProductionForecastEntry,ProductionForecastName.Name);
      OpenProductionForecast(
        ProductionForecast,ProductionForecastName.Name,ProductionForecastEntry."Location Code",ForecastType::Component);

      // Exercise: Set filter on "Prod. Forecast Quantity (Base)"
      ProductionForecast.Matrix.FILTER.SETFILTER("Prod. Forecast Quantity (Base)",'>0');

      // Verify: Item with "Prod. Forecast Quantity (Base)" > 0 can be found in Production Forecast Matrix
      Item.GET(ProductionForecastEntry."Item No.");
      Assert.IsTrue(ProductionForecast.Matrix.GOTORECORD(Item),STRSUBSTNO(ItemShouldExistErr,Item."No."));
    END;

    [Test]
    [HandlerFunctions(ProdOrderRoutingHandler)]
    PROCEDURE ChangeProdOrderRtngLineFromProdBinCode@193();
    VAR
      ProdOrderLine@1002 : Record 5406;
      WorkCenter@1000 : Record 99000754;
      RoutingRefNo@1001 : Integer;
    BEGIN
      // Verify ProdOrderLine's BinCode changes after ProdOrderRtngLine update
      Initialize;
      CreateProdOrderLineWithWhiteLocationAndUpdateWorkCenterBinCode(ProdOrderLine,WorkCenter,RoutingRefNo);

      LibraryVariableStorage.Enqueue(WorkCenter."No.");
      ProdOrderLine.ShowRouting; // set WorkCenterNo in ProdOrderRoutingHandler

      VerifyProdOrderLineBinCode(ProdOrderLine,WorkCenter."From-Production Bin Code");
    END;

    [Test]
    [HandlerFunctions(ReservationHandler)]
    PROCEDURE CircularReferenceConsumptionNotAllowedWithReservation@247();
    VAR
      ProductionOrder@1004 : Record 5405;
    BEGIN
      // [SCENARIO 360892] It is not allowed to post consumption that leads to circular reference in cost application if component is reserved
      Initialize;

      // [GIVEN] Two production orders consuming each other's produced items
      // [GIVEN] Consumption for the first order is posted
      CreateProdOrdersWithCrossReference(ProductionOrder);

      // [GIVEN] Component for the second order is reserved
      ReserveComponentForProdOrder(ProductionOrder.Status,ProductionOrder."No.");

      // [WHEN] Consumption of the reserved component is posted
      ASSERTERROR CreateAndPostConsumptionJournal(ProductionOrder."No.");

      // [THEN] Posting is not allowed
      VerifyComponentNotOnInventoryError(ProductionOrder.Status,ProductionOrder."No.");
    END;

    [Test]
    PROCEDURE CircularReferenceConsumptionNotAllowedWithoutReservation@248();
    VAR
      ProductionOrder@1004 : Record 5405;
    BEGIN
      // [SCENARIO 360892] It is not allowed to post consumption that leads to circular reference in cost application if component is not reserved
      Initialize;

      // [GIVEN] Two production orders consuming each other's produced items
      // [GIVEN] Consumption for the first order is posted
      CreateProdOrdersWithCrossReference(ProductionOrder);

      // [WHEN] Consumption of the reserved component is posted
      ASSERTERROR CreateAndPostConsumptionJournal(ProductionOrder."No.");

      // [THEN] Posting is not allowed
      VerifyComponentNotOnInventoryError(ProductionOrder.Status,ProductionOrder."No.");
    END;

    [Test]
    PROCEDURE CheckBackwardCalculatedTimeOnProdOrdCapConstrained@312();
    VAR
      WorkCenter1@1000 : Record 99000754;
      WorkCenter2@1001 : Record 99000754;
      RoutingLink@1007 : Record 99000777;
      Item@1009 : Record 27;
      UpperComponentItem@1002 : Record 27;
      LowerComponentItem@1008 : Record 27;
      ProductionOrder@1003 : Record 5405;
      Capacity@1004 : Integer;
    BEGIN
      // [FEATURE] [Routing] [Refresh Production Order]
      // [SCENARIO 361976] Check Date-Time calculation when refreshing back Production Order with concurrent capacity workcenters.

      // [GIVEN] Create two workcenters with concurrent capacities > 1.
      Initialize;
      Capacity := 10; // Capacity 10 needed for test.
      CreateWorkCenterWithCapacity(WorkCenter1,Capacity);
      CreateWorkCenterWithCapacity(WorkCenter2,Capacity);

      // [GIVEN] Create two production Items, one is a component for another.
      // [GIVEN] Each Item with a route having different workcenters, and concurrent capacities > 1.
      LibraryInventory.CreateItem(LowerComponentItem);
      LibraryInventory.CreateItem(UpperComponentItem);
      LibraryManufacturing.CreateRoutingLink(RoutingLink);
      CreateRoutingAndBOM(UpperComponentItem."No.",LowerComponentItem."No.",WorkCenter1."No.",Capacity,RoutingLink.Code);
      LibraryInventory.CreateItem(Item);
      CreateRoutingAndBOM(Item."No.",UpperComponentItem."No.",WorkCenter2."No.",Capacity,RoutingLink.Code);

      // [GIVEN] Create Production order for top Item.
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,
        Item."No.",LibraryRandom.RandIntInRange(10,20));

      // [WHEN] Refresh Production Order (back)
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // [THEN] Routing time calculated backwards line by line: [finish time] - [work time] = [start time]; [next line finish time] = [start time], so on.
      VerifyProdOrderDateTimes(ProductionOrder,Capacity);
    END;

    [Test]
    PROCEDURE CheckEndingDateTimeAfterRefreshingPOForwardWhenOperationDoesNotHaveAnyTimeDefined@211();
    VAR
      ProductionOrder@1006 : Record 5405;
      ProdOrderRoutingLine@1005 : Record 5409;
      WorkCenter@1004 : Record 99000754;
      WorkCenter2@1003 : Record 99000754;
      ItemNo@1002 : Code[20];
      RoutingNo@1001 : Code[20];
      PrevOperationEndingDateTime@1000 : DateTime;
    BEGIN
      // [FEATURE] [Routing] [Refresh Production Order]
      // [SCENARIO 362347] Operation starting date-time is set to ending date-time when operation does not have any time defined after refreshing Production Order Forward
      Initialize;

      // [GIVEN] Item with Routing of two Routing Lines with different Work Centers.
      ItemNo := CreateItemWithRoutingAndTwoWorkCenters(WorkCenter,WorkCenter2,RoutingNo);
      // [GIVEN] Calculate Calendar for Work Center in last Routing Line and Reset Time in first Routing Line
      LibraryManufacturing.CalculateWorkCenterCalendar(
        WorkCenter2,CALCDATE('<-1D>',WORKDATE),CALCDATE('<1D>',WORKDATE));
      ResetRunTimeOnRoutingLine(RoutingNo,WorkCenter."No.");

      // [GIVEN] Released Production Order
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,ItemNo,
        LibraryRandom.RandDec(10,2));

      // [WHEN] Refresh Production Order. Calculate Forward
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,TRUE,TRUE,TRUE,FALSE,FALSE);

      // [THEN] Prod Order Routing Line has Starting Date-Time equal to Ending Date-Time
      FindProdOrderRtngLn(ProdOrderRoutingLine,ProductionOrder.Status::Released,ProductionOrder."No.",RoutingNo,WorkCenter2."No.");
      PrevOperationEndingDateTime := ProdOrderRoutingLine."Ending Date-Time";
      FindProdOrderRtngLn(ProdOrderRoutingLine,ProductionOrder.Status::Released,ProductionOrder."No.",RoutingNo,WorkCenter."No.");
      ProdOrderRoutingLine.TESTFIELD("Starting Date-Time",PrevOperationEndingDateTime);
      ProdOrderRoutingLine.TESTFIELD("Ending Date-Time",ProdOrderRoutingLine."Starting Date-Time");
    END;

    [Test]
    PROCEDURE CheckEndingDateTimeAfterRefreshingPOBackwardWhenOperationDoesNotHaveAnyTimeDefined@233();
    VAR
      ProductionOrder@1005 : Record 5405;
      ProdOrderRoutingLine@1004 : Record 5409;
      WorkCenter@1003 : Record 99000754;
      WorkCenter2@1002 : Record 99000754;
      ItemNo@1001 : Code[20];
      RoutingNo@1000 : Code[20];
      NextOperationEndingDateTime@1006 : DateTime;
    BEGIN
      // [FEATURE] [Routing] [Refresh Production Order]
      // [SCENARIO 362347] Operation ending date-time is set to starting date-time when operation does not have any time defined after refreshing Production Order Backward
      Initialize;

      // [GIVEN] Item with Routing of two Routing Lines with different Work Centers.
      ItemNo := CreateItemWithRoutingAndTwoWorkCenters(WorkCenter,WorkCenter2,RoutingNo);
      // [GIVEN] Calculate Calendar for Work Center in First Routing Line and Reset Time in last Routing Line
      LibraryManufacturing.CalculateWorkCenterCalendar(
        WorkCenter,CALCDATE('<-1D>',WORKDATE),CALCDATE('<1D>',WORKDATE));
      ResetRunTimeOnRoutingLine(RoutingNo,WorkCenter2."No.");

      // [GIVEN] Released Production Order
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,ItemNo,
        LibraryRandom.RandDec(10,2));

      // [WHEN] Refresh Production Order. Calculate Backward
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,FALSE,FALSE);

      // [THEN] Prod Order Routing Line has Ending Date-Time equal to Starting Date-Time
      FindProdOrderRtngLn(ProdOrderRoutingLine,ProductionOrder.Status::Released,ProductionOrder."No.",RoutingNo,WorkCenter."No.");
      NextOperationEndingDateTime := ProdOrderRoutingLine."Starting Date-Time";
      FindProdOrderRtngLn(ProdOrderRoutingLine,ProductionOrder.Status::Released,ProductionOrder."No.",RoutingNo,WorkCenter2."No.");
      ProdOrderRoutingLine.TESTFIELD("Ending Date-Time",NextOperationEndingDateTime);
      ProdOrderRoutingLine.TESTFIELD("Starting Date-Time",ProdOrderRoutingLine."Ending Date-Time");
    END;

    [Test]
    [HandlerFunctions(MessageHandler2)]
    PROCEDURE ProdOrderEndingDateBeforeComponentReceiptDateAllowedWithWarning@198();
    VAR
      ProductionOrder@1002 : Record 5405;
      ProdOrderLine@1003 : Record 5406;
      MessageCount@1006 : Integer;
    BEGIN
      // [FEATURE] [Manufacturing] [Production Order]
      // [SCENARIO 361467] Warning is raised when Ending Date on prod. order line is set earlier than Expected Receipt Date of the component reserved for this line
      Initialize;

      // [GIVEN] Purchased Item.
      // [GIVEN] Produced item and component item, both with manufacturing policy "Make to Order"
      // [GIVEN] Multi-level production order is created. Component is reserved with Expected Receipt Date = WORKDATE
      CreateAndRefreshProdOrderForMakeToOrderItem(ProductionOrder);

      // [WHEN] Manufacturing Ending Date is set to WORKDATE - 1 day
      LibraryVariableStorage.Enqueue(ReservationDateConflictTxt);
      LibraryVariableStorage.Enqueue(MessageCount);
      FindProductionOrderLine(ProdOrderLine,ProductionOrder.Status,ProductionOrder."No.",ProductionOrder."Source No.");
      ProdOrderLine.VALIDATE("Ending Date",CALCDATE('<-1D>',ProdOrderLine."Ending Date"));

      // [THEN] One warning message is raised.
      MessageCount := LibraryVariableStorage.DequeueInteger;
      Assert.AreEqual(1,MessageCount,WrongNumberOfMessagesErr);

      // Text verification is done in MessageHandler2
    END;

    [Test]
    PROCEDURE ProdOrderCompDueDateBeforeComponentReceiptDateIsNotAllowed@270();
    VAR
      ProductionOrder@1002 : Record 5405;
      ProdOrderComponent@1007 : Record 5407;
      ReservationCheckDateConfl@1009 : Codeunit 99000815;
    BEGIN
      // [FEATURE] [Manufacturing] [Production Order]
      // [SCENARIO 361467] Error is raised when Ending Date on Prod. Order Component is explicitly set earlier than the date on which it is reserved for a parent Prod. Order Line.
      Initialize;

      // [GIVEN] Purchased Item.
      // [GIVEN] Produced item and component item, both with manufacturing policy "Make to Order"
      // [GIVEN] Multi-level production order is created. Component is reserved with Expected Receipt Date = WORKDATE
      CreateAndRefreshProdOrderForMakeToOrderItem(ProductionOrder);

      // [WHEN] Due Date for the component item is shifted one day earlier.
      FindProdOrderComponent(ProdOrderComponent,ProductionOrder.Status,ProductionOrder."No.");
      ProdOrderComponent."Due Date" := CALCDATE('<-1D>',ProdOrderComponent."Due Date");
      ASSERTERROR ReservationCheckDateConfl.ProdOrderComponentCheck(ProdOrderComponent,TRUE,TRUE);

      // [THEN] Error message is raised.
      Assert.ExpectedError(ReservDateConflictErr);
    END;

    [Test]
    PROCEDURE CheckDateTimeIsUpdatedOnProdOrderAfterCarryingOutPlanningWorksheet@209();
    VAR
      RequisitionLine@1000 : Record 246;
      ProdOrder@1001 : Record 5405;
    BEGIN
      // [FEATURE] [Production Order] [Planning Worksheet] [Date-time]
      // [SCENARIO 364536] Starting- and Ending Date-time on Planned Production Prder should be updated after Carrying out message from Planning Worksheet
      Initialize;

      // [GIVEN] Requisition Line with Starting Date = "X1", Starting Time = "Y1", Ending Date = "X2", Ending Time = "Y2"
      CreateRequisitionLineWithDates(RequisitionLine);

      // [WHEN] Carry Out Action Message
      LibraryPlanning.CarryOutActionMsgPlanWksh(RequisitionLine);

      // [THEN] Production Order is created with Starting Date-Time = "X1 Y1", Ending Date-time = "X2 Y2"
      WITH ProdOrder DO BEGIN
        SETRANGE("Source No.",RequisitionLine."No.");
        FINDFIRST;
        Assert.AreEqual(CREATEDATETIME("Starting Date","Starting Time"),"Starting Date-Time",StartingDateTimeErr);
        Assert.AreEqual(CREATEDATETIME("Ending Date","Ending Time"),"Ending Date-Time",EndingDateTimeErr);
      END;
    END;

    [Test]
    [HandlerFunctions(ExchangeProductionBOMItemHandler)]
    PROCEDURE ExchangeBOMItemCreateNewVersionWithPhantomBOM@212();
    VAR
      UnitOfMeasure@1000 : Record 204;
      ProdBOMLine@1005 : Record 99000772;
      ParentProdBOMVersion@1007 : Record 99000779;
      ParentBOMNo@1001 : Code[20];
      ChildItemNo@1002 : Code[20];
      PhantomBOMNo@1004 : Code[20];
    BEGIN
      // [FEATURE] [Production BOM] [Exchange Production BOM Item]
      // [SCENARIO] Exchange Production BOM Item creates new version for phantom BOM, but not for its parent BOM if BOM's active version doesn't contain exchanged item

      // [GIVEN] Production BOM with 1 component "I1"
      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      ParentBOMNo := CreateProductionBOM(UnitOfMeasure.Code);
      ChildItemNo := FindProductionBOMComponent(ParentBOMNo);

      // [GIVEN] Version of the BOM with a phantom BOM including the same component "I1" as a child
      // [GIVEN] BOM version structiure: BOM -> Phantom BOM -> Component I1
      PhantomBOMNo := CreateProductionBOMForSingleItem(ChildItemNo,UnitOfMeasure.Code);
      CreateProductionBOMVersion(
        ParentProdBOMVersion,ParentBOMNo,UnitOfMeasure.Code,WORKDATE,ProdBOMLine.Type::"Production BOM",PhantomBOMNo,1);
      ModifyProductionBOMVersionStatus(ParentProdBOMVersion,ParentProdBOMVersion.Status::Certified);

      // [GIVEN] Item "I2"
      // [WHEN] Run "Exchange Production BOM Item" to replace item "I1" with "I2" and "Create New Version" option
      RunExchangeProdBOMItemReportWithParameters(ChildItemNo,LibraryInventory.CreateItemNo,TRUE);

      // [THEN] Version for parent BOM has not been created
      ParentProdBOMVersion.SETRANGE("Production BOM No.",ParentBOMNo);
      ParentProdBOMVersion.SETFILTER("Version Code",'<>%1',ParentProdBOMVersion."Version Code");
      Assert.AreEqual(0,ParentProdBOMVersion.COUNT,ProdBOMVersionMustNotExistErr);

      // [THEN] New version of the phantom BOM has been created
      ParentProdBOMVersion.SETRANGE("Production BOM No.",PhantomBOMNo);
      Assert.AreEqual(1,ParentProdBOMVersion.COUNT,ProdBOMVersionMustExistErr);
    END;

    [Test]
    [HandlerFunctions(ExchangeProductionBOMItemHandler)]
    PROCEDURE ExchangeBOMItemCreateNewVersionCopiesActiveBOMVersion@221();
    VAR
      UnitOfMeasure@1000 : Record 204;
      ProdBomVersion@1007 : Record 99000779;
      ProdBOMHeader@1001 : Record 99000771;
      Components@1002 : ARRAY [3] OF Code[20];
    BEGIN
      // [FEATURE] [Production BOM] [Exchange Production BOM Item]
      // [SCENARIO] Exchange Production BOM Item creates new version of production BOM based on the active BOM version

      // [GIVEN] Production BOM with 1 component "I1"
      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      ProdBOMHeader.GET(CreateProductionBOM(UnitOfMeasure.Code));
      Components[1] := FindProductionBOMComponent(ProdBOMHeader."No.");
      Components[2] := LibraryInventory.CreateItemNo;

      // Production BOM version with 2 components: "I1" and "I2", active on the WORKDATE
      CreateProductionBOMVersionWithTwoComponents(
        ProdBomVersion,ProdBOMHeader,ProdBOMHeader."Unit of Measure Code",WORKDATE,Components[1],Components[2]);

      // [GIVEN] Item "I3"
      Components[3] := LibraryInventory.CreateItemNo;

      // [WHEN] Run "Exchange Production BOM Item" to replace item "I1" with "I3" and "Create New Version" option
      RunExchangeProdBOMItemReportWithParameters(Components[1],Components[3],TRUE);

      // [THEN] New version created containing two items: "I2" and "I3"
      VerifyProductionBOMLineExists(
        ProdBomVersion."Production BOM No.",FindLastBOMVersionCode(ProdBomVersion."Production BOM No."),Components[2]);
      VerifyProductionBOMLineExists(
        ProdBomVersion."Production BOM No.",FindLastBOMVersionCode(ProdBomVersion."Production BOM No."),Components[3]);
    END;

    [Test]
    [HandlerFunctions(ExchangeProductionBOMItemHandler)]
    PROCEDURE ExchangeBOMItemCreateNewVersionCopiesBaseListIfVersionInactive@229();
    VAR
      UnitOfMeasure@1000 : Record 204;
      ProdBomVersion@1007 : Record 99000779;
      ProdBOMHeader@1001 : Record 99000771;
      Components@1002 : ARRAY [3] OF Code[20];
    BEGIN
      // [FEATURE] [Production BOM] [Exchange Production BOM Item]
      // [SCENARIO] Exchange Production BOM Item creates new version of production BOM based on the BOM list if the BOM version is inactive

      // [GIVEN] Production BOM with 1 component "I1"
      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      ProdBOMHeader.GET(CreateProductionBOM(UnitOfMeasure.Code));
      Components[1] := FindProductionBOMComponent(ProdBOMHeader."No.");
      Components[2] := LibraryInventory.CreateItemNo;

      // Production BOM version with 2 components: "I1" and "I2", active on WORKDATE + 1 day
      CreateProductionBOMVersionWithTwoComponents(
        ProdBomVersion,ProdBOMHeader,ProdBOMHeader."Unit of Measure Code",CALCDATE('<1D>',WORKDATE),Components[1],Components[2]);

      // [GIVEN] Item "I3"
      Components[3] := LibraryInventory.CreateItemNo;

      // [WHEN] Run "Exchange Production BOM Item" to replace item "I1" with "I3" and "Create New Version" option
      RunExchangeProdBOMItemReportWithParameters(Components[1],Components[3],TRUE);

      // [THEN] New version created contains item "I3", but does no have "I2"
      VerifyProductionBOMLineNotExists(
        ProdBomVersion."Production BOM No.",FindLastBOMVersionCode(ProdBomVersion."Production BOM No."),Components[2]);
      VerifyProductionBOMLineExists(
        ProdBomVersion."Production BOM No.",FindLastBOMVersionCode(ProdBomVersion."Production BOM No."),Components[3]);
    END;

    [Test]
    [HandlerFunctions(ProductionJournalHandler,ConfirmHandlerTrue,MessageHandler,ViewAppliedEntriesPageHandler2,ViewAppliedEntriesModalPageHandler)]
    PROCEDURE ApplicationWorkSheetUndoManualChanges@123();
    VAR
      ProductionOrder@1000 : Record 5405;
      ProdOrderComponent@1001 : Record 5407;
      SalesHeader@1002 : Record 36;
      TempItemLedgEntry@1007 : TEMPORARY Record 32;
      ProductionJournalMgt@1003 : Codeunit 5510;
      ApplicationWorksheet@1004 : TestPage 521;
    BEGIN
      // [FEATURE] [Manufacturing] [Application Worksheet]
      // [SCENARIO 375807] User actions in Application Worksheet cannot result in negative Item Ledger Entries of type Consumption.

      // [GIVEN] Purchased Item, Consumption posted (applied to purchase) and Sales Order posted (negative).
      Initialize;
      CreateInitialSetupForReleasedProductionOrder(ProductionOrder,ProdOrderComponent);
      ProductionJournalMgt.Handling(ProductionOrder,ProdOrderComponent."Prod. Order Line No.");
      CreateAndPostSalesOrder(
        SalesHeader,ProdOrderComponent."Item No.",ProdOrderComponent."Expected Quantity");

      SaveExistingILEs(TempItemLedgEntry,ProdOrderComponent."Item No.");

      // [GIVEN] In Application Worksheet Consumption unapplied, Sale applied to Purchase
      ApplicationWorksheet.OPENEDIT;
      ApplicationWorksheet.FILTER.SETFILTER("Item No.",ProdOrderComponent."Item No.");

      ApplicationWorksheet.FIRST;
      WHILE ApplicationWorksheet."Entry Type".ASINTEGER <> TempItemLedgEntry."Entry Type"::Consumption DO
        IF NOT ApplicationWorksheet.NEXT THEN
          ERROR(STRSUBSTNO(EntryOfTypeNotFoundErr,TempItemLedgEntry."Entry Type"::Consumption));
      ApplicationWorksheet.AppliedEntries.INVOKE;

      ApplicationWorksheet.FIRST;
      WHILE ApplicationWorksheet."Entry Type".ASINTEGER <> TempItemLedgEntry."Entry Type"::Sale DO
        IF NOT ApplicationWorksheet.NEXT THEN
          ERROR(STRSUBSTNO(EntryOfTypeNotFoundErr,TempItemLedgEntry."Entry Type"::Sale));
      ApplicationWorksheet.UnappliedEntries.INVOKE;

      COMMIT;

      // [GIVEN] 'Reapply All' gives an error, due to negative Consumption entry.
      ASSERTERROR ApplicationWorksheet.Action42.INVOKE; // Reapply All
      Assert.ExpectedError(InsufficientQuantityErr);

      // [WHEN] 'Undo Manual Changes' invoked.
      ApplicationWorksheet.UndoApplications.INVOKE;

      // [THEN] Item Ledger Entries are reverted to previous state.
      VerifyExistingILEs(TempItemLedgEntry,ProdOrderComponent."Item No.");
    END;

    [Test]
    PROCEDURE ItemLedgEntryUndoApplicationPositive@208();
    VAR
      PositiveItemLedgEntry@1006 : Record 32;
      NegativeItemLedgEntry@1004 : Record 32;
      TempItemLedgEntry@1007 : TEMPORARY Record 32;
      ItemJnlPostLine@1001 : Codeunit 22;
      ItemNo@1008 : Code[20];
    BEGIN
      // [FEATURE] [Manufacturing] [Application Worksheet]
      // [SCENARIO 375807] Item Ledger Entries are reverted to previous state after ReApply negative entry to positive one with LogApply and UndoApplications.

      // [GIVEN] Item with 2 Item Ledger Entries: positive "P" and negative "N", not applied.
      Initialize;
      ItemNo := PrepareUndoApplication;
      FindILE(PositiveItemLedgEntry,ItemNo,PositiveItemLedgEntry."Entry Type"::Purchase);
      FindILE(NegativeItemLedgEntry,ItemNo,NegativeItemLedgEntry."Entry Type"::Sale);
      Unapply(PositiveItemLedgEntry."Entry No.",NegativeItemLedgEntry."Entry No.");

      SaveExistingILEs(TempItemLedgEntry,ItemNo);

      // [GIVEN] Reapply "N" to "P" and log.
      ItemJnlPostLine.ReApply(PositiveItemLedgEntry,NegativeItemLedgEntry."Entry No.");
      ItemJnlPostLine.LogApply(PositiveItemLedgEntry,NegativeItemLedgEntry);

      // [WHEN] Undo applications.
      ItemJnlPostLine.UndoApplications;

      // [THEN] "P" and "N" are reverted to previous state.
      VerifyExistingILEs(TempItemLedgEntry,ItemNo);
    END;

    [Test]
    PROCEDURE ItemLedgEntryUndoApplicationNegative@216();
    VAR
      PositiveItemLedgEntry@1004 : Record 32;
      NegativeItemLedgEntry@1003 : Record 32;
      TempItemLedgEntry@1002 : TEMPORARY Record 32;
      ItemJnlPostLine@1001 : Codeunit 22;
      ItemNo@1000 : Code[20];
    BEGIN
      // [FEATURE] [Manufacturing] [Application Worksheet]
      // [SCENARIO 375807] Item Ledger Entries are reverted to previous state after ReApply positive entry to negative one with LogApply and UndoApplications.

      // [GIVEN] Item with 2 Item Ledger Entries: positive "P" and negative "N", not applied.
      Initialize;
      ItemNo := PrepareUndoApplication;
      FindILE(PositiveItemLedgEntry,ItemNo,PositiveItemLedgEntry."Entry Type"::Purchase);
      FindILE(NegativeItemLedgEntry,ItemNo,NegativeItemLedgEntry."Entry Type"::Sale);
      Unapply(PositiveItemLedgEntry."Entry No.",NegativeItemLedgEntry."Entry No.");
      FindILE(NegativeItemLedgEntry,ItemNo,NegativeItemLedgEntry."Entry Type"::Sale);

      SaveExistingILEs(TempItemLedgEntry,ItemNo);

      // [GIVEN] Reapply "P" to "N" and log.
      ItemJnlPostLine.ReApply(NegativeItemLedgEntry,PositiveItemLedgEntry."Entry No.");
      ItemJnlPostLine.LogApply(NegativeItemLedgEntry,PositiveItemLedgEntry);

      // [WHEN] Undo applications.
      ItemJnlPostLine.UndoApplications;

      // [THEN] "P" and "N" are reverted to previous state.
      VerifyExistingILEs(TempItemLedgEntry,ItemNo);
    END;

    [Test]
    PROCEDURE ItemLedgEntryUndoUnapplicationPositive@217();
    VAR
      PositiveItemLedgEntry@1004 : Record 32;
      NegativeItemLedgEntry@1003 : Record 32;
      TempItemLedgEntry@1002 : TEMPORARY Record 32;
      ItemApplnEntry@1005 : Record 339;
      ItemJnlPostLine@1001 : Codeunit 22;
      ItemNo@1000 : Code[20];
    BEGIN
      // [FEATURE] [Manufacturing] [Application Worksheet]
      // [SCENARIO 375807] Item Ledger Entries are reverted to previous state after UnApply with LogUnapply and UndoApplications.

      // [GIVEN] Item with 2 Item Ledger Entries: positive "P" and negative "N", fully applied.
      Initialize;
      ItemNo := PrepareUndoApplication;
      FindILE(PositiveItemLedgEntry,ItemNo,PositiveItemLedgEntry."Entry Type"::Purchase);
      FindILE(NegativeItemLedgEntry,ItemNo,NegativeItemLedgEntry."Entry Type"::Sale);

      SaveExistingILEs(TempItemLedgEntry,ItemNo);

      // [GIVEN] Unapply "N" and "P" and log.
      WITH ItemApplnEntry DO BEGIN
        SETRANGE("Inbound Item Entry No.",PositiveItemLedgEntry."Entry No.");
        SETRANGE("Outbound Item Entry No.",NegativeItemLedgEntry."Entry No.");
        FINDFIRST;
      END;
      ItemJnlPostLine.UnApply(ItemApplnEntry);
      ItemJnlPostLine.LogUnapply(ItemApplnEntry);

      // [WHEN] Undo unapplication.
      ItemJnlPostLine.UndoApplications;

      // [THEN] "P" and "N" are reverted to previous state.
      VerifyExistingILEs(TempItemLedgEntry,ItemNo);
    END;

    [Test]
    [HandlerFunctions(DummyProdOrderRoutingHandler)]
    PROCEDURE ProdOrderRoutingPageDoesNotUpdateBinCodeInMultilevelOrder@222();
    VAR
      ProdOrderLine@1000 : ARRAY [2] OF Record 5406;
      WorkCenter@1001 : Record 99000754;
      ProdOrderComponent@1003 : Record 5407;
      Location@1004 : Record 14;
      Bin@1005 : ARRAY [2] OF Record 7354;
      RoutingRefNo@1002 : Integer;
    BEGIN
      // [FEATURE] [Warehouse] [Bin] [Routing]
      // [SCENARIO 360012] Bin Code is not updated in a prod. order line when opening prod. order routing page if "Planning Level Code" > 0

      // [GIVEN] Create location "L" with 2 bins: "B1" and "B2". Set "From-Production Bin Code" = "B2"
      // [GIVEN] Create multilevel production order on location "L"
      CreateProdOrderLineWithWhiteLocationAndUpdateWorkCenterBinCode(ProdOrderLine[1],WorkCenter,RoutingRefNo);

      Location.GET(ProdOrderLine[1]."Location Code");
      LibraryWarehouse.CreateBin(Bin[1],Location.Code,LibraryUtility.GenerateGUID,'','');
      LibraryWarehouse.CreateBin(Bin[2],Location.Code,LibraryUtility.GenerateGUID,'','');
      Location."From-Production Bin Code" := Bin[2].Code;
      Location.MODIFY;

      ProdOrderLine[2] := ProdOrderLine[1];
      ProdOrderLine[2]."Line No." := ProdOrderLine[1]."Line No." + 10000;
      ProdOrderLine[2]."Planning Level Code" := ProdOrderLine[1]."Planning Level Code" + 1;
      ProdOrderLine[2]."Bin Code" := Bin[1].Code;
      ProdOrderLine[2].INSERT;

      // [GIVEN] Set bin code = "B1" on production order line
      ProductionOrderNo := ProdOrderLine[1]."Prod. Order No.";
      FindProductionOrderComponent(ProdOrderComponent);
      ProdOrderComponent."Bin Code" := Bin[1].Code;
      ProdOrderComponent."Supplied-by Line No." := ProdOrderLine[2]."Line No.";
      ProdOrderComponent.MODIFY;

      // [WHEN] Open prod. order routing for the low-level line
      ProdOrderLine[2].ShowRouting;
      ProdOrderLine[2].FIND;

      // [THEN] Bin code in production order line is "B1"
      ProdOrderLine[2].TESTFIELD("Bin Code",ProdOrderComponent."Bin Code");
    END;

    [Test]
    PROCEDURE GlobalDimensionsInOutputJournalLineAreUpdatedOnExplodingRouting@18();
    VAR
      ProductionOrder@1000 : Record 5405;
      ProdOrderLine@1001 : Record 5406;
      ItemJournalBatch@1002 : Record 233;
      DimensionValue@1005 : ARRAY [2] OF Record 349;
    BEGIN
      // [FEATURE] [Item Journal] [Dimension]
      // [SCENARIO 380531] Shortcut Dimension 1 & 2 codes are populated from Prod. Order Line on exploding Routing in Output Journal.
      Initialize;

      // [GIVEN] Global Dimension Values "GV1" and "GV2".
      // [GIVEN] Production Item "I" with Routing and BOM.
      // [GIVEN] Prod. Order Line of Item "I" with Global Dimensions Values "GV1" and "GV2".
      CreateProdOrderLineWithGlobalDims(ProductionOrder,ProdOrderLine,DimensionValue);

      // [WHEN] Create Output Journal Line and explode Routing.
      OutputJournalExplodeRouting(ItemJournalBatch,ProductionOrder);

      // [THEN] All Output Journal Lines have Shortcut Dimension 1 & 2 codes populated with "GV1" and "GV2" values correspondingly.
      VerifyGlobalDimensionCodesInItemJournalBatch(ItemJournalBatch,DimensionValue[1].Code,DimensionValue[2].Code);
    END;

    [Test]
    PROCEDURE GlobalDimensionsInOutputJournalLineAreUpdatedOnValidatingWorkCenterNo@258();
    VAR
      ProductionOrder@1000 : Record 5405;
      ProdOrderLine@1001 : Record 5406;
      ProdOrderRoutingLine@1004 : Record 5409;
      ItemJournalBatch@1002 : Record 233;
      ItemJournalLine@1003 : Record 83;
      DimensionValue@1005 : ARRAY [2] OF Record 349;
    BEGIN
      // [FEATURE] [Item Journal] [Dimension]
      // [SCENARIO 380531] Shortcut Dimension 1 & 2 codes are populated from Prod. Order Line on validating Work/Machine Center in Output Journal.
      Initialize;

      // [GIVEN] Global Dimension Values "GV1" and "GV2".
      // [GIVEN] Production Item "I" with Routing and BOM.
      // [GIVEN] Prod. Order Line of Item "I" with Global Dimensions Values "GV1" and "GV2".
      CreateProdOrderLineWithGlobalDims(ProductionOrder,ProdOrderLine,DimensionValue);

      // [GIVEN] Output Journal Line with Production Order No. and Routing fields populated.
      CreateOutputJournal(ItemJournalBatch,ItemJournalLine,ProductionOrder."No.");
      PopulateRoutingOnOutputJournalLine(ItemJournalLine,ProdOrderRoutingLine,ProdOrderLine);

      // [WHEN] Validate production capacity No. on the Output Line.
      ItemJournalLine.VALIDATE("No.",ProdOrderRoutingLine."No.");

      // [THEN] Output Journal Line has Shortcut Dimension 1 & 2 codes populated with "GV1" and "GV2" values correspondingly.
      ItemJournalLine.TESTFIELD("Shortcut Dimension 1 Code",DimensionValue[1].Code);
      ItemJournalLine.TESTFIELD("Shortcut Dimension 2 Code",DimensionValue[2].Code);
    END;

    [Test]
    PROCEDURE DeleteItemExistingInCertifiedProdBOMVersionIsNotAllowed@160();
    VAR
      Item@1000 : Record 27;
      ProductionBOMVersion@1001 : Record 99000779;
    BEGIN
      // [FEATURE] [UT]
      // [SCENARIO 381274] User should not be able to delete Item if it is added to Production BOM Version with Status = "Certified"
      Initialize;

      // [GIVEN] Certified Production BOM Version for Item "X"
      LibraryInventory.CreateItem(Item);
      MockProdBOMHeaderWithVersionForItem(ProductionBOMVersion,Item."No.",ProductionBOMVersion.Status::Certified);

      // [WHEN] Delete Item "X"
      ASSERTERROR Item.DELETE(TRUE);

      // [THEN] Error raised that you cannot delete Item because it exists in certified Production BOM Version
      Assert.ExpectedError(STRSUBSTNO(CannotDeleteItemIfProdBOMVersionExistsErr,Item.TABLECAPTION,Item."No."));
    END;

    [Test]
    PROCEDURE DeleteItemExistingInNotCertifiedProdBOMVersionIsAllowed@234();
    VAR
      Item@1001 : Record 27;
      ProductionBOMVersion@1000 : Record 99000779;
    BEGIN
      // [SCENARIO 381274] User should be able to delete Item if it is added to Production BOM Version with Status = "Under Development"
      Initialize;

      // [GIVEN] Production BOM Version with Status = "Under Development" for Item "X"
      LibraryInventory.CreateItem(Item);
      MockProdBOMHeaderWithVersionForItem(ProductionBOMVersion,Item."No.",ProductionBOMVersion.Status::"Under Development");

      // [WHEN] Delete Item "X"
      Item.DELETE(TRUE);

      // [THEN] Item "X" successfully deleted
      Assert.IsFalse(Item.FIND,'Item should be deleted');
    END;

    [Test]
    PROCEDURE RefreshProductionOrderWithSourceTypeSalesHeaderTwoLinesDifferentLocations@236();
    VAR
      SalesLine@1006 : ARRAY [2] OF Record 37;
      ProductionOrder@1003 : Record 5405;
      ProdOrderLine@1008 : Record 5406;
      Item@1010 : ARRAY [2] OF Record 27;
      BOMNo@1011 : Code[20];
      i@1005 : Integer;
    BEGIN
      // [FEATURE] [Production Order] [Source Type]
      // [SCENARIO 381335] Production Order can be refreshed when it has "Source Type" = "Sales Header", corresponding Sales Order contains two lines with different locations and one item is BOM component of another.
      Initialize;

      // [GIVEN] Two Items A and B with "Replenishment System" = "Prod. Order" and "Manufacturing Policy" = "Make-to-Order"
      FOR i := 1 TO 2 DO
        CreateItemWithReplenishmentSystemAndManufacturingPolicy(
          Item[i],Item[i]."Replenishment System"::"Prod. Order",Item[i]."Manufacturing Policy"::"Make-to-Order");

      // [GIVEN] Item A is the BOM component of Item B
      BOMNo := CreateProductionBOMForSingleItem(Item[1]."No.",Item[1]."Base Unit of Measure");
      Item[2].VALIDATE("Production BOM No.",BOMNo);
      Item[2].MODIFY(TRUE);

      // [GIVEN] Released Sales Order S with two lines for items A and B, locations in lines are different
      CreateSalesOrderLinesAtLocations(SalesLine,Item,2,TRUE);

      // [GIVEN] Released Production Order P with "Source Type" = "Sales Header", "Source No." = S."No."
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,
        ProductionOrder."Source Type"::"Sales Header",SalesLine[1]."Document No.",LibraryRandom.RandInt(5));

      // [WHEN] Refresh Production Order P
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      FOR i := 1 TO 2 DO BEGIN
        // [THEN] Production Order Line L with corresponding Location Code for each Item A and B exists
        FindProdOrderLineByItemNoLocationCodeAndPlanningLevelCode(ProdOrderLine,Item[i]."No.",SalesLine[i]."Location Code",0);

        // [THEN] Locations and Quantities in L are corresponding to the ones of Sales Order S lines
        ProdOrderLine.TESTFIELD(Quantity,SalesLine[i].Quantity);
      END;
    END;

    [Test]
    PROCEDURE RefreshProductionOrderMultiLevelStructureWithSourceTypeSalesHeaderMultipleLinesAtDifferentLocations@274();
    VAR
      SalesLine@1006 : ARRAY [4] OF Record 37;
      ProductionOrder@1003 : Record 5405;
      Item@1010 : ARRAY [4] OF Record 27;
      i@1005 : Integer;
    BEGIN
      // [FEATURE] [Production Order] [Source Type]
      // [SCENARIO 382024] Multi-level structure is created according to the BOM and the locations for a Production Order where a Sales Order with different locations in lines is a Source.
      Initialize;

      // [GIVEN] 4 Items with "Replenishment System" = "Prod. Order", "Manufacturing Policy" = "Make-to-Order" : I1, I2, I3, I4.
      FOR i := 1 TO 4 DO
        CreateItemWithReplenishmentSystemAndManufacturingPolicy(
          Item[i],Item[i]."Replenishment System"::"Prod. Order",Item[i]."Manufacturing Policy"::"Make-to-Order");

      // [GIVEN] I2 has I3 and I4 as BOM components B-2-3, B-2-4.
      SetNewProductionBOMToItemForArrayOfChildItems(Item[2],Item,3,4);

      // [GIVEN] I1 has I2, I3 and I4 as BOM components B-1-2, B-1-3, B-1-4.
      SetNewProductionBOMToItemForArrayOfChildItems(Item[1],Item,2,4);

      // [GIVEN] Released Sales Order S with 4 lines SL_A_I1, SL_B_I2, SL_C_I3, SL_D_I4 for Items I1, I2, I3, I4 at 4 different locations A, B, C, D.
      CreateSalesOrderLinesAtLocations(SalesLine,Item,4,TRUE);

      // [GIVEN] Released Production Order P with "Source Type" = "Sales Header", "Source No." = S."No."
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,
        ProductionOrder."Source Type"::"Sales Header",SalesLine[1]."Document No.",LibraryRandom.RandInt(5));

      // [WHEN] Refresh Production Order P
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // [THEN] Production Order has 9 Lines at Location A - D for the component I1 - I4 with Planning Level Code 0 - 2 :

      // [THEN] Planning Level Code 0 for Locations A - D for Items I1 - I4 : PL-A-0-I1, PL-B-0-I2, PL-C-0-I3, PL-D-0-I4
      // [THEN] Planning Level Code 1 for Locations A - B for Items I2 - I4 :            PL-A-1-I2, PL-B-1-I3, PL-B-1-I4
      // [THEN] Planning Level Code 2 for Location      A for Items I3 - I4 :                       PL-A-2-I3, PL-A-2-I4

      // [THEN] PL-A-0-I1."Quantity (Base)" = SL_A_I1."Quantity (Base)"
      // [THEN] PL-B-0-I2."Quantity (Base)" = SL_B_I2."Quantity (Base)"
      // [THEN] PL-C-0-I3."Quantity (Base)" = SL_C_I3."Quantity (Base)"
      // [THEN] PL-D-0-I4."Quantity (Base)" = SL_D_I4."Quantity (Base)"
      // [THEN] PL-A-1-I2."Quantity (Base)" = SL_A_I1."Quantity (Base)" * B-1-2."Quantity per"
      // [THEN] PL-B-1-I3."Quantity (Base)" = SL_B_I2."Quantity (Base)" * B-1-3."Quantity per"
      // [THEN] PL-B-1-I4."Quantity (Base)" = SL_B_I2."Quantity (Base)" * B-1-4."Quantity per"
      // [THEN] PL-A-2-I3."Quantity (Base)" = SL_A_I1."Quantity (Base)" * B-1-2."Quantity per" * B-2-3."Quantity per"
      // [THEN] PL-A-2-I4."Quantity (Base)" = SL_A_I1."Quantity (Base)" * B-1-2."Quantity per" * B-2-4."Quantity per"

      VerifyProductionOrderLineToSalesLineMultiLevelStructureWhenAllLocationsAreDifferent(Item,SalesLine,0,1,0,0);
      VerifyProductionOrderLineToSalesLineMultiLevelStructureWhenAllLocationsAreDifferent(Item,SalesLine,0,2,0,0);
      VerifyProductionOrderLineToSalesLineMultiLevelStructureWhenAllLocationsAreDifferent(Item,SalesLine,0,3,0,0);
      VerifyProductionOrderLineToSalesLineMultiLevelStructureWhenAllLocationsAreDifferent(Item,SalesLine,0,4,0,0);
      VerifyProductionOrderLineToSalesLineMultiLevelStructureWhenAllLocationsAreDifferent(Item,SalesLine,1,1,2,0);
      VerifyProductionOrderLineToSalesLineMultiLevelStructureWhenAllLocationsAreDifferent(Item,SalesLine,1,2,3,0);
      VerifyProductionOrderLineToSalesLineMultiLevelStructureWhenAllLocationsAreDifferent(Item,SalesLine,1,2,4,0);
      VerifyProductionOrderLineToSalesLineMultiLevelStructureWhenAllLocationsAreDifferent(Item,SalesLine,2,1,2,3);
      VerifyProductionOrderLineToSalesLineMultiLevelStructureWhenAllLocationsAreDifferent(Item,SalesLine,2,1,2,4);
    END;

    [Test]
    PROCEDURE RefreshProductionOrderMultiLevelStructureCollapsingWithSourceTypeSalesHeaderMultipleLinesAtOneLocation@275();
    VAR
      SalesLine@1006 : ARRAY [2] OF Record 37;
      ProductionBOMLine@1000 : ARRAY [2] OF Record 99000772;
      ProductionOrder@1003 : Record 5405;
      ProdOrderLine@1002 : Record 5406;
      Item@1010 : ARRAY [3] OF Record 27;
      i@1005 : Integer;
    BEGIN
      // [FEATURE] [Production Order] [Source Type]
      // [SCENARIO 382024] Multi-level structure is created according to the BOM where a Sales Order with lines at one location is a Source, component line of Production Order is collapsed.
      Initialize;

      // [GIVEN] 3 Items with "Replenishment System" = "Prod. Order", "Manufacturing Policy" = "Make-to-Order" : I1, I2, I3.
      FOR i := 1 TO 3 DO
        CreateItemWithReplenishmentSystemAndManufacturingPolicy(
          Item[i],Item[i]."Replenishment System"::"Prod. Order",Item[i]."Manufacturing Policy"::"Make-to-Order");

      // [GIVEN] I1 has I3 as a BOM component BL1.
      SetNewProductionBOMToItemForArrayOfChildItems(Item[1],Item,3,3);

      // [GIVEN] I2 also has I3 as a BOM component BL2.
      SetNewProductionBOMToItemForArrayOfChildItems(Item[2],Item,3,3);

      // [GIVEN] Released Sales Order S with 2 lines SL1 and SL2  for Items I1 and I2 at one location.
      CreateSalesOrderLinesAtLocations(SalesLine,Item,2,FALSE);

      // [GIVEN] Released Production Order P with "Source Type" = "Sales Header", "Source No." = S."No."
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,
        ProductionOrder."Source Type"::"Sales Header",SalesLine[1]."Document No.",LibraryRandom.RandInt(5));

      // [WHEN] Refresh Production Order P
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // [THEN] Production Order Line PL1 for I1 has "Planning Level Code" = 0 and PL1."Quantity (Base)" = SL1."Quantity (Base)".
      FindProdOrderLineByItemNoLocationCodeAndPlanningLevelCode(ProdOrderLine,Item[1]."No.",SalesLine[1]."Location Code",0);
      Assert.RecordCount(ProdOrderLine,1);
      ProdOrderLine.TESTFIELD("Quantity (Base)",SalesLine[1]."Quantity (Base)");

      // [THEN] Production Order Line PL2 for I2 has "Planning Level Code" = 0 and PL2."Quantity (Base)" = SL2."Quantity (Base)".
      FindProdOrderLineByItemNoLocationCodeAndPlanningLevelCode(ProdOrderLine,Item[2]."No.",SalesLine[2]."Location Code",0);
      Assert.RecordCount(ProdOrderLine,1);
      ProdOrderLine.TESTFIELD("Quantity (Base)",SalesLine[2]."Quantity (Base)");

      FOR i := 1 TO 2 DO
        FindProductionBOMLine(ProductionBOMLine[i],Item[i]."Production BOM No.");

      // [THEN] Production Order Line for PL3 the component I3 has Planning Level Code = 1 and PL3."Quantity (Base)" = [BL1."Quantity per" * SL1."Quantity (Base)"  + BL2."Quantity per" * SL2."Quantity (Base)"].
      FindProdOrderLineByItemNoLocationCodeAndPlanningLevelCode(ProdOrderLine,Item[3]."No.",SalesLine[i]."Location Code",1);
      Assert.RecordCount(ProdOrderLine,1);
      ProdOrderLine.TESTFIELD(
        "Quantity (Base)",SalesLine[1]."Quantity (Base)" * ProductionBOMLine[1]."Quantity per" +
        SalesLine[2]."Quantity (Base)" * ProductionBOMLine[2]."Quantity per");
    END;

    [Test]
    [HandlerFunctions(ExchangeProductionBOMItemHandler)]
    PROCEDURE ExchangeBOMItemCreateNewVersionWhenVersionCodeIsIncompatibleWithINCSTRFunction@239();
    VAR
      UnitOfMeasure@1000 : Record 204;
      ProdBomVersion@1007 : Record 99000779;
      ProdBOMHeader@1001 : Record 99000771;
      ProductionBOMLine@1003 : Record 99000772;
      Components@1002 : ARRAY [3] OF Code[20];
    BEGIN
      // [FEATURE] [Production BOM] [Exchange Production BOM Item]
      // [SCENARIO 381449] Exchange Production BOM Item creates new version of production BOM based on the active BOM version when INCSTR function for "Version Code" returns the value which already exists for "Production BOM No."
      // [GIVEN] Production BOM with component "I1"
      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      ProdBOMHeader.GET(CreateProductionBOM(UnitOfMeasure.Code));
      Components[1] := FindProductionBOMComponent(ProdBOMHeader."No.");

      // [GIVEN] Items "I2" and "I3"
      Components[2] := LibraryInventory.CreateItemNo;
      Components[3] := LibraryInventory.CreateItemNo;

      // [GIVEN] Production BOM version with "Version Code" = '9'
      CreateNamedProductionBOMVersion(
        ProdBomVersion,ProdBOMHeader."No.",ProdBOMHeader."Unit of Measure Code",
        WORKDATE,ProductionBOMLine.Type::Item,Components[1],1,'9');

      // [WHEN] Run "Exchange Production BOM Item" twice with "Create New Version" option to replace item "I1" with "I2" first time and to replace item "I2" with "I3" second time
      RunExchangeProdBOMItemReportWithParameters(Components[1],Components[2],TRUE);
      RunExchangeProdBOMItemReportWithParameters(Components[2],Components[3],TRUE);

      // [THEN] New version with "Version Code" = '11' created containing item "I3"
      ProductionBOMLine.SETRANGE("Production BOM No.",ProdBOMHeader."No.");
      ProductionBOMLine.SETRANGE("Version Code",'11');
      ProductionBOMLine.SETRANGE(Type,ProductionBOMLine.Type::Item);
      ProductionBOMLine.SETRANGE("No.",Components[3]);
      Assert.RecordIsNotEmpty(ProductionBOMLine);
    END;

    [Test]
    PROCEDURE ConsumeCapacityOnCCRWorkCenterBetweenAllocatedTimeBackwardPlanning@268();
    VAR
      RoutingHeader@1000 : Record 99000763;
      Item@1004 : Record 27;
      ProductionOrder@1005 : ARRAY [3] OF Record 5405;
    BEGIN
      // [FEATURE] [Production Order] [Capacity Constrained Resource]
      // [SCENARIO] When a capacity constrained resource has allocated capacity on the beginning and end of a day, new capacity should be allocated before the last allocated time on the same date on backward planning

      Initialize;

      // [GIVEN] Work center "CCR" configured as a capacity constrained resource with 8-hour working day from 08:00 to 16:00, 100% capacity
      CreateRoutingOnCapacityConstrainedWorkCenter(RoutingHeader,LibraryRandom.RandIntInRange(10,20));

      // [GIVEN] Item produced on the capacity constrained work center, Run Time = 10 minutes
      CreateItemWithRouting(Item,RoutingHeader."No.");

      // [GIVEN] Create and refresh a production order that will consume 10 minutes on the "CCR" work center: from 23.01.2019 15:50 to 23.01.2019 16:00
      CreateAndRefreshProductionOrderWithItem(ProductionOrder[1],ProductionOrder[1].Status::Released,Item."No.",1);
      // [GIVEN] Create and refresh a production order, set starting time to 08:00. New order will consume 10 minutes on the "CCR" work center: from 23.01.2019 08:00 to 23.01.2019 08:10
      CreateReleasedProdOrderWithCustomStartingTime(ProductionOrder[2],Item."No.",1,080000T);

      // [WHEN] Create and refresh backward the third prodution order.
      CreateAndRefreshProductionOrderWithItem(ProductionOrder[3],ProductionOrder[3].Status::Released,Item."No.",1);

      // [THEN] The last order consumes available capacity between the first two orders. Starting time = 15:40, Ending time = 15:50
      ProductionOrder[3].CALCFIELDS("Allocated Capacity Need");
      ProductionOrder[3].TESTFIELD("Starting Date",ProductionOrder[1]."Starting Date");
      ProductionOrder[3].TESTFIELD("Ending Date",ProductionOrder[1]."Ending Date");
      ProductionOrder[3].TESTFIELD(
        "Starting Time",ProductionOrder[1]."Starting Time" - ProductionOrder[3]."Allocated Capacity Need" * 60000);
      ProductionOrder[3].TESTFIELD("Ending Time",ProductionOrder[1]."Starting Time");
    END;

    [Test]
    PROCEDURE ConsumeCapacityOnCCRWorkCenterBetweenAllocatedTimeForwardPlanning@269();
    VAR
      RoutingHeader@1004 : Record 99000763;
      Item@1002 : Record 27;
      ProductionOrder@1001 : ARRAY [3] OF Record 5405;
    BEGIN
      // [FEATURE] [Production Order] [Capacity Constrained Resource]
      // [SCENARIO] When a capacity constrained resource has allocated capacity on the beginning and end of a day, new capacity should be allocated after the first allocated time on the same date on forward planning

      Initialize;

      // [GIVEN] Work center "CCR" configured as a capacity constrained resource with 8-hour working day from 08:00 to 16:00, 100% capacity
      CreateRoutingOnCapacityConstrainedWorkCenter(RoutingHeader,LibraryRandom.RandIntInRange(10,20));

      // [GIVEN] Item produced on the capacity constrained work center, Run Time = 10 minutes
      CreateItemWithRouting(Item,RoutingHeader."No.");

      // [GIVEN] Create and refresh a production order that will consume 10 minutes on the "CCR" work center: from 23.01.2019 15:50 to 23.01.2019 16:00
      CreateAndRefreshProductionOrderWithItem(ProductionOrder[1],ProductionOrder[1].Status::Released,Item."No.",1);
      // [GIVEN] Create and refresh a production order, set starting time to 08:00. New order will consume 10 minutes on the "CCR" work center: from 23.01.2019 08:00 to 23.01.2019 08:10
      CreateReleasedProdOrderWithCustomStartingTime(ProductionOrder[2],Item."No.",1,080000T);

      // Create the third production order, set starting time = 08:00
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder[3],ProductionOrder[3].Status::Released,ProductionOrder[3]."Source Type"::Item,Item."No.",1);
      ProductionOrder[3].VALIDATE("Starting Date-Time",CREATEDATETIME(ProductionOrder[3]."Starting Date",080000T));

      // [WHEN] Refresh the prodution order forward.
      LibraryManufacturing.RefreshProdOrder(ProductionOrder[3],TRUE,TRUE,TRUE,TRUE,FALSE);

      // [THEN] The last order consumes available capacity between the first two orders. Starting time = 08:00, Ending time = 08:20
      ProductionOrder[3].FIND;
      ProductionOrder[3].CALCFIELDS("Allocated Capacity Need");
      ProductionOrder[3].TESTFIELD("Starting Date",ProductionOrder[2]."Starting Date");
      ProductionOrder[3].TESTFIELD("Ending Date",ProductionOrder[2]."Ending Date");
      ProductionOrder[3].TESTFIELD("Starting Time",ProductionOrder[2]."Starting Time");
      ProductionOrder[3].TESTFIELD(
        "Ending Time",ProductionOrder[2]."Ending Time" + ProductionOrder[3]."Allocated Capacity Need" * 60000);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE SalesOrderPlanningCreatesSeparateProdOrderLinesForLocations@277();
    VAR
      Item@1000 : ARRAY [4] OF Record 27;
      Location@1003 : ARRAY [2] OF Record 14;
      SalesHeader@1001 : Record 36;
      SalesLine@1002 : Record 37;
      ProductionOrder@1004 : Record 5405;
    BEGIN
      // [FEATURE] [Location] [Sales Order Planning]
      // [SCENARIO 216835] Sales order planning should create a separate production order line for a manufactured subcomponent when sold items are on different locations

      // [GIVEN] Low-level component "C"
      LibraryInventory.CreateItem(Item[1]);

      // [GIVEN] Mid-level component "M" with "Make-to-Order" manufacturing policy. Component "M" includes the item "C" in its production BOM
      CreateItemWithReorderingPolicy(
        Item[2],Item[2]."Replenishment System"::"Prod. Order",Item[2]."Manufacturing Policy"::"Make-to-Order",'',
        CreateProductionBOMForSingleItem(Item[1]."No.",Item[1]."Base Unit of Measure"),'');

      // [GIVEN] High-level products "P1" and "P2", both having manufacturing policy "Make-to-Order" and including the component "M"
      CreateItemWithReorderingPolicy(
        Item[3],Item[3]."Replenishment System"::"Prod. Order",Item[3]."Manufacturing Policy"::"Make-to-Order",'',
        CreateProductionBOMForSingleItem(Item[2]."No.",Item[2]."Base Unit of Measure"),'');

      CreateItemWithReorderingPolicy(
        Item[4],Item[4]."Replenishment System"::"Prod. Order",Item[4]."Manufacturing Policy"::"Make-to-Order",'',
        CreateProductionBOMForSingleItem(Item[2]."No.",Item[2]."Base Unit of Measure"),'');

      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location[1]);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location[2]);

      // [GIVEN] Sales order with two lines: the first line with item "P1" on location "BLUE", the second - item "P2" on location "RED"
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,LibrarySales.CreateCustomerNo);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,Item[3]."No.",10);
      SalesLine.VALIDATE("Location Code",Location[1].Code);
      SalesLine.MODIFY(TRUE);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,Item[4]."No.",10);
      SalesLine.VALIDATE("Location Code",Location[2].Code);
      SalesLine.MODIFY(TRUE);

      // [WHEN] Run "Create Production Order" from the sales order
      LibraryManufacturing.CreateProductionOrderFromSalesOrder(SalesHeader,ProductionOrder.Status::Released,1);

      // [THEN] Production order with 4 lines is created:
      // [THEN] 1 production order line for item "P1" on "BLUE" location
      VerifyProdOrderLinesCount(Item[3]."No.",Location[1].Code,'',1);
      // [THEN] 1 production order line for item "P2" on "RED" location
      VerifyProdOrderLinesCount(Item[4]."No.",Location[2].Code,'',1);
      // [THEN] 1 production order line for item "M" on "BLUE" location
      VerifyProdOrderLinesCount(Item[2]."No.",Location[1].Code,'',1);
      // [THEN] 1 production order line for item "M" on "RED" location
      VerifyProdOrderLinesCount(Item[2]."No.",Location[2].Code,'',1);
    END;

    [Test]
    [HandlerFunctions(MessageHandler)]
    PROCEDURE SalesOrderPlanningCreatesSeparateProdOrderLinesForVariants@290();
    VAR
      Item@1000 : ARRAY [4] OF Record 27;
      ItemVariant@1003 : ARRAY [2] OF Record 5401;
      SalesHeader@1001 : Record 36;
      SalesLine@1002 : Record 37;
      ProductionOrder@1004 : Record 5405;
    BEGIN
      // [FEATURE] [Item Variant] [Sales Order Planning]
      // [SCENARIO 216835] Sales order planning should create a separate production order line for a manufactured subcomponent when the sold item is presented in different variants in sales order lines

      // [GIVEN] Low-level component "C"
      LibraryInventory.CreateItem(Item[1]);

      // [GIVEN] Mid-level component "M" with "Make-to-Order" manufacturing policy. Component "M" includes the item "C" in its production BOM
      CreateItemWithReorderingPolicy(
        Item[2],Item[2]."Replenishment System"::"Prod. Order",Item[2]."Manufacturing Policy"::"Make-to-Order",'',
        CreateProductionBOMForSingleItem(Item[1]."No.",Item[1]."Base Unit of Measure"),'');

      // [GIVEN] Item "M" has two variants "V1" and "V2"
      LibraryInventory.CreateItemVariant(ItemVariant[1],Item[2]."No.");
      LibraryInventory.CreateItemVariant(ItemVariant[2],Item[2]."No.");

      // [GIVEN] High-level product "P1" has manufacturing policy "Make-to-Order" and includs the component "M" in variant "V1"
      CreateProductionBOMForSingleItemWithVariant(
        Item[3],Item[2]."Base Unit of Measure",Item[2]."No.",ItemVariant[1].Code,LibraryRandom.RandInt(20));

      // [GIVEN] High-level product "P2" has manufacturing policy "Make-to-Order" and includs the component "M" in variant "V2"
      CreateProductionBOMForSingleItemWithVariant(
        Item[4],Item[2]."Base Unit of Measure",Item[2]."No.",ItemVariant[2].Code,LibraryRandom.RandInt(20));

      // [GIVEN] Sales order with two lines: the first line with item "P1", the second - item "P2"
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,LibrarySales.CreateCustomerNo);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,Item[3]."No.",10);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,Item[4]."No.",10);

      // [WHEN] Run "Create Production Order" from the sales order
      LibraryManufacturing.CreateProductionOrderFromSalesOrder(SalesHeader,ProductionOrder.Status::Released,1);

      // [THEN] Production order with 4 lines is created:
      // [THEN] 1 production order line for item "P1"
      VerifyProdOrderLinesCount(Item[3]."No.",'','',1);
      // [THEN] 1 production order line for item "P1"
      VerifyProdOrderLinesCount(Item[3]."No.",'','',1);
      // [THEN] 1 production order line for item "M", variant "V1"
      VerifyProdOrderLinesCount(Item[2]."No.",'',ItemVariant[1].Code,1);
      // [THEN] 1 production order line for item "M", variant "V2"
      VerifyProdOrderLinesCount(Item[2]."No.",'',ItemVariant[2].Code,1);
    END;

    LOCAL PROCEDURE Initialize@4();
    VAR
      LibraryERMCountryData@1000 : Codeunit 131305;
    BEGIN
      // Clear global variables.
      CLEAR(ShowError);
      CLEAR(EndingTimeError);
      CLEAR(ProductionOrderNo);
      CLEAR(ProductionOrderStatus);
      CLEAR(OverWrite);
      CLEAR(StartingTime);
      CLEAR(EndingTime);
      CLEAR(CapacityValue);
      CLEAR(WorkCenterNo2);
      CLEAR(Capacity2);
      CLEAR(ProductionForecastName2);
      CLEAR(ItemNo2);
      CLEAR(LocationCode2);
      CLEAR(DateChangeFormula);
      CLEAR(ExchangeNo);
      CLEAR(WithNo);
      CLEAR(CreateNewVersion);
      CLEAR(GLB_ItemTrackingQty);
      CLEAR(GLB_SerialNo);
      LibraryVariableStorage.Clear;

      // Lazy Setup.
      IF isInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;

      isInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE PrepareUndoApplication@237() : Code[20];
    VAR
      Item@1000 : Record 27;
      ItemJournalLine@1002 : Record 83;
      Quantity@1001 : Decimal;
    BEGIN
      LibraryInventory.CreateItem(Item);
      Quantity := LibraryRandom.RandDecInRange(10,20,2);

      CreateAndPostItemJournalLine(
        ItemJournalLine,ItemJournalLine."Entry Type"::Purchase,Item."No.",
        Quantity,WORKDATE,'');
      CreateAndPostItemJournalLine(
        ItemJournalLine,ItemJournalLine."Entry Type"::Sale,Item."No.",
        Quantity,WORKDATE,'');

      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE FindILE@244(VAR ItemLedgEntry@1000 : Record 32;ItemNo@1002 : Code[20];EntryType@1001 : Option);
    BEGIN
      WITH ItemLedgEntry DO BEGIN
        SETRANGE("Item No.",ItemNo);
        SETRANGE("Entry Type",EntryType);
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE Unapply@245(PositiveILENo@1000 : Integer;NegativeILENo@1001 : Integer);
    VAR
      ItemApplnEntry@1002 : Record 339;
      ItemJnlPostLine@1003 : Codeunit 22;
    BEGIN
      WITH ItemApplnEntry DO BEGIN
        SETRANGE("Inbound Item Entry No.",PositiveILENo);
        SETRANGE("Outbound Item Entry No.",NegativeILENo);
        FINDFIRST;
        ItemJnlPostLine.UnApply(ItemApplnEntry);
      END;
    END;

    LOCAL PROCEDURE SaveExistingILEs@246(VAR TempItemLedgEntry@1000 : TEMPORARY Record 32;ItemNo@1001 : Code[20]);
    VAR
      ItemLedgEntry@1002 : Record 32;
    BEGIN
      WITH ItemLedgEntry DO BEGIN
        SETRANGE("Item No.",ItemNo);
        FINDSET;
        REPEAT
          TempItemLedgEntry := ItemLedgEntry;
          TempItemLedgEntry.INSERT;
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE AddParentItemAsBOMComponent@97(VAR ProductionBOMHeader@1004 : Record 99000771;VAR ProductionBOMLine@1001 : Record 99000772;Item@1000 : Record 27);
    BEGIN
      ProductionBOMHeader.GET(Item."Production BOM No.");
      ModifyStatusInProductionBOM(ProductionBOMHeader,ProductionBOMHeader.Status::"Under Development");
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,Item."No.",LibraryRandom.RandDec(100,2));  // Taking Random Quantity.
    END;

    LOCAL PROCEDURE AddRoutingLine@168(VAR RoutingLine@1000 : Record 99000764;RoutingNo@1001 : Code[20];WorkCenterNo@1003 : Code[20];OperationNo@1004 : Integer);
    VAR
      RoutingHeader@1002 : Record 99000763;
    BEGIN
      RoutingHeader.GET(RoutingNo);
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::"Under Development");
      LibraryManufacturing.CreateRoutingLine(
        RoutingHeader,RoutingLine,'',FORMAT(OperationNo),RoutingLine.Type::"Work Center",WorkCenterNo);
      ModifyRunTimeOnRoutingLine(RoutingLine,LibraryRandom.RandInt(200));
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::Certified);
    END;

    LOCAL PROCEDURE CalculateRandomTime@122() RandomTime : Time;
    BEGIN
      EVALUATE(RandomTime,FORMAT(LibraryRandom.RandInt(23)));  // Use Random Values for Custom Time.
    END;

    LOCAL PROCEDURE CreateAndModifyProductionBOM@112(VAR ProductionBOMHeader@1001 : Record 99000771);
    VAR
      UnitOfMeasure@1000 : Record 204;
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      LibraryInventory.CreateUnitOfMeasureCode(UnitOfMeasure);
      ProductionBOMHeader.GET(CreateProductionBOM(UnitOfMeasure.Code));
      ModifyStatusInProductionBOM(ProductionBOMHeader,ProductionBOMHeader.Status::New);
      FindProductionBOMLine(ProductionBOMLine,ProductionBOMHeader."No.");
      ProductionBOMLine.VALIDATE("Ending Date",CALCDATE('<-' + FORMAT(LibraryRandom.RandInt(5)) + 'D>',WORKDATE));  // Use random Ending Date.
      ProductionBOMLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndPostCapacityJournal@88(Quantity@1001 : Decimal;WorkCenterNo@1002 : Code[20]);
    VAR
      ItemJournalLine@1000 : Record 83;
      ItemJournalBatch@1003 : Record 233;
      ItemJournalTemplate@1004 : Record 82;
    BEGIN
      SelectItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Type::Capacity);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,ItemJournalLine."Entry Type"::Output,'',0); // Zero used for Quantity.
      ItemJournalLine.VALIDATE(Type,ItemJournalLine.Type::"Work Center");
      ItemJournalLine.VALIDATE("No.",WorkCenterNo);
      ItemJournalLine.VALIDATE("Stop Time",Quantity);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE CreateAndPostConsumptionJournal@1020(ProductionOrderNo@1015 : Code[20]);
    VAR
      ItemJournalBatch@1013 : Record 233;
    BEGIN
      CalculateConsumptionJournal(ItemJournalBatch,ProductionOrderNo);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateAndPostItemJournalLine@6(ItemJournalLine@1000 : Record 83;EntryType@1004 : Option;ItemNo@1003 : Code[20];Quantity@1005 : Decimal;PostingDate@1006 : Date;LocationCode@1001 : Code[10]);
    VAR
      ItemJournalBatch@1002 : Record 233;
      ItemJournalTemplate@1007 : Record 82;
    BEGIN
      SelectItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Type::Item);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,EntryType,ItemNo,Quantity);
      ItemJournalLine.VALIDATE("Posting Date",PostingDate);
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CreateAndRefreshProductionOrder@17(VAR ProductionOrder@1000 : Record 5405;Status@1001 : Option) : Code[20];
    BEGIN
      CreateAndRefreshProductionOrderWithItem(
        ProductionOrder,Status,CreateItemWithRoutingAndProductionBOM,LibraryRandom.RandDec(10,2));
      EXIT(ProductionOrder."No.");
    END;

    LOCAL PROCEDURE CreateAndRefreshProductionOrderWithItem@280(VAR ProductionOrder@1001 : Record 5405;Status@1000 : Option;ItemNo@1002 : Code[20];Quantity@1003 : Decimal);
    BEGIN
      LibraryManufacturing.CreateProductionOrder(ProductionOrder,Status,ProductionOrder."Source Type"::Item,ItemNo,Quantity);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      ProductionOrder.FIND;
    END;

    LOCAL PROCEDURE CreateAndRefreshProdOrderWithSpecificDueDate@158(VAR ProductionOrder@1000 : Record 5405;ItemNo@1003 : Code[20];DueDate@1006 : Date);
    VAR
      RlsdProdOrder@1001 : TestPage 99000831;
    BEGIN
      // Create Released Production Order
      LibraryManufacturing.CreateProductionOrder(ProductionOrder,
        ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,ItemNo,LibraryRandom.RandDec(10,2));

      // Set Due Date and Refresh Production Order
      // Use page to modify Due Date of Production Order, since using Validate method on Production Order Record cannot work
      RlsdProdOrder.OPENEDIT;
      RlsdProdOrder.FILTER.SETFILTER("No.",ProductionOrder."No.");
      RlsdProdOrder."Due Date".SETVALUE(DueDate);
      ProductionOrder.GET(ProductionOrder.Status,ProductionOrder."No.");
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateBOMComponent@73(ParentItemNo@1001 : Code[20];ItemNo@1002 : Code[20];QuantityPer@1004 : Decimal);
    VAR
      BOMComponent@1000 : Record 90;
      Item@1003 : Record 27;
    BEGIN
      Item.GET(ItemNo);
      LibraryManufacturing.CreateBOMComponent(
        BOMComponent,ParentItemNo,BOMComponent.Type::Item,Item."No.",QuantityPer,Item."Base Unit of Measure");
    END;

    LOCAL PROCEDURE CreateCommentLineForProductionBOM@150(ProductionBOMNo@1000 : Code[20]);
    VAR
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      ProductionBOMLine.SETRANGE("Production BOM No.",ProductionBOMNo);
      ProductionBOMLine.FINDFIRST;
      LibraryManufacturing.CreateProductionBOMCommentLine(ProductionBOMLine);
    END;

    LOCAL PROCEDURE CreateCommentLineForItem@151(No@1000 : Code[20]);
    VAR
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      ProductionBOMLine.SETRANGE("No.",No);
      ProductionBOMLine.FINDFIRST;
      LibraryManufacturing.CreateProductionBOMCommentLine(ProductionBOMLine);
    END;

    LOCAL PROCEDURE CreateSalesOrderLinesAtLocations@271(VAR SalesLine@1001 : ARRAY [4] OF Record 37;VAR Item@1002 : ARRAY [4] OF Record 27;SalesLineCount@1003 : Integer;DifferentLocations@1006 : Boolean);
    VAR
      SalesHeader@1000 : Record 36;
      Location@1005 : Record 14;
      LocationCode@1007 : Code[10];
      i@1004 : Integer;
    BEGIN
      IF NOT DifferentLocations THEN BEGIN
        LibraryWarehouse.CreateLocation(Location);
        LocationCode := Location.Code;
      END;

      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,LibrarySales.CreateCustomerNo);
      FOR i := 1 TO SalesLineCount DO BEGIN
        IF DifferentLocations THEN BEGIN
          LibraryWarehouse.CreateLocation(Location);
          LocationCode := Location.Code;
        END;
        LibrarySales.CreateSalesLine(SalesLine[i],SalesHeader,SalesLine[i].Type::Item,Item[i]."No.",LibraryRandom.RandInt(20));
        SalesLine[i].VALIDATE("Location Code",LocationCode);
        SalesLine[i].VALIDATE("Unit Price",LibraryRandom.RandDec(10,2));
        SalesLine[i].MODIFY(TRUE);
      END;
      LibrarySales.ReleaseSalesDocument(SalesHeader);
    END;

    LOCAL PROCEDURE CalculateConsumptionJournal@1019(VAR ItemJournalBatch@1101 : Record 233;ProductionOrderNo@1021 : Code[20]);
    VAR
      ItemJournalTemplate@1000 : Record 82;
    BEGIN
      SelectItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Type::Consumption);
      LibraryManufacturing.CalculateConsumption(ProductionOrderNo,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE CalculateEndingTime@124(WorkCenter@1002 : Record 99000754;StartingTime@1000 : Time) EndingTime : Time;
    BEGIN
      EndingTime := StartingTime + LibraryRandom.RandInt(5) * CalendarManagement.TimeFactor(WorkCenter."Unit of Measure Code");  // Adding Random value to Starting Time as Ending Time should be later than the Starting Time.
      IF EndingTime < StartingTime THEN
        EndingTime := 235959T;  // Replace UpdatedTime with Maximum Time.
    END;

    LOCAL PROCEDURE CreateInitialSetupForReleasedProductionOrder@82(VAR ProductionOrder@1000 : Record 5405;VAR ProdOrderComponent@1002 : Record 5407);
    VAR
      ItemJournalLine@1001 : Record 83;
    BEGIN
      ProductionOrderNo := CreateAndRefreshProductionOrder(ProductionOrder,ProductionOrder.Status::Released);  // Use existing ProductionOrderNo as global to avoid local parameters.
      FindProductionOrderComponent(ProdOrderComponent);
      CreateAndPostItemJournalLine(
        ItemJournalLine,ItemJournalLine."Entry Type"::"Positive Adjmt.",ProdOrderComponent."Item No.",
        ProdOrderComponent."Expected Quantity",WORKDATE,'');
    END;

    LOCAL PROCEDURE CreateItemAndItemComponent@15(VAR ItemNo@1000 : Code[20];VAR ComponentNo@1001 : Code[20]);
    BEGIN
      ItemNo := CreateItemWithRoutingAndProductionBOM;
      ComponentNo := CreateItemWithRoutingAndProductionBOM;
    END;

    LOCAL PROCEDURE CreateItemReclassJournalLine@35(VAR ItemJournalLine@1002 : Record 83;ItemNo@1003 : Code[20];Quantity@1004 : Decimal);
    VAR
      ItemJournalBatch@1001 : Record 233;
      ItemJournalTemplate@1000 : Record 82;
    BEGIN
      SelectItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Type::Transfer);
      LibraryInventory.CreateItemJournalLine(
        ItemJournalLine,ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name,ItemJournalLine."Entry Type"::" ",ItemNo,
        Quantity);
    END;

    LOCAL PROCEDURE CreateItemWithLotForLotReorderingPolicyAndSafetyStockQuantity@132(VAR Item@1000 : Record 27);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Reordering Policy",Item."Reordering Policy"::"Lot-for-Lot");
      Item.VALIDATE("Safety Stock Quantity",LibraryRandom.RandDec(100,2));  // Use random value for Safety Stock Quantity.
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemWithRouting@278(VAR Item@1000 : Record 27;RoutingNo@1001 : Code[20]);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Routing No.",RoutingNo);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemWithRoutingAndProductionBOM@23() : Code[20];
    VAR
      Item@1001 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Unit Price",LibraryRandom.RandDec(100,2));  // Use random value for Unit Price.
      Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(100,2));  // Use random value for Unit Cost.
      Item.VALIDATE("Production BOM No.",CreateProductionBOM(Item."Base Unit of Measure"));
      Item.VALIDATE("Routing No.",CreateRouting);
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::"Prod. Order");
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateItemWithRoutingAndTwoWorkCenters@213(VAR WorkCenter@1005 : Record 99000754;VAR WorkCenter2@1000 : Record 99000754;VAR RoutingNo@1001 : Code[20]) : Code[20];
    VAR
      Item@1003 : Record 27;
      ShopCalendarWorkingDays@1002 : Record 99000752;
    BEGIN
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));
      CreateWorkCenterWithWorkCenterGroup(WorkCenter2,CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));

      RoutingNo := CreateCertifiedRoutingWithTwoLines(WorkCenter."No.",WorkCenter2."No.");

      LibraryInventory.CreateItem(Item);
      WITH Item DO BEGIN
        VALIDATE("Routing No.",RoutingNo);
        MODIFY;
        EXIT("No.");
      END;
    END;

    LOCAL PROCEDURE CreateItemWithReorderingPolicy@78(VAR Item@1000 : Record 27;ReplenishmentSystem@1001 : Option;ManufacturingPolicy@1004 : Option;InventoryPostingGroup@1005 : Code[10];ProductionBOMNo@1002 : Code[20];RoutingNo@1003 : Code[20]);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Replenishment System",ReplenishmentSystem);
      Item.VALIDATE("Reordering Policy",Item."Reordering Policy"::Order);
      Item.VALIDATE("Manufacturing Policy",ManufacturingPolicy);
      IF InventoryPostingGroup <> '' THEN
        Item.VALIDATE("Inventory Posting Group",InventoryPostingGroup);
      Item.VALIDATE("Production BOM No.",ProductionBOMNo);
      Item.VALIDATE("Routing No.",RoutingNo);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemWithReplenishmentSystemAndManufacturingPolicy@264(VAR Item@1000 : Record 27;ReplenishmentSystem@1001 : Option;ManufacturingPolicy@1004 : Option);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Replenishment System",ReplenishmentSystem);
      Item.VALIDATE("Manufacturing Policy",ManufacturingPolicy);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateMultipleItemsWithReorderingPolicy@10(VAR Item@1003 : Record 27;VAR Item2@1005 : Record 27;Quantity@1002 : Decimal);
    VAR
      InventoryPostingGroup@1001 : Record 94;
      BlankLocation@1004 : Record 14;
    BEGIN
      LibraryInventory.CreateInventoryPostingGroup(InventoryPostingGroup);
      BlankLocation.INIT;
      LibraryInventory.UpdateInventoryPostingSetup(BlankLocation);
      CreateItemWithReorderingPolicy(
        Item,Item."Replenishment System"::Purchase,Item."Manufacturing Policy"::"Make-to-Stock",
        InventoryPostingGroup.Code,'','');
      CreateItemWithReorderingPolicy(
        Item2,Item."Replenishment System"::"Prod. Order",Item2."Manufacturing Policy"::"Make-to-Stock",
        InventoryPostingGroup.Code,
        CreateProductionBOMLineForSelectedItem(Item."No.",Item."Base Unit of Measure",Quantity),CreateRoutingWithRoutingLinkCode);
    END;

    LOCAL PROCEDURE CreateItemWithReorderingPolicyAndInventoryPostingGroup@47(VAR Item@1002 : Record 27;ReplenishmentSystem@1003 : Option;ManufacturingPolicy@1004 : Option) : Code[10];
    VAR
      InventoryPostingGroup@1001 : Record 94;
      BlankLocation@1005 : Record 14;
    BEGIN
      LibraryInventory.CreateInventoryPostingGroup(InventoryPostingGroup);
      BlankLocation.INIT;
      LibraryInventory.UpdateInventoryPostingSetup(BlankLocation);
      CreateItemWithReorderingPolicy(
        Item,ReplenishmentSystem,ManufacturingPolicy,InventoryPostingGroup.Code,'','');
      EXIT(InventoryPostingGroup.Code);
    END;

    LOCAL PROCEDURE CreateLocation@58() : Code[10];
    VAR
      Location@1000 : Record 14;
      LibraryWarehouse@1001 : Codeunit 132204;
    BEGIN
      LibraryWarehouse.CreateLocation(Location);
      EXIT(Location.Code);
    END;

    LOCAL PROCEDURE CreateProdOrderComponent@249(VAR ProdOrderComponent@1000 : Record 5407;ProdOrderStatus@1001 : Option;ProdOrderNo@1002 : Code[20];ProdOrderLineNo@1003 : Integer;ItemNo@1004 : Code[20];LocationCode@1005 : Code[10];QtyPer@1006 : Decimal);
    BEGIN
      WITH ProdOrderComponent DO BEGIN
        LibraryManufacturing.CreateProductionOrderComponent(ProdOrderComponent,ProdOrderStatus,ProdOrderNo,ProdOrderLineNo);
        VALIDATE("Item No.",ItemNo);
        VALIDATE("Quantity per",QtyPer);
        VALIDATE("Location Code",LocationCode);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateWhiteLocation@194(VAR Location@1000 : Record 14);
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      WITH Location DO BEGIN
        VALIDATE("Bin Mandatory",TRUE);
        VALIDATE("Require Receive",TRUE);
        VALIDATE("Require Shipment",TRUE);
        VALIDATE("Require Put-away",TRUE);
        VALIDATE("Require Pick",TRUE);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateOutputJournal@259(VAR ItemJournalBatch@1004 : Record 233;VAR ItemJournalLine@1000 : Record 83;ProductionOrderNo@1001 : Code[20]);
    VAR
      ItemJournalTemplate@1003 : Record 82;
    BEGIN
      SelectItemJournalBatch(ItemJournalBatch,ItemJournalTemplate.Type::Output);
      ItemJournalTemplate.GET(ItemJournalBatch."Journal Template Name");
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
      LibraryManufacturing.CreateOutputJournal(ItemJournalLine,ItemJournalTemplate,ItemJournalBatch,'',ProductionOrderNo);
    END;

    LOCAL PROCEDURE CreateAndPostOutputJournal@39(ProductionOrderNo@1003 : Code[20]) : Code[20];
    VAR
      ItemJournalBatch@1001 : Record 233;
      ItemJournalLine@1000 : Record 83;
    BEGIN
      CreateOutputJournal(ItemJournalBatch,ItemJournalLine,ProductionOrderNo);
      LibraryInventory.OutputJnlExplRoute(ItemJournalLine);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
      EXIT(ItemJournalLine."Document No.");
    END;

    LOCAL PROCEDURE CreateProductionBOM@34(UnitOfMeasureCode@1001 : Code[10]) : Code[20];
    VAR
      Item@1003 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      EXIT(CreateProductionBOMForSingleItem(Item."No.",UnitOfMeasureCode));
    END;

    LOCAL PROCEDURE CreateProductionBOMVersion@219(VAR ProdBomVersion@1008 : Record 99000779;ProductionBOMNo@1001 : Code[20];UnitOfMeasureCode@1002 : Code[10];StartingDate@1000 : Date;Type@1005 : Option;No@1006 : Code[20];Quantity@1007 : Decimal);
    VAR
      ProdBOMHeader@1003 : Record 99000771;
      ProdBOMLine@1004 : Record 99000772;
    BEGIN
      ProdBOMHeader.GET(ProductionBOMNo);
      LibraryManufacturing.CreateProductionBOMVersion(ProdBomVersion,ProductionBOMNo,LibraryUtility.GenerateGUID,UnitOfMeasureCode);
      ProdBomVersion.VALIDATE("Starting Date",StartingDate);
      LibraryManufacturing.CreateProductionBOMLine(ProdBOMHeader,ProdBOMLine,ProdBomVersion."Version Code",Type,No,Quantity);
    END;

    LOCAL PROCEDURE CreateNamedProductionBOMVersion@260(VAR ProdBomVersion@1008 : Record 99000779;ProductionBOMNo@1001 : Code[20];UnitOfMeasureCode@1002 : Code[10];StartingDate@1000 : Date;Type@1005 : Option;No@1006 : Code[20];Quantity@1007 : Decimal;Version@1009 : Code[20]);
    VAR
      ProdBOMHeader@1003 : Record 99000771;
      ProdBOMLine@1004 : Record 99000772;
    BEGIN
      ProdBOMHeader.GET(ProductionBOMNo);
      LibraryManufacturing.CreateProductionBOMVersion(ProdBomVersion,ProductionBOMNo,Version,UnitOfMeasureCode);
      ProdBomVersion.VALIDATE("Starting Date",StartingDate);
      LibraryManufacturing.CreateProductionBOMLine(ProdBOMHeader,ProdBOMLine,ProdBomVersion."Version Code",Type,No,Quantity);
    END;

    LOCAL PROCEDURE CreateProductionBOMWithComponent@215(UnitOfMeasureCode@1001 : Code[10];ComponentItemNo@1004 : Code[20];RoutingLinkCode@1003 : Code[10]) : Code[20];
    VAR
      ProductionBOMHeader@1000 : Record 99000771;
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UnitOfMeasureCode);

      WITH ProductionBOMLine DO BEGIN
        LibraryManufacturing.CreateProductionBOMLine(
          ProductionBOMHeader,ProductionBOMLine,'',Type::Item,ComponentItemNo,1); // Qty per = 1
        VALIDATE("Routing Link Code",RoutingLinkCode);
        MODIFY(TRUE);
      END;

      ModifyStatusInProductionBOM(ProductionBOMHeader,ProductionBOMHeader.Status::Certified);
      EXIT(ProductionBOMHeader."No.");
    END;

    LOCAL PROCEDURE CreateProductionForecastEntry@91(VAR ProductionForecastEntry@1001 : Record 99000852;ProductionForecastName@1000 : Code[10]);
    VAR
      Item@1002 : Record 27;
    BEGIN
      LibraryManufacturing.CreateProductionForecastEntry(
        ProductionForecastEntry,ProductionForecastName,LibraryInventory.CreateItem(Item),CreateLocation,WORKDATE,TRUE);
      ProductionForecastEntry.VALIDATE("Forecast Quantity (Base)",LibraryRandom.RandDec(100,2));  // Use random value for Forecast Quantity Base.
      ProductionForecastEntry.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRegisteredAbsence@63(CapacityType@1002 : Option;No@1001 : Code[20];Date@1003 : Date) : Decimal;
    VAR
      RegisteredAbsence@1000 : Record 99000848;
    BEGIN
      LibraryManufacturing.CreateRegisteredAbsence(RegisteredAbsence,CapacityType,No,Date,StartingTime,EndingTime);
      RegisteredAbsence.VALIDATE(Capacity,100 + LibraryRandom.RandDec(10,2));  // Taking Random value for Capacity.
      RegisteredAbsence.MODIFY(TRUE);
      EXIT(RegisteredAbsence.Capacity);
    END;

    LOCAL PROCEDURE CreateReleasedProductionOrder@21(VAR ProductionOrder@1001 : Record 5405) : Integer;
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      CreateAndRefreshProductionOrder(ProductionOrder,ProductionOrder.Status::Released);
      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      EXIT(ProdOrderLine.COUNT);
    END;

    LOCAL PROCEDURE CreateRequisitionLine@126(VAR RequisitionLine@1001 : Record 246);
    VAR
      RequisitionWkshName@1000 : Record 245;
      Item@1002 : Record 27;
    BEGIN
      CreateRequisitionWorksheetName(RequisitionWkshName);
      LibraryPlanning.CreateRequisitionLine(RequisitionLine,RequisitionWkshName."Worksheet Template Name",RequisitionWkshName.Name);
      RequisitionLine.VALIDATE(Type,RequisitionLine.Type::Item);
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::"Prod. Order");
      Item.MODIFY;
      RequisitionLine.VALIDATE("No.",Item."No.");
      RequisitionLine.VALIDATE("Ending Date",WORKDATE);
      RequisitionLine.VALIDATE("Due Date",CALCDATE('<' + FORMAT(LibraryRandom.RandInt(5)) + 'D>',WORKDATE));  // Use random Due Date.
      RequisitionLine.VALIDATE(Quantity,LibraryRandom.RandDec(10,2));  // Use random Quantity.
      RequisitionLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRequisitionLineWithDates@225(VAR RequisitionLine@1000 : Record 246);
    BEGIN
      CreateRequisitionLine(RequisitionLine);
      WITH RequisitionLine DO BEGIN
        VALIDATE("Action Message","Action Message"::New);
        VALIDATE("Starting Date",WORKDATE);
        VALIDATE("Starting Time",TIME);
        VALIDATE("Ending Date",WORKDATE + 1);
        VALIDATE("Ending Time",TIME + 1);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateCertifiedRoutingWithTwoLines@242(WorkCenterNo@1002 : Code[20];WorkCenterNo2@1003 : Code[20]) : Code[20];
    VAR
      RoutingHeader@1001 : Record 99000763;
      RoutingLine@1000 : Record 99000764;
    BEGIN
      WITH LibraryManufacturing DO BEGIN
        CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);

        CreateRoutingLine(
          RoutingHeader,RoutingLine,'',FORMAT(LibraryRandom.RandInt(100)),RoutingLine.Type::"Work Center",WorkCenterNo);
        RoutingLine.VALIDATE("Run Time",LibraryRandom.RandInt(10));
        RoutingLine.MODIFY;

        CreateRoutingLine(
          RoutingHeader,RoutingLine,'',FORMAT(LibraryRandom.RandInt(100)),RoutingLine.Type::"Work Center",WorkCenterNo2);
        RoutingLine.VALIDATE("Run Time",LibraryRandom.RandInt(10));
        RoutingLine.MODIFY;
      END;

      WITH RoutingHeader DO BEGIN
        VALIDATE(Status,Status::Certified);
        MODIFY(TRUE);
        EXIT("No.");
      END;
    END;

    LOCAL PROCEDURE CreateProductionBOMForSingleItem@68(ItemNo@1004 : Code[20];UnitOfMeasureCode@1001 : Code[10]) : Code[20];
    VAR
      ProductionBOMHeader@1000 : Record 99000771;
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UnitOfMeasureCode);
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ItemNo,LibraryRandom.RandDec(100,2));
      ModifyStatusInProductionBOM(ProductionBOMHeader,ProductionBOMHeader.Status::Certified);
      EXIT(ProductionBOMHeader."No.");
    END;

    LOCAL PROCEDURE CreateProductionBOMForSetOfItems@272(VAR Item@1004 : Record 27;UnitOfMeasureCode@1001 : Code[10]) : Code[20];
    VAR
      ProductionBOMHeader@1000 : Record 99000771;
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UnitOfMeasureCode);
      IF Item.FINDSET THEN
        REPEAT
          LibraryManufacturing.CreateProductionBOMLine(
            ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,Item."No.",LibraryRandom.RandIntInRange(10,20));
        UNTIL Item.NEXT = 0;
      ModifyStatusInProductionBOM(ProductionBOMHeader,ProductionBOMHeader.Status::Certified);
      EXIT(ProductionBOMHeader."No.");
    END;

    LOCAL PROCEDURE CreateProductionBOMForSingleItemNonCertified@300(VAR ProductionBOMHeader@1000 : Record 99000771;UnitOfMeasureCode@1001 : Code[10];ItemNo@1003 : Code[20];Qty@1004 : Decimal);
    VAR
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UnitOfMeasureCode);
      LibraryManufacturing.CreateProductionBOMLine(ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ItemNo,Qty);
    END;

    LOCAL PROCEDURE CreateProductionBOMForSingleItemWithVariant@303(VAR Item@1006 : Record 27;UnitOfMeasureCode@1002 : Code[10];ItemNo@1003 : Code[20];VariantCode@1005 : Code[10];Qty@1004 : Decimal);
    VAR
      ProductionBOMHeader@1001 : Record 99000771;
      ProductionBOMLine@1000 : Record 99000772;
    BEGIN
      CreateProductionBOMForSingleItemNonCertified(ProductionBOMHeader,UnitOfMeasureCode,ItemNo,Qty);

      ProductionBOMLine.SETRANGE("Production BOM No.",ProductionBOMHeader."No.");
      ProductionBOMLine.FINDFIRST;
      ProductionBOMLine.VALIDATE("Variant Code",VariantCode);
      ProductionBOMLine.MODIFY(TRUE);

      ModifyStatusInProductionBOM(ProductionBOMHeader,ProductionBOMHeader.Status::Certified);

      CreateItemWithReorderingPolicy(
        Item,Item."Replenishment System"::"Prod. Order",Item."Manufacturing Policy"::"Make-to-Order",'',
        ProductionBOMLine."Production BOM No.",'');
    END;

    LOCAL PROCEDURE SetNewProductionBOMToItemForArrayOfChildItems@266(VAR ParentItem@1003 : Record 27;ChildItem@1000 : ARRAY [4] OF Record 27;FromChildNo@1001 : Integer;ToChildNo@1002 : Integer);
    VAR
      TempChildSetItem@1004 : TEMPORARY Record 27;
      i@1005 : Integer;
    BEGIN
      FOR i := FromChildNo TO ToChildNo DO BEGIN
        TempChildSetItem := ChildItem[i];
        TempChildSetItem.INSERT;
      END;
      ParentItem.VALIDATE(
        "Production BOM No.",CreateProductionBOMForSetOfItems(TempChildSetItem,ParentItem."Base Unit of Measure"));
      ParentItem.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateProductionBOMVersionWithTwoComponents@265(VAR ProdBOMVersion@1007 : Record 99000779;VAR ProdBOMHeader@1003 : Record 99000771;UnitOfMeasureCode@1004 : Code[10];StartingDate@1005 : Date;ComponentCode1@1001 : Code[20];ComponentCode2@1002 : Code[20]);
    VAR
      ProdBOMLine@1006 : Record 99000772;
    BEGIN
      CreateProductionBOMVersion(
        ProdBOMVersion,ProdBOMHeader."No.",UnitOfMeasureCode,StartingDate,ProdBOMLine.Type::Item,ComponentCode1,1);
      LibraryManufacturing.CreateProductionBOMLine(
        ProdBOMHeader,ProdBOMLine,ProdBOMVersion."Version Code",ProdBOMLine.Type::Item,ComponentCode2,1);
      ModifyProductionBOMVersionStatus(ProdBOMVersion,ProdBOMVersion.Status::Certified);
    END;

    LOCAL PROCEDURE CreateProdOrderLineWithWhiteLocationAndUpdateWorkCenterBinCode@206(VAR ProdOrderLine@1004 : Record 5406;VAR WorkCenter@1006 : Record 99000754;VAR RoutingRefNo@1002 : Integer);
    VAR
      ProductionOrder@1005 : Record 5405;
      ProdOrderRoutingLine@1003 : Record 5409;
      Location@1001 : Record 14;
      Bin@1000 : Record 7354;
    BEGIN
      CreateWhiteLocation(Location);
      LibraryWarehouse.CreateBin(
        Bin,Location.Code,LibraryUtility.GenerateRandomCode(Bin.FIELDNO(Code),DATABASE::Bin),'','');

      CreateReleasedProductionOrder(ProductionOrder);
      FindFirstProdOrderLine(ProdOrderLine,ProductionOrder.Status,ProductionOrder."No.");
      UpdateProdOrderLineLocationCode(ProdOrderLine,Location.Code);

      FindProductionOrderRoutingLine(ProdOrderRoutingLine,ProdOrderLine);
      ProdOrderRoutingLine."From-Production Bin Code" := LibraryUtility.GenerateGUID;
      ProdOrderRoutingLine.MODIFY;
      UpdateWorkCenterLocationCodeAndFromProdBinCode(WorkCenter,ProdOrderRoutingLine."Work Center No.",Location.Code,Bin.Code);
      RoutingRefNo := ProdOrderRoutingLine."Routing Reference No.";
    END;

    LOCAL PROCEDURE CreateReleasedProdOrderWithCustomStartingTime@282(VAR ProductionOrder@1000 : Record 5405;ItemNo@1001 : Code[20];Quantity@1002 : Decimal;StartingTime@1003 : Time);
    BEGIN
      CreateAndRefreshProductionOrderWithItem(ProductionOrder,ProductionOrder.Status::Released,ItemNo,Quantity);
      ProductionOrder.VALIDATE("Starting Time",StartingTime);
      ProductionOrder.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateProdOrderLineWithGlobalDims@228(VAR ProductionOrder@1002 : Record 5405;VAR ProdOrderLine@1001 : Record 5406;VAR DimensionValue@1000 : ARRAY [2] OF Record 349);
    VAR
      GeneralLedgerSetup@1004 : Record 98;
    BEGIN
      GeneralLedgerSetup.GET;
      LibraryDimension.CreateDimensionValue(DimensionValue[1],GeneralLedgerSetup."Global Dimension 1 Code");
      LibraryDimension.CreateDimensionValue(DimensionValue[2],GeneralLedgerSetup."Global Dimension 2 Code");

      CreateAndRefreshProductionOrder(ProductionOrder,ProductionOrder.Status::Released);
      FindFirstProdOrderLine(ProdOrderLine,ProductionOrder.Status,ProductionOrder."No.");
      SetGlobalDimsOnProdOrderLine(ProdOrderLine."Dimension Set ID",DimensionValue);
      ProdOrderLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRequisitionWorksheetName@129(VAR RequisitionWkshName@1002 : Record 245);
    VAR
      ReqWkshTemplate@1000 : Record 244;
    BEGIN
      ReqWkshTemplate.SETRANGE(Type,ReqWkshTemplate.Type::Planning);
      RequisitionWkshName.SETRANGE(Recurring,FALSE);
      ReqWkshTemplate.FINDFIRST;
      LibraryPlanning.CreateRequisitionWkshName(RequisitionWkshName,ReqWkshTemplate.Name);
    END;

    LOCAL PROCEDURE CreateRouting@8() : Code[20];
    VAR
      RoutingHeader@1000 : Record 99000763;
      RoutingLine@1001 : Record 99000764;
      WorkCenter@1002 : Record 99000754;
    BEGIN
      LibraryManufacturing.CreateWorkCenter(WorkCenter);
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);
      LibraryManufacturing.CreateRoutingLine(
        RoutingHeader,RoutingLine,'',FORMAT(LibraryRandom.RandInt(100)),RoutingLine.Type::"Work Center",WorkCenter."No.");
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
      EXIT(RoutingHeader."No.");
    END;

    LOCAL PROCEDURE CreateRoutingOnCapacityConstrainedWorkCenter@273(VAR RoutingHeader@1000 : Record 99000763;RunTime@1003 : Integer);
    VAR
      WorkCenter@1005 : Record 99000754;
      RoutingLine@1001 : Record 99000764;
    BEGIN
      CreateWorkCenterCapacityConstrained(WorkCenter);

      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);
      LibraryManufacturing.CreateRoutingLine(
        RoutingHeader,RoutingLine,'',LibraryUtility.GenerateGUID,RoutingLine.Type::"Work Center",WorkCenter."No.");
      RoutingLine.VALIDATE("Run Time",RunTime);
      RoutingLine.MODIFY(TRUE);

      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRoutingWithWorkCenter@311(WorkCenterNo@1003 : Code[20];ConcurrentCapacities@1004 : Integer;RoutingLinkCode@1005 : Code[10]) : Code[20];
    VAR
      RoutingHeader@1000 : Record 99000763;
      RoutingLine@1001 : Record 99000764;
    BEGIN
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);

      WITH RoutingLine DO BEGIN
        LibraryManufacturing.CreateRoutingLine(
          RoutingHeader,RoutingLine,'',FORMAT(LibraryRandom.RandInt(100)),Type::"Work Center",WorkCenterNo);
        VALIDATE("Setup Time",1);
        VALIDATE("Run Time",1);
        VALIDATE("Concurrent Capacities",ConcurrentCapacities);
        VALIDATE("Routing Link Code",RoutingLinkCode);
        MODIFY(TRUE);
      END;

      WITH RoutingHeader DO BEGIN
        VALIDATE(Status,Status::Certified);
        MODIFY(TRUE);
        EXIT("No.");
      END;
    END;

    LOCAL PROCEDURE CreateShopCalendarCodeWithAllDaysWorking@62(VAR ShopCalendarWorkingDays@1001 : Record 99000752) : Code[10];
    VAR
      ShopCalendarWorkingDays2@1000 : Record 99000752;
      ShopCalendarCode@1003 : Code[10];
    BEGIN
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarWorkingDays;
      ShopCalendarWorkingDays.SETRANGE("Shop Calendar Code",ShopCalendarCode);
      ShopCalendarWorkingDays.FINDFIRST;
      LibraryManufacturing.CreateShopCalendarWorkingDays(
        ShopCalendarWorkingDays2,ShopCalendarCode,ShopCalendarWorkingDays.Day::Saturday,ShopCalendarWorkingDays."Work Shift Code",
        080000T,160000T);
      LibraryManufacturing.CreateShopCalendarWorkingDays(
        ShopCalendarWorkingDays2,ShopCalendarCode,ShopCalendarWorkingDays.Day::Sunday,ShopCalendarWorkingDays."Work Shift Code",
        080000T,160000T);
      EXIT(ShopCalendarCode);
    END;

    LOCAL PROCEDURE CreateWorkCenterWithWorkCenterGroup@26(VAR WorkCenter@1001 : Record 99000754;ShopCalendarCode@1004 : Code[10]);
    BEGIN
      LibraryManufacturing.CreateWorkCenter(WorkCenter);
      WorkCenter.VALIDATE("Shop Calendar Code",ShopCalendarCode);
      WorkCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateWorkCenterWithCapacity@310(VAR WorkCenter@1001 : Record 99000754;CapacityToSet@1004 : Integer);
    VAR
      CapacityUnitOfMeasure@1002 : Record 99000780;
      ShopCalendarWorkingDays@1003 : Record 99000752;
    BEGIN
      LibraryManufacturing.CreateCapacityUnitOfMeasure(
        CapacityUnitOfMeasure,CapacityUnitOfMeasure.Type::Hours);
      WITH WorkCenter DO BEGIN
        LibraryManufacturing.CreateWorkCenter(WorkCenter);
        VALIDATE("Unit of Measure Code",CapacityUnitOfMeasure.Code);
        VALIDATE("Shop Calendar Code",CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));
        VALIDATE(Capacity,CapacityToSet);
        MODIFY(TRUE);
      END;

      LibraryManufacturing.CalculateWorkCenterCalendar(
        WorkCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<+1M>',WORKDATE));
    END;

    LOCAL PROCEDURE CreateWorkCenterWithCalendarCode@155(VAR WorkCenter@1000 : Record 99000754;ShopCalendarCode@1001 : Code[10]);
    BEGIN
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,'');
      WorkCenter.VALIDATE("Shop Calendar Code",ShopCalendarCode);
      WorkCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateWorkCenterWithCalendarCodeAndRoundingPrecision@156(VAR WorkCenter@1000 : Record 99000754;ShopCalendarCode@1001 : Code[10];Precision@1003 : Decimal);
    BEGIN
      CreateWorkCenterWithCalendarCode(WorkCenter,ShopCalendarCode);
      WorkCenter.VALIDATE("Calendar Rounding Precision",Precision);
      WorkCenter.MODIFY(TRUE);
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<+1M>',WORKDATE));
    END;

    LOCAL PROCEDURE CreateMachineCenterAndUpdateProdOderRtngLine@226(VAR MachineCenter@1002 : Record 99000758;VAR ProdOrderRtngLine@1003 : Record 5409;WorkCenter@1001 : Record 99000754;ProdOrderLine@1004 : Record 5406;RoutingRefNo@1005 : Integer);
    VAR
      Bin@1000 : Record 7354;
    BEGIN
      LibraryWarehouse.CreateBin(
        Bin,WorkCenter."Location Code",LibraryUtility.GenerateRandomCode(Bin.FIELDNO(Code),DATABASE::Bin),'','');

      WITH MachineCenter DO BEGIN
        LibraryManufacturing.CreateMachineCenter(MachineCenter,WorkCenter."No.",LibraryRandom.RandDec(10,2));
        VALIDATE("From-Production Bin Code",Bin.Code);
        MODIFY;
      END;

      WITH ProdOrderRtngLine DO BEGIN
        SETRANGE(Status,ProdOrderLine.Status);
        SETRANGE("Prod. Order No.",ProdOrderLine."Prod. Order No.");
        SETRANGE("Routing Reference No.",RoutingRefNo);
        FINDLAST;
      END;
    END;

    LOCAL PROCEDURE CreateMachineCenter@53(WorkCenterNo@1000 : Code[20]) : Code[20];
    VAR
      MachineCenter@1001 : Record 99000758;
    BEGIN
      LibraryManufacturing.CreateMachineCenter(MachineCenter,WorkCenterNo,LibraryRandom.RandDec(10,2));  // Taking Random value for Capacity.
      EXIT(MachineCenter."No.")
    END;

    LOCAL PROCEDURE CreateAndPostSalesOrder@57(VAR SalesHeader@1002 : Record 36;ItemNo@1000 : Code[20];Quantity@1004 : Decimal);
    BEGIN
      CreateSalesOrder(SalesHeader,ItemNo,Quantity);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE CreateSalesOrder@167(VAR SalesHeader@1002 : Record 36;ItemNo@1000 : Code[20];Quantity@1004 : Decimal);
    VAR
      SalesLine@1003 : Record 37;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,'');
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
      SalesLine.VALIDATE("Unit Price",LibraryRandom.RandDec(10,2));
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateProductionBOMLineForSelectedItem@5(ItemNo@1004 : Code[20];UnitOfMeasureCode@1001 : Code[10];Quantity@1007 : Decimal) : Code[20];
    VAR
      ProductionBOMHeader@1000 : Record 99000771;
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UnitOfMeasureCode);
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ItemNo,Quantity);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
      EXIT(ProductionBOMHeader."No.");
    END;

    LOCAL PROCEDURE CreateRoutingWithRoutingLinkCode@13() : Code[20];
    VAR
      RoutingHeader@1000 : Record 99000763;
      RoutingLine@1001 : Record 99000764;
      WorkCenter@1002 : Record 99000754;
      RoutingLink@1004 : Record 99000777;
    BEGIN
      WorkCenter.FINDFIRST;
      RoutingLink.FINDFIRST;
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);
      LibraryManufacturing.CreateRoutingLine(
        RoutingHeader,RoutingLine,'',FORMAT(LibraryRandom.RandInt(100)),RoutingLine.Type::"Work Center",WorkCenter."No.");
      RoutingLine.VALIDATE("Routing Link Code",RoutingLink.Code);
      RoutingLine.MODIFY(TRUE);
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
      EXIT(RoutingHeader."No.");
    END;

    LOCAL PROCEDURE CreateMultipleProductionBOMLines@2018(ItemNo@1201 : Code[20];ItemNo2@1202 : Code[20];UnitOfMeasureCode@1209 : Code[10];Quantity@1203 : Decimal) : Code[20];
    VAR
      ProductionBOMHeader@1204 : Record 99000771;
      ProductionBOMLine@1205 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UnitOfMeasureCode);
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ItemNo,Quantity);
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ItemNo2,Quantity);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
      EXIT(ProductionBOMHeader."No.");
    END;

    LOCAL PROCEDURE CreateProdBOMMultipleLinesRoutingLink@141(VAR ProductionBOMHeader@1001 : Record 99000771;Item@1000 : ARRAY [10] OF Record 27;RoutingLinkCode@1005 : ARRAY [10] OF Code[10];UnitOfMeasureCode@1002 : Code[10]);
    VAR
      ProductionBOMLine@1006 : Record 99000772;
      ItemArrayCounter@1003 : Integer;
      ItemArrayLength@1004 : Integer;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,UnitOfMeasureCode);
      ItemArrayLength := ARRAYLEN(Item);
      FOR ItemArrayCounter := 1 TO ItemArrayLength DO
        IF Item[ItemArrayCounter]."No." <> '' THEN BEGIN
          LibraryManufacturing.CreateProductionBOMLine(
            ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,
            Item[ItemArrayCounter]."No.",LibraryRandom.RandInt(100));
          IF RoutingLinkCode[ItemArrayCounter] <> '' THEN BEGIN
            ProductionBOMLine.VALIDATE("Routing Link Code",RoutingLinkCode[ItemArrayCounter]);
            ProductionBOMLine.MODIFY;
          END;
        END;
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateShopCalendar@143(StartingTime@1006 : Time;EndingTime@1000 : Time) : Code[10];
    VAR
      ShopCalendar@1004 : Record 99000751;
      ShopCalendarCode@1002 : Code[10];
    BEGIN
      ShopCalendarCode := LibraryManufacturing.CreateShopCalendarCode(ShopCalendar);
      CreateShopCalendarWorkingDays(ShopCalendarCode,StartingTime,EndingTime);
      EXIT(ShopCalendarCode);
    END;

    LOCAL PROCEDURE CreateShopCalendarWorkingDays@144(ShopCalendarCode@1007 : Code[10];StartingTime@1006 : Time;EndingTime@1000 : Time);
    VAR
      ShopCalendarWorkingDays@1001 : Record 99000752;
      WorkShift@1003 : Record 99000750;
      WorkShiftCode@1002 : Code[10];
    BEGIN
      ShopCalendarWorkingDays.SETRANGE("Shop Calendar Code",ShopCalendarCode);
      WorkShiftCode := LibraryManufacturing.CreateWorkShiftCode(WorkShift);
      LibraryManufacturing.CreateShopCalendarWorkingDays(
        ShopCalendarWorkingDays,ShopCalendarCode,ShopCalendarWorkingDays.Day::Monday,WorkShiftCode,StartingTime,EndingTime);
      LibraryManufacturing.CreateShopCalendarWorkingDays(
        ShopCalendarWorkingDays,ShopCalendarCode,ShopCalendarWorkingDays.Day::Tuesday,WorkShiftCode,StartingTime,EndingTime);
      LibraryManufacturing.CreateShopCalendarWorkingDays(
        ShopCalendarWorkingDays,ShopCalendarCode,ShopCalendarWorkingDays.Day::Wednesday,WorkShiftCode,StartingTime,EndingTime);
      LibraryManufacturing.CreateShopCalendarWorkingDays(
        ShopCalendarWorkingDays,ShopCalendarCode,ShopCalendarWorkingDays.Day::Thursday,WorkShiftCode,StartingTime,EndingTime);
      LibraryManufacturing.CreateShopCalendarWorkingDays(
        ShopCalendarWorkingDays,ShopCalendarCode,ShopCalendarWorkingDays.Day::Friday,WorkShiftCode,StartingTime,EndingTime);
    END;

    LOCAL PROCEDURE CreateShopCalendarWeekendWorkingDays@153(ShopCalendarCode@1007 : Code[10];StartingTime@1006 : Time;EndingTime@1000 : Time);
    VAR
      ShopCalendarWorkingDays@1001 : Record 99000752;
      WorkShift@1003 : Record 99000750;
      WorkShiftCode@1002 : Code[10];
    BEGIN
      WorkShiftCode := LibraryManufacturing.CreateWorkShiftCode(WorkShift);
      LibraryManufacturing.CreateShopCalendarWorkingDays(
        ShopCalendarWorkingDays,ShopCalendarCode,ShopCalendarWorkingDays.Day::Saturday,WorkShiftCode,StartingTime,EndingTime);
      LibraryManufacturing.CreateShopCalendarWorkingDays(
        ShopCalendarWorkingDays,ShopCalendarCode,ShopCalendarWorkingDays.Day::Sunday,WorkShiftCode,StartingTime,EndingTime);
    END;

    LOCAL PROCEDURE CreateShopCalendarWithTwoWorkShifts@152(StartingTime@1000 : Time;ChangeShiftTime@1001 : Time;EndingTime@1002 : Time) : Code[10];
    VAR
      ShopCalendarCode@1003 : Code[10];
    BEGIN
      ShopCalendarCode := CreateShopCalendar(StartingTime,ChangeShiftTime);
      CreateShopCalendarWorkingDays(ShopCalendarCode,ChangeShiftTime,EndingTime);
      EXIT(ShopCalendarCode);
    END;

    LOCAL PROCEDURE CreateProdOrderWithComponentAndPostOutput@250(VAR ProductionOrder@1000 : Record 5405;OutputItemNo@1001 : Code[20];ComponentItemNo@1006 : Code[20];ProdLocationCode@1002 : Code[10];ComponentLocationCode@1003 : Code[10]);
    VAR
      ProdOrderLine@1004 : Record 5406;
      ProdOrderComponent@1005 : Record 5407;
    BEGIN
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,OutputItemNo,1);
      ProductionOrder.VALIDATE("Location Code",ProdLocationCode);
      ProductionOrder.MODIFY(TRUE);

      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      FindProductionOrderLine(ProdOrderLine,ProductionOrder.Status,ProductionOrder."No.",OutputItemNo);
      CreateProdOrderComponent(
        ProdOrderComponent,ProdOrderLine.Status,ProdOrderLine."Prod. Order No.",
        ProdOrderLine."Line No.",ComponentItemNo,ComponentLocationCode,1);

      CreateAndPostOutputJournal(ProductionOrder."No.");

      TransferItem(OutputItemNo,1,ProdLocationCode,ComponentLocationCode);
    END;

    LOCAL PROCEDURE CreateProdOrdersWithCrossReference@251(VAR OpenProdOrder@1003 : Record 5405);
    VAR
      Item@1000 : ARRAY [2] OF Record 27;
      Location@1001 : ARRAY [2] OF Record 14;
      ProductionOrder@1002 : ARRAY [2] OF Record 5405;
    BEGIN
      LibraryInventory.CreateItem(Item[1]);
      LibraryInventory.CreateItem(Item[2]);

      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location[1]);
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location[2]);

      // 1st prod. order produces item[1] and consumes item[2], 2nd produces item[2] and consumes item[1]
      CreateProdOrderWithComponentAndPostOutput(ProductionOrder[1],Item[1]."No.",Item[2]."No.",Location[1].Code,Location[2].Code);
      CreateProdOrderWithComponentAndPostOutput(ProductionOrder[2],Item[2]."No.",Item[1]."No.",Location[1].Code,Location[2].Code);

      // Component for the 2nd production order is consumed, 1st is left on inventory
      CreateAndPostConsumptionJournal(ProductionOrder[2]."No.");
      OpenProdOrder := ProductionOrder[1];
    END;

    LOCAL PROCEDURE CreateProductionItemWithRouting@147(VAR Item@1000 : Record 27;VAR RoutingLine@1005 : Record 99000764;WorkCenterNo@1003 : Code[20]);
    VAR
      RoutingHeader@1002 : Record 99000763;
      CapacityUnitOfMeasure@1004 : Record 99000780;
    BEGIN
      // Create Routing, set work center and run time in routing line
      RoutingHeader.GET(CreateRouting);
      RoutingLine.SETRANGE("Routing No.",RoutingHeader."No.");
      RoutingLine.FINDFIRST;
      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,CapacityUnitOfMeasure.Type::Minutes); // Create Unit Of Measure (Minutes) for Run Time on routing line
      ModifyWorkCenterAndRunTimeOnRoutingLine(
        RoutingLine,WorkCenterNo,CapacityUnitOfMeasure.Code,LibraryRandom.RandInt(200));

      // Create Production Item
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Routing No.",RoutingHeader."No.");
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateProductionItemWithMultipleRoutingLines@181(VAR RoutingLine@1000 : Record 99000764;VAR RoutingLine2@1001 : Record 99000764;VAR Item@1002 : Record 27);
    VAR
      WorkCenter@1003 : Record 99000754;
      OperationNo@1004 : Integer;
    BEGIN
      CreateWorkCenterWithCalendarCode(WorkCenter,LibraryManufacturing.UpdateShopCalendarWorkingDays);
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<+1M>',WORKDATE));

      // Create Production Item with Routing, use the work center created above in routing line
      CreateProductionItemWithRouting(Item,RoutingLine,WorkCenter."No.");
      EVALUATE(OperationNo,RoutingLine."Operation No.");
      AddRoutingLine(
        RoutingLine2,RoutingLine."Routing No.",WorkCenter."No.",OperationNo + LibraryRandom.RandInt(20)); // Add the second routing line
    END;

    LOCAL PROCEDURE CreateAndRefreshProdOrderWithSpecificItem@186(VAR ProductionOrder@1000 : Record 5405;ItemNo@1001 : Code[20];Forward@1002 : Boolean);
    BEGIN
      // Create Released Production Order
      LibraryManufacturing.CreateProductionOrder(ProductionOrder,
        ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,ItemNo,LibraryRandom.RandDec(10,2));
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,Forward,TRUE,TRUE,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateAndRefreshProdOrderForMakeToOrderItem@263(VAR ProductionOrder@1000 : Record 5405);
    VAR
      ParentItem@1006 : Record 27;
      CompItem@1005 : Record 27;
      PurchasedItem@1004 : Record 27;
      InvtPostingGroupCode@1001 : Code[10];
    BEGIN
      LibraryInventory.CreateItem(PurchasedItem);

      InvtPostingGroupCode :=
        CreateItemWithReorderingPolicyAndInventoryPostingGroup(
          CompItem,CompItem."Replenishment System"::"Prod. Order",CompItem."Manufacturing Policy"::"Make-to-Order");

      CreateItemWithReorderingPolicy(
        ParentItem,ParentItem."Replenishment System"::"Prod. Order",ParentItem."Manufacturing Policy"::"Make-to-Order",
        InvtPostingGroupCode,CreateMultipleProductionBOMLines(
          CompItem."No.",PurchasedItem."No.",CompItem."Base Unit of Measure",LibraryRandom.RandDec(100,2)),'');

      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,ParentItem."No.",
        LibraryRandom.RandDec(10,2));
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateSalesOrderAndCalculateOrderPlan@185(Item@1000 : Record 27;ReplenishmentSystem@1003 : Option);
    VAR
      SalesHeader@1001 : Record 36;
      RequisitionLine@1002 : Record 246;
    BEGIN
      Item.VALIDATE("Replenishment System",ReplenishmentSystem); // Modify the replenishment system for calculating Order Planning
      Item.MODIFY(TRUE);
      CreateSalesOrder(SalesHeader,Item."No.",LibraryRandom.RandInt(10)); // Create a Sales Order for the item

      // Calculate Order Planning for Sales Demand, that will generate Planning Routing Line for the item
      LibraryPlanning.CalculateOrderPlanSales(RequisitionLine);
    END;

    LOCAL PROCEDURE CreateWorkCenterAndProductionItem@166(VAR Item@1002 : Record 27;VAR RoutingLine@1001 : Record 99000764);
    VAR
      WorkCenter@1003 : Record 99000754;
    BEGIN
      // Create Production Item with two Routing Lines, the 1st one contains only run time, the second one contains only wait time
      CreateWorkCenterWithCalendarCode(WorkCenter,LibraryManufacturing.UpdateShopCalendarWorkingDays);
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<+1M>',WORKDATE));

      // Create Production Item with Routing, use the work center created above in routing line
      CreateProductionItemWithRouting(Item,RoutingLine,WorkCenter."No.");

      ModifyRunTimeOnRoutingLine(RoutingLine,0); // Set run time to 0 for the convenience of calculating the starting datetime of the routing line with a random Quantity of items to produce
      ModifyWaitTimeOnRoutingLine(RoutingLine,LibraryRandom.RandIntInRange(7,14) * 24 * 60); // Set wait time to 1 ~ 2 weeks
    END;

    LOCAL PROCEDURE CreateWorkCenterCapacityConstrained@283(VAR WorkCenter@1000 : Record 99000754);
    VAR
      CapacityConstrainedResource@1003 : Record 99000866;
      ShopCalendarWorkingDays@1004 : Record 99000752;
    BEGIN
      CreateWorkCenterWithWorkCenterGroup(WorkCenter,CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,CALCDATE('<-1W>',WORKDATE),CALCDATE('<1W>',WORKDATE));
      LibraryManufacturing.CreateCapacityConstrainedResource(
        CapacityConstrainedResource,CapacityConstrainedResource."Capacity Type"::"Work Center",WorkCenter."No.");
    END;

    LOCAL PROCEDURE FilteringOnProdOrderCapacityNeed@165(VAR ProdOrderCapacityNeed@1000 : Record 5410;WorkCenterNo@1256 : Code[20];Date@1257 : Date);
    BEGIN
      ProdOrderCapacityNeed.SETRANGE("No.",WorkCenterNo);
      ProdOrderCapacityNeed.SETRANGE(Date,Date);
    END;

    LOCAL PROCEDURE FindLastBOMVersionCode@231(ProdBOMNo@1000 : Code[20]) : Code[20];
    VAR
      ProductionBOMVersion@1001 : Record 99000779;
    BEGIN
      WITH ProductionBOMVersion DO BEGIN
        SETRANGE("Production BOM No.",ProdBOMNo);
        FINDLAST;
        EXIT("Version Code");
      END;
    END;

    LOCAL PROCEDURE FindProductionOrderLine@2019(VAR ProdOrderLine@1256 : Record 5406;Status@1257 : Option;ProdOrderNo@1258 : Code[20];ItemNo@1259 : Code[20]);
    BEGIN
      ProdOrderLine.SETRANGE(Status,Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProdOrderNo);
      ProdOrderLine.SETRANGE("Item No.",ItemNo);
      ProdOrderLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindFirstProdOrderLine@195(VAR ProdOrderLine@1000 : Record 5406;ProdOrderStatus@1002 : Option;ProdOrderNo@1001 : Code[20]);
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProdOrderStatus);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProdOrderNo);
      ProdOrderLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindProdOrderLineByItemNoLocationCodeAndPlanningLevelCode@276(VAR ProdOrderLine@1256 : Record 5406;ItemNo@1259 : Code[20];LocationCode@1001 : Code[10];PlanningLevelCode@1000 : Integer);
    BEGIN
      ProdOrderLine.SETRANGE("Item No.",ItemNo);
      ProdOrderLine.SETRANGE("Location Code",LocationCode);
      ProdOrderLine.SETRANGE("Planning Level Code",PlanningLevelCode);
      ProdOrderLine.FINDFIRST;
    END;

    LOCAL PROCEDURE GetQuantityPerFromProductionBOMLineByNo@243(VAR ProductionBOMLine@1256 : Record 99000772;No@1259 : Code[20]) : Decimal;
    BEGIN
      WITH ProductionBOMLine DO BEGIN
        SETRANGE(Type,Type::Item);
        SETRANGE("No.",No);
        FINDFIRST;
        EXIT("Quantity per");
      END;
    END;

    LOCAL PROCEDURE FillTempBufOfProductionBOMLinesByBOMNo@279(VAR ProductionBOMLineBuf@1256 : Record 99000772;BOMNo@1000 : Code[20]);
    VAR
      ProductionBOMLine@1001 : Record 99000772;
    BEGIN
      ProductionBOMLine.SETRANGE("Production BOM No.",BOMNo);
      IF ProductionBOMLine.FINDSET THEN
        REPEAT
          ProductionBOMLineBuf := ProductionBOMLine;
          ProductionBOMLineBuf.INSERT;
        UNTIL ProductionBOMLine.NEXT = 0;
    END;

    LOCAL PROCEDURE FindProductionBOMComponent@113(ProductionBOMNo@1001 : Code[20]) : Code[20];
    VAR
      ProductionBOMLine@1000 : Record 99000772;
    BEGIN
      ProductionBOMLine.SETRANGE("Production BOM No.",ProductionBOMNo);
      ProductionBOMLine.FINDFIRST;
      EXIT(ProductionBOMLine."No.");
    END;

    LOCAL PROCEDURE FindProductionBOMLine@114(VAR ProductionBOMLine@1000 : Record 99000772;ProductionBOMNo@1001 : Code[20]) : Boolean;
    BEGIN
      ProductionBOMLine.SETRANGE("Production BOM No.",ProductionBOMNo);
      EXIT(ProductionBOMLine.FINDFIRST);
    END;

    LOCAL PROCEDURE FindProductionOrderComponent@84(VAR ProdOrderComponent@1000 : Record 5407);
    BEGIN
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderComponent.FINDFIRST;
    END;

    LOCAL PROCEDURE FindProductionOrderRoutingLine@154(VAR ProdOrdRtngLn@1000 : Record 5409;ProdOrdLn@1001 : Record 5406) : Boolean;
    BEGIN
      ProdOrdRtngLn.SETRANGE(Status,ProdOrdLn.Status);
      ProdOrdRtngLn.SETRANGE("Prod. Order No.",ProdOrdLn."Prod. Order No.");
      ProdOrdRtngLn.SETRANGE("Routing Reference No.",ProdOrdLn."Line No.");
      EXIT(ProdOrdRtngLn.FINDFIRST);
    END;

    LOCAL PROCEDURE FindProdOrderComponent@252(VAR ProdOrderComponent@1000 : Record 5407;ProdOrderStatus@1001 : Option;ProdOrderNo@1002 : Code[20]);
    BEGIN
      WITH ProdOrderComponent DO BEGIN
        SETRANGE(Status,ProdOrderStatus);
        SETRANGE("Prod. Order No.",ProdOrderNo);
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE FindPlanningRoutingLine@178(VAR PlanningRoutingLine@1256 : Record 99000830;WorkCenterNo@1257 : Code[20];OperationNo@1000 : Code[10]);
    BEGIN
      PlanningRoutingLine.SETRANGE("Work Center No.",WorkCenterNo);
      PlanningRoutingLine.SETRANGE("Operation No.",OperationNo);
      PlanningRoutingLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindFirstProdOrderRoutingLine@33(VAR ProdOrderRoutingLine@1002 : Record 5409;ProductionOrderStatus@1001 : Option;ProductionOrderNo@1000 : Code[20]);
    BEGIN
      WITH ProdOrderRoutingLine DO BEGIN
        SETRANGE(Status,ProductionOrderStatus);
        SETRANGE("Prod. Order No.",ProductionOrderNo);
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE FindProdOrderRoutingLine@176(VAR ProdOrderRoutingLine@1256 : Record 5409;WorkCenterNo@1257 : Code[20];OperationNo@1000 : Code[10]);
    BEGIN
      ProdOrderRoutingLine.SETRANGE("Work Center No.",WorkCenterNo);
      ProdOrderRoutingLine.SETRANGE("Operation No.",OperationNo);
      ProdOrderRoutingLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindProdOrderRtngLn@210(VAR ProdOrderRoutingLine@1256 : Record 5409;ProductionOrderStatus@1001 : Option;ProductionOrderNo@1002 : Code[20];RoutingNo@1000 : Code[20];WorkCenterNo@1257 : Code[20]);
    BEGIN
      WITH ProdOrderRoutingLine DO BEGIN
        SETRANGE(Status,ProductionOrderStatus);
        SETRANGE("Prod. Order No.",ProductionOrderNo);
        SETRANGE("Routing No.",RoutingNo);
        SETRANGE("Work Center No.",WorkCenterNo);
        FINDFIRST;
      END;
    END;

    LOCAL PROCEDURE FindShopCalendarWorkingDaysForWorkCenter@187(VAR ShopCalendarWorkingDays@1000 : Record 99000752;WorkCenterNo@1001 : Code[20];Day@1002 : Option);
    VAR
      WorkCenter@1003 : Record 99000754;
    BEGIN
      WorkCenter.GET(WorkCenterNo);
      ShopCalendarWorkingDays.SETRANGE("Shop Calendar Code",WorkCenter."Shop Calendar Code");
      ShopCalendarWorkingDays.SETRANGE(Day,Day);
      ShopCalendarWorkingDays.FINDFIRST;
    END;

    LOCAL PROCEDURE GetCalendarEntry@75(VAR CalendarEntry@1000 : Record 99000757;CapacityType@1002 : Option;No@1001 : Code[20]);
    BEGIN
      CalendarEntry.SETRANGE("Capacity Type",CapacityType);
      CalendarEntry.SETRANGE("No.",No);
      CalendarEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE GetRoundedTime@27(Date2@1000 : Date) : Time;
    BEGIN
      EXIT(DT2TIME(ROUNDDATETIME(CREATEDATETIME(Date2,TIME))));  // Rounding the Time for successfull verification.
    END;

    LOCAL PROCEDURE GetProdOrderCapacityNeedDate@162(WorkCenterNo@1000 : Code[20]) : Date;
    VAR
      ProdOrderCapacityNeed@1001 : Record 5410;
    BEGIN
      ProdOrderCapacityNeed.SETRANGE("No.",WorkCenterNo);
      ProdOrderCapacityNeed.FINDFIRST;
      EXIT(ProdOrderCapacityNeed.Date);
    END;

    LOCAL PROCEDURE MockProdBOMHeaderWithVersionForItem@230(VAR ProductionBOMVersion@1002 : Record 99000779;ItemNo@1000 : Code[20];VersionStatus@1004 : Option);
    VAR
      ProductionBOMHeader@1001 : Record 99000771;
    BEGIN
      ProductionBOMHeader.INIT;
      ProductionBOMHeader."No." := LibraryUtility.GenerateGUID;
      ProductionBOMHeader.Status := ProductionBOMHeader.Status::"Under Development";
      ProductionBOMHeader.INSERT;
      ProductionBOMVersion.INIT;
      ProductionBOMVersion."Production BOM No." := ProductionBOMHeader."No.";
      ProductionBOMVersion."Version Code" := LibraryUtility.GenerateGUID;
      ProductionBOMVersion.Status := VersionStatus;
      ProductionBOMVersion.INSERT;
      MockProdBOMLine(ItemNo,ProductionBOMHeader."No.",ProductionBOMVersion."Version Code");
    END;

    LOCAL PROCEDURE MockProdBOMLine@262(ItemNo@1000 : Code[20];ProdBOMHeaderNo@1001 : Code[20];VersionNo@1002 : Code[20]);
    VAR
      ProductionBOMLine@1003 : Record 99000772;
    BEGIN
      ProductionBOMLine.INIT;
      ProductionBOMLine."Production BOM No." := ProdBOMHeaderNo;
      ProductionBOMLine."Version Code" := VersionNo;
      ProductionBOMLine.Type := ProductionBOMLine.Type::Item;
      ProductionBOMLine."No." := ItemNo;
      ProductionBOMLine.INSERT;
    END;

    LOCAL PROCEDURE ModifyCapacityOfMachineCenter@69(MachineCenterNo@1000 : Code[20]) : Decimal;
    VAR
      MachineCenter@1001 : Record 99000758;
    BEGIN
      MachineCenter.GET(MachineCenterNo);
      MachineCenter.VALIDATE(Capacity,LibraryRandom.RandDec(10,2));  // Taking Random value for Capacity.
      MachineCenter.MODIFY(TRUE);
      EXIT(MachineCenter.Capacity);
    END;

    LOCAL PROCEDURE ModifyCapacityOfWorkCenter@107(VAR WorkCenter@1000 : Record 99000754);
    BEGIN
      WorkCenter.VALIDATE(Capacity,LibraryRandom.RandDec(10,2));  // Taking Random value for Capacity.
      WorkCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ModifyStatusInProductionBOM@104(VAR ProductionBOMHeader@1000 : Record 99000771;Status@1001 : Option);
    BEGIN
      ProductionBOMHeader.VALIDATE(Status,Status);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ModifyProductionBOMVersionStatus@214(VAR ProdBomVersion@1000 : Record 99000779;Status@1001 : Option);
    BEGIN
      ProdBomVersion.VALIDATE(Status,Status);
      ProdBomVersion.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ModifyWorkCenterAndCalculateCalendar@80(VAR WorkCenter@1001 : Record 99000754;AbsenceCapacity@1002 : Decimal);
    BEGIN
      WorkCenter.VALIDATE(Capacity,AbsenceCapacity + LibraryRandom.RandDec(10,2));  // Adding Random value to Absence Capacity as Work Center Capacity should be greater than it.
      WorkCenter.MODIFY(TRUE);
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,WORKDATE,WORKDATE);
    END;

    LOCAL PROCEDURE ModifyRoutingStatus@205(VAR RoutingHeader@1000 : Record 99000763;Status@1001 : Option);
    BEGIN
      RoutingHeader.VALIDATE(Status,Status);
      RoutingHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ModifyWorkCenterAndWaitTimeOnRoutingLine@142(VAR RoutingLine@1000 : Record 99000764;WorkCenterNo@1005 : Code[20];CapacityUomCode@1002 : Code[10];WaitTime@1004 : Integer);
    VAR
      RoutingHeader@1001 : Record 99000763;
    BEGIN
      RoutingHeader.GET(RoutingLine."Routing No.");
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::"Under Development");
      RoutingHeader.MODIFY(TRUE);

      RoutingLine.VALIDATE("No.",WorkCenterNo);
      RoutingLine.VALIDATE("Wait Time",WaitTime);
      RoutingLine.VALIDATE("Wait Time Unit of Meas. Code",CapacityUomCode);
      RoutingLine.MODIFY(TRUE);

      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ModifyWorkCenterAndRunTimeOnRoutingLine@146(VAR RoutingLine@1000 : Record 99000764;WorkCenterNo@1005 : Code[20];CapacityUomCode@1002 : Code[10];RunTime@1004 : Integer);
    VAR
      RoutingHeader@1001 : Record 99000763;
    BEGIN
      RoutingHeader.GET(RoutingLine."Routing No.");
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::"Under Development");

      WITH RoutingLine DO BEGIN
        VALIDATE("No.",WorkCenterNo);
        VALIDATE("Run Time",RunTime);
        VALIDATE("Run Time Unit of Meas. Code",CapacityUomCode);
        MODIFY(TRUE);
      END;

      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::Certified);
    END;

    LOCAL PROCEDURE ModifySetupTimeOnRoutingLine@172(VAR RoutingLine@1000 : Record 99000764;SetupTime@1004 : Decimal);
    VAR
      RoutingHeader@1001 : Record 99000763;
    BEGIN
      RoutingHeader.GET(RoutingLine."Routing No.");
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::"Under Development");
      RoutingLine.VALIDATE("Setup Time",SetupTime);
      RoutingLine.MODIFY(TRUE);
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::Certified);
    END;

    LOCAL PROCEDURE ModifyWaitTimeOnRoutingLine@170(VAR RoutingLine@1000 : Record 99000764;WaitTime@1004 : Decimal);
    VAR
      RoutingHeader@1001 : Record 99000763;
    BEGIN
      RoutingHeader.GET(RoutingLine."Routing No.");
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::"Under Development");
      RoutingLine.VALIDATE("Wait Time",WaitTime);
      RoutingLine.MODIFY(TRUE);
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::Certified);
    END;

    LOCAL PROCEDURE ModifyRunTimeOnRoutingLine@169(VAR RoutingLine@1000 : Record 99000764;RunTime@1004 : Decimal);
    VAR
      RoutingHeader@1001 : Record 99000763;
    BEGIN
      RoutingHeader.GET(RoutingLine."Routing No.");
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::"Under Development");
      RoutingLine.VALIDATE("Run Time",RunTime);
      RoutingLine.MODIFY(TRUE);
      ModifyRoutingStatus(RoutingHeader,RoutingHeader.Status::Certified);
    END;

    LOCAL PROCEDURE ModifyStartingDateOnProdOrderRtngLn@173(VAR ProdOrderRoutingLine@1002 : Record 5409;Date@1000 : Date);
    BEGIN
      ProdOrderRoutingLine.VALIDATE("Starting Date",Date);
      ProdOrderRoutingLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ModifyEndingDateOnProdOrderRtngLn@182(VAR ProdOrderRoutingLine@1002 : Record 5409;Date@1000 : Date);
    BEGIN
      ProdOrderRoutingLine.VALIDATE("Ending Date",Date);
      ProdOrderRoutingLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ModifyStartingDateOnPlanningRtngLn@171(VAR PlanningRoutingLine@1002 : Record 99000830;Date@1000 : Date);
    BEGIN
      PlanningRoutingLine.VALIDATE("Starting Date",Date);
      PlanningRoutingLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE ModifyEndingDateOnPlanningRtngLn@184(VAR PlanningRoutingLine@1002 : Record 99000830;Date@1000 : Date);
    BEGIN
      PlanningRoutingLine.VALIDATE("Ending Date",Date);
      PlanningRoutingLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE OutputJournalExplodeRouting@1106(VAR ItemJournalBatch@1022 : Record 233;ProductionOrder@1000 : Record 5405);
    VAR
      ItemJournalLine@1001 : Record 83;
    BEGIN
      CreateOutputJournal(ItemJournalBatch,ItemJournalLine,ProductionOrder."No.");
      LibraryInventory.OutputJnlExplRoute(ItemJournalLine);
    END;

    LOCAL PROCEDURE OpenProductionForecast@207(ProductionForecast@1000 : TestPage 99000919;ProductionForecastName@1001 : Code[10];LocationCode@1002 : Code[10];ForecastTypeOption@1003 : Option);
    BEGIN
      WITH ProductionForecast DO BEGIN
        OPENEDIT;
        ProductionForecastName.SETVALUE(ProductionForecastName);
        LocationFilter.SETVALUE(LocationCode);
        ForecastType.SETVALUE(ForecastTypeOption);
      END;
    END;

    LOCAL PROCEDURE PopulateRoutingOnOutputJournalLine@238(VAR ItemJournalLine@1000 : Record 83;VAR ProdOrderRoutingLine@1001 : Record 5409;ProdOrderLine@1002 : Record 5406);
    BEGIN
      FindFirstProdOrderRoutingLine(ProdOrderRoutingLine,ProdOrderLine.Status,ProdOrderLine."Prod. Order No.");
      WITH ItemJournalLine DO BEGIN
        VALIDATE("Routing No.",ProdOrderRoutingLine."Routing No.");
        VALIDATE("Routing Reference No.",ProdOrderRoutingLine."Routing Reference No.");
        VALIDATE("Item No.",ProdOrderLine."Item No.");
        VALIDATE("Operation No.",ProdOrderRoutingLine."Operation No.");
        VALIDATE(Type,ProdOrderRoutingLine.Type);
      END;
    END;

    LOCAL PROCEDURE ProdOrderCapacityNeedExist@163(ItemNo@1000 : Code[20];CapacityDate@1001 : Date;StartingTime@1002 : Time;AllocatedTime@1003 : Decimal) : Boolean;
    VAR
      ProdOrderCapacityNeed@1004 : Record 5410;
    BEGIN
      WITH ProdOrderCapacityNeed DO BEGIN
        SETRANGE("No.",ItemNo);
        SETRANGE(Date,CapacityDate);
        SETRANGE("Starting Time",StartingTime);
        SETRANGE("Allocated Time",AllocatedTime);
        EXIT(NOT ISEMPTY);
      END;
    END;

    LOCAL PROCEDURE ResetRunTimeOnRoutingLine@227(RoutingNo@1002 : Code[20];WorkCenterNo@1000 : Code[20]);
    VAR
      RoutingLine@1001 : Record 99000764;
    BEGIN
      WITH RoutingLine DO BEGIN
        SETRANGE("Routing No.",RoutingNo);
        SETRANGE("Work Center No.",WorkCenterNo);
        FINDFIRST;
        "Run Time" := 0;
        MODIFY;
      END;
    END;

    LOCAL PROCEDURE ReserveComponentForProdOrder@253(ProdOrderStatus@1002 : Option;ProdOrderNo@1003 : Code[20]);
    VAR
      ProdOrderComponent@1000 : Record 5407;
      Reservation@1001 : Page 498;
    BEGIN
      FindProdOrderComponent(ProdOrderComponent,ProdOrderStatus,ProdOrderNo);
      Reservation.SetProdOrderComponent(ProdOrderComponent);
      Reservation.RUNMODAL;
    END;

    LOCAL PROCEDURE RestoreManufacturingSetup@64(DocNoIsProdOrderNo@1001 : Boolean);
    VAR
      ManufacturingSetup@1000 : Record 99000765;
    BEGIN
      ManufacturingSetup.GET;
      ManufacturingSetup.VALIDATE("Doc. No. Is Prod. Order No.",DocNoIsProdOrderNo);
      ManufacturingSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE RunCopyProductionDocument@28(ProductionOrder@1001 : Record 5405);
    VAR
      CopyProductionOrderDocument@1000 : Report 99003802;
    BEGIN
      CLEAR(CopyProductionOrderDocument);
      CopyProductionOrderDocument.SetProdOrder(ProductionOrder);
      CopyProductionOrderDocument.RUN;
    END;

    LOCAL PROCEDURE RunCopyProductionForecast@99(VAR ProductionForecastEntry@1001 : Record 99000852);
    VAR
      CopyProductionForecast@1000 : Report 99003803;
    BEGIN
      COMMIT;  // Commit required for batch job report.
      CLEAR(CopyProductionForecast);
      CopyProductionForecast.SETTABLEVIEW(ProductionForecastEntry);
      CopyProductionForecast.RUN;
    END;

    LOCAL PROCEDURE RunDeleteExpiredComponentsReport@111(VAR ProductionBOMHeader@1001 : Record 99000771);
    VAR
      DeleteExpiredComponents@1000 : Report 99001041;
    BEGIN
      COMMIT;  // Commit required for batch job.
      CLEAR(DeleteExpiredComponents);
      DeleteExpiredComponents.SETTABLEVIEW(ProductionBOMHeader);
      DeleteExpiredComponents.RUN;
    END;

    LOCAL PROCEDURE RunExchangeProductionBOMItemReport@105();
    VAR
      ExchangeProductionBOMItem@1000 : Report 99001043;
    BEGIN
      CLEAR(ExchangeProductionBOMItem);
      COMMIT;  // Commit required for batch job report.
      ExchangeProductionBOMItem.RUN;
    END;

    LOCAL PROCEDURE RunExchangeProdBOMItemReportWithParameters@261(ItemToExchangeNo@1000 : Code[20];NewItemNo@1001 : Code[20];CreateVersion@1002 : Boolean);
    BEGIN
      ExchangeNo := ItemToExchangeNo;
      WithNo := NewItemNo;
      CreateNewVersion := CreateVersion;
      RunExchangeProductionBOMItemReport;
    END;

    LOCAL PROCEDURE RunImplementRegisteredAbsenceReport@29(RegisteredAbsence@1001 : Record 99000848);
    VAR
      ImplementRegisteredAbsence@1000 : Report 99003801;
    BEGIN
      COMMIT;  // Commit is required to run the Report.
      RegisteredAbsence.SETRANGE("No.",RegisteredAbsence."No.");
      CLEAR(ImplementRegisteredAbsence);
      ImplementRegisteredAbsence.SETTABLEVIEW(RegisteredAbsence);
      ImplementRegisteredAbsence.RUN;
    END;

    LOCAL PROCEDURE RunRecalculateCalendarReport@65(VAR CalendarEntry@1002 : Record 99000757);
    VAR
      RecalculateCalendar@1000 : Report 99001047;
    BEGIN
      CLEAR(RecalculateCalendar);
      COMMIT;  // COMMIT is required to run the Report.
      RecalculateCalendar.SETTABLEVIEW(CalendarEntry);
      RecalculateCalendar.RUN;
    END;

    LOCAL PROCEDURE RunRegAbsFromMachineCenterReport@56(MachineCenterNo@1002 : Code[20]);
    VAR
      MachineCenter@1000 : Record 99000758;
      RegAbsFromMachineCtr@1001 : Report 99003800;
    BEGIN
      MachineCenter.SETRANGE("No.",MachineCenterNo);
      CLEAR(RegAbsFromMachineCtr);
      RegAbsFromMachineCtr.SETTABLEVIEW(MachineCenter);
      COMMIT;  // COMMIT is required to run the Report.
      RegAbsFromMachineCtr.RUN;
    END;

    LOCAL PROCEDURE RunRegAbsFromWorkCenterReport@59(WorkCenterNo@1002 : Code[20]);
    VAR
      WorkCenter@1001 : Record 99000754;
      RegAbsFromWorkCenter@1000 : Report 99003805;
    BEGIN
      WorkCenter.SETRANGE("No.",WorkCenterNo);
      CLEAR(RegAbsFromWorkCenter);
      RegAbsFromWorkCenter.SETTABLEVIEW(WorkCenter);
      COMMIT;  // COMMIT is required to run the Report.
      RegAbsFromWorkCenter.RUN;
    END;

    LOCAL PROCEDURE SelectItemJournalBatch@37(VAR ItemJournalBatch@1000 : Record 233;ItemJournalTemplateType@1002 : Option);
    VAR
      ItemJournalTemplate@1001 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplateType);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplateType,ItemJournalTemplate.Name);
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
    END;

    LOCAL PROCEDURE SetItemAndComponentQuantity@7(VAR ItemQuantity@1000 : Decimal;VAR ComponentQuantity@1001 : Decimal);
    BEGIN
      // Use random values for Item and Component Quantity.
      ItemQuantity := LibraryRandom.RandDec(100,2);
      ComponentQuantity := LibraryRandom.RandDec(100,2);
    END;

    LOCAL PROCEDURE SetItemTrackingCodeSerialSpecific@121(ItemNo@1001 : Code[20]);
    VAR
      Item@1000 : Record 27;
      ItemTrackingCode@1002 : Record 6502;
    BEGIN
      LibraryItemTracking.CreateItemTrackingCode(ItemTrackingCode,TRUE,FALSE);

      Item.GET(ItemNo);
      Item.VALIDATE("Item Tracking Code",ItemTrackingCode.Code);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE SetGlobalDimsOnProdOrderLine@232(VAR DimensionSetID@1000 : Integer;VAR DimensionValue@1001 : ARRAY [2] OF Record 349);
    BEGIN
      DimensionSetID :=
        LibraryDimension.CreateDimSet(DimensionSetID,DimensionValue[1]."Dimension Code",DimensionValue[1].Code);
      DimensionSetID :=
        LibraryDimension.CreateDimSet(DimensionSetID,DimensionValue[2]."Dimension Code",DimensionValue[2].Code);
    END;

    LOCAL PROCEDURE SetupProdOrdWithRtng@140(VAR ProdOrd@1000 : Record 5405;ItemNo@1001 : Code[20]);
    VAR
      RlsdProdOrd@1002 : TestPage 99000831;
    BEGIN
      LibraryManufacturing.CreateProductionOrder(
        ProdOrd,ProdOrd.Status::Released,ProdOrd."Source Type"::Item,ItemNo,
        LibraryRandom.RandDec(10,2));  // Taking Random Quantity.
      RlsdProdOrd.OPENEDIT;
      RlsdProdOrd.FILTER.SETFILTER("No.",ProdOrd."No.");

      // Create Released Prod. Order Lines
      WITH RlsdProdOrd.ProdOrderLines DO BEGIN
        "Item No.".SETVALUE(ItemNo);
        Quantity.SETVALUE(ProdOrd.Quantity / 2);
        NEXT;
        "Item No.".SETVALUE(ItemNo);
        Quantity.SETVALUE(ProdOrd.Quantity / 2);
      END;

      LibraryManufacturing.RefreshProdOrder(ProdOrd,FALSE,FALSE,TRUE,FALSE,FALSE); // Select Calculating Lines when Refreshing Order
    END;

    LOCAL PROCEDURE SetupProdOrdLnWithPostedOutput@148(VAR ProdOrdLn@1000 : Record 5406);
    VAR
      Item@1006 : Record 27;
      ProdOrd@1005 : Record 5405;
      ProdJnlMgt@1003 : Codeunit 5510;
    BEGIN
      Item.GET(CreateItemWithRoutingAndProductionBOM);

      // Create a released Prod. Order, create 2 Prod. Order lines, calculate routings
      SetupProdOrdWithRtng(ProdOrd,Item."No.");

      // Find the first Prod. Order Line
      FindProductionOrderLine(ProdOrdLn,ProdOrd.Status,ProdOrd."No.",Item."No.");

      // Open and post Production Journal. Posting is done in ProductionJournalHandler function.
      ProdJnlMgt.Handling(ProdOrd,ProdOrdLn."Line No.");
    END;

    LOCAL PROCEDURE SetupForCalculateWaitingTimeWithMultipleCalendars@157(VAR Item@1001 : Record 27;VAR WorkCenter@1002 : Record 99000754;WaitTime@1004 : Integer) : Date;
    VAR
      ShopCalendarWorkingDays@1009 : Record 99000752;
      AllDaysWorkingWorkCenter@1000 : Record 99000754;
      RoutingHeader@1008 : Record 99000763;
      RoutingLine@1007 : Record 99000764;
      RoutingLine2@1006 : Record 99000764;
      CapacityUnitOfMeasure@1005 : Record 99000780;
      MfgSetup@1012 : Record 99000765;
      StartingDate@1011 : Date;
    BEGIN
      // Create Work Center with all days working Calender
      CreateWorkCenterWithCalendarCode(AllDaysWorkingWorkCenter,CreateShopCalendarCodeWithAllDaysWorking(ShopCalendarWorkingDays));

      // Create Work Center with Monday ~ Friday working Calender
      // The Ending Time of the Monday ~ Friday working Calendar cannot equal that of the Calender with all days working (4:00PM),
      // otherwise the issue mentioned in TFS48588 can not be reproed. It is not easy to set proper random value
      // for starting time and ending time, so use 11:00PM as ending time, and 8:00AM as starting time
      CreateWorkCenterWithCalendarCode(WorkCenter,CreateShopCalendar(080000T,230000T));
      StartingDate := CALCDATE('<WD6>',WORKDATE); // Get a Weekend Date, this will be the starting date for the routing line with weekend work day calendar
      LibraryManufacturing.CalculateWorkCenterCalendar(
        AllDaysWorkingWorkCenter,CALCDATE('<-1M>',StartingDate),CALCDATE('<+1M>',StartingDate)); // Calculate working days needed by the test
      LibraryManufacturing.CalculateWorkCenterCalendar(
        WorkCenter,CALCDATE('<-1M>',StartingDate),CALCDATE('<1M>',StartingDate)); // Calculate working days needed by the test

      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,CapacityUnitOfMeasure.Type::Days); // Create Unit Of Measure (Days) for Wait Time on routing line

      // Create Routing with 2 routing lines
      RoutingHeader.GET(CreateRouting);
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::"Under Development");
      RoutingHeader.MODIFY(TRUE);
      LibraryManufacturing.CreateRoutingLine(
        RoutingHeader,RoutingLine,'',FORMAT(LibraryRandom.RandInt(100)),RoutingLine.Type::"Work Center",WorkCenter."No.");
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);

      // Set Monday ~ Friday working calendar to the first routing line, set all days working calendar to the second routing line
      // Set wait time for both lines
      RoutingLine2.SETRANGE("Routing No.",RoutingHeader."No.");
      RoutingLine2.FINDSET;
      ModifyWorkCenterAndWaitTimeOnRoutingLine(RoutingLine2,WorkCenter."No.",CapacityUnitOfMeasure.Code,WaitTime);
      RoutingLine2.NEXT;
      ModifyWorkCenterAndWaitTimeOnRoutingLine(RoutingLine2,AllDaysWorkingWorkCenter."No.",CapacityUnitOfMeasure.Code,WaitTime);

      // Create Production Item
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Routing No.",RoutingHeader."No.");
      Item.MODIFY(TRUE);

      // Calculate the due date of prod. order, since the ending date - starting date = WaitTime + 1 for the last routing line,
      // the ending date of the last routing line + Default Safety Lead Time = the prod. order due date
      // so use below formula to calculate prod. due date
      MfgSetup.GET;
      EXIT(CALCDATE(MfgSetup."Default Safety Lead Time",CALCDATE('<+' + FORMAT(WaitTime + 1) + 'D>',StartingDate)));
    END;

    LOCAL PROCEDURE SetupWaitTimeOnProdOrderRtngLnWithoutCapactityConstrained@183(VAR RoutingLine@1000 : Record 99000764;VAR RoutingLine2@1001 : Record 99000764);
    VAR
      Item@1004 : Record 27;
      ProductionOrder@1006 : Record 5405;
    BEGIN
      CreateProductionItemWithMultipleRoutingLines(RoutingLine,RoutingLine2,Item);
      ModifyRunTimeOnRoutingLine(RoutingLine,0); // Set run time to 0 for the convenience of calculating the ending datetime of the routing line with a random Quantity of items to produce
      ModifyWaitTimeOnRoutingLine(RoutingLine,LibraryRandom.RandIntInRange(24 * 60,48 * 60)); // Set wait time to 1 ~ 2 days
      CreateAndRefreshProdOrderWithSpecificItem(ProductionOrder,Item."No.",FALSE); // Create and Refresh Released Production Order
    END;

    LOCAL PROCEDURE SetupWaitTimeOnPlanningRtngLnWithoutCapactityConstrained@192(VAR RoutingLine@1000 : Record 99000764;VAR RoutingLine2@1001 : Record 99000764);
    VAR
      Item@1004 : Record 27;
    BEGIN
      CreateProductionItemWithMultipleRoutingLines(RoutingLine,RoutingLine2,Item);
      ModifyRunTimeOnRoutingLine(RoutingLine,0); // Set run time to 0 for the convenience of calculating the ending datetime of the routing line with a random Quantity of items to produce
      ModifyWaitTimeOnRoutingLine(RoutingLine,LibraryRandom.RandIntInRange(24 * 60,48 * 60)); // Set wait time to 1 ~ 2 days
      CreateSalesOrderAndCalculateOrderPlan(Item,Item."Replenishment System"::"Prod. Order");
    END;

    LOCAL PROCEDURE SetupWaitTimeOnProdOrderRtngLnForBackwardCalculation@191(VAR RoutingLine@1000 : Record 99000764;VAR RoutingLine2@1001 : Record 99000764);
    VAR
      Item@1004 : Record 27;
      ProductionOrder@1006 : Record 5405;
    BEGIN
      CreateProductionItemWithMultipleRoutingLines(RoutingLine,RoutingLine2,Item);
      ModifyRunTimeOnRoutingLine(RoutingLine2,0); // Set run time to 0 for the convenience of calculating the starting datetime of the routing line with a random Quantity of items to produce
      ModifyWaitTimeOnRoutingLine(RoutingLine2,LibraryRandom.RandIntInRange(24 * 60,48 * 60)); // Set wait time to 1 ~ 2 days
      CreateAndRefreshProdOrderWithSpecificItem(ProductionOrder,Item."No.",FALSE); // Create and Refresh Released Production Order
    END;

    LOCAL PROCEDURE SetupWaitTimeOnPlanningRtngLnForBackwardCalculation@189(VAR RoutingLine@1000 : Record 99000764;VAR RoutingLine2@1001 : Record 99000764);
    VAR
      Item@1004 : Record 27;
    BEGIN
      CreateProductionItemWithMultipleRoutingLines(RoutingLine,RoutingLine2,Item);
      ModifyRunTimeOnRoutingLine(RoutingLine2,0); // Set run time to 0 for the convenience of calculating the starting datetime of the routing line with a random Quantity of items to produce
      ModifyWaitTimeOnRoutingLine(RoutingLine2,LibraryRandom.RandIntInRange(24 * 60,48 * 60)); // Set wait time to 1 ~ 2 days
      CreateSalesOrderAndCalculateOrderPlan(Item,Item."Replenishment System"::"Prod. Order");
    END;

    LOCAL PROCEDURE TransferItem@254(ItemNo@1001 : Code[20];Qty@1002 : Decimal;FromLocationCode@1003 : Code[10];ToLocationCode@1004 : Code[10]);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      WITH ItemJournalLine DO BEGIN
        CreateItemReclassJournalLine(ItemJournalLine,ItemNo,Qty);
        VALIDATE("Entry Type","Entry Type"::Transfer);
        VALIDATE("Location Code",FromLocationCode);
        VALIDATE("New Location Code",ToLocationCode);
        MODIFY(TRUE);
        LibraryInventory.PostItemJournalLine("Journal Template Name","Journal Batch Name");
      END;
    END;

    LOCAL PROCEDURE UpdateInventorySetup@1024(ExpectedCostPostingtoGL@1000 : Boolean;AutomaticCostPosting@1026 : Boolean);
    VAR
      InventorySetup@1001 : Record 313;
    BEGIN
      InventorySetup.GET;
      InventorySetup.VALIDATE("Expected Cost Posting to G/L",ExpectedCostPostingtoGL);
      InventorySetup.VALIDATE("Automatic Cost Posting",AutomaticCostPosting);
      InventorySetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateManufacturingSetup@49(NewDocNoIsProdOrderNo@1001 : Boolean) OldDocNoIsProdOrderNo : Boolean;
    VAR
      ManufacturingSetup@1000 : Record 99000765;
    BEGIN
      ManufacturingSetup.GET;
      OldDocNoIsProdOrderNo := ManufacturingSetup."Doc. No. Is Prod. Order No.";
      RestoreManufacturingSetup(NewDocNoIsProdOrderNo);
    END;

    LOCAL PROCEDURE UpdateProductionOrderComponent@20(ProductionOrderNo@1002 : Code[20];ItemNo@1003 : Code[20]);
    VAR
      ProdOrderComponent@1001 : Record 5407;
      RoutingLink@1000 : Record 99000777;
    BEGIN
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderComponent.SETRANGE("Item No.",ItemNo);
      ProdOrderComponent.FINDFIRST;
      RoutingLink.FINDFIRST;
      ProdOrderComponent.VALIDATE("Flushing Method",ProdOrderComponent."Flushing Method"::Backward);
      ProdOrderComponent.VALIDATE("Routing Link Code",RoutingLink.Code);
      ProdOrderComponent.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateSalesReceivableSetup@48(VAR OldCreditWarnings@1004 : Option;VAR OldStockoutWarning@1003 : Boolean;NewCreditWarnings@1001 : Option;NewStockoutWarning@1002 : Boolean);
    VAR
      SalesReceivablesSetup@1000 : Record 311;
    BEGIN
      SalesReceivablesSetup.GET;
      OldCreditWarnings := SalesReceivablesSetup."Credit Warnings";
      OldStockoutWarning := SalesReceivablesSetup."Stockout Warning";
      SalesReceivablesSetup.VALIDATE("Credit Warnings",NewCreditWarnings);
      SalesReceivablesSetup.VALIDATE("Stockout Warning",NewStockoutWarning);
      SalesReceivablesSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateProductionBOMOnParentItem@131(VAR Item@1000 : Record 27;ItemNo@1001 : Code[20];ItemNo2@1002 : Code[20]);
    BEGIN
      Item.VALIDATE(
        "Production BOM No.",
        CreateMultipleProductionBOMLines(ItemNo,ItemNo2,Item."Base Unit of Measure",LibraryRandom.RandDec(10,2)));
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateProdOrderLineLocationCode@199(VAR ProdOrderLine@1000 : Record 5406;LocationCode@1001 : Code[10]);
    BEGIN
      ProdOrderLine.VALIDATE("Location Code",LocationCode);
      ProdOrderLine.MODIFY;
    END;

    LOCAL PROCEDURE UpdateWorkCenterLocationCodeAndFromProdBinCode@196(VAR WorkCenter@1001 : Record 99000754;WorkCenterNo@1000 : Code[20];LocationCode@1002 : Code[10];BinCode@1003 : Code[20]);
    BEGIN
      WorkCenter.GET(WorkCenterNo);
      WorkCenter.VALIDATE("Location Code",LocationCode);
      WorkCenter.VALIDATE("From-Production Bin Code",BinCode);
      WorkCenter.MODIFY;
    END;

    LOCAL PROCEDURE VerifyCalculatedCapacity@81();
    VAR
      WorkCenter@1004 : Record 99000754;
      ShopCalendarWorkingDays@1001 : Record 99000752;
      WorkCenterCalendar@1000 : TestPage 99000769;
    BEGIN
      WorkCenter.GET(WorkCenterNo2);
      ShopCalendarWorkingDays.SETRANGE("Shop Calendar Code",WorkCenter."Shop Calendar Code");
      ShopCalendarWorkingDays.SETRANGE(Day,DATE2DWY(WORKDATE,1) - 1);  // Indexing for Days start from 0-6.
      IF ShopCalendarWorkingDays.FINDFIRST THEN
        Capacity2 :=
          (ShopCalendarWorkingDays."Ending Time" - ShopCalendarWorkingDays."Starting Time") /
          CalendarManagement.TimeFactor(WorkCenter."Unit of Measure Code"); // Use Capacity2 as global for Handler.
      WorkCenterCalendar.OPENEDIT;
      WorkCenterCalendar.ShowMatrix.INVOKE;
    END;

    LOCAL PROCEDURE VerifyCalendarAbsenceEntry@30(WorkCenterNo@1002 : Code[20];RegisteredAbsence@1001 : Record 99000848);
    VAR
      CalendarAbsenceEntry@1000 : Record 99000760;
    BEGIN
      CalendarAbsenceEntry.SETFILTER("Work Center No.",WorkCenterNo);
      CalendarAbsenceEntry.FINDFIRST;
      CalendarAbsenceEntry.TESTFIELD(Date,RegisteredAbsence.Date);
      CalendarAbsenceEntry.TESTFIELD(Capacity,RegisteredAbsence.Capacity);
      CalendarAbsenceEntry.TESTFIELD("Starting Time",RegisteredAbsence."Starting Time");
      CalendarAbsenceEntry.TESTFIELD("Ending Time",RegisteredAbsence."Ending Time");
    END;

    LOCAL PROCEDURE VerifyCalendarEntry@71(WorkCenterNo@1000 : Code[20];CapacityTotal@1001 : Decimal);
    VAR
      CalendarEntry@1002 : Record 99000757;
    BEGIN
      GetCalendarEntry(CalendarEntry,CalendarEntry."Capacity Type"::"Work Center",WorkCenterNo);
      CalendarEntry.TESTFIELD("Capacity (Total)",CapacityTotal);
    END;

    LOCAL PROCEDURE VerifyCapacityLedgerEntry@89(WorkCenterNo@1002 : Code[20];Quantity@1003 : Decimal);
    VAR
      CapacityLedgerEntry@1000 : Record 5832;
    BEGIN
      CapacityLedgerEntry.SETRANGE("No.",WorkCenterNo);
      CapacityLedgerEntry.FINDFIRST;
      CapacityLedgerEntry.TESTFIELD(Quantity,Quantity);
    END;

    LOCAL PROCEDURE VerifyComponentNotOnInventoryError@255(ProdOrderStatus@1000 : Option;ProdOrderNo@1001 : Code[20]);
    VAR
      ProdOrderComponent@1002 : Record 5407;
    BEGIN
      FindProdOrderComponent(ProdOrderComponent,ProdOrderStatus,ProdOrderNo);
      Assert.ExpectedError(STRSUBSTNO(IsNotOnInventoryErr,ProdOrderComponent."Item No."));
    END;

    LOCAL PROCEDURE VerifyComponentOnItemReclassJournal@36(ComponentNo@1000 : Code[20];Quantity@1002 : Decimal);
    VAR
      ItemJournalLine@1001 : Record 83;
    BEGIN
      ItemJournalLine.SETRANGE("Item No.",ComponentNo);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.TESTFIELD(Quantity,Quantity);
    END;

    LOCAL PROCEDURE VerifyGlobalDimensionCodesInItemJournalBatch@224(ItemJournalBatch@1000 : Record 233;ShortcutDimension1Code@1001 : Code[20];ShortcutDimension2Code@1002 : Code[20]);
    VAR
      ItemJournalLine@1003 : Record 83;
    BEGIN
      WITH ItemJournalLine DO BEGIN
        SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
        SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
        FINDSET;
        REPEAT
          TESTFIELD("Shortcut Dimension 1 Code",ShortcutDimension1Code);
          TESTFIELD("Shortcut Dimension 2 Code",ShortcutDimension2Code);
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE VerifyItemJournalLine@1027(ItemJournalBatch@1102 : Record 233;ProductionOrderNo@1029 : Code[20];ItemNo@1030 : Code[20];Quantity@1031 : Decimal);
    VAR
      ItemJournalLine@1032 : Record 83;
    BEGIN
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.TESTFIELD("Document No.",ProductionOrderNo);
      ItemJournalLine.TESTFIELD("Item No.",ItemNo);
      ItemJournalLine.TESTFIELD(Quantity,Quantity);
    END;

    LOCAL PROCEDURE VerifyEntryInRegisteredAbsence@74(No@1002 : Code[20];Date@1003 : Date;Capacity@1001 : Decimal);
    VAR
      RegisteredAbsence@1000 : Record 99000848;
    BEGIN
      RegisteredAbsence.SETRANGE("No.",No);
      RegisteredAbsence.SETRANGE(Date,Date);
      RegisteredAbsence.FINDFIRST;
      RegisteredAbsence.TESTFIELD(Capacity,Capacity);
    END;

    LOCAL PROCEDURE VerifyGLEntry@11(InventoryPostingGroupCode@1103 : Code[20];ProductionOrderNo@1000 : Code[20]);
    VAR
      GLEntry@1033 : Record 17;
      InventoryPostingSetup@1035 : Record 5813;
    BEGIN
      InventoryPostingSetup.SETRANGE("Invt. Posting Group Code",InventoryPostingGroupCode);
      InventoryPostingSetup.FINDFIRST;
      GLEntry.SETRANGE("Document No.",ProductionOrderNo);
      GLEntry.FINDFIRST;
      GLEntry.TESTFIELD("G/L Account No.",InventoryPostingSetup."Inventory Account (Interim)");
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntry@51(ItemNo@1001 : Code[20];EntryType@1000 : Option;Quantity@1002 : Decimal);
    VAR
      ItemLedgerEntry@1003 : Record 32;
    BEGIN
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.SETRANGE("Entry Type",EntryType);
      ItemLedgerEntry.FINDFIRST;
      ItemLedgerEntry.TESTFIELD(Quantity,Quantity);
    END;

    LOCAL PROCEDURE VerifyProdOrderLinesIncreaseAfterCopy@38(ProductionOrder@1002 : Record 5405;NoOfRowsBeforeCopy@1001 : Integer);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      Assert.IsTrue(ProdOrderLine.COUNT > NoOfRowsBeforeCopy,CopyDocumentError);
    END;

    LOCAL PROCEDURE VerifyProductionForecastEntry@92(ProductionForecastEntry@1000 : Record 99000852);
    VAR
      ProductionForecastEntry2@1001 : Record 99000852;
    BEGIN
      ProductionForecastEntry2.SETRANGE("Production Forecast Name",ProductionForecastName2);
      ProductionForecastEntry2.FINDFIRST;
      ProductionForecastEntry2.TESTFIELD("Item No.",ProductionForecastEntry."Item No.");
      ProductionForecastEntry2.TESTFIELD("Forecast Date",CALCDATE(DateChangeFormula,WORKDATE));
      ProductionForecastEntry2.TESTFIELD("Forecast Quantity",ProductionForecastEntry."Forecast Quantity");
      ProductionForecastEntry2.TESTFIELD("Location Code" ,ProductionForecastEntry."Location Code");
      ProductionForecastEntry2.TESTFIELD("Component Forecast",ProductionForecastEntry."Component Forecast");
    END;

    LOCAL PROCEDURE VerifyProductionForecastName@98();
    VAR
      ProductionForecastName@1000 : Record 99000851;
    BEGIN
      ProductionForecastName.GET('');
      ProductionForecastName.TESTFIELD(Description,'');
    END;

    LOCAL PROCEDURE VerifyProductionOrderStatistics@83();
    VAR
      ProdOrderLine@1000 : Record 5406;
      ReleasedProductionOrders@1002 : TestPage 9326;
      ProductionOrderStatistics@1003 : TestPage 99000816;
    BEGIN
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderLine.FINDFIRST;
      ReleasedProductionOrders.OPENVIEW;
      ReleasedProductionOrders.FILTER.SETFILTER("No.",ProductionOrderNo);
      ProductionOrderStatistics.TRAP;
      ReleasedProductionOrders."Page Production Order Statistics".INVOKE;
      ProductionOrderStatistics.ExpCapNeed.ASSERTEQUALS(
        (ProdOrderLine."Ending Date-Time" - ProdOrderLine."Starting Date-Time") /
        CalendarManagement.TimeFactor(FORMAT(ProductionOrderStatistics.CapacityUoM)));
    END;

    LOCAL PROCEDURE VerifyProdOrderLineBinCode@204(VAR ProdOrderLine@1000 : Record 5406;WorkCenterBinCode@1001 : Code[20]);
    BEGIN
      ProdOrderLine.FIND;
      Assert.AreEqual(WorkCenterBinCode,ProdOrderLine."Bin Code",ProdOrderLineBinCodeErr);
    END;

    LOCAL PROCEDURE VerifyProdOrderLinesCount@288(ItemNo@1001 : Code[20];LocationCode@1002 : Code[10];VariantCode@1003 : Code[10];ExpectedCount@1004 : Integer);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      ProdOrderLine.SETRANGE("Item No.",ItemNo);
      ProdOrderLine.SETRANGE("Location Code",LocationCode);
      ProdOrderLine.SETRANGE("Variant Code",VariantCode);
      Assert.AreEqual(ExpectedCount,ProdOrderLine.COUNT,WrongProdOrderLinesCountErr);
    END;

    LOCAL PROCEDURE VerifyILEs@128(VAR ItemLedgerEntry@1000 : Record 32;ItemNo@1004 : Code[20];Quantity@1003 : Integer;AppliesToEntryFilter@1002 : Text[100];Count@1001 : Integer);
    BEGIN
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.SETFILTER("Applies-to Entry",AppliesToEntryFilter);
      ItemLedgerEntry.SETRANGE(Quantity,Quantity);
      ItemLedgerEntry.FINDSET;
      // Output Qty. * two normal postings
      Assert.AreEqual(Count,ItemLedgerEntry.COUNT,
        STRSUBSTNO('Missing or excess Item Ledger Entries after reverse posting to Output Journal, under filters %1',
          ItemLedgerEntry.GETFILTERS));
    END;

    LOCAL PROCEDURE VerifyDocumentNoExistOnItemLedgerEntry@3(DocumentNo@1002 : Code[20]);
    VAR
      ItemLedgerEntry@1003 : Record 32;
    BEGIN
      ItemLedgerEntry.SETRANGE("Document No.",DocumentNo);
      IF ItemLedgerEntry.ISEMPTY THEN
        ERROR(DocumentNoError,DocumentNo);
    END;

    LOCAL PROCEDURE VerifyQuantityOnProdOrderLine@2020(Status@1278 : Option;ProductionOrderNo@1279 : Code[20];ItemNo@1280 : Code[20];QtyOnComponentLines@1271 : Decimal);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      FindProductionOrderLine(ProdOrderLine,Status,ProductionOrderNo,ItemNo);
      ProdOrderLine.TESTFIELD(Quantity,QtyOnComponentLines);
    END;

    LOCAL PROCEDURE VerifyExpectedQuantityOnProdOrderComponent@135(Item@1002 : Record 27;ProductionOrderNo@1987 : Code[20];ProdOrderLineQuantity@1000 : Decimal);
    VAR
      ProdOrderComponent@1968 : Record 5407;
      ExpectedQuantity@1001 : Decimal;
    BEGIN
      ProdOrderComponent.SETRANGE(Status,ProdOrderComponent.Status::Released);
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderComponent.SETRANGE("Item No.",Item."No.");
      ProdOrderComponent.FINDFIRST;
      ExpectedQuantity := ProdOrderComponent."Quantity per" * ProdOrderLineQuantity;
      Assert.AreNearlyEqual(
        ExpectedQuantity,ProdOrderComponent."Expected Quantity",Item."Rounding Precision",
        STRSUBSTNO(ExpectedQuantityError,ExpectedQuantity));
      Assert.AreNearlyEqual(
        ExpectedQuantity,ProdOrderComponent."Remaining Quantity",Item."Rounding Precision",
        STRSUBSTNO(ExpectedQuantityError,ExpectedQuantity));
    END;

    LOCAL PROCEDURE VerifyDateTimeOnProdOrderRoutingLine@159(ProductionOrder@1003 : Record 5405;RoutingNo@1002 : Code[20];WorkCenterNo@1000 : Code[20];WaitTime@1004 : Integer);
    VAR
      ProdOrderRoutingLine@1001 : Record 5409;
    BEGIN
      // Verify: Find the routing line with Monday ~ Friday working days
      ProdOrderRoutingLine.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderRoutingLine.SETRANGE("Routing No.",RoutingNo);
      ProdOrderRoutingLine.SETRANGE("Work Center No.",WorkCenterNo);
      ProdOrderRoutingLine.FINDFIRST;

      // Verify the start Date-Time and Ending Date-time
      Assert.AreEqual(
        CALCDATE('<+' + FORMAT(WaitTime) + 'D>',ProdOrderRoutingLine."Starting Date"),
        ProdOrderRoutingLine."Ending Date",'');

      // The starting time will be equal to ending time
      ProdOrderRoutingLine.TESTFIELD("Starting Time",ProdOrderRoutingLine."Ending Time");
    END;

    LOCAL PROCEDURE VerifyProductionBOMLineExists@235(ProductionBOMNo@1000 : Code[20];VersionCode@1001 : Code[20];No@1002 : Code[20]) : Boolean;
    VAR
      ProductionBOMLine@1003 : Record 99000772;
    BEGIN
      ProductionBOMLine.INIT;
      ProductionBOMLine.SETRANGE("Production BOM No.",ProductionBOMNo);
      ProductionBOMLine.SETRANGE("Version Code",VersionCode);
      ProductionBOMLine.SETRANGE("No.",No);
      Assert.RecordIsNotEmpty(ProductionBOMLine);
    END;

    LOCAL PROCEDURE VerifyProductionBOMLineNotExists@240(ProductionBOMNo@1002 : Code[20];VersionCode@1001 : Code[20];No@1000 : Code[20]);
    VAR
      ProductionBOMLine@1003 : Record 99000772;
    BEGIN
      ProductionBOMLine.INIT;
      ProductionBOMLine.SETRANGE("Production BOM No.",ProductionBOMNo);
      ProductionBOMLine.SETRANGE("Version Code",VersionCode);
      ProductionBOMLine.SETRANGE("No.",No);
      Assert.RecordIsEmpty(ProductionBOMLine);
    END;

    LOCAL PROCEDURE VerifyExistingILEs@257(VAR TempItemLedgEntry@1000 : TEMPORARY Record 32;ItemNo@1001 : Code[20]);
    VAR
      ItemLedgEntry@1002 : Record 32;
    BEGIN
      WITH ItemLedgEntry DO BEGIN
        SETRANGE("Item No.",ItemNo);
        FINDSET;
        REPEAT
          TempItemLedgEntry.GET("Entry No.");
          TESTFIELD("Remaining Quantity",TempItemLedgEntry."Remaining Quantity");
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE VerifyProductionOrderLineToSalesLineMultiLevelStructureWhenAllLocationsAreDifferent@267(VAR Item@1000 : ARRAY [4] OF Record 27;VAR SalesLine@1001 : ARRAY [4] OF Record 37;PlanningLevelCode@1005 : Integer;SalesLineAndTopLevelItemIndex@1003 : Integer;LevelOneItemIndex@1007 : Integer;LevelTwoItemIndex@1009 : Integer);
    VAR
      ProdOrderLine@1008 : Record 5406;
      TempProductionBOMLine@1006 : ARRAY [2] OF TEMPORARY Record 99000772;
      ProdOrderItemIndex@1010 : Integer;
      LevelOneMultiplicator@1011 : Decimal;
      LevelTwoMultiplicator@1012 : Decimal;
      i@1002 : Integer;
    BEGIN
      FOR i := 1 TO 2 DO
        FillTempBufOfProductionBOMLinesByBOMNo(TempProductionBOMLine[i],Item[i]."Production BOM No.");

      LevelOneMultiplicator := 1;
      LevelTwoMultiplicator := 1;

      CASE PlanningLevelCode OF
        0:
          ProdOrderItemIndex := SalesLineAndTopLevelItemIndex;
        1:
          BEGIN
            ProdOrderItemIndex := LevelOneItemIndex;
            LevelOneMultiplicator := GetQuantityPerFromProductionBOMLineByNo(
                TempProductionBOMLine[SalesLineAndTopLevelItemIndex],Item[LevelOneItemIndex]."No.");
          END;
        2:
          BEGIN
            ProdOrderItemIndex := LevelTwoItemIndex;
            LevelOneMultiplicator :=
              GetQuantityPerFromProductionBOMLineByNo(
                TempProductionBOMLine[SalesLineAndTopLevelItemIndex],Item[LevelOneItemIndex]."No.");
            LevelTwoMultiplicator :=
              GetQuantityPerFromProductionBOMLineByNo(
                TempProductionBOMLine[LevelOneItemIndex],Item[LevelTwoItemIndex]."No.");
          END;
      END;

      FindProdOrderLineByItemNoLocationCodeAndPlanningLevelCode(
        ProdOrderLine,Item[ProdOrderItemIndex]."No.",
        SalesLine[SalesLineAndTopLevelItemIndex]."Location Code",PlanningLevelCode);

      Assert.RecordCount(ProdOrderLine,1);

      ProdOrderLine.TESTFIELD(
        "Quantity (Base)",
        SalesLine[SalesLineAndTopLevelItemIndex]."Quantity (Base)" * LevelOneMultiplicator * LevelTwoMultiplicator);
    END;

    [RequestPageHandler]
    PROCEDURE CopyProductionOrderDocumentHandler@25(VAR CopyProductionOrderDocument@1000 : TestRequestPage 99003802);
    BEGIN
      CopyProductionOrderDocument.Status.SETVALUE(ProductionOrderStatus);
      CopyProductionOrderDocument.DocumentNo.SETVALUE(ProductionOrderNo);
      CopyProductionOrderDocument.IncludeHeader.SETVALUE(TRUE);
      CopyProductionOrderDocument.OK.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE ImplementRegisteredAbsenceHandler@32(VAR ImplementRegisteredAbsence@1000 : TestRequestPage 99003801);
    BEGIN
      ImplementRegisteredAbsence.Overwrite.SETVALUE(TRUE);
      ImplementRegisteredAbsence.OK.INVOKE;
    END;

    [ReportHandler]
    PROCEDURE RecalculateCalendarReportHandler@40(VAR RecalculateCalendar@1000 : Report 99001047);
    BEGIN
    END;

    [RequestPageHandler]
    PROCEDURE RegAbsFromWorkCenterReportHandler@72(VAR RegAbsFromWorkCenter@1000 : TestRequestPage 99003805);
    BEGIN
      RegAbsFromWorkCenter.StartingDate.SETVALUE(FORMAT(0D));

      IF NOT ShowError THEN BEGIN
        RegAbsFromWorkCenter.StartingTime.SETVALUE(FORMAT(StartingTime));
        RegAbsFromWorkCenter.EndingTime.SETVALUE(FORMAT(EndingTime));
        RegAbsFromWorkCenter.StartingDate.SETVALUE(FORMAT(WORKDATE));
        RegAbsFromWorkCenter.EndingDate.SETVALUE(FORMAT(WORKDATE));
        RegAbsFromWorkCenter.Capacity.SETVALUE(CapacityValue);
        RegAbsFromWorkCenter.Overwrite.SETVALUE(OverWrite);
      END;
      RegAbsFromWorkCenter.OK.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE RegAbsFromMachineCenterReportHandler@70(VAR RegAbsFromMachineCenter@1000 : TestRequestPage 99003800);
    BEGIN
      RegAbsFromMachineCenter.StartingDate.SETVALUE(FORMAT(0D));

      IF NOT ShowError THEN BEGIN
        RegAbsFromMachineCenter.StartingTime.SETVALUE(FORMAT(StartingTime));
        RegAbsFromMachineCenter.EndingTime.SETVALUE(FORMAT(EndingTime));
      END;
      IF NOT EndingTimeError THEN BEGIN
        RegAbsFromMachineCenter.StartingDate.SETVALUE(FORMAT(WORKDATE));
        RegAbsFromMachineCenter.EndingDate.SETVALUE(FORMAT(WORKDATE));
        RegAbsFromMachineCenter.Capacity.SETVALUE(CapacityValue);
        RegAbsFromMachineCenter.Overwrite.SETVALUE(OverWrite);
      END;
      RegAbsFromMachineCenter.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE WorkCenterCalendarMatrixHandler@86(VAR WorkCenterCalendarMatrix@1000 : TestPage 9291);
    BEGIN
      WorkCenterCalendarMatrix.FILTER.SETFILTER("No.",WorkCenterNo2);
      WorkCenterCalendarMatrix.Field1.ASSERTEQUALS(Capacity2);
    END;

    [ModalPageHandler]
    PROCEDURE ProductionJournalHandler@85(VAR ProductionJournal@1000 : TestPage 5510);
    BEGIN
      ProductionJournal.LAST;
      ProductionJournal."Setup Time".SETVALUE(LibraryRandom.RandInt(5));  // Use random Setup Time value is not important.
      ProductionJournal."Run Time".SETVALUE(LibraryRandom.RandInt(5));  // Use random Run Time value is not important.
      ProductionJournal.Post.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE CopyProductionForecastHandler@93(VAR CopyProductionForecast@1000 : TestRequestPage 99003803);
    BEGIN
      IF ProductionForecastName2 <> '' THEN BEGIN
        CopyProductionForecast.ProductionForecastName.SETVALUE(ProductionForecastName2);
        CopyProductionForecast.ItemNo.SETVALUE(ItemNo2);
        CopyProductionForecast.LocationCode.SETVALUE(LocationCode2);
        CopyProductionForecast.ComponentForecast.SETVALUE(TRUE);
        CopyProductionForecast.DateChangeFormula.SETVALUE(DateChangeFormula);
      END;
      CopyProductionForecast.OK.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE ExchangeProductionBOMItemHandler@102(VAR ExchangeProductionBOMItem@1000 : TestRequestPage 99001043);
    BEGIN
      ExchangeProductionBOMItem.StartingDate.SETVALUE('');

      IF NOT ShowError THEN BEGIN
        ExchangeProductionBOMItem.ExchangeType.SETVALUE(1);  // Use 1 for Item.
        ExchangeProductionBOMItem.ExchangeNo.SETVALUE(ExchangeNo);
        ExchangeProductionBOMItem.WithType.SETVALUE(1);   // Use 1 for Item.
        ExchangeProductionBOMItem.WithNo.SETVALUE(WithNo);
        ExchangeProductionBOMItem."Create New Version".SETVALUE(CreateNewVersion);
        ExchangeProductionBOMItem.StartingDate.SETVALUE(FORMAT(WORKDATE));
        ExchangeProductionBOMItem.Recertify.SETVALUE(TRUE);
        ExchangeProductionBOMItem.CopyRoutingLink.SETVALUE(TRUE);
        ExchangeProductionBOMItem."Delete Exchanged Component".SETVALUE(NOT CreateNewVersion);
      END;
      ExchangeProductionBOMItem.OK.INVOKE;
    END;

    [RequestPageHandler]
    PROCEDURE DeleteExpiredComponentsHandler@116(VAR DeleteExpiredComponents@1000 : TestRequestPage 99001041);
    BEGIN
      IF NOT ShowError THEN
        DeleteExpiredComponents.DeleteBefore.SETVALUE(FORMAT(WORKDATE));
      DeleteExpiredComponents.OK.INVOKE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandlerTrue@54(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@106(Message@1000 : Text[1024]);
    BEGIN
    END;

    [MessageHandler]
    PROCEDURE MessageHandler2@223(Message@1000 : Text[1024]);
    VAR
      MessageCount@1001 : Integer;
    BEGIN
      Assert.IsTrue(STRPOS(Message,LibraryVariableStorage.DequeueText) > 0,Message);
      MessageCount := LibraryVariableStorage.DequeueInteger;
      MessageCount += 1;
      LibraryVariableStorage.Enqueue(MessageCount);
    END;

    [StrMenuHandler]
    PROCEDURE OptionDialog@41(Options@1002 : Text[1024];VAR Choice@1001 : Integer;Instruction@1000 : Text[1024]);
    BEGIN
      Choice := 1;  // Use 1 for Copy Dimensions from BOM.
    END;

    [ModalPageHandler]
    PROCEDURE OutputJournalItemtrackingPageHandler@119(VAR ItemTrackingLines@1000 : TestPage 6510);
    VAR
      i@1001 : Integer;
    BEGIN
      FOR i := 1 TO ABS(GLB_ItemTrackingQty) DO BEGIN
        ItemTrackingLines."Serial No.".SETVALUE(GLB_SerialNo);
        ItemTrackingLines."Quantity (Base)".SETVALUE(GLB_ItemTrackingQty / ABS(GLB_ItemTrackingQty));
        ItemTrackingLines.NEXT;
        COMMIT;
        GLB_SerialNo := INCSTR(GLB_SerialNo);
      END;
    END;

    LOCAL PROCEDURE PostOutputJournalWithIT@118(ProductionOrder@1000 : Record 5405;Quantity@1001 : Integer);
    VAR
      ItemJournalLine@1003 : Record 83;
      OutputJournal@1002 : TestPage 99000823;
    BEGIN
      ItemJournalLine.DELETEALL;
      COMMIT;

      OutputJournal.OPENEDIT;
      OutputJournal."Order No.".SETVALUE(ProductionOrder."No.");
      OutputJournal."Item No.".SETVALUE(ProductionOrder."Source No.");
      OutputJournal."Operation No.".SETVALUE(OperationNo(ProductionOrder));
      OutputJournal."Output Quantity".SETVALUE(Quantity);

      GLB_ItemTrackingQty := Quantity;
      GLB_SerialNo := 'OUTPUT_REVERT_SN1';

      OutputJournal."Item Tracking Lines".INVOKE; // Jump to: OutputJournalItemtrackingPageHandler
      COMMIT;
      OutputJournal.Post.INVOKE;
    END;

    LOCAL PROCEDURE SetQuantity@117(VAR ProductionOrder@1000 : Record 5405;Quantity@1001 : Integer);
    BEGIN
      ProductionOrder.GET(ProductionOrder.Status,ProductionOrder."No.");
      ProductionOrder.VALIDATE(Quantity,Quantity);
      ProductionOrder.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE OperationNo@115(ProductionOrder@1000 : Record 5405) : Code[10];
    VAR
      ProdOrderRoutingLine@1001 : Record 5409;
    BEGIN
      ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderRoutingLine.FINDFIRST;
      EXIT(ProdOrderRoutingLine."Operation No.");
    END;

    [PageHandler]
    PROCEDURE ViewAppliedEntriesPageHandler@2(VAR ViewAppliedEntries@1000 : TestPage 522);
    VAR
      AppliedQuantity@1001 : Variant;
      ItemNo@1002 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(ItemNo);
      LibraryVariableStorage.Dequeue(AppliedQuantity);
      ViewAppliedEntries.FILTER.SETFILTER("Item No.",ItemNo);
      ViewAppliedEntries.ApplQty.ASSERTEQUALS(AppliedQuantity);
      ViewAppliedEntries.OK.INVOKE;
    END;

    [PageHandler]
    PROCEDURE ViewAppliedEntriesPageHandler2@218(VAR ViewAppliedEntries@1000 : TestPage 522);
    BEGIN
      ViewAppliedEntries.RemoveAppButton.INVOKE
    END;

    [ModalPageHandler]
    PROCEDURE ViewAppliedEntriesModalPageHandler@203(VAR ViewAppliedEntries@1000 : TestPage 522);
    BEGIN
      ViewAppliedEntries.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ProdOrderRoutingHandler@201(VAR ProdOrderRouting@1000 : TestPage 99000817);
    VAR
      Variant@1001 : Variant;
    BEGIN
      LibraryVariableStorage.Dequeue(Variant);
      ProdOrderRouting."No.".SETVALUE(Variant);
      ProdOrderRouting.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE DummyProdOrderRoutingHandler@220(VAR ProdOrderRouting@1000 : TestPage 99000817);
    BEGIN
      ProdOrderRouting.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE MachineCenterPageHandler@202(VAR MachineCenter@1000 : TestPage 99000761);
    BEGIN
      MachineCenter.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ReservationHandler@256(VAR ReservationPage@1000 : TestPage 498);
    BEGIN
      ReservationPage.FIRST;
      ReservationPage."Auto Reserve".INVOKE;
      ReservationPage.OK.INVOKE;
    END;

    LOCAL PROCEDURE CreateRoutingAndBOM@309(ItemNo@1000 : Code[20];ComponentNo@1001 : Code[20];WorkCenterNo@1002 : Code[20];ConcurrentCapacities@1004 : Integer;RoutingLinkCode@1005 : Code[10]);
    VAR
      Item@1003 : Record 27;
    BEGIN
      WITH Item DO BEGIN
        GET(ItemNo);
        VALIDATE(
          "Production BOM No.",
          CreateProductionBOMWithComponent("Base Unit of Measure",ComponentNo,RoutingLinkCode));
        VALIDATE(
          "Routing No.",
          CreateRoutingWithWorkCenter(WorkCenterNo,ConcurrentCapacities,RoutingLinkCode));
        VALIDATE("Replenishment System","Replenishment System"::"Prod. Order");
        VALIDATE("Manufacturing Policy","Manufacturing Policy"::"Make-to-Order");
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE VerifyProdOrderDateTimes@308(ProductionOrder@1000 : Record 5405;WorkCenterCapacity@1003 : Integer);
    VAR
      ProdOrderLine@1004 : Record 5406;
      ExpStartDateTime@1006 : DateTime;
      ExpEndDateTime@1005 : DateTime;
    BEGIN
      WITH ProdOrderLine DO BEGIN
        SETRANGE(Status,ProductionOrder.Status);
        SETRANGE("Prod. Order No.",ProductionOrder."No.");
        FINDSET;
        ExpStartDateTime := "Ending Date-Time";
        REPEAT
          ExpEndDateTime := ExpStartDateTime;
          Assert.AreEqual(
            DT2DATE(ExpEndDateTime),DT2DATE("Ending Date-Time"),STRSUBSTNO(WrongDateTimeErr,FIELDCAPTION("Ending Date")));
          Assert.AreEqual(
            DT2TIME(ExpEndDateTime),DT2TIME("Ending Date-Time"),STRSUBSTNO(WrongDateTimeErr,FIELDCAPTION("Ending Time")));
          ExpStartDateTime := ExpEndDateTime - ((3600 * 1000) * (1 + Quantity / WorkCenterCapacity));
          Assert.AreEqual(
            DT2DATE(ExpStartDateTime),DT2DATE("Starting Date-Time"),STRSUBSTNO(WrongDateTimeErr,FIELDCAPTION("Starting Date")));
          Assert.AreEqual(
            DT2TIME(ExpStartDateTime),DT2TIME("Starting Date-Time"),STRSUBSTNO(WrongDateTimeErr,FIELDCAPTION("Starting Time")));
        UNTIL NEXT = 0;
      END;
    END;

    BEGIN
    {
      // [FEATURE] [Manufacturing] [SCM]
      Unsupported version tags:
      SE: Unable to Execute

       Unsupported version tags:
       IN: Unable to Execute

       1. Verify that a Planned Production Order can be copied into a Released Production Order.
       2. Verify that a Firm Planned Production Order can be copied into a Released Production Order.
       3. Verify that a Released Production Order can be copied into a Released Production Order.
       4. Verify that a Finished Production Order can be copied into a Released Production Order.
       5. Check the functionality of Report Implement Registered Absence.
       6. Test Explode BOM functionality on Item Reclass Journal.
       7. Verify that the Updated field becomes True when we perform Update action on Absence entry invoked by Work Center.
       8. Verify Capacity(Total) field on Calendar entry after recalculating Work Center Calendar with Absence entry.
       9. Verify that Capacity(Total) on Calendar entry is calculated based on Absence entry having Starting and Ending Time and it ignores the Absence entry where Starting Time is null.
      10. Check that the Error message is generated when RegAbsFromWorkCenter Report is run with blank data.
      11. Check that the Registered Absence does not gets overwritten when RegAbsFromWorkCenter Report is run with Overwrite = False.
      12. Check that the Registered Absence gets overwritten when RegAbsFromWorkCenter Report is run with Overwrite = True.
      13. Check that the Error message is generated when RegAbsFromMachineCenter Report is run with blank Starting Date.
      14. Check that the Error message is generated when RegAbsFromMachineCenter Report is run with Starting Time later than the Ending Time.
      15. Check that the Registered Absence does not gets overwritten when RegAbsFromMachineCenter Report is run with Overwrite = False.
      16. Check that the Registered Absence gets overwritten when RegAbsFromMachineCenter Report is run with Overwrite = True.
      17. Check the functionality of Recalculate Calendar for Machine Center.
      18. Test and Verify Calculated Capacity on Work Center Calendar Matrix Page.
      19. Test and Verify Expected Capacity Need on Production Order Statistics.
      20. Test and Verify Consumption posted by Production Journal.
      21. Verify Capacity Ledger Entry after posting Capacity Journal Line.
      22. Test and verify functionality of Copy Production Forecast report with blank Production Forecast Name.
      23. Test and verify functionality of Copy Production Forecast report with Production Forecast Entry.
      24. Test functionality of Exchange Production BOM Item report with blank Starting Date.
      25. Test functionality of Exchange Production BOM Item report with Create New Version as true and Delete Exchanged Component as false.
      26. Test functionality of Exchange Production BOM Item report with Create New Version as false and Delete Exchanged Component as true.
      27. Validate error message when Status is set to Certified in Production BOM on adding Parent Item in BOM Line.
      28. Validate Status can be set to Under Development on adding Parent Item in BOM Line and Certified on deleting the Parent Item from BOM Line.
      29. Test to verify error message on running Calculate Work Center Calendar report with blank Starting date.
      30. Test to verify the functionality of Calculate Work Center Calendar report.
      31. Test the functionality of Delete Expired Components report with blank Delete Before Date.
      32. Test the functionality of Delete Expired Components report.
      33. Test and verify Starting Date and Ending Date after refreshing Planning Line.
      34. Test and verify Delete Planning Worksheet Lines functionality after Calculate Regenerative Plan.
      35. Test to validate Consumption Journal After release Production Order and calculate Consumption.
      36. Test to validate Output Journal after Posting Consumption Journal.
      37. Test to validate G/L Entry after posting output Journal.
      38. Check the Quantity on View Applied Item Entries After Application Worksheet.
      39. Check Document No. on Item Ledger Entry when Field Doc. No. Is Prod. Order No. is False on Manufacturing Setup.
      40. Check Quantity on Prod. Order Line equal to Qty. on Component Lines.
      41. Check Expected Quantity and Remaining Quantity on Prod. Order Component.
      42. Check error when modifying routing No. on posted Prod. Order line
      43. Check error when deleting posted Prod. Order line
      44. Verify Production Order Routing Lines will be deleted for the specific production order line as soon as the Routing No. is changed
      45. Check Starting Date Time is calculated correctly for the Prod. Order Routing Line in a backward calculated Scenario if the prior
          Prod. Order Routing Line is scheduled at non-Working Day for the calculated Prod. Order Routing Line with waiting time >= 5 Days
      46. Check Starting Date Time is calculated correctly for the Prod. Order Routing Line in a backward calculated Scenario if the prior
          Prod. Order Routing Line is scheduled at non-Working Day for the calculated Prod. Order Routing Line with waiting time < 5 Days
      47. Check Prod. Order Capactiy Need is calculated correctly when there is work shift ending at midnight
      48. Check Prod. Order Capactiy Need is calculated correctly when modifying Starting time in Planning Routing Line with work shift ending at midnight
      49. Check the Starting Date on Prod. Order Line is calculated correctly when routing's setup time ends at midnight
      50. Check Wait Time on Prod. Order Routing Line is not Capacity constrained.
      51. Check Wait Time on Planning Routing Line is not Capacity constrained.
      52. Check Wait Time on Prod. Order Routing Line is not Capacity constrained with backward calculation when multiple routing lines exist.
      53. Check Wait Time on Planning Routing Line is not Capacity constrained with backward calculation when multiple routing lines exist.
      54. Check Wait Time on Prod. Order Routing Line is not Capacity constrained with backward calculation when wait time exceeds 1 week.
      55. Check Wait Time on Planning Routing Line is not Capacity constrained with backward calculation when wait time exceeds 1 week.
      56. Check filtering on Production Forecast can provide expected results.
      57. Verify ProdOrderLine's BinCode changes after ProdOrderRtngLine update
      58. Posting of component consumption leading to circular reference in cost application is not allowed for reserved component
      59. Posting of component consumption leading to circular reference in cost application is not allowed for non-reserved component
      60. Check Date-Time calculation when refreshing back Production Order with concurrent capacity workcenters.

      TFS_TS_ID = 270822
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      CopyPlannedProductionOrder                                                             128941
      CopyFirmPlannedProductionOrder                                                         128941
      CopyReleasedProductionOrder                                                            128941
      CopyFinishedProductionOrder                                                            128941

      TFS_TS_ID = 268064
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      ImplementRegisteredAbsenceReport                                                       128940

      TFS_TS_ID = 272013
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      ItemReclassJournal                                                                     141374

      TFS_TS_ID = 272652
      Cover Test cases:
      ---------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ---------------------------------------------------------------------------------------------
      WorkCenterAbsenceUpdate                                                                141370
      RecalculateWorkCenterCalendarWithAbsence                                               141370
      RecalculateWorkCenterCalendarWithNullStaringTimeInAbsence                              141370
      RegisteredAbsenceFromWorkCenterReportWithBlankData                                     128943
      RegisteredAbsenceFromWorkCenterReportWithOverwriteFalse                                128943
      RegisteredAbsenceFromWorkCenterReportWithOverwriteTrue                                 128943

      TFS_TS_ID = 273888
      Cover Test cases:
      ---------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ---------------------------------------------------------------------------------------------
      RegisteredAbsenceFromMachineCenterReportWithStartingDateError                          128939
      RegisteredAbsenceFromMachineCenterReportWithTimeError                                  128939
      RegisteredAbsenceFromMachineCenterReportWithOverwriteFalse                             128939
      RegisteredAbsenceFromMachineCenterReportWithOverwriteTrue                              128939

      TFS_TS_ID = 273109
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      RecalculateMachineCenterCalendarReport                                                 128938

      TFS_TS_ID = 273973
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      CalculatedCapacityOnWorkCenterCalendarMatrix                                           144679

      TFS_TS_ID = 273974
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      ExpectedCapacityNeedOnProductionOrderStatistics                                 143132,143133
      ConsumptionPostedByProductionJournal                                                   144529

      TFS_TS_ID = 276191
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      CapacityLedgerEntryAfterPostingCapacityJournal                                         141340

      TFS_TS_ID = 278099
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      CopyProductionForecastNameWithBlankDescription,CopyProductionForecastEntry             128942

      TFS_TS_ID = 278103
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      ExchangeProductionBOMItemError,ExchangeProductionBOMItemWithCreateNewVersion           128935
      ExchangeProductionBOMItemWithDeleteExchangedComponent                                  128935

      TFS_TS_ID = 278116
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      ParentItemInProductionBOMLineError                                                     144528
      ParentItemInProductionBOMLineUnderDevelopment                                          144528

      TFS_TS_ID = 278122
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      CalculateWorkCenterCalendarReportWithBlankStartingDate                                 128937
      CalculateWorkCenterCalendarReport                                                      128937

      TFS_TS_ID = 278104
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      DeleteExpiredComponentsReportWithError,DeleteExpiredComponentsReport                  128934

      TFS_TS_ID = 281502
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      RefreshPlanningLine                                                                    129150

      TFS_TS_ID = 277797
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      DeletePlanningWorksheetLines                                                           143370

      TFS_TS_ID = 287235
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      CalculateConsumptionAfterRefreshProductionOrder                                       281259
      OutputJournalAfterCalculateConsumption                                                281259
      GLEntryAfterPostOutputJournal                                                         281259

      Bug ID = 303009
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      QuantityOnAppliedEntriesAfterApplicationWorkSheet                                      302456

      Bug_ID = 305532
      Cover Test cases:
      ----------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ----------------------------------------------------------------------------------------------
      DocumentNoOnItemLedgerEntry                                                            304094

      Bug ID: 317705
      ---------------------------------------------------------------------------------------------
      Test Function Name                                                                 TFS ID
      ---------------------------------------------------------------------------------------------
      QuantityOnProductionOrderLine,ExpectedQuantityOnProductionOrderComponenent         318170

      Cover test cases for Sicily Merge Bug
      ---------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ---------------------------------------------------------------------------------------------
      ChangeRtngOnProdOrdLnWithPostedOutput                                                   27007
      DeleteProdOrdLnWithPostedOutput                                                         27007
      ChangeRtngOnProdOrdLn                                                                   27919
      CalculateWaitingTimeIncludingWeekendWithMultipleCalendars                               48588
      CalculateWaitingTimeWithMultipleCalendars                                               48588
      CalculateProdOrderCapactiyNeedWithWorkShiftEndAtMidnight                                50331
      CalculateProdOrderCapactiyNeedWithWorkShiftEndAtMidnightInPlanningRoutingLine           50331
      CalculateProdOrderStartingDateWithRoutingSetupTimeEndAtMidnight                         50331
      CheckWaitTimeOnProdOrderRoutingLineWithoutCapacityConstrained                           54440
      CheckWaitTimeOnPlanningRoutingLineWithoutCapacityConstrained                            54440
      CheckWaitTimeStartingOnWeekendOnProdOrdRtngLnWithoutCapConstrained                      55372
      CheckWaitTimeStartingOnWeekendOnPlanningRtngLnWithoutCapConstrained                     55372
      CheckBackwardCalculatedWaitTimeOnProdOrdRtngLnWithoutCapConstrained                     55372
      CheckBackwardCalculatedWaitTimeOnPlanningRtngLnWithoutCapConstrained                    55372
      FilterOnProductionForecast                                                              67424
      ChangeProdOrderRtngLineFromProdBinCode                                                 106055
      CircularReferenceConsumptionNotAllowedWithReservation                                  360892
      CircularReferenceConsumptionNotAllowedWithoutReservation                               360892

      Cover test cases for SE Merge Bug
      ---------------------------------------------------------------------------------------------
      Test Function Name                                                                     TFS ID
      ---------------------------------------------------------------------------------------------
      CheckBackwardCalculatedTimeOnProdOrdCapConstrained                                     362462
    }
    END.
  }
}

