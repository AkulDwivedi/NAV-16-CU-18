OBJECT Codeunit 137105 SCM Kitting ATS in Whse/IT IM
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            IsInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LocationInvtMvmt@1021 : Record 14;
      CompItem@1035 : Record 27;
      KitItem@1036 : Record 27;
      Assert@1009 : Codeunit 130000;
      LibraryWarehouse@1002 : Codeunit 132204;
      LibraryUtility@1003 : Codeunit 131000;
      LibraryAssembly@1010 : Codeunit 132207;
      LibraryInventory@1014 : Codeunit 132201;
      LibraryPurchase@1043 : Codeunit 130512;
      LibraryKitting@1024 : Codeunit 132205;
      LibraryRandom@1017 : Codeunit 130440;
      IsInitialized@1000 : Boolean;
      MSG_MVMT_CREATED@1001 : TextConst 'ENU=Number of Invt. Movement activities';
      MSG_NOT_ON_INVT@1008 : TextConst 'ENU="Item "';
      MSG_NOTHING_TO_CREATE@1027 : TextConst 'ENU=There is nothing to create';
      MSG_STATUS_MUST_BE_RELEASED@1056 : TextConst 'ENU=Status must be equal to ''Released''';
      MSG_NOT_ON_INVT1@1029 : TextConst 'ENU=Item %1';
      MSG_QTY_OUTST@1057 : TextConst 'ENU=You cannot handle more than the outstanding';
      MSG_SER_NO_MUST@1026 : TextConst 'ENU=Serial No. must have a value';
      MSG_LOT_NO_MUST@1006 : TextConst 'ENU=Lot No. must have a value';
      LocationTakeBinCode@1032 : Code[20];
      LocationAdditionalBinCode@1013 : Code[20];
      LocationToBinCode@1004 : Code[20];
      LocationFromBinCode@1058 : Code[20];
      LocationAdditionalPickBinCode@1044 : Code[20];
      WhseActivityType@1041 : 'None,WhsePick,InvtMvmt';
      Tracking@1049 : 'Untracked,Lot,Serial,LotSerial';
      GLB_ITPageHandler@1040 : 'AssignITSpec,SelectITSpec,AssignITSpecPartial,PutManuallyITSpec';
      PAR_ITPage_AssignSerial@1039 : Boolean;
      PAR_ITPage_AssignLot@1020 : Boolean;
      PAR_ITPage_AssignPartial@1011 : Boolean;
      PAR_ITPage_AssignQty@1005 : Decimal;
      PAR_ITPage_ITNo@1012 : Code[20];
      PAR_ITPage_FINDDIR@1028 : Code[20];
      WorkDate2@1019 : Date;
      MSG_WHSE_HANDLING_REQUIRED@1015 : TextConst 'ENU="Warehouse handling is required for Entry Type = Assembly Consumption, Order No. = "';
      MSG_QTY_TO_HANDLE_BASE_MUST_BE_NOT@1007 : TextConst 'ENU=Qty. to Handle (Base) in Tracking Specification for Item No.';

    LOCAL PROCEDURE Initialize@25();
    VAR
      WarehouseSetup@1001 : Record 5769;
      SalesReceivablesSetup@1002 : Record 311;
      PurchasesPayablesSetup@1006 : Record 312;
      AssemblySetup@1000 : Record 905;
      MfgSetup@1004 : Record 99000765;
      LibraryERMCountryData@1008 : Codeunit 131305;
    BEGIN
      IF IsInitialized THEN
        EXIT;

      // Setup Demonstration data.
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralLedgerSetup;
      LibraryERMCountryData.UpdateGeneralPostingSetup;

      CLEARLASTERROR;
      MfgSetup.GET;
      WorkDate2 := CALCDATE(MfgSetup."Default Safety Lead Time",WORKDATE); // to avoid Due Date Before Work Date message.
      LibraryAssembly.UpdateAssemblySetup(AssemblySetup,'',AssemblySetup."Copy Component Dimensions from"::"Item/Resource Card",
        LibraryUtility.GetGlobalNoSeriesCode);

      LibraryWarehouse.NoSeriesSetup(WarehouseSetup);

      SalesReceivablesSetup.GET;
      SalesReceivablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      SalesReceivablesSetup.MODIFY(TRUE);

      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Order Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      PurchasesPayablesSetup.MODIFY(TRUE);

      LocationSetupInvtMvmt(LocationInvtMvmt);

      IsInitialized := TRUE;
      COMMIT;
    END;

    LOCAL PROCEDURE SetGenWarehouseEntriesFilter@99(VAR WarehouseEntry@1001 : Record 7312;AssemblyHeader@1000 : Record 900);
    VAR
      SourceCodeSetup@1002 : Record 242;
    BEGIN
      WarehouseEntry.RESET;
      SourceCodeSetup.GET;
      WarehouseEntry.SETRANGE("Source Code",SourceCodeSetup.Assembly);
      // WarehouseEntry.SETRANGE("Whse. Document Type",WarehouseEntry."Whse. Document Type"::Assembly);
      // WarehouseEntry.SETRANGE("Whse. Document No.",AssemblyHeader."No.");
      WarehouseEntry.SETRANGE("Source No.",AssemblyHeader."No.");
      WarehouseEntry.SETRANGE("Registering Date",AssemblyHeader."Posting Date");
      WarehouseEntry.SETRANGE("User ID",USERID);
    END;

    LOCAL PROCEDURE SetLocWarehouseEntriesFilter@147(VAR WarehouseEntry@1001 : Record 7312;VariantCode@1000 : Code[20];UOMCode@1002 : Code[20];Quantity@1003 : Decimal;WarehouseEntryType@1004 : Integer;LocationCode@1005 : Code[20];BinCode@1006 : Code[20];ItemNo@1007 : Code[20];SourceLineNo@1008 : Integer);
    BEGIN
      WarehouseEntry.SETRANGE("Variant Code",VariantCode);
      WarehouseEntry.SETRANGE("Unit of Measure Code",UOMCode);
      WarehouseEntry.SETRANGE(Quantity,Quantity);
      WarehouseEntry.SETRANGE("Entry Type",WarehouseEntryType);
      WarehouseEntry.SETRANGE("Location Code",LocationCode);
      WarehouseEntry.SETRANGE("Bin Code",BinCode);
      WarehouseEntry.SETRANGE("Item No.",ItemNo);
      // Description is not set because of bug
      // WarehouseEntry.SETRANGE(Description,TempAssemblyLine.Description);
      // WarehouseEntry.SETRANGE("Source Document",WarehouseEntry."Source Document"::"Assembly Order");
      WarehouseEntry.SETRANGE("Source Line No.",SourceLineNo);
    END;

    LOCAL PROCEDURE VerifyWarehouseEntries@125(AssemblyHeader@1001 : Record 900;VAR TempAssemblyLine@1002 : TEMPORARY Record 901;AssembledQty@1003 : Decimal;ShouldBeCreated@1004 : Boolean;ExpectedNoOfWhseEntries@1005 : Integer);
    VAR
      WarehouseEntry@1000 : Record 7312;
    BEGIN
      // Verify whole amount of warehouse entries
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);

      SetGenWarehouseEntriesFilter(WarehouseEntry,AssemblyHeader);
      IF ShouldBeCreated THEN
        Assert.AreEqual(ExpectedNoOfWhseEntries,WarehouseEntry.COUNT,
          'Incorect number of warehouse entries for assembly ' + AssemblyHeader."No.")
      ELSE
        Assert.AreEqual(0,WarehouseEntry.COUNT,
          'Incorect number of warehouse entries for assembly ' + AssemblyHeader."No.");

      // Verify warehouse entries for header assembly item
      SetGenWarehouseEntriesFilter(WarehouseEntry,AssemblyHeader);
      SetLocWarehouseEntriesFilter(WarehouseEntry,
        AssemblyHeader."Variant Code",
        AssemblyHeader."Unit of Measure Code",
        AssembledQty,
        WarehouseEntry."Entry Type"::"Positive Adjmt.",
        AssemblyHeader."Location Code",
        AssemblyHeader."Bin Code",
        AssemblyHeader."Item No.",
        0);
      IF ShouldBeCreated THEN
        Assert.AreEqual(1,WarehouseEntry.COUNT,
          'Incorrect number of warehouse entries for assembly item ' + AssemblyHeader."Item No.")
      ELSE
        Assert.AreEqual(0,WarehouseEntry.COUNT,
          'Incorrect number of warehouse entries for assembly item ' + AssemblyHeader."Item No.");

      // Verify warehouse entries for components
      TempAssemblyLine.FINDSET;
      REPEAT
        SetGenWarehouseEntriesFilter(WarehouseEntry,AssemblyHeader);
        SetLocWarehouseEntriesFilter(WarehouseEntry,
          TempAssemblyLine."Variant Code",
          TempAssemblyLine."Unit of Measure Code",
          -TempAssemblyLine."Quantity to Consume",
          WarehouseEntry."Entry Type"::"Negative Adjmt.",
          TempAssemblyLine."Location Code",
          TempAssemblyLine."Bin Code",
          TempAssemblyLine."No.",
          TempAssemblyLine."Line No.");
        IF ShouldBeCreated THEN
          Assert.AreEqual(1,WarehouseEntry.COUNT,
            'Incorrect number of warehouse entries for assembly line ' + TempAssemblyLine."No.")
        ELSE
          Assert.AreEqual(0,WarehouseEntry.COUNT,
            'Incorrect number of warehouse entries for assembly line ' + TempAssemblyLine."No.");
      UNTIL TempAssemblyLine.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyBinContent@101(LocationCode@1003 : Code[20];BinCode@1000 : Code[20];ItemNo@1002 : Code[20];Quantity@1001 : Decimal);
    VAR
      BinContent@1004 : Record 7302;
    BEGIN
      BinContent.RESET;
      BinContent.SETRANGE("Location Code",LocationCode);
      BinContent.SETRANGE("Bin Code",BinCode);
      BinContent.SETRANGE("Item No.",ItemNo);
      IF BinContent.FINDFIRST THEN BEGIN
        BinContent.CALCFIELDS(Quantity);
        BinContent.TESTFIELD(Quantity,Quantity);
      END ELSE
        Assert.AreEqual(Quantity,0,'Incorrect Qty of Item ' + ItemNo + ' in Bin ' + BinCode);
    END;

    LOCAL PROCEDURE VerifyBinContentsMvmt@30(AssemblyHeader@1000 : Record 900;VAR TempAssemblyLine@1001 : TEMPORARY Record 901;QtySupplement@1002 : Decimal;AssembledQty@1003 : Decimal);
    BEGIN
      // Veryfy bin content for header assembly item
      VerifyBinContent(AssemblyHeader."Location Code",AssemblyHeader."Bin Code",AssemblyHeader."Item No.",AssembledQty);

      // Verify bin contents for components
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;

      REPEAT
        VerifyBinContent(TempAssemblyLine."Location Code",TempAssemblyLine."Bin Code",
          TempAssemblyLine."No.",0);
        VerifyBinContent(TempAssemblyLine."Location Code",LocationTakeBinCode,
          TempAssemblyLine."No.",
          QtySupplement + TempAssemblyLine.Quantity - TempAssemblyLine."Quantity to Consume" - TempAssemblyLine."Consumed Quantity")
      UNTIL TempAssemblyLine.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE VerifyRegInvtMvmt@26(AssemblyHeader@1001 : Record 900;VAR TempAssemblyLine@1004 : TEMPORARY Record 901;WarehouseActivityHeaderNo@1005 : Code[20];ExpectedNoOfRegInvtMmnt@1006 : Integer;NotEnoughItemNo@1008 : Code[20];NotEnoughQty@1007 : Decimal;AdditionalBinQty@1009 : Decimal);
    VAR
      RegdInvtMovementLn@1000 : Record 7345;
      RegdInvtMovementHdr@1002 : Record 7344;
      ExpectedNoOfLines@1010 : Integer;
    BEGIN
      VerifyRegInvtMvmtHeader(AssemblyHeader,ExpectedNoOfRegInvtMmnt);

      RegdInvtMovementHdr.SETRANGE("Invt. Movement No.",WarehouseActivityHeaderNo);
      RegdInvtMovementHdr.FINDFIRST;

      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);

      RegdInvtMovementLn.RESET;
      RegdInvtMovementLn.SETRANGE("No.",RegdInvtMovementHdr."No.");

      ExpectedNoOfLines := 2 * TempAssemblyLine.COUNT;
      IF AdditionalBinQty > 0 THEN
        ExpectedNoOfLines += 2;
      Assert.AreEqual(
        ExpectedNoOfLines,RegdInvtMovementLn.COUNT,COPYSTR('There are not ' + FORMAT(ExpectedNoOfLines) +
          ' reg Invt mvmt lines within the filter: ' + RegdInvtMovementHdr.GETFILTERS,1,1024));

      VerifyRegInvtMvmtLines(RegdInvtMovementHdr,TempAssemblyLine,
        RegdInvtMovementLn."Action Type"::Take,LocationTakeBinCode,NotEnoughItemNo,NotEnoughQty,AdditionalBinQty);
      VerifyRegInvtMvmtLines(RegdInvtMovementHdr,TempAssemblyLine,
        RegdInvtMovementLn."Action Type"::Place,LocationToBinCode,NotEnoughItemNo,NotEnoughQty,AdditionalBinQty);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyRegInvtMvmtHeader@78(AssemblyHeader@1001 : Record 900;ExpectedNoOfRegInvtMmnt@1006 : Integer);
    VAR
      RegdInvtMovementHdr@1002 : Record 7344;
      WarehouseRequest@1003 : Record 5765;
    BEGIN
      RegdInvtMovementHdr.RESET;
      RegdInvtMovementHdr.SETRANGE("Source No.",AssemblyHeader."No.");
      RegdInvtMovementHdr.SETRANGE("Source Document",WarehouseRequest."Source Document"::"Assembly Consumption");
      RegdInvtMovementHdr.SETRANGE("Source Type",DATABASE::"Assembly Line");
      RegdInvtMovementHdr.SETRANGE("Source Subtype",AssemblyHeader."Document Type");
      RegdInvtMovementHdr.SETRANGE("Location Code",AssemblyHeader."Location Code");
      RegdInvtMovementHdr.SETRANGE("Destination Type",RegdInvtMovementHdr."Destination Type"::Item);
      RegdInvtMovementHdr.SETRANGE("Destination No.",AssemblyHeader."Item No.");
      Assert.AreEqual(ExpectedNoOfRegInvtMmnt,RegdInvtMovementHdr.COUNT,COPYSTR(
          'There should be 1 registered InvtMvmtHeader within the filter: ' +
          RegdInvtMovementHdr.GETFILTERS,1,1024));
    END;

    [Normal]
    LOCAL PROCEDURE VerifyWhseActivity@6(AssemblyHeader@1001 : Record 900;VAR TempAssemblyLine@1004 : TEMPORARY Record 901;VAR WhseActivityHdr@1005 : Record 5766;NotEnoughItemNo@1006 : Code[20];NotEnoughQty@1002 : Decimal;AdditionalBinQty@1007 : Decimal);
    VAR
      WhseActivityLine@1000 : Record 5767;
      ExpectedNoOfItems@1008 : Integer;
    BEGIN
      VerifyWhseActivityHeader(AssemblyHeader,WhseActivityHdr);

      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);

      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHdr."No.");

      ExpectedNoOfItems := 2 * TempAssemblyLine.COUNT;
      IF AdditionalBinQty > 0 THEN
        ExpectedNoOfItems += 2;

      Assert.AreEqual(
        ExpectedNoOfItems,WhseActivityLine.COUNT,COPYSTR('There are not ' + FORMAT(ExpectedNoOfItems) +
          ' whse activity lines within the filter: ' + WhseActivityHdr.GETFILTERS,1,1024));

      VerifyWhseActivityLines(WhseActivityHdr,TempAssemblyLine,
        WhseActivityLine."Action Type"::Take,LocationTakeBinCode,NotEnoughItemNo,NotEnoughQty,AdditionalBinQty);
      VerifyWhseActivityLines(WhseActivityHdr,TempAssemblyLine,
        WhseActivityLine."Action Type"::Place,LocationToBinCode,NotEnoughItemNo,NotEnoughQty,AdditionalBinQty);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyWhseActivityHeader@15(AssemblyHeader@1001 : Record 900;VAR WarehouseActivityHeader@1005 : Record 5766);
    BEGIN
      WarehouseActivityHeader.RESET;
      WarehouseActivityHeader.SETRANGE("Location Code",AssemblyHeader."Location Code");

      IF WarehouseActivityHeader.Type = WarehouseActivityHeader.Type::Pick THEN
        // WarehouseActivityHeader.SETRANGE("Source No.",AssemblyHeader."No.");
        // WarehouseActivityHeader.SETRANGE("Source Document",WarehouseRequest."Source Document"::"Assembly Consumption");
        // WarehouseActivityHeader.SETRANGE("Source Type",DATABASE::"Assembly Line");
        // WarehouseActivityHeader.SETRANGE("Source Subtype",AssemblyHeader."Document Type");
        // WarehouseActivityHeader.SETRANGE("Destination Type",WarehouseActivityHeader."Destination Type"::Item);
        // WarehouseActivityHeader.SETRANGE("Destination No.",AssemblyHeader."Item No.");
        // WarehouseActivityHeader.SETRANGE("Destination Type",WarehouseActivityHeader."Destination Type"::Item);
        // WarehouseActivityHeader.SETRANGE("Destination No.",AssemblyHeader."Item No.");
        ;

      Assert.AreEqual(1,WarehouseActivityHeader.COUNT,COPYSTR('There should be 1 whse activity header within the filter: ' +
          WarehouseActivityHeader.GETFILTERS,1,1024));

      WarehouseActivityHeader.FINDFIRST;
    END;

    [Normal]
    LOCAL PROCEDURE VerifyRegInvtMvmtLines@36(RegdInvtMovementHdr@1003 : Record 7344;VAR TempAssemblyLine@1000 : TEMPORARY Record 901;ActionType@1002 : Option;BinCode@1004 : Code[20];NotEnoughItemNo@1005 : Code[20];NotEnoughQty@1006 : Decimal;AdditionalBinQty@1007 : Decimal);
    VAR
      RegdInvtMovementLn@1001 : Record 7345;
    BEGIN
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;

      REPEAT
        IF TempAssemblyLine."No." = NotEnoughItemNo THEN BEGIN
          VerifyRegInvtMvmtLine(RegdInvtMovementHdr,TempAssemblyLine,ActionType,BinCode,
            NotEnoughQty);
        END ELSE
          VerifyRegInvtMvmtLine(RegdInvtMovementHdr,TempAssemblyLine,ActionType,BinCode,
            TempAssemblyLine."Quantity to Consume");

      UNTIL TempAssemblyLine.NEXT = 0;

      IF AdditionalBinQty > 0 THEN BEGIN
        TempAssemblyLine.RESET;
        TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
        TempAssemblyLine.SETRANGE("No.",NotEnoughItemNo);
        TempAssemblyLine.FINDFIRST;

        IF ActionType = RegdInvtMovementLn."Action Type"::Take THEN
          VerifyRegInvtMvmtLine(RegdInvtMovementHdr,TempAssemblyLine,ActionType,LocationAdditionalBinCode,
            AdditionalBinQty)
        ELSE
          VerifyRegInvtMvmtLine(RegdInvtMovementHdr,TempAssemblyLine,ActionType,BinCode,
            AdditionalBinQty);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE VerifyRegInvtMvmtLine@34(RegdInvtMovementHdr@1003 : Record 7344;VAR TempAssemblyLine@1000 : TEMPORARY Record 901;ActionType@1002 : Option;BinCode@1004 : Code[20];Qty@1008 : Decimal);
    VAR
      RegdInvtMovementLn@1001 : Record 7345;
    BEGIN
      RegdInvtMovementLn.RESET;
      RegdInvtMovementLn.SETRANGE("No.",RegdInvtMovementHdr."No.");
      RegdInvtMovementLn.SETRANGE("Action Type",ActionType);
      RegdInvtMovementLn.SETRANGE("Bin Code",BinCode);
      RegdInvtMovementLn.SETRANGE("Location Code",TempAssemblyLine."Location Code");
      RegdInvtMovementLn.SETRANGE("Item No.",TempAssemblyLine."No.");
      RegdInvtMovementLn.SETRANGE(Description,TempAssemblyLine.Description);
      RegdInvtMovementLn.SETRANGE("Unit of Measure Code",TempAssemblyLine."Unit of Measure Code");
      RegdInvtMovementLn.SETRANGE("Qty. per Unit of Measure",1);
      RegdInvtMovementLn.SETRANGE("Due Date",TempAssemblyLine."Due Date");

      RegdInvtMovementLn.SETRANGE(Quantity,Qty);
      RegdInvtMovementLn.SETRANGE("Qty. (Base)",Qty);

      Assert.AreEqual(1,RegdInvtMovementLn.COUNT,COPYSTR('There are not 1 registered Invt mvmt lines within the filter: ' +
          RegdInvtMovementLn.GETFILTERS,1,1024));
    END;

    [Normal]
    LOCAL PROCEDURE VerifyWhseActivityLines@21(WhseActivityHdr@1003 : Record 5766;VAR TempAssemblyLine@1000 : TEMPORARY Record 901;ActionType@1002 : Option;BinCode@1004 : Code[20];NotEnoughItemNo@1005 : Code[20];NotEnoughQty@1006 : Decimal;AdditionalBinQty@1007 : Decimal);
    VAR
      WhseActivityLine@1001 : Record 5767;
    BEGIN
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;

      REPEAT
        IF TempAssemblyLine."No." = NotEnoughItemNo THEN
          VerifyWhseActivityLine(WhseActivityHdr,TempAssemblyLine,ActionType,BinCode,NotEnoughQty,NotEnoughQty)
        ELSE
          VerifyWhseActivityLine(WhseActivityHdr,TempAssemblyLine,ActionType,BinCode,TempAssemblyLine."Quantity to Consume",
            TempAssemblyLine."Quantity to Consume");
      UNTIL TempAssemblyLine.NEXT = 0;

      IF AdditionalBinQty > 0 THEN BEGIN
        TempAssemblyLine.RESET;
        TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
        TempAssemblyLine.SETRANGE("No.",NotEnoughItemNo);
        TempAssemblyLine.FINDFIRST;

        IF ActionType = WhseActivityLine."Action Type"::Take THEN
          VerifyWhseActivityLine(
            WhseActivityHdr,TempAssemblyLine,ActionType,LocationAdditionalBinCode,AdditionalBinQty,AdditionalBinQty)
        ELSE
          VerifyWhseActivityLine(WhseActivityHdr,TempAssemblyLine,ActionType,BinCode,AdditionalBinQty,AdditionalBinQty);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE VerifyWhseActivityLine@32(WhseActivityHdr@1003 : Record 5766;VAR TempAssemblyLine@1000 : TEMPORARY Record 901;ActionType@1002 : Option;BinCode@1004 : Code[20];Qty@1006 : Decimal;QtyToHandle@1007 : Decimal);
    VAR
      WhseActivityLine@1001 : Record 5767;
    BEGIN
      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHdr."No.");
      WhseActivityLine.SETRANGE("Action Type",ActionType);
      WhseActivityLine.SETRANGE("Location Code",TempAssemblyLine."Location Code");
      WhseActivityLine.SETRANGE("Item No.",TempAssemblyLine."No.");
      WhseActivityLine.SETRANGE("Bin Code",BinCode);
      WhseActivityLine.SETRANGE(Quantity,Qty);

      Assert.AreEqual(1,WhseActivityLine.COUNT,COPYSTR('There is no whse activity line within the filter: ' +
          WhseActivityLine.GETFILTERS,1,1024));
      WhseActivityLine.FINDFIRST;

      Assert.AreEqual(TempAssemblyLine.Description,WhseActivityLine.Description,'Incorrect descriprion');
      Assert.AreEqual(TempAssemblyLine."Unit of Measure Code",WhseActivityLine."Unit of Measure Code",'Incorrect UOM');
      Assert.AreEqual(TempAssemblyLine."Due Date",WhseActivityLine."Due Date",'Incorrect due date');
      Assert.AreEqual(1,WhseActivityLine."Qty. per Unit of Measure",'Incorrect qty per UOM');
      Assert.AreEqual(Qty,WhseActivityLine."Qty. (Base)",'Incorrect qty base');

      Assert.AreEqual(QtyToHandle,WhseActivityLine."Qty. to Handle",'incorrect qty to handle');
      IF QtyToHandle > 0 THEN
        Assert.AreEqual(Qty - QtyToHandle,WhseActivityLine."Qty. Handled",'incorrect qty. handled')
      ELSE
        Assert.AreEqual(0,WhseActivityLine."Qty. Handled",'incorrect qty. handled');
    END;

    LOCAL PROCEDURE AddCompInventoryNotEnough@11(AssemblyHeader@1001 : Record 900;NotEnoughNo@1003 : Integer;VAR NotEnoughItemNo@1006 : Code[20];CompQtyFactor@1007 : Integer;VAR ResultQtys@1004 : ARRAY [10] OF Decimal;AddAdditionalQty@1009 : Boolean;BinToPutCode@1000 : Code[20]);
    VAR
      Item@1002 : Record 27;
      AssemblyLine@1010 : Record 901;
      i@1005 : Integer;
      ItemsCount@1008 : Integer;
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.FINDSET;

      // Calculate result quantities
      i := 1;
      REPEAT
        ResultQtys[i] := AssemblyLine.Quantity * CompQtyFactor / 100;
        IF i = NotEnoughNo THEN BEGIN
          Item.GET(AssemblyLine."No.");
          NotEnoughItemNo := Item."No.";
          ResultQtys[i] := ROUND(ResultQtys[i],0.00001,'>');
          ResultQtys[i] -= 0.00002;
          ItemsCount := AssemblyLine.COUNT + 1;
          ResultQtys[ItemsCount] := 0.00002;
        END ELSE
          ResultQtys[i] := ROUND(ResultQtys[i],0.00001,'>');

        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add inventory
      i := 1;
      AssemblyLine.FINDSET;
      REPEAT
        LibraryAssembly.AddItemInventory(AssemblyLine,WorkDate2,AssemblyLine."Location Code",BinToPutCode,ResultQtys[i]);
        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add rest inventory to additional bin
      IF AddAdditionalQty THEN BEGIN
        AssemblyLine.RESET;
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
        AssemblyLine.SETRANGE("No.",NotEnoughItemNo);
        AssemblyLine.FINDFIRST;

        LibraryAssembly.AddItemInventory(
          AssemblyLine,WorkDate2,AssemblyLine."Location Code",LocationAdditionalBinCode,ResultQtys[ItemsCount]);
      END;
    END;

    LOCAL PROCEDURE LocationSetupBM@60(VAR Location@1000 : Record 14);
    VAR
      WarehouseEmployee@1001 : Record 7301;
      Bin@1002 : Record 7354;
    BEGIN
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      LibraryWarehouse.CreateWarehouseEmployee(WarehouseEmployee,Location.Code,FALSE);

      // Skip validate trigger for bin mandatory to improve performance.
      Location."Bin Mandatory" := TRUE;
      Location.MODIFY(TRUE);

      AssignBinCodesBM;

      LibraryWarehouse.CreateBin(Bin,Location.Code,LocationAdditionalBinCode,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,LocationToBinCode,'','');
      LibraryWarehouse.CreateBin(Bin,Location.Code,LocationFromBinCode,'','');
      Location.VALIDATE("From-Assembly Bin Code",LocationFromBinCode);
      Location.VALIDATE("To-Assembly Bin Code",LocationToBinCode);
      Location.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE LocationSetupInvtMvmt@2(VAR Location@1000 : Record 14);
    VAR
      Bin@1002 : Record 7354;
    BEGIN
      LocationSetupBM(Location);
      // Skip validate trigger to improve performance.
      Location."Require Pick" := TRUE;

      AssignBinCodesInvtMvmt;

      LibraryWarehouse.CreateBin(Bin,Location.Code,LocationTakeBinCode,'','');
      Location.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE AssignBinCodesBM@63();
    BEGIN
      LocationAdditionalBinCode := 'ABin';
      LocationToBinCode := 'ToBin';
      LocationFromBinCode := 'FromBin';
      LocationTakeBinCode := '';
      LocationAdditionalPickBinCode := '';
    END;

    [Normal]
    LOCAL PROCEDURE AssignBinCodesInvtMvmt@62();
    BEGIN
      AssignBinCodesBM;

      LocationTakeBinCode := 'TakeBin';
    END;

    [Normal]
    LOCAL PROCEDURE PostAssemblyHeader@172(AssemblyHeaderNo@1000 : Code[20];ExpectedError@1002 : Text[1024]);
    VAR
      AssemblyHeader@1003 : Record 900;
    BEGIN
      AssemblyHeader.INIT;
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,ExpectedError);
    END;

    LOCAL PROCEDURE NormalPostingInvtMvmt@4(HeaderQtyFactor@1012 : Decimal;PartialPostFactor@1011 : Decimal;QtySupplement@1018 : Decimal) : Code[20];
    VAR
      TempAssemblyLine@1007 : TEMPORARY Record 901;
      AssemblyHeader@1019 : Record 900;
      AssembledQty@1013 : Decimal;
    BEGIN
      AssignBinCodesInvtMvmt;

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationInvtMvmt.Code,LibraryRandom.RandIntInRange(1,3));

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,QtySupplement,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);
      AssembledQty := AssemblyHeader."Quantity to Assemble";
      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      CreateInvtMovementAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,'',0,0);

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify.
      VerifyBinContentsMvmt(AssemblyHeader,TempAssemblyLine,QtySupplement,AssembledQty);

      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      VerifyWarehouseEntries(AssemblyHeader,TempAssemblyLine,AssembledQty,TRUE,TempAssemblyLine.COUNT + 1);
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssembledQty);
      LibraryAssembly.VerifyItemRegister(AssemblyHeader);

      EXIT(AssemblyHeader."No.");
    END;

    [Normal]
    LOCAL PROCEDURE CreateInvtMovementAndVerify@22(AssemblyHeaderNo@1000 : Code[20];VAR TempAssemblyLine@1001 : TEMPORARY Record 901;ExpectedNoOfRegInvtMmnt@1004 : Integer;NotEnoughItemNo@1003 : Code[20];NotEnoughQty@1002 : Decimal;AdditionalBinQty@1005 : Decimal);
    VAR
      WhseActivityHeader@1006 : Record 5766;
      AssemblyHeader@1008 : Record 900;
    BEGIN
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      AutoFillQtyInventoryActivity(AssemblyHeader);
      VerifyWhseActivity(AssemblyHeader,TempAssemblyLine,WhseActivityHeader,NotEnoughItemNo,NotEnoughQty,AdditionalBinQty);

      LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);
      VerifyRegInvtMvmt(AssemblyHeader,TempAssemblyLine,WhseActivityHeader."No.",ExpectedNoOfRegInvtMmnt,NotEnoughItemNo,
        NotEnoughQty,
        AdditionalBinQty);
    END;

    [MessageHandler]
    PROCEDURE MvmtMessageHandler@27(Message@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(STRPOS(Message,MSG_MVMT_CREATED) > 0,
        PADSTR('Actual:' + Message + ',Expected:' + MSG_MVMT_CREATED,1024));
    END;

    LOCAL PROCEDURE MoveNotEnoughItemInvtMvmt@67(HeaderQtyFactor@1016 : Integer;PartialPostFactor@1017 : Integer);
    VAR
      TempAssemblyLine@1011 : TEMPORARY Record 901;
      AssemblyHeader@1009 : Record 900;
      WhseActivityHeader@1013 : Record 5766;
      WhseActivityLine@1014 : Record 5767;
      NotEnoughItemNo@1008 : Code[20];
      NotEnoughNo@1005 : Integer;
      NoOfItems@1004 : Integer;
      NotEnoughQty@1015 : Decimal;
    BEGIN
      AssignBinCodesInvtMvmt;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationInvtMvmt.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      // Create Inventory Movement and Verify
      LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      AutoFillQtyInventoryActivity(AssemblyHeader);
      VerifyWhseActivity(AssemblyHeader,TempAssemblyLine,WhseActivityHeader,'',0,0);

      // Reduce Quantity to Handled of one of the items
      NotEnoughNo := LibraryRandom.RandIntInRange(1,NoOfItems);
      UpdateWhseActivityLine(NotEnoughNo,NotEnoughItemNo,NotEnoughQty,TempAssemblyLine,WhseActivityHeader,-0.00001);

      // Register Inventory Movement and verify
      LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);
      VerifyRegInvtMvmt(AssemblyHeader,TempAssemblyLine,WhseActivityHeader."No.",1,NotEnoughItemNo,NotEnoughQty,0);

      // Post asssembly order
      PostAssemblyHeader(AssemblyHeader."No.",MSG_WHSE_HANDLING_REQUIRED);

      // Verify inventory movemennt with rest of the item
      VerifyWhseActivityHeader(AssemblyHeader,WhseActivityHeader);

      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");

      Assert.AreEqual(
        2,WhseActivityLine.COUNT,COPYSTR('There are not 2 whse activ. lines within the filter: ' + WhseActivityHeader.GETFILTERS,1,1024)
        );

      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.SETRANGE("No.",NotEnoughItemNo);
      TempAssemblyLine.FINDFIRST;

      VerifyWhseActivityLine(WhseActivityHeader,TempAssemblyLine,WhseActivityLine."Action Type"::Take,LocationTakeBinCode,
        TempAssemblyLine."Quantity to Consume",TempAssemblyLine."Quantity to Consume" - NotEnoughQty);
      VerifyWhseActivityLine(WhseActivityHeader,TempAssemblyLine,WhseActivityLine."Action Type"::Place,LocationToBinCode,
        TempAssemblyLine."Quantity to Consume",TempAssemblyLine."Quantity to Consume" - NotEnoughQty);

      // Register inventory movement
      LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);
      VerifyRegInvtMvmtHeader(AssemblyHeader,2);

      // Post assembly order
      PostAssemblyHeader(AssemblyHeader."No.",'');
    END;

    LOCAL PROCEDURE NotEnoughItemPostingInvtMvmt@52(HeaderQtyFactor@1012 : Decimal;PartialPostFactor@1011 : Decimal;AddAdditionalQty@1000 : Boolean);
    VAR
      TempAssemblyLine@1007 : TEMPORARY Record 901;
      AssemblyHeader@1022 : Record 900;
      ExpectedErrorMessage@1002 : Text[1024];
      NotEnoughItemNo@1015 : Code[20];
      NotEnoughNo@1018 : Integer;
      NoOfItems@1019 : Integer;
      Qtys@1017 : ARRAY [10] OF Decimal;
    BEGIN
      AssignBinCodesInvtMvmt;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationInvtMvmt.Code,NoOfItems);

      NotEnoughNo := LibraryRandom.RandIntInRange(1,NoOfItems);
      AddCompInventoryNotEnough(AssemblyHeader,NotEnoughNo,NotEnoughItemNo,PartialPostFactor,Qtys,AddAdditionalQty,
        LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      IF AddAdditionalQty THEN
        CreateInvtMovementAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,NotEnoughItemNo,Qtys[NotEnoughNo],Qtys[NoOfItems + 1])
      ELSE
        CreateInvtMovementAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,NotEnoughItemNo,Qtys[NotEnoughNo],0);

      IF AddAdditionalQty THEN
        ExpectedErrorMessage := ''
      ELSE
        ExpectedErrorMessage := STRSUBSTNO(MSG_NOT_ON_INVT1,NotEnoughItemNo);

      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessage);
    END;

    [Normal]
    LOCAL PROCEDURE UpdateWhseActivityLine@54(NoToChange@1000 : Integer;VAR ChangedItemNo@1004 : Code[20];VAR ChangedItemQty@1005 : Decimal;VAR TempAssemblyLine@1001 : TEMPORARY Record 901;WhseActivityHeader@1007 : Record 5766;QtyToAdd@1002 : Decimal);
    VAR
      WhseActivityLine@1003 : Record 5767;
      i@1006 : Integer;
    BEGIN
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      TempAssemblyLine.FINDSET;

      i := 1;
      REPEAT
        IF i = NoToChange THEN
          ChangedItemNo := TempAssemblyLine."No.";
        i += 1;
      UNTIL TempAssemblyLine.NEXT = 0;

      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");
      WhseActivityLine.SETRANGE("Item No.",ChangedItemNo);
      Assert.AreEqual(2,WhseActivityLine.COUNT,COPYSTR('There are not 2 registered whse activity lines within the filter: ' +
          WhseActivityLine.GETFILTERS,1,1024));

      WhseActivityLine.FINDSET;
      ChangedItemQty := ROUND(WhseActivityLine.Quantity,0.00001,'<');
      ChangedItemQty += QtyToAdd;

      REPEAT
        WhseActivityLine.VALIDATE("Qty. to Handle",ChangedItemQty);
        WhseActivityLine.MODIFY(TRUE);
      UNTIL WhseActivityLine.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE AutoFillQtyInventoryActivity@138(AssemblyHeader@1000 : Record 900);
    VAR
      WhseActivityLine@1002 : Record 5767;
      WhseActivityHeader@1001 : Record 5766;
    BEGIN
      WhseActivityHeader.RESET;
      WhseActivityHeader.SETRANGE("Location Code",AssemblyHeader."Location Code");
      WhseActivityHeader.FINDLAST;

      // Check that quantity is not autofilled
      IF WhseActivityHeader.Type <> WhseActivityHeader.Type::Pick THEN BEGIN
        WhseActivityLine.RESET;
        WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");

        REPEAT
          Assert.AreEqual(0,WhseActivityLine."Qty. to Handle",'Incorrect value');
        UNTIL WhseActivityLine.NEXT = 0;

        LibraryWarehouse.AutoFillQtyInventoryActivity(WhseActivityHeader);
      END;
    END;

    LOCAL PROCEDURE PostingPartialIT@124(Location@1001 : Record 14;WhseActivity@1002 : Option;ExpectedErrorMessage@1000 : Text[1024];AssignITBeforeWhseAct@1005 : Boolean;AssignITOnWhseAct@1008 : Boolean);
    VAR
      AssemblyHeader@1019 : Record 900;
    BEGIN
      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,100);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,TRUE,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,TRUE,FALSE,'-');
      END;

      ASSERTERROR CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,TRUE,'-','');
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ExpectedErrorMessage) > 0,
        COPYSTR('Actual:' + GETLASTERRORTEXT + ',Expected:' + ExpectedErrorMessage,1,1024));
      CLEARLASTERROR;
    END;

    LOCAL PROCEDURE Post2Steps@122(Location@1000 : Record 14;WhseActivity@1002 : Option;AssignITBeforeWhseAct@1005 : Boolean;AssignITOnWhseAct@1006 : Boolean);
    VAR
      AssemblyHeader@1003 : Record 900;
      AssemblyLine@1007 : Record 901;
      TempAssemblyLine2@1008 : TEMPORARY Record 901;
      ReleaseAssemblyDoc@1004 : Codeunit 903;
      AssemblyHeaderNo@1010 : Code[20];
      HeaderQtyFactor@1001 : Decimal;
    BEGIN
      HeaderQtyFactor := LibraryRandom.RandIntInRange(50,60);

      AssemblyHeaderNo := NormalPostingIT(Location,HeaderQtyFactor,0,WhseActivity,'',AssignITBeforeWhseAct,AssignITOnWhseAct,FALSE);

      // Post rest of the asembly order
      AssemblyHeader.RESET;
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationTakeBinCode);

      ReleaseAssemblyDoc.Reopen(AssemblyHeader);

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");

      AssemblyLine.FINDSET;
      REPEAT
        IF AssemblyLine."Quantity to Consume" > 0 THEN BEGIN
          AssemblyLine.VALIDATE("Quantity to Consume",1);
          AssemblyLine.MODIFY(TRUE);
          TempAssemblyLine2 := AssemblyLine;
          TempAssemblyLine2.INSERT
        END;
      UNTIL (AssemblyLine.NEXT = 0);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,FALSE,TRUE,'+')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,FALSE,FALSE,'+');
      END;

      CreateAndRegisterWhseActivity(AssemblyHeaderNo,WhseActivity,AssignITOnWhseAct,FALSE,'+','');

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
    END;

    [Normal]
    LOCAL PROCEDURE ReuseFromAnotherOrder@121(Location@1002 : Record 14;WhseActivity@1000 : Option;AssignITBeforeWhseAct@1005 : Boolean;AssignITOnWhseAct@1003 : Boolean);
    VAR
      AssemblyHeader2@1019 : Record 900;
      AssemblyHeader@1011 : Record 900;
      ReleaseAssemblyDoc@1004 : Codeunit 903;
      HeaderQtyFactor@1015 : Decimal;
      Qty1@1006 : Integer;
    BEGIN
      HeaderQtyFactor := 100;

      Qty1 := LibraryRandom.RandIntInRange(6,8);
      CreateAssemblyOrder(Location,Qty1,AssemblyHeader);

      PurchaseComponentsToBin(AssemblyHeader,Qty1,Location,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,FALSE,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,FALSE,FALSE,'-');
      END;

      CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,FALSE,'-','');

      ReleaseAssemblyDoc.Reopen(AssemblyHeader);

      HeaderQtyFactor := 40;
      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      // Post asssembly order
      PostAssemblyHeader(AssemblyHeader."No.",'');

      // Create and post another assembly order
      CreateAssemblyOrder(Location,ROUND(Qty1 * (100 - HeaderQtyFactor) / 100,1,'<'),AssemblyHeader2);

      PrepareOrderPosting(AssemblyHeader2,100);

      AssignITToAssemblyLines(AssemblyHeader2,FALSE,TRUE,'-');

      // Components should not be reserved for first order so we expect posting to go correctly
      PostAssemblyHeader(AssemblyHeader2."No.",'');
    END;

    LOCAL PROCEDURE PurchaseComponentsToBin@120(AssemblyHeader@1000 : Record 900;QtySupplement@1001 : Decimal;Location@1007 : Record 14;BinCode@1006 : Code[20]);
    VAR
      AssemblyLine@1003 : Record 901;
      PurchaseHeader@1002 : Record 38;
    BEGIN
      CreatePurchaseHeader(Location.Code,PurchaseHeader);

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      IF AssemblyLine.FINDSET THEN
        REPEAT
          CreatePurchaseLine(PurchaseHeader,AssemblyLine."No.",Location,BinCode,
            ROUND(AssemblyLine.Quantity + QtySupplement,1,'>'));
        UNTIL AssemblyLine.NEXT = 0;

      PostPurchaseHeader(PurchaseHeader,Location,'');
    END;

    LOCAL PROCEDURE PurchaseComponentsNotEnough@118(Location@1012 : Record 14;AssemblyHeader@1001 : Record 900;NotEnoughNo@1003 : Integer;VAR NotEnoughItemNo@1006 : Code[20];CompQtyFactor@1007 : Integer;VAR ResultQtys@1004 : ARRAY [10] OF Decimal;AddAdditionalQty@1009 : Boolean;BinToPutCode@1000 : Code[20]);
    VAR
      Item@1002 : Record 27;
      AssemblyLine@1010 : Record 901;
      PurchaseHeader@1011 : Record 38;
      i@1005 : Integer;
      ItemsCount@1008 : Integer;
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.FINDSET;

      // Calculate result quantities
      i := 1;
      REPEAT
        ResultQtys[i] := AssemblyLine.Quantity * CompQtyFactor / 100;
        IF i = NotEnoughNo THEN BEGIN
          Item.GET(AssemblyLine."No.");
          NotEnoughItemNo := Item."No.";
          ResultQtys[i] := ROUND(ResultQtys[i],1,'>');
          ResultQtys[i] -= 2;
          ItemsCount := AssemblyLine.COUNT + 1;
          ResultQtys[ItemsCount] := 2;
        END ELSE
          ResultQtys[i] := ROUND(ResultQtys[i],1,'>');

        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add inventory
      CreatePurchaseHeader(Location.Code,PurchaseHeader);

      i := 1;
      AssemblyLine.FINDSET;
      REPEAT
        CreatePurchaseLine(PurchaseHeader,AssemblyLine."No.",Location,BinToPutCode,ResultQtys[i]);
        i += 1;
      UNTIL AssemblyLine.NEXT = 0;

      // Add rest inventory to additional bin
      IF AddAdditionalQty THEN BEGIN
        AssemblyLine.RESET;
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
        AssemblyLine.SETRANGE("No.",NotEnoughItemNo);
        AssemblyLine.FINDFIRST;

        CreatePurchaseLine(PurchaseHeader,AssemblyLine."No.",
          Location,LocationAdditionalBinCode,ResultQtys[ItemsCount]);
        PostPurchaseHeader(PurchaseHeader,Location,NotEnoughItemNo);
      END ELSE
        PostPurchaseHeader(PurchaseHeader,Location,'');
    END;

    [Normal]
    LOCAL PROCEDURE CreateAssemblyOrder@110(Location@1000 : Record 14;Qty@1002 : Integer;VAR AssemblyHeader@1001 : Record 900);
    BEGIN
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,WorkDate2,KitItem."No.",Location.Code,Qty,'');

      CreateAssemblyLine(AssemblyHeader,CompItem."No.",LibraryRandom.RandIntInRange(2,4),FALSE,FALSE);
    END;

    LOCAL PROCEDURE CreateAssemblyLine@108(VAR AssemblyHeader@1000 : Record 900;ItemNo@1002 : Code[20];Quantity@1003 : Integer;AssignBinCode@1004 : Boolean;AssignIT@1005 : Boolean);
    VAR
      AssemblyLine@1001 : Record 901;
      AssemblyOrderPage@1006 : TestPage 900;
    BEGIN
      LibraryKitting.AddLine(AssemblyHeader,AssemblyLine.Type::Item,ItemNo,
        LibraryAssembly.GetUnitOfMeasureCode(AssemblyLine.Type::Item,ItemNo,TRUE),
        Quantity,1,'');

      IF AssignBinCode THEN BEGIN
        AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
        AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
        AssemblyLine.SETRANGE("No.",ItemNo);
        AssemblyLine.FINDLAST;

        AssemblyLine.VALIDATE("Bin Code",LocationAdditionalBinCode);
        AssemblyLine.VALIDATE("Quantity to Consume",Quantity);
        AssemblyLine.MODIFY;
      END;

      IF AssignIT THEN BEGIN
        AssemblyOrderPage.OPENEDIT;
        AssemblyOrderPage.FILTER.SETFILTER("No.",AssemblyHeader."No.");

        AssemblyOrderPage.Lines.LAST;

        PrepareHandleSelectEntries(FALSE);
        AssemblyOrderPage.Lines."Item Tracking Lines".INVOKE;
        AssemblyOrderPage.OK.INVOKE;
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CreateItems@107(ItemTracking@1000 : Option);
    BEGIN
      CreateTrackedItem(CompItem,ItemTracking);
      CreateTrackedItem(KitItem,Tracking::Untracked);
    END;

    LOCAL PROCEDURE CreateTrackedItem@106(VAR Item@1000 : Record 27;TrackingType@1001 : Option);
    VAR
      Serial@1003 : Boolean;
      Lot@1002 : Boolean;
    BEGIN
      LibraryInventory.CreateItem(Item);
      IF TrackingType <> Tracking::Untracked THEN BEGIN
        Lot := (TrackingType = Tracking::Lot) OR (TrackingType = Tracking::LotSerial);
        Serial := (TrackingType = Tracking::Serial) OR (TrackingType = Tracking::LotSerial);
        AssignItemTrackingCode(Item,Lot,Serial);
      END;
    END;

    LOCAL PROCEDURE CreateItemTrackingCode@105(VAR ItemTrackingCode@1000 : Record 6502;Lot@1001 : Boolean;Serial@1002 : Boolean);
    VAR
      LibraryUtility@1003 : Codeunit 131000;
    BEGIN
      IF NOT ItemTrackingCode.GET(Serial) THEN BEGIN
        ItemTrackingCode.INIT;
        ItemTrackingCode.VALIDATE(Code,
          LibraryUtility.GenerateRandomCode(ItemTrackingCode.FIELDNO(Code),DATABASE::"Item Tracking Code"));
        ItemTrackingCode.INSERT(TRUE);
        ItemTrackingCode.VALIDATE("SN Specific Tracking",Serial);
        ItemTrackingCode.VALIDATE("Lot Specific Tracking",Lot);
        ItemTrackingCode.VALIDATE("SN Warehouse Tracking",Serial);
        ItemTrackingCode.VALIDATE("Lot Warehouse Tracking",Lot);
        ItemTrackingCode.MODIFY(TRUE);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchaseHeader@104(LocationCode@1001 : Code[10];VAR PurchaseHeader@1000 : Record 38);
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      PurchaseHeader.VALIDATE("Location Code",LocationCode);
      PurchaseHeader.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchaseLine@103(PurchaseHeader@1000 : Record 38;ItemNo@1002 : Code[20];Location@1003 : Record 14;BinCode@1004 : Code[20];Qty@1005 : Decimal);
    VAR
      PurchaseLine@1001 : Record 39;
    BEGIN
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Qty);
      PurchaseLine.VALIDATE("Location Code",Location.Code);
      IF NOT Location."Require Receive" THEN
        PurchaseLine.VALIDATE("Bin Code",BinCode);
      PurchaseLine.MODIFY(TRUE);

      AssignITToPurchLine(PurchaseHeader,PurchaseLine);
    END;

    [Normal]
    LOCAL PROCEDURE CreateAndRegisterWhseActivity@102(AssemblyHeaderNo@1000 : Code[20];WhseActivity@1007 : Option;AssignITOnWhseAct@1001 : Boolean;ITPartial@1002 : Boolean;FindDirection@1003 : Code[10];ExpectedError@1004 : Text[1024]);
    VAR
      WhseActivityHeader@1006 : Record 5766;
      AssemblyHeader@1008 : Record 900;
    BEGIN
      IF WhseActivity = WhseActivityType::None THEN
        EXIT;

      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      CASE WhseActivity OF
        WhseActivityType::WhsePick:
          LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
        WhseActivityType::InvtMvmt:
          LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      END;

      AutoFillQtyWhseActivity(AssemblyHeader,WhseActivityHeader);

      IF AssignITOnWhseAct THEN
        AssignITWhseActivity(AssemblyHeader,WhseActivityHeader,ITPartial,FindDirection);

      IF ExpectedError = '' THEN
        LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader)
      ELSE BEGIN
        ASSERTERROR LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);
        Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ExpectedError) > 0,
          'Expected:' + ExpectedError + '. Actual:' + GETLASTERRORTEXT);
        CLEARLASTERROR;
      END;
    END;

    [Normal]
    LOCAL PROCEDURE PrepareOrderPosting@100(VAR AssemblyHeader@1000 : Record 900;HeaderQtyFactor@1001 : Integer);
    VAR
      AssemblyLine@1002 : Record 901;
      ITType@1005 : Option;
    BEGIN
      AssemblyHeader.VALIDATE("Quantity to Assemble",AssemblyHeader."Quantity to Assemble" * HeaderQtyFactor / 100);
      AssemblyHeader.MODIFY(TRUE);

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);

      IF AssemblyLine.FINDSET THEN
        REPEAT
          GetItemIT(AssemblyLine."No.",ITType);
          IF (ITType = Tracking::Serial) OR (ITType = Tracking::LotSerial) THEN BEGIN
            AssemblyLine.VALIDATE("Quantity to Consume",ROUND(AssemblyLine."Quantity to Consume",1,'<'));
            AssemblyLine.MODIFY(TRUE)
          END;
        UNTIL (AssemblyLine.NEXT = 0);

      AssemblyHeader.GET(AssemblyHeader."Document Type",AssemblyHeader."No.");
      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);
    END;

    [Normal]
    LOCAL PROCEDURE PostPurchaseHeader@96(PurchaseHeader@1000 : Record 38;Location@1014 : Record 14;NotEnoughItemNo@1002 : Code[20]);
    VAR
      WarehouseReceiptHeader@1011 : Record 7316;
      WarehouseActivityHeader@1004 : Record 5766;
      WarehouseActivityLine@1003 : Record 5767;
      WhseReceiptLine@1001 : Record 7317;
      Bin@1005 : Record 7354;
      GetSourceDocInbound@1008 : Codeunit 5751;
      PurchaseHeaderNo@1012 : Code[20];
    BEGIN
      PurchaseHeaderNo := PurchaseHeader."No.";

      LibraryPurchase.ReleasePurchaseDocument(PurchaseHeader);
      IF Location."Require Receive" THEN BEGIN
        GetSourceDocInbound.CreateFromPurchOrder(PurchaseHeader);

        WhseReceiptLine.SETRANGE("Source Document",WhseReceiptLine."Source Document"::"Purchase Order");
        WhseReceiptLine.SETRANGE("Source No.",PurchaseHeader."No.");
        WhseReceiptLine.FINDFIRST;
        WarehouseReceiptHeader.GET(WhseReceiptLine."No.");
        LibraryWarehouse.PostWhseReceipt(WarehouseReceiptHeader);
      END;

      PurchaseHeader.RESET;
      PurchaseHeader.SETRANGE("No.",PurchaseHeaderNo);
      PurchaseHeader.FINDFIRST;
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      IF Location."Require Put-away" THEN BEGIN
        WarehouseActivityHeader.SETRANGE("Location Code",Location.Code);
        WarehouseActivityHeader.FINDFIRST;
        WarehouseActivityLine.SETRANGE("No.",WarehouseActivityHeader."No.");
        WarehouseActivityLine.FINDFIRST;

        WarehouseActivityLine.AutofillQtyToHandle(WarehouseActivityLine);

        LibraryWarehouse.FindBin(Bin,Location.Code,'PICK',4);
        WarehouseActivityLine.RESET;
        WarehouseActivityLine.SETRANGE("No.",WarehouseActivityHeader."No.");
        WarehouseActivityLine.SETRANGE("Action Type",WarehouseActivityLine."Action Type"::Place);
        IF WarehouseActivityLine.FINDSET THEN
          REPEAT
            WarehouseActivityLine.VALIDATE("Zone Code",'PICK');
            WarehouseActivityLine.VALIDATE("Bin Code",Bin.Code);
            WarehouseActivityLine.MODIFY(TRUE)
          UNTIL (WarehouseActivityLine.NEXT = 0);

        IF (LocationAdditionalPickBinCode <> '') AND (NotEnoughItemNo <> '') THEN BEGIN
          WarehouseActivityLine.RESET;
          WarehouseActivityLine.SETRANGE("No.",WarehouseActivityHeader."No.");
          WarehouseActivityLine.SETRANGE("Item No.",NotEnoughItemNo);
          WarehouseActivityLine.SETRANGE("Action Type",WarehouseActivityLine."Action Type"::Place);
          WarehouseActivityLine.FINDSET;

          WarehouseActivityLine.VALIDATE("Bin Code",LocationAdditionalPickBinCode);
          WarehouseActivityLine.MODIFY(TRUE);
          WarehouseActivityLine.NEXT;
          WarehouseActivityLine.VALIDATE("Bin Code",LocationAdditionalPickBinCode);
          WarehouseActivityLine.MODIFY(TRUE);
        END;

        LibraryWarehouse.RegisterWhseActivity(WarehouseActivityHeader);
      END;
    END;

    LOCAL PROCEDURE MoveNotEnoughItem@92(Location@1002 : Record 14;HeaderQtyFactor@1016 : Integer;WhseActivity@1000 : Option;ExpectedErrorMessage@1001 : Text[1024];AssignITBeforeWhseAct@1003 : Boolean;AssignITOnWhseAct@1006 : Boolean;QtyToAdd@1012 : Integer);
    VAR
      AssemblyHeader@1009 : Record 900;
      WhseActivityHeader@1013 : Record 5766;
    BEGIN
      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,FALSE,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,FALSE,FALSE,'-');
      END;

      // Create Whse Activity
      CASE WhseActivity OF
        WhseActivityType::WhsePick:
          LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
        WhseActivityType::InvtMvmt:
          LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      END;

      AutoFillQtyWhseActivity(AssemblyHeader,WhseActivityHeader);

      // Update Quantity to Handled of one of the items
      UpdateWhseActivityLineIT(WhseActivityHeader,CompItem."No.",QtyToAdd);

      IF AssignITOnWhseAct THEN
        AssignITWhseActivity(AssemblyHeader,WhseActivityHeader,FALSE,'-');

      // Register whse activity
      LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);

      // Post asssembly order
      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessage);

      IF AssignITOnWhseAct THEN
        AssignITWhseActivity(AssemblyHeader,WhseActivityHeader,FALSE,'-');

      // Register rest of the whse activity
      LibraryWarehouse.RegisterWhseActivity(WhseActivityHeader);

      // Post asssembly order
      PostAssemblyHeader(AssemblyHeader."No.",'');
    END;

    [Normal]
    LOCAL PROCEDURE AutoFillQtyWhseActivity@89(AssemblyHeader@1000 : Record 900;VAR WhseActivityHeader@1003 : Record 5766);
    VAR
      WhseActivityLine@1002 : Record 5767;
    BEGIN
      WhseActivityHeader.RESET;
      WhseActivityHeader.SETRANGE("Location Code",AssemblyHeader."Location Code");
      WhseActivityHeader.FINDLAST;

      // Check that quantity is not autofilled
      IF WhseActivityHeader.Type <> WhseActivityHeader.Type::Pick THEN BEGIN
        WhseActivityLine.RESET;
        WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");

        REPEAT
          Assert.AreEqual(0,WhseActivityLine."Qty. to Handle",'Incorrect value');
        UNTIL WhseActivityLine.NEXT = 0;

        LibraryWarehouse.AutoFillQtyInventoryActivity(WhseActivityHeader);
      END;
    END;

    LOCAL PROCEDURE RecreateWhseActivity@87(Location@1000 : Record 14;WhseActivity@1002 : Option;AssignITBeforeWhseAct@1009 : Boolean;AssignITOnWhseAct@1007 : Boolean);
    VAR
      AssemblyHeader@1003 : Record 900;
      WhseActivityHdr@1008 : Record 5766;
      HeaderQtyFactor@1001 : Decimal;
    BEGIN
      HeaderQtyFactor := LibraryRandom.RandIntInRange(50,60);

      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,0,Location,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,FALSE,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,FALSE,FALSE,'-');
      END;

      CASE WhseActivity OF
        WhseActivityType::WhsePick:
          LibraryAssembly.CreateWhsePick(AssemblyHeader,USERID,0,FALSE,FALSE,FALSE);
        WhseActivityType::InvtMvmt:
          LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      END;

      AutoFillQtyWhseActivity(AssemblyHeader,WhseActivityHdr);

      IF AssignITOnWhseAct THEN
        AssignITWhseActivity(AssemblyHeader,WhseActivityHdr,FALSE,'-');

      WhseActivityHdr.DELETE(TRUE);

      CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,FALSE,'-','');

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');
    END;

    LOCAL PROCEDURE AssignItemTrackingCode@86(VAR Item@1000 : Record 27;LotTracked@1001 : Boolean;SerialTracked@1002 : Boolean);
    VAR
      ItemTrackingCode@1003 : Record 6502;
      LibraryUtility@1004 : Codeunit 131000;
    BEGIN
      CreateItemTrackingCode(ItemTrackingCode,LotTracked,SerialTracked);

      Item.VALIDATE("Item Tracking Code",ItemTrackingCode.Code);

      Item.VALIDATE("Item Tracking Code",ItemTrackingCode.Code);
      Item.VALIDATE("Serial Nos.",LibraryUtility.GetGlobalNoSeriesCode);

      Item.VALIDATE("Lot Nos.",LibraryUtility.GetGlobalNoSeriesCode);

      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE NormalPostingIT@127(Location@1003 : Record 14;HeaderQtyFactor@1012 : Decimal;QtySupplement@1018 : Decimal;WhseActivity@1002 : Option;ExpectedErrorMessage@1000 : Text[1024];AssignITBeforeWhseAct@1005 : Boolean;AssignITOnWhseAct@1008 : Boolean;ITPartial@1001 : Boolean) : Code[20];
    VAR
      AssemblyHeader@1019 : Record 900;
    BEGIN
      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsToBin(AssemblyHeader,QtySupplement,Location,LocationToBinCode)
      ELSE
        PurchaseComponentsToBin(AssemblyHeader,QtySupplement,Location,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,FALSE,'-');
      END;

      CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,ITPartial,'-','');

      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessage);

      EXIT(AssemblyHeader."No.");
    END;

    [Normal]
    LOCAL PROCEDURE GetItemIT@84(ItemNo@1000 : Code[20];VAR ITType@1003 : Option);
    VAR
      Item@1001 : Record 27;
      ItemTrackingCode@1002 : Record 6502;
    BEGIN
      Item.GET(ItemNo);

      IF Item."Item Tracking Code" = '' THEN
        EXIT;

      ItemTrackingCode.GET(Item."Item Tracking Code");

      ITType := Tracking::Untracked;

      IF ItemTrackingCode."Lot Specific Tracking" AND ItemTrackingCode."SN Specific Tracking" THEN
        ITType := Tracking::LotSerial
      ELSE
        IF (NOT ItemTrackingCode."Lot Specific Tracking") AND ItemTrackingCode."SN Specific Tracking" THEN
          ITType := Tracking::Serial
        ELSE
          IF ItemTrackingCode."Lot Specific Tracking" AND (NOT ItemTrackingCode."SN Specific Tracking") THEN
            ITType := Tracking::Lot;
    END;

    [Normal]
    LOCAL PROCEDURE PrepareHandleSelectEntries@83(ITPartial@1000 : Boolean);
    BEGIN
      GLB_ITPageHandler := GLB_ITPageHandler::SelectITSpec;
      PAR_ITPage_AssignPartial := ITPartial;
    END;

    [Normal]
    LOCAL PROCEDURE PrepareHandlePutManually@82(ItemNo@1001 : Code[20];ITType@1002 : Option;ITPartial@1000 : Boolean;Quantity@1003 : Decimal;FindDir@1004 : Code[10]);
    BEGIN
      GLB_ITPageHandler := GLB_ITPageHandler::PutManuallyITSpec;
      PAR_ITPage_AssignLot := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Lot);
      PAR_ITPage_AssignSerial := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Serial);
      PAR_ITPage_AssignPartial := ITPartial;
      PAR_ITPage_AssignQty := Quantity;
      PAR_ITPage_ITNo := ItemNo;
      PAR_ITPage_FINDDIR := FindDir;
    END;

    LOCAL PROCEDURE PrepareHandleAssignPartial@109(ITType@1001 : Option;Quantity@1000 : Decimal);
    BEGIN
      GLB_ITPageHandler := GLB_ITPageHandler::AssignITSpec;
      PAR_ITPage_AssignLot := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Lot);
      PAR_ITPage_AssignSerial := (ITType = Tracking::LotSerial) OR (ITType = Tracking::Serial);
      PAR_ITPage_AssignPartial := TRUE;
      PAR_ITPage_AssignQty := Quantity;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage@80(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      CASE GLB_ITPageHandler OF
        GLB_ITPageHandler::AssignITSpec,GLB_ITPageHandler::AssignITSpecPartial:
          BEGIN
            IF PAR_ITPage_AssignSerial THEN
              HNDL_ITPage_AssignSerial(ItemTrackingLinesPage)
            ELSE
              IF PAR_ITPage_AssignLot THEN
                HNDL_ITPage_AssignLot(ItemTrackingLinesPage);
          END;
        GLB_ITPageHandler::SelectITSpec:
          HNDL_ITPage_SelectEntries(ItemTrackingLinesPage);
        GLB_ITPageHandler::PutManuallyITSpec:
          HNDL_ITPage_PutITManually(ItemTrackingLinesPage);
      END
    END;

    [ModalPageHandler]
    [HandlerFunctions(HNDL_EnterQty)]
    PROCEDURE HNDL_ITPage_AssignSerial@79(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      ItemTrackingLinesPage."Assign Serial No.".INVOKE;
      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage_AssignLot@77(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      ItemTrackingLinesPage."Assign Lot No.".INVOKE; // Assign Lot No.
      IF PAR_ITPage_AssignPartial THEN
        ItemTrackingLinesPage."Quantity (Base)".SETVALUE(PAR_ITPage_AssignQty);
      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage_SelectEntries@76(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    BEGIN
      ItemTrackingLinesPage."Select Entries".INVOKE; // Select Entries
      IF PAR_ITPage_AssignPartial THEN BEGIN
        ItemTrackingLinesPage.LAST;
        ItemTrackingLinesPage."Quantity (Base)".SETVALUE(ItemTrackingLinesPage."Quantity (Base)".ASINTEGER - 1);
      END;

      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_ITPage_PutITManually@73(VAR ItemTrackingLinesPage@1000 : TestPage 6510);
    VAR
      ItemLedgerEntry@1001 : Record 32;
      TrackedQty@1003 : Integer;
    BEGIN
      ItemLedgerEntry.RESET;
      ItemLedgerEntry.SETRANGE("Item No.",PAR_ITPage_ITNo);
      ItemLedgerEntry.FIND(PAR_ITPage_FINDDIR);

      TrackedQty := ItemLedgerEntry.COUNT;

      IF (ItemLedgerEntry."Serial No." <> '') AND (PAR_ITPage_AssignQty < ItemLedgerEntry.COUNT) THEN
        TrackedQty := PAR_ITPage_AssignQty;

      IF PAR_ITPage_AssignPartial THEN
        TrackedQty -= 1;

      IF ItemTrackingLinesPage.LAST THEN
        ItemTrackingLinesPage.NEXT;

      WHILE TrackedQty > 0 DO BEGIN
        TrackedQty -= 1;

        IF STRLEN(ItemLedgerEntry."Serial No.") > 0 THEN
          ItemTrackingLinesPage."Serial No.".SETVALUE(ItemLedgerEntry."Serial No.");
        IF STRLEN(ItemLedgerEntry."Lot No.") > 0 THEN
          ItemTrackingLinesPage."Lot No.".SETVALUE(ItemLedgerEntry."Lot No.");

        IF PAR_ITPage_AssignQty < ItemLedgerEntry.Quantity THEN
          ItemTrackingLinesPage."Quantity (Base)".SETVALUE(PAR_ITPage_AssignQty)
        ELSE
          ItemTrackingLinesPage."Quantity (Base)".SETVALUE(ItemLedgerEntry.Quantity);
        IF ItemLedgerEntry.NEXT <> 0 THEN
          ItemTrackingLinesPage.NEXT;
      END;

      ItemTrackingLinesPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNDL_EnterQty@71(VAR EnterQuantityPage@1000 : TestPage 6513);
    BEGIN
      IF PAR_ITPage_AssignLot THEN
        EnterQuantityPage.CreateNewLotNo.VALUE := 'yes';
      IF PAR_ITPage_AssignPartial THEN
        EnterQuantityPage.QtyToCreate.SETVALUE(PAR_ITPage_AssignQty);
      EnterQuantityPage.OK.INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE HNLD_ItemTrackingSummary@94(VAR ItemTrackingSummaryPage@1000 : TestPage 6500);
    BEGIN
      ItemTrackingSummaryPage.OK.INVOKE;
    END;

    LOCAL PROCEDURE AssignITToPurchLine@41(PurchaseHeader@1001 : Record 38;PurchaseLine@1000 : Record 39);
    VAR
      PurchaseOrderPage@1004 : TestPage 50;
      ITType@1002 : Option;
    BEGIN
      GetItemIT(PurchaseLine."No.",ITType);

      IF ITType = Tracking::Untracked THEN
        EXIT;

      PurchaseOrderPage.OPENEDIT;
      PurchaseOrderPage.FILTER.SETFILTER("No.",PurchaseHeader."No.");

      PurchaseOrderPage.PurchLines.LAST;

      PrepareHandleAssignPartial(ITType,PurchaseLine.Quantity);
      PurchaseOrderPage.PurchLines."Item Tracking Lines".INVOKE;

      PurchaseOrderPage.OK.INVOKE;
    END;

    LOCAL PROCEDURE AssignITToAssemblyLines@66(VAR AssemblyHeader@1000 : Record 900;ITPartial@1002 : Boolean;SelectEntries@1004 : Boolean;FindDir@1005 : Code[10]);
    VAR
      AssemblyLine@1001 : Record 901;
      AssemblyOrderPage@1003 : TestPage 900;
    BEGIN
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.FINDSET;

      AssemblyOrderPage.OPENEDIT;
      AssemblyOrderPage.FILTER.SETFILTER("No.",AssemblyHeader."No.");

      REPEAT
        AssignITToAsmLine(AssemblyLine."No.",AssemblyLine."Quantity to Consume",ITPartial,SelectEntries,AssemblyOrderPage,FindDir);
      UNTIL AssemblyLine.NEXT = 0;

      AssemblyOrderPage.OK.INVOKE;
    END;

    LOCAL PROCEDURE AssignITToAsmLine@40(ItemNo@1002 : Code[20];Quantity@1006 : Decimal;ITPartial@1004 : Boolean;SelectEntries@1003 : Boolean;AssemblyOrderPage@1001 : TestPage 900;FindDir@1000 : Code[10]);
    VAR
      ITType@1005 : Option;
    BEGIN
      GetItemIT(ItemNo,ITType);

      IF ITType = Tracking::Untracked THEN
        EXIT;

      AssemblyOrderPage.Lines.FILTER.SETFILTER("No.",ItemNo);

      IF SelectEntries THEN
        PrepareHandleSelectEntries(ITPartial)
      ELSE
        PrepareHandlePutManually(ItemNo,ITType,ITPartial,Quantity,FindDir);

      AssemblyOrderPage.Lines."Item Tracking Lines".INVOKE;
    END;

    [Normal]
    LOCAL PROCEDURE AssignITWhseActivity@35(AssemblyHeader@1000 : Record 900;WhseActivityHeader@1001 : Record 5766;ITPartial@1002 : Boolean;FindDirection@1004 : Code[10]);
    VAR
      AssemblyLine@1003 : Record 901;
    BEGIN
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);

      IF AssemblyLine.FINDSET THEN
        REPEAT
          AssingITWhseActivityLine(AssemblyLine."No.",WhseActivityHeader,ITPartial,FindDirection);
        UNTIL (AssemblyLine.NEXT = 0);
    END;

    LOCAL PROCEDURE AssingITWhseActivityLine@20(ItemNo@1001 : Code[20];WhseActivityHeader@1000 : Record 5766;ITPartial@1005 : Boolean;FindDirection@1008 : Code[10]);
    VAR
      WhseActivityLineTake@1002 : Record 5767;
      WhseActivityLinePlace@1003 : Record 5767;
      ItemLedgerEntry@1004 : Record 32;
      TrackedQty@1006 : Integer;
    BEGIN
      ItemLedgerEntry.RESET;
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.FIND(FindDirection);

      WhseActivityLineTake.RESET;
      WhseActivityLineTake.SETRANGE("No.",WhseActivityHeader."No.");
      WhseActivityLineTake.SETRANGE("Item No.",ItemNo);
      WhseActivityLineTake.SETRANGE("Serial No.",'');
      WhseActivityLineTake.SETRANGE("Lot No.",'');
      WhseActivityLineTake.SETRANGE("Action Type",WhseActivityLineTake."Action Type"::Take);

      TrackedQty := WhseActivityLineTake.COUNT;
      IF ITPartial THEN
        TrackedQty := WhseActivityLineTake.COUNT - 1;

      REPEAT
        IF TrackedQty = 0 THEN
          EXIT;

        TrackedQty -= 1;
        WhseActivityLineTake.RESET;
        WhseActivityLineTake.SETRANGE("No.",WhseActivityHeader."No.");
        WhseActivityLineTake.SETRANGE("Item No.",ItemNo);
        WhseActivityLineTake.SETRANGE("Serial No.",'');
        WhseActivityLineTake.SETRANGE("Lot No.",'');
        WhseActivityLineTake.SETRANGE("Action Type",WhseActivityLineTake."Action Type"::Take);
        IF NOT WhseActivityLineTake.FINDFIRST THEN
          EXIT; // in case of partial posting whse activity has less lines then in item ledger entries

        WhseActivityLinePlace.RESET;
        WhseActivityLinePlace.SETRANGE("No.",WhseActivityHeader."No.");
        WhseActivityLinePlace.SETRANGE("Item No.",ItemNo);
        WhseActivityLinePlace.SETRANGE("Serial No.",'');
        WhseActivityLinePlace.SETRANGE("Lot No.",'');
        WhseActivityLinePlace.SETRANGE("Action Type",WhseActivityLinePlace."Action Type"::Place);
        WhseActivityLinePlace.FINDFIRST;

        WhseActivityLineTake.VALIDATE("Serial No.",ItemLedgerEntry."Serial No.");
        WhseActivityLinePlace.VALIDATE("Serial No.",ItemLedgerEntry."Serial No.");

        WhseActivityLineTake.VALIDATE("Lot No.",ItemLedgerEntry."Lot No.");
        WhseActivityLinePlace.VALIDATE("Lot No.",ItemLedgerEntry."Lot No.");

        WhseActivityLineTake.MODIFY(TRUE);
        WhseActivityLinePlace.MODIFY(TRUE);

      UNTIL ItemLedgerEntry.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE UpdateWhseActivityLineIT@128(WhseActivityHeader@1007 : Record 5766;ItemNoToUpdate@1000 : Code[20];QtyToAdd@1002 : Decimal);
    VAR
      WhseActivityLine@1003 : Record 5767;
      ChangedItemQty@1004 : Integer;
    BEGIN
      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");
      WhseActivityLine.SETRANGE("Item No.",ItemNoToUpdate);
      WhseActivityLine.SETRANGE("Action Type",WhseActivityLine."Action Type"::Place);
      WhseActivityLine.FINDFIRST;

      ChangedItemQty := ROUND(WhseActivityLine.Quantity,1,'<');
      ChangedItemQty += QtyToAdd;

      WhseActivityLine.VALIDATE("Qty. to Handle",ChangedItemQty);
      WhseActivityLine.MODIFY(TRUE);

      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");
      WhseActivityLine.SETRANGE("Item No.",ItemNoToUpdate);
      WhseActivityLine.SETRANGE("Action Type",WhseActivityLine."Action Type"::Take);
      WhseActivityLine.FINDFIRST;

      ChangedItemQty := ROUND(WhseActivityLine.Quantity,1,'<');
      ChangedItemQty += QtyToAdd;

      WhseActivityLine.VALIDATE("Qty. to Handle",ChangedItemQty);
      WhseActivityLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE NotEnoughItemPostingIT@65(Location@1003 : Record 14;HeaderQtyFactor@1012 : Decimal;PartialPostFactor@1011 : Decimal;AddAdditionalQty@1000 : Boolean;WhseActivity@1002 : Option;ExpectedErrorMessagePost@1004 : Text[1024];ExpectedErrorMessageReg@1007 : Text[1024];AssignITBeforeWhseAct@1006 : Boolean;AssignITOnWhseAct@1005 : Boolean;ITPartial@1001 : Boolean);
    VAR
      AssemblyHeader@1022 : Record 900;
      NotEnoughItemNo@1015 : Code[20];
      NotEnoughNo@1018 : Integer;
      Qtys@1017 : ARRAY [10] OF Decimal;
    BEGIN
      CreateAssemblyOrder(Location,LibraryRandom.RandIntInRange(6,8),AssemblyHeader);

      NotEnoughNo := 1;

      IF WhseActivity = WhseActivityType::None THEN
        PurchaseComponentsNotEnough(
          Location,AssemblyHeader,NotEnoughNo,NotEnoughItemNo,PartialPostFactor,Qtys,AddAdditionalQty,LocationToBinCode)
      ELSE
        PurchaseComponentsNotEnough(
          Location,AssemblyHeader,NotEnoughNo,NotEnoughItemNo,PartialPostFactor,Qtys,AddAdditionalQty,LocationTakeBinCode);

      PrepareOrderPosting(AssemblyHeader,HeaderQtyFactor);

      IF AssignITBeforeWhseAct THEN BEGIN
        IF WhseActivity = WhseActivityType::None THEN
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,TRUE,'-')
        ELSE
          AssignITToAssemblyLines(AssemblyHeader,ITPartial,FALSE,'-');
      END;

      CreateAndRegisterWhseActivity(AssemblyHeader."No.",WhseActivity,AssignITOnWhseAct,ITPartial,'-',ExpectedErrorMessageReg);

      PostAssemblyHeader(AssemblyHeader."No.",ExpectedErrorMessagePost);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtFullPost@7();
    BEGIN
      // TC-IMVMT
      Initialize;
      NormalPostingInvtMvmt(100,100,0);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtFullPartCompPost@75();
    BEGIN
      // TC-IMVMT
      Initialize;
      NormalPostingInvtMvmt(100,LibraryRandom.RandIntInRange(1,99),0);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtPartPost@44();
    BEGIN
      // TC-IMVMT
      Initialize;
      NormalPostingInvtMvmt(LibraryRandom.RandIntInRange(1,99),LibraryRandom.RandIntInRange(1,99),0);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtFullPostQtySupplem@47();
    BEGIN
      // TC-IMVMT
      Initialize;
      NormalPostingInvtMvmt(100,100,LibraryRandom.RandIntInRange(1,10));
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtPartPostQtySupplem@46();
    BEGIN
      // TC-IMVMT
      Initialize;
      NormalPostingInvtMvmt(
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,10));
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtFullPost2Steps@49();
    VAR
      AssemblyHeader@1003 : Record 900;
      AssemblyLine@1007 : Record 901;
      TempAssemblyLine2@1008 : TEMPORARY Record 901;
      AssemblyHeaderNo@1010 : Code[20];
      HeaderQtyFactor@1001 : Decimal;
      PartialPostFactor@1000 : Decimal;
      QtySupplement@1004 : Decimal;
      AssembledQty@1009 : Decimal;
      FullAssembledQty@1011 : Decimal;
    BEGIN
      // TC-IMVMT
      // Test does partial posting and verifies it. Then it posts rest of the order and verifies
      Initialize;
      AssignBinCodesInvtMvmt;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,99);
      PartialPostFactor := HeaderQtyFactor;
      QtySupplement := LibraryRandom.RandIntInRange(1,10);

      AssemblyHeaderNo := NormalPostingInvtMvmt(
          HeaderQtyFactor,
          PartialPostFactor,
          QtySupplement);

      // Post rest of the asembly order
      AssemblyHeader.INIT;
      AssemblyHeader.SETRANGE("No.",AssemblyHeaderNo);
      AssemblyHeader.FINDFIRST;

      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");

      AssemblyLine.FINDSET;
      REPEAT
        IF AssemblyLine."Quantity to Consume" > 0 THEN BEGIN
          TempAssemblyLine2 := AssemblyLine;
          TempAssemblyLine2.INSERT
        END;
      UNTIL (AssemblyLine.NEXT = 0);

      CreateInvtMovementAndVerify(AssemblyHeaderNo,TempAssemblyLine2,2,'',0,0);

      AssembledQty := AssemblyHeader."Quantity to Assemble";
      FullAssembledQty := AssemblyHeader.Quantity;
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify.
      VerifyBinContentsMvmt(AssemblyHeader,TempAssemblyLine2,QtySupplement,FullAssembledQty);

      TempAssemblyLine2.RESET;
      TempAssemblyLine2.SETRANGE(Type,TempAssemblyLine2.Type::Item);
      VerifyWarehouseEntries(AssemblyHeader,TempAssemblyLine2,AssembledQty,TRUE,2 * (TempAssemblyLine2.COUNT + 1));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtPostNotRelease@24();
    VAR
      AssemblyHeader@1003 : Record 900;
      TempAssemblyLine@1004 : TEMPORARY Record 901;
      HeaderQtyFactor@1001 : Decimal;
      PartialPostFactor@1000 : Decimal;
      ATOMovementsCreated@1002 : Integer;
      TotalATOMovementsToBeCreated@1005 : Integer;
    BEGIN
      // TC-IMVMT
      Initialize;
      AssignBinCodesInvtMvmt;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,100);
      PartialPostFactor := LibraryRandom.RandIntInRange(1,100);

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationInvtMvmt.Code,LibraryRandom.RandIntInRange(1,3));

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      ASSERTERROR AssemblyHeader.CreateInvtMovement(FALSE,FALSE,TRUE,ATOMovementsCreated,TotalATOMovementsToBeCreated);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,MSG_STATUS_MUST_BE_RELEASED) > 0,
        'Actual:' + GETLASTERRORTEXT + ',Expected:' + MSG_STATUS_MUST_BE_RELEASED);
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtCreateSame@29();
    VAR
      AssemblyHeader@1003 : Record 900;
      TempAssemblyLine@1004 : TEMPORARY Record 901;
      HeaderQtyFactor@1001 : Decimal;
      PartialPostFactor@1000 : Decimal;
    BEGIN
      // TC-IMVMT
      Initialize;
      AssignBinCodesInvtMvmt;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,100);
      PartialPostFactor := LibraryRandom.RandIntInRange(1,100);

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationInvtMvmt.Code,LibraryRandom.RandIntInRange(1,3));
      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);
      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      CreateInvtMovementAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,'',0,0);

      ASSERTERROR LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,MSG_NOTHING_TO_CREATE) > 0,
        PADSTR('Actual:' + GETLASTERRORTEXT + ',Expected:' + MSG_NOTHING_TO_CREATE,1024));
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtRecreate@10();
    VAR
      AssemblyHeader@1003 : Record 900;
      WhseActivityHdr@1008 : Record 5766;
      TempAssemblyLine@1004 : TEMPORARY Record 901;
      HeaderQtyFactor@1001 : Decimal;
      PartialPostFactor@1000 : Decimal;
      AssembledQty@1007 : Decimal;
    BEGIN
      // Test creates inventory movement, deletes it, creates a new one and verifies it
      // TC-IMVMT
      Initialize;
      AssignBinCodesInvtMvmt;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,100);
      PartialPostFactor := LibraryRandom.RandIntInRange(1,100);

      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationInvtMvmt.Code,LibraryRandom.RandIntInRange(1,3));

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,0,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);
      AssembledQty := AssemblyHeader."Quantity to Assemble";

      LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      AutoFillQtyInventoryActivity(AssemblyHeader);
      VerifyWhseActivity(AssemblyHeader,TempAssemblyLine,WhseActivityHdr,'',0,0);

      WhseActivityHdr.DELETE(TRUE);

      CreateInvtMovementAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,'',0,0);

      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Verify.
      VerifyBinContentsMvmt(AssemblyHeader,TempAssemblyLine,0,AssembledQty);
      TempAssemblyLine.RESET;
      TempAssemblyLine.SETRANGE(Type,TempAssemblyLine.Type::Item);
      VerifyWarehouseEntries(AssemblyHeader,TempAssemblyLine,AssembledQty,TRUE,TempAssemblyLine.COUNT + 1);
      LibraryAssembly.VerifyILEs(TempAssemblyLine,AssemblyHeader,AssembledQty);
      LibraryAssembly.VerifyItemRegister(AssemblyHeader);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtFullNotEnoughItemInBin@51();
    BEGIN
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks no error appears during full posting
      Initialize;
      NotEnoughItemPostingInvtMvmt(100,100,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtPartNotEnoughItemInBin@50();
    BEGIN
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during partial posting
      Initialize;
      NotEnoughItemPostingInvtMvmt(
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtFullNotEnoughItemInInv@43();
    BEGIN
      // There is not enough item in inventory (there is not enough item in ToBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      NotEnoughItemPostingInvtMvmt(100,100,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtPartNotEnoughItemInInv@5();
    BEGIN
      // There is enough item in inventory but there is not enough item in ToBin
      // Test checks that no error appears during partial posting
      Initialize;

      NotEnoughItemPostingInvtMvmt(
        LibraryRandom.RandIntInRange(1,99),
        LibraryRandom.RandIntInRange(1,99),
        FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtPartPostMoveNotEnItem@68();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for partial posting, reduces one of the quantity, registeres inventory movement and posts.
      // Then test checks inventory movement for the rest of the qty, registeres inventory movement and posts.
      Initialize;
      MoveNotEnoughItemInvtMvmt(LibraryRandom.RandIntInRange(1,100),
        LibraryRandom.RandIntInRange(1,100));
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtFullPostMoveNotEnItem@42();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for full posting, reduces one of the quantity, registeres inventory movement and posts.
      // Then test checks inventory movement for the rest of the qty, registeres inventory movement and fully posts.
      Initialize;
      MoveNotEnoughItemInvtMvmt(LibraryRandom.RandIntInRange(1,100),
        LibraryRandom.RandIntInRange(1,100));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtPostNoInvtMvmt@93();
    VAR
      AssemblyHeader@1004 : Record 900;
      TempAssemblyLine@1005 : TEMPORARY Record 901;
      HeaderQtyFactor@1003 : Decimal;
      PartialPostFactor@1002 : Decimal;
      NoOfItems@1001 : Integer;
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,100);
      PartialPostFactor := LibraryRandom.RandIntInRange(1,100);

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationInvtMvmt.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,LibraryRandom.RandIntInRange(1,9),
        AssemblyHeader."Location Code",LocationToBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      PostAssemblyHeader(AssemblyHeader."No.",'');
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtReuseFromAnotherOrder@74();
    VAR
      TempAssemblyLine@1013 : TEMPORARY Record 901;
      TempAssemblyLine2@1018 : TEMPORARY Record 901;
      AssemblyHeader2@1019 : Record 900;
      AssemblyHeader@1011 : Record 900;
      ReleaseAssemblyDoc@1004 : Codeunit 903;
      NoOfItems@1006 : Integer;
      HeaderQtyFactor@1015 : Decimal;
      PartialPostFactor@1014 : Decimal;
      AssemblyItemNo@1016 : Code[20];
    BEGIN
      // Test checks that inventory movement created for one assembly order can be reused for another
      Initialize;
      AssignBinCodesInvtMvmt;

      HeaderQtyFactor := 100;
      PartialPostFactor := 100;

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationInvtMvmt.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,LibraryRandom.RandIntInRange(1,5),
        AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      CreateInvtMovementAndVerify(AssemblyHeader."No.",TempAssemblyLine,1,'',0,0);

      ReleaseAssemblyDoc.Reopen(AssemblyHeader);

      HeaderQtyFactor := 10;
      PartialPostFactor := 10;
      AssemblyHeader.VALIDATE("Quantity to Assemble",AssemblyHeader."Quantity to Assemble" * HeaderQtyFactor / 100);
      AssemblyItemNo := AssemblyHeader."Item No.";

      // Post asssembly order
      PostAssemblyHeader(AssemblyHeader."No.",'');

      // Create another assembly order
      LibraryAssembly.CreateAssemblyHeader(AssemblyHeader2,WorkDate2,AssemblyItemNo,LocationInvtMvmt.Code,AssemblyHeader.Quantity,'');
      LibraryAssembly.PrepareOrderPosting(AssemblyHeader2,TempAssemblyLine2,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      // Post assembly order
      PostAssemblyHeader(AssemblyHeader2."No.",'');
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE InvtMvmtCreateMoreThenQtyOutst@85();
    VAR
      TempAssemblyLine@1013 : TEMPORARY Record 901;
      AssemblyHeader@1011 : Record 900;
      WhseActivityHeader@1002 : Record 5766;
      WhseActivityLine@1001 : Record 5767;
      NoOfItems@1006 : Integer;
      QtySupplement@1003 : Integer;
      HeaderQtyFactor@1015 : Decimal;
      PartialPostFactor@1014 : Decimal;
    BEGIN
      // Test checks that inventory movement cannot be created for more then qty outstanding
      Initialize;
      AssignBinCodesInvtMvmt;

      HeaderQtyFactor := LibraryRandom.RandIntInRange(1,100);
      PartialPostFactor := LibraryRandom.RandIntInRange(1,100);
      QtySupplement := LibraryRandom.RandIntInRange(5000,10000);

      NoOfItems := LibraryRandom.RandIntInRange(1,3);
      LibraryAssembly.CreateAssemblyOrder(AssemblyHeader,WorkDate2,LocationInvtMvmt.Code,NoOfItems);

      LibraryAssembly.AddCompInventoryToBin(AssemblyHeader,WorkDate2,QtySupplement,AssemblyHeader."Location Code",LocationTakeBinCode);

      LibraryAssembly.PrepareOrderPosting(AssemblyHeader,TempAssemblyLine,HeaderQtyFactor,PartialPostFactor,TRUE,WorkDate2);

      CODEUNIT.RUN(CODEUNIT::"Release Assembly Document",AssemblyHeader);

      // Create Inventory Movement and Verify
      LibraryAssembly.CreateInvtMovement(AssemblyHeader."No.",FALSE,FALSE,TRUE);
      AutoFillQtyInventoryActivity(AssemblyHeader);
      VerifyWhseActivity(AssemblyHeader,TempAssemblyLine,WhseActivityHeader,'',0,0);

      // Increase Quantity to Handled of one of the items
      WhseActivityLine.RESET;
      WhseActivityLine.SETRANGE("No.",WhseActivityHeader."No.");

      WhseActivityLine.FINDFIRST;
      ASSERTERROR WhseActivityLine.VALIDATE("Qty. to Handle",QtySupplement);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,MSG_QTY_OUTST) > 0,
        'Actual:' + GETLASTERRORTEXT + ',Expected:' + MSG_QTY_OUTST);
      CLEARLASTERROR;
    END;

    [ModalPageHandler]
    PROCEDURE AvailabilityWindowHandler@9(VAR AsmAvailability@1000 : Page 908;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::Yes; // always confirm
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtFullPost@297();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationInvtMvmt,100,0,WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtPartPost@296();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,99),0,
        WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtFullPostQtySupplem@295();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationInvtMvmt,100,LibraryRandom.RandIntInRange(1,10),
        WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtPartPostQtySupplem@294();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtFullPost2Steps@293();
    BEGIN
      // Test does partial posting and verifies it. Then it posts rest of the order and verifies
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      Post2Steps(LocationInvtMvmt,WhseActivityType::InvtMvmt,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtRecreate@292();
    BEGIN
      // Test creates inventory movement, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      RecreateWhseActivity(LocationInvtMvmt,WhseActivityType::InvtMvmt,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtFullNotEnoughItemInBin@291();
    BEGIN
      // There is enough item in inventory but there is not enough item in FromBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,TRUE,WhseActivityType::InvtMvmt,'','',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtFullNotEnoughItemInInv@290();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,FALSE,WhseActivityType::InvtMvmt,MSG_NOT_ON_INVT,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtPartPostMoveNotEnL@289();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for partial posting, reduces one of the quantity, registeres inventory movement and posts.
      // Then test checks inventory movement for the rest of the qty, registeres inventory movement and posts.
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      MoveNotEnoughItem(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        WhseActivityType::InvtMvmt,MSG_QTY_TO_HANDLE_BASE_MUST_BE_NOT,FALSE,TRUE,-1);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullPostMoveNotEnL@288();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for full posting, reduces one of the quantity, registeres inventory movement and posts.
      // Then test checks inventory movement for the rest of the qty, registeres inventory movement and fully posts.
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      MoveNotEnoughItem(LocationInvtMvmt,100,WhseActivityType::InvtMvmt,MSG_QTY_TO_HANDLE_BASE_MUST_BE_NOT,FALSE,TRUE,-1);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtPartPostMoveNotEnLS@287();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for partial posting, reduces one of the quantity, registeres inventory movement and posts.
      // Then test checks inventory movement for the rest of the qty, registeres inventory movement and posts.
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      MoveNotEnoughItem(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        WhseActivityType::InvtMvmt,MSG_QTY_TO_HANDLE_BASE_MUST_BE_NOT,FALSE,TRUE,-1);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostMoveNotEnLS@286();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for full posting, reduces one of the quantity, registeres inventory movement and posts.
      // Then test checks inventory movement for the rest of the qty, registeres inventory movement and fully posts.
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      MoveNotEnoughItem(LocationInvtMvmt,100,WhseActivityType::InvtMvmt,MSG_QTY_TO_HANDLE_BASE_MUST_BE_NOT,FALSE,TRUE,-1);
    END;

    [Test]
    PROCEDURE ITInvtMvmtPostNoInvtMvmt@285();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,100),0,
        WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtReuseFromAnotherOrder@284();
    BEGIN
      // Test checks that inventory movement created for one assembly order can be reused for another
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      ReuseFromAnotherOrder(LocationInvtMvmt,WhseActivityType::InvtMvmt,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtFullPostAO@283();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationInvtMvmt,100,0,WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtPartPostAO@282();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,99),0,
        WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtFullPostQtySupplemAO@281();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationInvtMvmt,100,LibraryRandom.RandIntInRange(1,10),
        WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtPartPostQtySupplemAO@280();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtFullPost2StepsAO@279();
    BEGIN
      // Test does partial posting and verifies it. Then it posts rest of the order and verifies
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      Post2Steps(LocationInvtMvmt,WhseActivityType::InvtMvmt,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtRecreateAO@278();
    BEGIN
      // Test creates inventory movement, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      RecreateWhseActivity(LocationInvtMvmt,WhseActivityType::InvtMvmt,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtFullNotEnItemInBinAO@277();
    BEGIN
      // There is enough item in inventory but there is not enough item in FromBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,TRUE,WhseActivityType::InvtMvmt,'','',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtFullNotEnItemInInvAO@276();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,FALSE,WhseActivityType::InvtMvmt,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtPartPostMoveNotEnAOL@275();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for partial posting, reduces one of the quantity, registeres inventory movement and posts.
      // Then test checks inventory movement for the rest of the qty, registeres inventory movement and posts.
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      MoveNotEnoughItem(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        WhseActivityType::InvtMvmt,MSG_WHSE_HANDLING_REQUIRED,TRUE,FALSE,-1);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullPostMoveNotEnAOL@274();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for full posting, reduces one of the quantity, registeres inventory movement and posts.
      // Then test checks inventory movement for the rest of the qty, registeres inventory movement and fully posts.
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      MoveNotEnoughItem(LocationInvtMvmt,100,WhseActivityType::InvtMvmt,MSG_WHSE_HANDLING_REQUIRED,TRUE,FALSE,-1);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtPartPostMoveNotEnAOLS@273();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for partial posting, reduces one of the quantity, registeres inventory movement and posts.
      // Then test checks inventory movement for the rest of the qty, registeres inventory movement and posts.
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      MoveNotEnoughItem(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        WhseActivityType::InvtMvmt,MSG_WHSE_HANDLING_REQUIRED,TRUE,FALSE,-1);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostMoveNotEnAOLS@272();
    BEGIN
      // There is enough item in inventory
      // Test creates inventory movement for full posting, reduces one of the quantity, registeres inventory movement and posts.
      // Then test checks inventory movement for the rest of the qty, registeres inventory movement and fully posts.
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      MoveNotEnoughItem(LocationInvtMvmt,100,WhseActivityType::InvtMvmt,MSG_WHSE_HANDLING_REQUIRED,TRUE,FALSE,-1);
    END;

    [Test]
    PROCEDURE ITInvtMvmtPostNoInvtMvmtAO@271();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      LocationToBinCode := LocationInvtMvmt."To-Assembly Bin Code";
      CreateItems(Tracking::Untracked);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,100),0,
        WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler)]
    PROCEDURE ITInvtMvmtReuseFromAnotherOrdAO@270();
    BEGIN
      // Test checks that inventory movement created for one assembly order can be reused for another
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Untracked);

      ReuseFromAnotherOrder(LocationInvtMvmt,WhseActivityType::InvtMvmt,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostS@269();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationInvtMvmt,100,0,WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtPartPostS@268();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,99),0,
        WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostQtySupplemS@267();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationInvtMvmt,100,LibraryRandom.RandIntInRange(1,10),
        WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtPartPostQtySupplemS@266();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPost2StepsS@221();
    BEGIN
      // Test does partial posting and verifies it. Then it posts rest of the order and verifies
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      Post2Steps(LocationInvtMvmt,WhseActivityType::InvtMvmt,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtRecreateS@220();
    BEGIN
      // Test creates inventory movement, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      RecreateWhseActivity(LocationInvtMvmt,WhseActivityType::InvtMvmt,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullNotEnoughItemInBinS@219();
    BEGIN
      // There is enough item in inventory but there is not enough item in FromBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,TRUE,WhseActivityType::InvtMvmt,'','',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullNotEnoughItemInInvS@218();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,FALSE,WhseActivityType::InvtMvmt,MSG_NOT_ON_INVT,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITInvtMvmtPostNoInvtMvmtS@208();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,100),0,
        WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostPartITS@206();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      PostingPartialIT(LocationInvtMvmt,WhseActivityType::InvtMvmt,MSG_SER_NO_MUST,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostAOS@205();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationInvtMvmt,100,0,WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtPartPostAOS@203();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,99),0,
        WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostQtySupplemAOS@202();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationInvtMvmt,100,LibraryRandom.RandIntInRange(1,10),
        WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtPartPostQtySupplemAOS@201();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPost2StepsAOS@193();
    BEGIN
      // Test does partial posting and verifies it. Then it posts rest of the order and verifies
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      Post2Steps(LocationInvtMvmt,WhseActivityType::InvtMvmt,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtRecreateAOS@192();
    BEGIN
      // Test creates inventory movement, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      RecreateWhseActivity(LocationInvtMvmt,WhseActivityType::InvtMvmt,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullNotEnItemInBinAOS@191();
    BEGIN
      // There is enough item in inventory but there is not enough item in FromBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,TRUE,WhseActivityType::InvtMvmt,'','',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullNotEnItemInInvAOS@190();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,FALSE,WhseActivityType::InvtMvmt,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITInvtMvmtPostNoInvtMvmtAOS@189();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      LocationToBinCode := LocationInvtMvmt."To-Assembly Bin Code";
      CreateItems(Tracking::Serial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,100),0,
        WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostPartITAOS@187();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Serial);

      PostingPartialIT(LocationInvtMvmt,WhseActivityType::InvtMvmt,MSG_SER_NO_MUST,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullPostL@186();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationInvtMvmt,100,0,WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtPartPostL@181();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,99),0,
        WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullPostQtySupplemL@180();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationInvtMvmt,100,LibraryRandom.RandIntInRange(1,10),
        WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtPartPostQtySupplemL@179();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullPost2StepsL@178();
    BEGIN
      // Test does partial posting and verifies it. Then it posts rest of the order and verifies
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      Post2Steps(LocationInvtMvmt,WhseActivityType::InvtMvmt,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtRecreateL@177();
    BEGIN
      // Test creates inventory movement, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      RecreateWhseActivity(LocationInvtMvmt,WhseActivityType::InvtMvmt,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullNotEnoughItemInBinL@176();
    BEGIN
      // There is enough item in inventory but there is not enough item in FromBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,TRUE,WhseActivityType::InvtMvmt,'','',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullNotEnoughItemInInvL@175();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,FALSE,WhseActivityType::InvtMvmt,MSG_NOT_ON_INVT,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITInvtMvmtPostNoInvtMvmtL@174();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,100),0,
        WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITInvtMvmtReuseFromAnotherOrderL@173();
    BEGIN
      // Test checks that inventory movement created for one assembly order can be reused for another
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      ReuseFromAnotherOrder(LocationInvtMvmt,WhseActivityType::InvtMvmt,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullPostPartITL@171();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      PostingPartialIT(LocationInvtMvmt,WhseActivityType::InvtMvmt,MSG_LOT_NO_MUST,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullPostAOL@166();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationInvtMvmt,100,0,WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtPartPostAOL@165();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,99),0,
        WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullPostQtySupplemAOL@164();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationInvtMvmt,100,LibraryRandom.RandIntInRange(1,10),
        WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtPartPostQtySupplemAOL@156();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtRecreateAOL@155();
    BEGIN
      // Test creates inventory movement, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      RecreateWhseActivity(LocationInvtMvmt,WhseActivityType::InvtMvmt,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullNotEnItemInBinAOL@153();
    BEGIN
      // There is enough item in inventory but there is not enough item in FromBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,TRUE,WhseActivityType::InvtMvmt,'','',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullNotEnItemInInvAOL@152();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,FALSE,WhseActivityType::InvtMvmt,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITInvtMvmtPostNoInvtMvmtAOL@151();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,100),0,
        WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNLD_ItemTrackingSummary)]
    PROCEDURE ITInvtMvmtReuseFromAnotherOrdAOL@150();
    BEGIN
      // Test checks that inventory movement created for one assembly order can be reused for another
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      ReuseFromAnotherOrder(LocationInvtMvmt,WhseActivityType::InvtMvmt,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage)]
    PROCEDURE ITInvtMvmtFullPostPartITAOL@149();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::Lot);

      PostingPartialIT(LocationInvtMvmt,WhseActivityType::InvtMvmt,MSG_LOT_NO_MUST,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostLS@200();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationInvtMvmt,100,0,WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtPartPostLS@199();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,99),0,
        WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostQtySupplemLS@198();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationInvtMvmt,100,LibraryRandom.RandIntInRange(1,10),
        WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtPartPostQtySupplemLS@197();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::InvtMvmt,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPost2StepsLS@196();
    BEGIN
      // Test does partial posting and verifies it. Then it posts rest of the order and verifies
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      Post2Steps(LocationInvtMvmt,WhseActivityType::InvtMvmt,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtRecreateLS@195();
    BEGIN
      // Test creates inventory movement, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      RecreateWhseActivity(LocationInvtMvmt,WhseActivityType::InvtMvmt,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullNotEnoughItemInBinLS@194();
    BEGIN
      // There is enough item in inventory but there is not enough item in FromBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,TRUE,WhseActivityType::InvtMvmt,'','',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullNotEnoughItemInInvLS@185();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,FALSE,WhseActivityType::InvtMvmt,MSG_NOT_ON_INVT,'',FALSE,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITInvtMvmtPostNoInvtMvmtLS@184();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,100),0,
        WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostPartITLS@182();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      PostingPartialIT(LocationInvtMvmt,WhseActivityType::InvtMvmt,MSG_SER_NO_MUST,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostAOLS@170();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationInvtMvmt,100,0,WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtPartPostAOLS@169();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,99),0,
        WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostQtySupplemAOLS@168();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationInvtMvmt,100,LibraryRandom.RandIntInRange(1,10),
        WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtPartPostQtySupplemAOLS@167();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,60),
        LibraryRandom.RandIntInRange(1,10),WhseActivityType::InvtMvmt,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPost2StepsAOLS@163();
    BEGIN
      // Test does partial posting and verifies it. Then it posts rest of the order and verifies
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      Post2Steps(LocationInvtMvmt,WhseActivityType::InvtMvmt,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtRecreateAOLS@162();
    BEGIN
      // Test creates inventory movement, deletes it, creates a new one and verifies it
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      RecreateWhseActivity(LocationInvtMvmt,WhseActivityType::InvtMvmt,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullNotEnItemInBinAOLS@148();
    BEGIN
      // There is enough item in inventory but there is not enough item in FromBin
      // Test checks no error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,TRUE,WhseActivityType::InvtMvmt,'','',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullNotEnItemInInvAOLS@146();
    BEGIN
      // There is not enough item in inventory (there is not enough item in FromBin)
      // Test checks that correspondent error appears during full posting
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NotEnoughItemPostingIT(LocationInvtMvmt,100,100,FALSE,WhseActivityType::InvtMvmt,MSG_NOT_ON_INVT,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(HNDL_ITPage,HNDL_EnterQty,HNLD_ItemTrackingSummary)]
    PROCEDURE ITInvtMvmtPostNoInvtMvmtAOLS@145();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      NormalPostingIT(LocationInvtMvmt,LibraryRandom.RandIntInRange(50,100),0,
        WhseActivityType::None,'',TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(MvmtMessageHandler,HNDL_ITPage,HNDL_EnterQty)]
    PROCEDURE ITInvtMvmtFullPostPartITAOLS@157();
    BEGIN
      Initialize;
      AssignBinCodesInvtMvmt;
      CreateItems(Tracking::LotSerial);

      PostingPartialIT(LocationInvtMvmt,WhseActivityType::InvtMvmt,MSG_SER_NO_MUST,TRUE,FALSE);
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [Assemble-to-Stock] [Warehouse] [Item Tracking] [SCM]
      This CU is for deliverables "Kitting D07A - Assemble-to-Stock in Warehousing, as per the following" and " Kitting - Warehouse Item Tracking"
       for lcoation "Bin Mandatory+Require Pick"
    }
    END.
  }
}

