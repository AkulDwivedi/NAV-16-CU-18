OBJECT Codeunit 137614 SCM Costing Rollup Sev 3
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LibraryERMCountryData@1005 : Codeunit 131305;
      LibraryCosting@1002 : Codeunit 132200;
      LibraryInventory@1000 : Codeunit 132201;
      LibraryManufacturing@1011 : Codeunit 132202;
      LibraryPurchase@1015 : Codeunit 130512;
      LibrarySales@1003 : Codeunit 130509;
      LibraryERM@1006 : Codeunit 131300;
      LibraryPatterns@1007 : Codeunit 132212;
      LibraryJob@1014 : Codeunit 131920;
      Assert@1026 : Codeunit 130000;
      LibraryRandom@1001 : Codeunit 130440;
      isInitialized@1004 : Boolean;
      ValueMismatchErr@1010 : TextConst 'ENU=%1 in the Revaluation Journal line does not match the Item Ledger Entry applied to.';
      CostMismatchErr@1012 : TextConst '@@@="%1=Field Caption,%2=Table Caption,%3=Record Key";ENU=Incorrect %1 in %2 %3';
      EntryforJobMismatchErr@1013 : TextConst '@@@="%1=Table Caption,%2=Field Caption,%3=Field Value";ENU=Incorrect no. of %1 records for %2 %3';

    LOCAL PROCEDURE Initialize@6();
    BEGIN
      // Lazy Setup.
      IF isInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.CreateGeneralPostingSetupData;
      LibraryERMCountryData.UpdateGeneralLedgerSetup;
      LibraryERMCountryData.UpdateGeneralPostingSetup;

      isInitialized := TRUE;
      COMMIT;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE B256325_PostOutputJournalFromRelProdOrder@30();
    VAR
      InventorySetup2@1002 : Record 313;
      InventorySetup@1005 : Record 313;
      Item@1000 : Record 27;
      ProductionOrder@1001 : Record 5405;
      ValueEntry@1007 : Record 5802;
      ItemNo@1008 : Code[20];
    BEGIN
      // Verify Value Entry after post Output Journal which is created from Production Order.

      // Setup.
      Initialize;
      InventorySetup.GET;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup2,TRUE,TRUE,InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");

      // Create Item.
      ItemNo := CreateAndModifyItem('',Item."Costing Method"::FIFO,Item."Flushing Method"::Backward,
          Item."Replenishment System"::Purchase,0);

      // Excercise.
      SetupForPostOutputJournal(ProductionOrder,ItemNo);

      // Verify: Verify Value Entry after post Output Journal.
      VerifyValueEntry(ValueEntry."Item Ledger Entry Type"::Consumption,ProductionOrder."No.",ItemNo);
      VerifyValueEntry(ValueEntry."Item Ledger Entry Type"::Output,ProductionOrder."No.",ProductionOrder."Source No.");

      // Tear Down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE B256325_PostOutputJournalWithAppliesToEntry@1();
    VAR
      InventorySetup@1005 : Record 313;
      InventorySetup2@1004 : Record 313;
      Item@1000 : Record 27;
      ProductionOrder@1001 : Record 5405;
      ItemJournalLine@1006 : Record 83;
      ItemLedgerEntry@1003 : Record 32;
      ValueEntry@1002 : Record 5802;
      ItemNo@1011 : Code[20];
    BEGIN
      // Verify Value Entry and Application Worksheet after post Output Journal with 'Apply to Entry' which is created from Production Order.

      // Setup.
      Initialize;
      InventorySetup.GET;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup2,TRUE,TRUE,InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");

      // Create Item, Post Purchase Order, create Released Production Order.
      ItemNo := CreateAndModifyItem('',Item."Costing Method"::FIFO,
          Item."Flushing Method"::Backward,Item."Replenishment System"::Purchase,0);
      SetupForPostOutputJournal(ProductionOrder,ItemNo);

      // Create Output Journal with Applies to Entry and Post.
      FindItemLedgerEntry(ItemLedgerEntry,ItemLedgerEntry."Entry Type"::Output,ProductionOrder."No.");
      CreateOutputJournal(
        ItemJournalLine,ProductionOrder."Source No.",ProductionOrder."No.",GetOperationNo(ProductionOrder."No."),
        -ProductionOrder.Quantity,ItemLedgerEntry."Entry No.");

      // Excercise.
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // Verify: Verify Item Ledger Entry (Application Worksheet) and Value Entry after post Output Journal.
      FindItemLedgerEntry(ItemLedgerEntry,ItemLedgerEntry."Entry Type"::Consumption,ProductionOrder."No.");
      ItemLedgerEntry.TESTFIELD("Item No.",ItemNo);
      VerifyValueEntry(ValueEntry."Item Ledger Entry Type"::Consumption,ProductionOrder."No.",ItemNo);

      // Tear Down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE B256325_ExpCostAmountInValueEntry@147();
    VAR
      InventorySetup2@1003 : Record 313;
      InventorySetup@1005 : Record 313;
      Item@1000 : Record 27;
      ValueEntry@1002 : Record 5802;
      PurchaseLine@1001 : Record 39;
      PostedReceiptNo@1004 : Code[20];
    BEGIN
      // Verify Value Entry after receive Purchase Order.

      // Setup: Update Inventory Setup, create Purchase Order,
      Initialize;
      InventorySetup.GET;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup2,TRUE,TRUE,InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,
        CreateAndModifyItem('',Item."Costing Method"::FIFO,Item."Flushing Method"::Backward,Item."Replenishment System"::Purchase,0),
        '',CreateVendor,LibraryRandom.RandInt(10),WORKDATE);

      // Exercise
      PostedReceiptNo := PostPurchaseDocument(PurchaseLine,FALSE);

      // Verify: Verify; Value Entry after post Purchase Order.
      VerifyValueEntry(ValueEntry."Item Ledger Entry Type"::Purchase,PostedReceiptNo,PurchaseLine."No.");

      // Tear Down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE B256325_GLEntryAfterPostSalesOrder@196();
    VAR
      InventorySetup2@1002 : Record 313;
      InventorySetup@1005 : Record 313;
      Item@1000 : Record 27;
      PurchaseLine@1001 : Record 39;
      SalesLine@1003 : Record 37;
      SalesHeader@1006 : Record 36;
      GLEntry@1007 : Record 17;
      PostedInvoiceNo@1004 : Code[20];
    BEGIN
      // Verify GL Entry after post Salse Order.

      // Setup: Update Inventory Setup, create and post Purchase Order, create Sales Order.
      Initialize;
      InventorySetup.GET;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup2,TRUE,TRUE,InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
      CreateAndPostPurchaseOrder(
        PurchaseLine,
        CreateAndModifyItem('',Item."Costing Method"::FIFO,Item."Flushing Method"::Backward,Item."Replenishment System"::Purchase,0),
        LibraryRandom.RandDec(100,2),0,FALSE);
      CreateSalesDocument(SalesHeader,SalesLine,SalesLine."Document Type"::Order,SalesLine.Type::Item,PurchaseLine."No.",'',
        LibraryRandom.RandInt(10));
      SalesHeader.GET(SalesLine."Document Type",SalesLine."Document No.");

      // Exercise.
      PostedInvoiceNo := LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Verify: Verify GL Entry after post Salse Order.
      VerifyGLEntry(GLEntry."Document Type"::Invoice,PostedInvoiceNo,-SalesLine."Line Amount",GLEntry."Gen. Posting Type"::Sale);
      VerifyGLEntry(
        GLEntry."Document Type"::Invoice,PostedInvoiceNo,SalesLine."Amount Including VAT",GLEntry."Gen. Posting Type"::" ");

      // Tear Down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE B256325_GLEntryAfterPostCreditMemo@31();
    VAR
      SalesInvoiceLine@1012 : Record 113;
      InventorySetup2@1015 : Record 313;
      InventorySetup@1005 : Record 313;
      Item@1000 : Record 27;
      PurchaseLine@1001 : Record 39;
      PurchaseHeader@1009 : Record 38;
      ReasonCode@1032 : Record 231;
      SalesLine@1003 : Record 37;
      SalesHeader@1006 : Record 36;
      SalesHeader2@1008 : Record 36;
      GLEntry@1007 : Record 17;
      CopyDocMgt@1002 : Codeunit 6620;
      PostedCreditMemoNo@1004 : Code[20];
      PostedInvoiceNo@1011 : Code[20];
      LinesNotCopied@1013 : Integer;
      MissingExCostRevLink@1014 : Boolean;
    BEGIN
      // Verify GL Entry after post Credit Memo.

      // Setup: Update Inventory Setup, create and receive Purchase Order.
      Initialize;
      LibraryERM.CreateReasonCode(ReasonCode);  // Added for G1 Country Fix.
      InventorySetup.GET;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup2,TRUE,TRUE,InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
      CreateAndPostPurchaseOrder(
        PurchaseLine,
        CreateAndModifyItem('',Item."Costing Method"::FIFO,Item."Flushing Method"::Backward,Item."Replenishment System"::Purchase,0),
        LibraryRandom.RandDec(100,2),0,FALSE);

      // Reopen Purchase Order and update Direct Unit Cost on Purchase Line.
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);
      PurchaseLine.GET(PurchaseLine."Document Type",PurchaseLine."Document No.",PurchaseLine."Line No.");
      PurchaseLine.VALIDATE("Direct Unit Cost",(PurchaseLine."Direct Unit Cost" + LibraryRandom.RandInt(10)));
      PurchaseLine.MODIFY(TRUE);

      // Create Sales Order and post.
      CreateSalesDocument(SalesHeader,SalesLine,SalesLine."Document Type"::Order,SalesLine.Type::Item,PurchaseLine."No.",'',
        PurchaseLine.Quantity);
      PostedInvoiceNo := LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Create Sales Credit Memo, Get Posted Invoice to Reverse and Post.
      LibrarySales.CreateSalesHeader(SalesHeader2,SalesHeader2."Document Type"::"Credit Memo",SalesHeader."Sell-to Customer No.");
      SalesInvoiceLine.SETRANGE("Document No.",PostedInvoiceNo);
      SalesInvoiceLine.FINDFIRST;
      CopyDocMgt.SetProperties(FALSE,FALSE,FALSE,FALSE,TRUE,TRUE,TRUE);
      CopyDocMgt.CopySalesInvLinesToDoc(SalesHeader2,SalesInvoiceLine,LinesNotCopied,MissingExCostRevLink);
      SalesHeader2.VALIDATE("Reason Code",ReasonCode.Code);
      SalesHeader2.MODIFY(TRUE);
      FindSalesLine(SalesLine,SalesHeader2."Document Type"::"Credit Memo",SalesHeader2."No.");
      PostedCreditMemoNo := LibrarySales.PostSalesDocument(SalesHeader2,TRUE,TRUE);

      // Exercise: Post Purhcase received Purchase Order with updated 'Direct Unit Cost'.
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // Verify: Verify GL Entry after post Salse Credit Memo.
      VerifyGLEntry(
        GLEntry."Document Type"::"Credit Memo",PostedCreditMemoNo,SalesLine."Line Amount",GLEntry."Gen. Posting Type"::Sale);
      VerifyGLEntry(
        GLEntry."Document Type"::"Credit Memo",PostedCreditMemoNo,-SalesLine."Amount Including VAT",GLEntry."Gen. Posting Type"::" ");

      // Tear Down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE B266892_AdjustForDiffCurrExchgRate@15();
    VAR
      InventorySetup@1005 : Record 313;
      Item@1004 : Record 27;
      Currency@1000 : Record 4;
      SalesHeader@1002 : Record 36;
      ValueEntry@1001 : Record 5802;
      ItemNo@1003 : Code[20];
    BEGIN
      // Verify Value Entries in 'Cost Amount (Expected)(ACY)' of Item Ledger Entry when transactions posted with different Currency Exchange Rates.

      // Setup: Create Currency, add Additional Reporting Currency and update Inventory Setup.
      Initialize;
      InventorySetup.GET;
      ExecuteUIHandlers;
      CreateCurrencyWithExchangeRate(Currency);
      ItemNo := CreateAndModifyItem('',Item."Costing Method"::Average,Item."Flushing Method"::Manual,
          Item."Replenishment System"::Purchase,LibraryRandom.RandInt(10));
      SetupForAdjustCostOnACY(SalesHeader,ItemNo,Currency.Code);

      // Exercise.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');

      // Verify:
      FindValueEntry(ValueEntry,SalesHeader."Last Posting No.",'','',TRUE,ValueEntry."Item Ledger Entry Type"::Sale);
      ValueEntry.TESTFIELD("Document Type",ValueEntry."Document Type"::"Sales Invoice");
      ValueEntry.TESTFIELD(
        "Cost Amount (Actual) (ACY)",
        ROUND(ValueEntry."Cost per Unit (ACY)" * ValueEntry."Valued Quantity",LibraryERM.GetAmountRoundingPrecision,'='));

      // Tear down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");

      UpdateGeneralLedgerSetupForACY('');
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE B266892_PurchOrderWithDiffCurrExchgRate@279();
    VAR
      Item@1004 : Record 27;
      Currency@1000 : Record 4;
      InventorySetup@1009 : Record 313;
      SalesHeader@1002 : Record 36;
      SalesLine@1005 : Record 37;
      PurchaseLine@1007 : Record 39;
      ValueEntry@1001 : Record 5802;
      ItemNo@1003 : Code[20];
      UnitPrice@1006 : Decimal;
    BEGIN
      // Verify Value Entries with ACY transactions on different Posting Dates after run Adjust Cost Item batch job.

      // Setup: Create Currency, add Additional Reporting Currency and update Inventory Setup.
      Initialize;
      InventorySetup.GET;
      ExecuteUIHandlers;
      CreateCurrencyWithExchangeRate(Currency);
      ItemNo := CreateAndModifyItem('',Item."Costing Method"::Average,Item."Flushing Method"::Manual,
          Item."Replenishment System"::Purchase,LibraryRandom.RandInt(10));
      SetupForAdjustCostOnACY(SalesHeader,ItemNo,Currency.Code);

      // Create Sales Document and Post, create Purchase Document and Receive.
      CreateSalesDocument(
        SalesHeader,SalesLine,SalesHeader."Document Type"::Order,SalesLine.Type::Item,ItemNo,'',LibraryRandom.RandInt(20));
      UnitPrice := PurchaseLine."Direct Unit Cost" + LibraryRandom.RandInt(20); // Required Unit Price more than Direct Unit Cost.

      UpdateSalesDocument(SalesLine,SalesHeader,SalesHeader."Posting Date",Currency.Code,UnitPrice);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      CreatePurchaseOrderWithCurrency(
        PurchaseLine,ItemNo,Currency.Code,SalesHeader."Posting Date",LibraryRandom.RandInt(50),
        SalesLine.Quantity + LibraryRandom.RandInt(40));
      PostPurchaseDocument(PurchaseLine,FALSE);

      // Exercise.
      LibraryCosting.AdjustCostItemEntries(ItemNo,'');

      // Verify:
      FindValueEntry(ValueEntry,SalesHeader."Last Posting No.",'','',TRUE,ValueEntry."Item Ledger Entry Type"::Sale);
      ValueEntry.TESTFIELD("Document Type",ValueEntry."Document Type"::"Sales Invoice");
      ValueEntry.TESTFIELD(
        "Cost Amount (Actual) (ACY)",
        ROUND(ValueEntry."Cost per Unit (ACY)" * ValueEntry."Valued Quantity",LibraryERM.GetAmountRoundingPrecision,'='));

      // Tear Down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,InventorySetup."Automatic Cost Posting",InventorySetup."Expected Cost Posting to G/L",
        InventorySetup."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
      UpdateGeneralLedgerSetupForACY('');
    END;

    [Test]
    PROCEDURE B290899_CostAmountOnItemLedgerEntry@36();
    VAR
      Item@1002 : Record 27;
      ItemJournalBatch@1001 : Record 233;
      ItemJournalLine@1000 : Record 83;
      PosAdjItemLedgerEntry@1003 : Record 32;
    BEGIN
      // Verify Item Ledger Entry after posting Item Journal Line for Item having costing method Average.
      // Using hardcoded quantity and cost since this was a rounding error
      Initialize;

      // Setup: Create Item and post Positive Adj Item Journal Line.
      Item.GET(
        CreateAndModifyItem('',Item."Costing Method"::Average,Item."Flushing Method"::Manual,Item."Replenishment System"::Purchase,0));
      LibraryPatterns.POSTPositiveAdjustment(Item,'','','',2388,WORKDATE,63.3152);
      PosAdjItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      PosAdjItemLedgerEntry.FINDFIRST;

      // Exercise: Post Neg Adj. Item Journal Lines with Fixed Application.
      LibraryInventory.CreateItemJournalBatchByType(ItemJournalBatch,ItemJournalBatch."Template Type"::Item);

      LibraryPatterns.MAKEItemJournalLineWithApplication(ItemJournalLine,ItemJournalBatch,Item,'','',WORKDATE,
        ItemJournalLine."Entry Type"::"Negative Adjmt.",597,63.3152,PosAdjItemLedgerEntry."Entry No.");
      LibraryPatterns.MAKEItemJournalLineWithApplication(ItemJournalLine,ItemJournalBatch,Item,'','',WORKDATE,
        ItemJournalLine."Entry Type"::"Negative Adjmt.",597,63.3152,PosAdjItemLedgerEntry."Entry No.");
      LibraryPatterns.MAKEItemJournalLineWithApplication(ItemJournalLine,ItemJournalBatch,Item,'','',WORKDATE,
        ItemJournalLine."Entry Type"::"Negative Adjmt.",597,63.3152,PosAdjItemLedgerEntry."Entry No.");
      LibraryPatterns.MAKEItemJournalLineWithApplication(ItemJournalLine,ItemJournalBatch,Item,'','',WORKDATE,
        ItemJournalLine."Entry Type"::"Negative Adjmt.",597,63.3152,PosAdjItemLedgerEntry."Entry No.");

      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      // Adjust Cost
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // verify: Verify Cost Amount (Actual) on Item Ledger Entry
      LibraryCosting.CheckAdjustment(Item);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE B292993_GLEntriesAfterPostToGL@10();
    VAR
      InventorySetup2@1002 : Record 313;
      InventorySetup@1001 : Record 313;
      JobJournalLine@1003 : Record 210;
      GLEntry@1000 : Record 17;
    BEGIN
      // Verify G/L Entries after running Adjust Cost Item Entries and post Inventory to G/L batch job for an Item.

      // Setup: Create and post Job Journal Line and run Adjust Cost Item Entries.
      Initialize;
      InventorySetup.GET;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup2,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
      CreateAndPostJobJournalLine(JobJournalLine);
      LibraryCosting.AdjustCostItemEntries(JobJournalLine."No.",'');

      // Exercise: Post Inventory to G/L batch job.
      LibraryCosting.PostInvtCostToGL(FALSE,WORKDATE,'');

      // Verify: Verify Amount on G/L Entries.
      GLEntry.SETRANGE("Job No.",JobJournalLine."Job No.");
      Assert.AreEqual(2,GLEntry.COUNT,
        STRSUBSTNO(EntryforJobMismatchErr,GLEntry.TABLECAPTION,GLEntry.FIELDCAPTION("Job No."),JobJournalLine."Job No."));

      // Tear down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,InventorySetup."Automatic Cost Posting",InventorySetup."Expected Cost Posting to G/L",
        InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE B292993_PostInvCostToGLPerEntry@27();
    VAR
      Item@1006 : Record 27;
      InventorySetup@1002 : Record 313;
      InventorySetup2@1004 : Record 313;
      JobJournalLine@1003 : Record 210;
      ValueEntry@1000 : Record 5802;
      GLEntry@1007 : Record 17;
    BEGIN
      // Verify Value Entry after running Post Inventory Cost To G/L batch job using Post Method 'Per Entry'.

      // Setup: Create and post Job Journal Line, create and post Item Journal Line, run Adjust Cost Item Entries.
      Initialize;
      InventorySetup.GET;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup2,FALSE,FALSE,InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
      CreateAndPostJobJournalLine(JobJournalLine);
      Item.GET(JobJournalLine."No.");
      LibraryPatterns.POSTPositiveAdjustment(Item,'','','',
        LibraryRandom.RandDec(100,2),WORKDATE,LibraryRandom.RandDec(100,2));
      LibraryCosting.AdjustCostItemEntries(JobJournalLine."No.",'');

      // Exercise: Post Inventory to G/L batch job.
      LibraryCosting.PostInvtCostToGL(FALSE,WORKDATE,'');

      // Verify: Verify Value Entry after running Post Inventory Cost To G/L batch job.
      ValueEntry.SETRANGE("Job No.",JobJournalLine."Job No.");
      Assert.AreEqual(2,ValueEntry.COUNT,
        STRSUBSTNO(EntryforJobMismatchErr,ValueEntry.TABLECAPTION,ValueEntry.FIELDCAPTION("Job No."),JobJournalLine."Job No."));
      ValueEntry.SETRANGE("Job Task No.",JobJournalLine."Job Task No.");
      Assert.AreEqual(2,ValueEntry.COUNT,
        STRSUBSTNO(
          EntryforJobMismatchErr,ValueEntry.TABLECAPTION,ValueEntry.FIELDCAPTION("Job Task No."),JobJournalLine."Job Task No."));
      GLEntry.SETRANGE("Job No.",JobJournalLine."Job No.");
      Assert.AreEqual(4,GLEntry.COUNT,
        STRSUBSTNO(EntryforJobMismatchErr,GLEntry.TABLECAPTION,GLEntry.FIELDCAPTION("Job No."),JobJournalLine."Job No."));

      // Tear down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,InventorySetup."Automatic Cost Posting",InventorySetup."Expected Cost Posting to G/L",
        InventorySetup."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE B296703_FinishedProdOrderWithNewUOM@129();
    VAR
      ParentItem@1000 : Record 27;
      ChildItem@1001 : Record 27;
      PurchaseLine@1002 : Record 39;
      ProductionOrder@1003 : Record 5405;
      ProdOrderLine@1004 : Record 5406;
      ItemUnitOfMeasure@1005 : Record 5404;
      InventorySetup@1006 : Record 313;
      InventorySetup2@1007 : Record 313;
      ValueEntry@1008 : Record 5802;
      CostAmount@1010 : Decimal;
      QtyPer@1009 : Decimal;
      ProdQty@1011 : Decimal;
      QtyPerBaseUOM@1012 : Decimal;
    BEGIN
      // Setup: Create parent and child Items in a Production BOM and certify it. Update Overhead rate, Unit of measure and Quantity per unit of measure on Parent Item. Create and Post Purchase Order as Receive.
      Initialize;
      InventorySetup.GET;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup2,TRUE,TRUE,InventorySetup2."Automatic Cost Adjustment"::Always,InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");

      ProdQty := LibraryRandom.RandIntInRange(10,20);
      QtyPer := LibraryRandom.RandInt(5);
      QtyPerBaseUOM := LibraryRandom.RandIntInRange(2,10);
      CreateItemsSetup(ParentItem,ChildItem,QtyPer);
      UpdateItemOverheadRate(ParentItem);
      CreateItemUnitOfMeasure(ItemUnitOfMeasure,ParentItem."No.",QtyPerBaseUOM);
      CreateAndPostPurchaseOrder(PurchaseLine,ChildItem."No.",ProdQty * QtyPer * QtyPerBaseUOM,
        LibraryRandom.RandDec(100,2),FALSE);

      // Create and refresh Released Production Order and change Unit of Measure on Production Order Line.
      CreateAndRefreshProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ParentItem."No.",ProdQty,'','');
      UpdateProdOrderLineUnitOfMeasureCode(ProdOrderLine,ParentItem."No.",ItemUnitOfMeasure.Code);

      // Open Production Journal and Post.
      LibraryPatterns.POSTConsumption(ProdOrderLine,ChildItem,'','',ProdQty * QtyPer * QtyPerBaseUOM,WORKDATE,0);
      LibraryPatterns.POSTOutput(ProdOrderLine,ProdQty,WORKDATE,0);

      // Exercise: Change Status from Released to Finished.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");

      // Verify: Verify Value Entries for Finished Production Order With Entry Type Direct Cost and Indirect Cost.
      // Verify the Cost Amount, Cost Per Unit and Invoiced Quantity as Zero.
      ParentItem.FIND('=');
      FilterValueEntry(ValueEntry,ProductionOrder."No.",ValueEntry."Item Ledger Entry Type"::Output);

      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::"Direct Cost");
      ValueEntry.FINDFIRST;
      VerifyValueEntryQtyAmt(
        ValueEntry,ProductionOrder.Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",0,0,0,0);

      ValueEntry.NEXT;
      CostAmount := ParentItem."Last Direct Cost" * ItemUnitOfMeasure."Qty. per Unit of Measure" * ProductionOrder.Quantity;
      VerifyValueEntryQtyAmt(
        ValueEntry,0,CostAmount,ProductionOrder.Quantity * ItemUnitOfMeasure."Qty. per Unit of Measure",
        ParentItem."Last Direct Cost",CostAmount);

      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::"Indirect Cost");
      ValueEntry.FINDFIRST;
      CostAmount := ProdOrderLine."Overhead Rate" * ItemUnitOfMeasure."Qty. per Unit of Measure" * ProductionOrder.Quantity;
      VerifyValueEntryQtyAmt(
        ValueEntry,0,CostAmount,0,ProdOrderLine."Overhead Rate",CostAmount);

      // Tear Down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,InventorySetup."Automatic Cost Posting",InventorySetup."Expected Cost Posting to G/L",
        InventorySetup."Automatic Cost Adjustment",InventorySetup."Average Cost Calc. Type",InventorySetup."Average Cost Period");
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE PS33217@9();
    VAR
      Item@1000 : Record 27;
      ItemJournalBatch@1002 : Record 233;
      ItemJournalLine@1001 : Record 83;
      InventorySetup@1003 : Record 313;
      InventorySetup2@1004 : Record 313;
      ItemLedgerEntry@1005 : Record 32;
      UnitCost@1007 : Decimal;
    BEGIN
      // Using hardcoded quantity and cost since this was a rounding error
      // Setup
      Initialize;
      InventorySetup.GET;
      ExecuteUIHandlers;
      LibraryInventory.UpdateInventorySetup(
        InventorySetup2,InventorySetup."Automatic Cost Posting",InventorySetup."Expected Cost Posting to G/L",
        InventorySetup2."Automatic Cost Adjustment"::Never,InventorySetup."Average Cost Calc. Type"::Item,
        InventorySetup."Average Cost Period"::Day);

      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::Average,0);

      // Exercise
      LibraryInventory.CreateItemJournalBatchByType(ItemJournalBatch,ItemJournalBatch."Template Type"::Item);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJournalLine,ItemJournalBatch,Item,'','',WORKDATE,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",15,200.5807);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJournalLine,ItemJournalBatch,Item,'','',WORKDATE,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",5,200.58);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJournalLine,ItemJournalBatch,Item,'','',WORKDATE,
        ItemJournalLine."Entry Type"::"Negative Adjmt.",0.8,0);
      LibraryPatterns.MAKEItemJournalLine(
        ItemJournalLine,ItemJournalBatch,Item,'','',WORKDATE,
        ItemJournalLine."Entry Type"::"Negative Adjmt.",0.4,0);
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Verify
      ItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::"Negative Adjmt.");
      ItemLedgerEntry.FIND('-');
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      Assert.AreEqual(-160.46,ItemLedgerEntry."Cost Amount (Actual)",
        STRSUBSTNO(CostMismatchErr,
          ItemLedgerEntry.FIELDCAPTION("Cost Amount (Actual)"),ItemLedgerEntry.TABLECAPTION,ItemLedgerEntry."Entry No."));
      ItemLedgerEntry.NEXT;
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      Assert.AreEqual(-80.23,ItemLedgerEntry."Cost Amount (Actual)",
        STRSUBSTNO(CostMismatchErr,
          ItemLedgerEntry.FIELDCAPTION("Cost Amount (Actual)"),ItemLedgerEntry.TABLECAPTION,ItemLedgerEntry."Entry No."));
      Item.FIND('=');
      UnitCost := ROUND(200.58085,LibraryERM.GetUnitAmountRoundingPrecision);
      Assert.AreEqual(UnitCost,Item."Unit Cost",
        STRSUBSTNO(CostMismatchErr,Item.FIELDCAPTION("Unit Cost"),Item.TABLECAPTION,Item."No."));

      // Tear Down.
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,InventorySetup."Automatic Cost Posting",InventorySetup."Expected Cost Posting to G/L",
        InventorySetup."Automatic Cost Adjustment",InventorySetup."Average Cost Calc. Type",InventorySetup."Average Cost Period");
    END;

    [Test]
    PROCEDURE B262357_B319186_DimensionInRevalManual@2();
    BEGIN
      DimensionInReval(TRUE);
    END;

    [Test]
    PROCEDURE B262357_B319186_DimensionInRevalCalcInvValue@22();
    BEGIN
      DimensionInReval(FALSE);
    END;

    LOCAL PROCEDURE DimensionInReval@82(ManualRevaluation@1000 : Boolean);
    VAR
      Item@1006 : Record 27;
      ItemJournalBatch@1005 : Record 233;
      ItemJournalLine@1004 : Record 83;
      ItemLedgerEntry@1003 : Record 32;
      CalculatePer@1002 : 'Item Ledger Entry,Item';
      CalcBase@1001 : ' ,Last Direct Unit Cost,Standard Cost - Assembly List,Standard Cost - Manufacturing';
    BEGIN
      LibraryPatterns.MAKEItemSimple(Item,Item."Costing Method"::FIFO,0);

      CreateItemJournalLineWithGlobalDim(ItemJournalBatch,ItemJournalLine,Item);

      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
      ItemLedgerEntry.SETRANGE("Item No.",Item."No.");
      ItemLedgerEntry.FINDLAST;

      // Exercise: Create a revaluation journal line to apply to the posted purchase
      IF ManualRevaluation THEN BEGIN
        LibraryInventory.CreateItemJournalBatchByType(ItemJournalBatch,ItemJournalBatch."Template Type"::Revaluation);
        LibraryPatterns.MAKEItemJournalLine(ItemJournalLine,ItemJournalBatch,Item,'','',WORKDATE,
          ItemJournalLine."Entry Type"::Purchase,ItemLedgerEntry.Quantity,0);
        ItemJournalLine.VALIDATE("Applies-to Entry",ItemLedgerEntry."Entry No.");
        ItemJournalLine.MODIFY(TRUE);
      END ELSE BEGIN
        LibraryPatterns.MAKERevaluationJournalLine(ItemJournalBatch,Item,WORKDATE,
          CalculatePer::"Item Ledger Entry",FALSE,FALSE,FALSE,CalcBase::" ");
        ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
        ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
        ItemJournalLine.SETRANGE("Applies-to Entry",ItemLedgerEntry."Entry No.");
        ItemJournalLine.FINDFIRST;
      END;

      // Verify
      Assert.AreEqual(ItemLedgerEntry."Dimension Set ID",ItemJournalLine."Dimension Set ID",
        STRSUBSTNO(ValueMismatchErr,ItemJournalLine.FIELDCAPTION("Dimension Set ID")));
      Assert.AreEqual(ItemLedgerEntry."Global Dimension 1 Code",ItemJournalLine."Shortcut Dimension 1 Code",
        STRSUBSTNO(ValueMismatchErr,ItemJournalLine.FIELDCAPTION("Shortcut Dimension 1 Code")));
      Assert.AreEqual(ItemLedgerEntry."Global Dimension 2 Code",ItemJournalLine."Shortcut Dimension 2 Code",
        STRSUBSTNO(ValueMismatchErr,ItemJournalLine.FIELDCAPTION("Shortcut Dimension 2 Code")));
    END;

    LOCAL PROCEDURE CreateAndCertifyProductionBOM@77(VAR ProductionBOMHeader@1000 : Record 99000771;BaseUnitOfMeasure@1003 : Code[10];No@1004 : Code[20];RoutingLinkCode@1001 : Code[10]);
    VAR
      ProductionBOMLine@1002 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,BaseUnitOfMeasure);
      LibraryManufacturing.CreateProductionBOMLine(ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,No,1);  // Use blank value for Version Code and 1 for Quantity per.
      ProductionBOMLine.VALIDATE("Routing Link Code",RoutingLinkCode);
      ProductionBOMLine.MODIFY(TRUE);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndModifyItem@26(VendorNo@1001 : Code[20];CostingMethod@1004 : Option;FlushingMethod@1003 : Option;ReplenishmentSystem@1002 : Option;IndCostPercentage@1005 : Decimal) : Code[20];
    VAR
      Item@1000 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Costing Method",CostingMethod);
      Item.VALIDATE("Last Direct Cost",LibraryRandom.RandInt(10));
      Item.VALIDATE("Unit Cost",LibraryRandom.RandInt(10));
      Item.VALIDATE("Unit Price",LibraryRandom.RandDec(10,2));
      Item.VALIDATE("Indirect Cost %",IndCostPercentage);
      Item.VALIDATE("Reordering Policy",Item."Reordering Policy"::"Lot-for-Lot");
      Item.VALIDATE("Vendor No.",VendorNo);
      Item.VALIDATE("Replenishment System",ReplenishmentSystem);
      Item.VALIDATE("Flushing Method",FlushingMethod);
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateAndPostJobJournalLine@18(VAR JobJournalLine@1001 : Record 210);
    VAR
      Item@1004 : Record 27;
      Job@1003 : Record 167;
      JobTask@1002 : Record 1001;
    BEGIN
      Item.GET(CreateAndModifyItem('',Item."Costing Method"::Average,Item."Flushing Method"::Manual,
          Item."Replenishment System"::Purchase,0));
      LibraryJob.CreateJob(Job);
      LibraryJob.CreateJobTask(Job,JobTask);
      LibraryJob.CreateJobJournalLine(JobJournalLine."Line Type"::" ",JobTask,JobJournalLine);
      JobJournalLine.VALIDATE(Type,JobJournalLine.Type::Item);
      JobJournalLine.VALIDATE("No.",Item."No.");
      JobJournalLine.VALIDATE(Quantity,LibraryRandom.RandDec(10,2));
      JobJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(10,2));
      JobJournalLine.MODIFY(TRUE);
      LibraryJob.PostJobJournal(JobJournalLine);
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrder@46(VAR PurchaseLine@1000 : Record 39;ItemNo@1002 : Code[20];Qty@1001 : Decimal;DirectUnitCost@1003 : Decimal;Invoice@1004 : Boolean) : Code[20];
    BEGIN
      CreatePurchaseDocument(
        PurchaseLine,PurchaseLine."Document Type"::Order,ItemNo,'',CreateVendor,Qty,WORKDATE);
      IF DirectUnitCost <> 0 THEN BEGIN
        PurchaseLine.VALIDATE("Direct Unit Cost",DirectUnitCost);
        PurchaseLine.MODIFY(TRUE);
      END;
      EXIT(PostPurchaseDocument(PurchaseLine,Invoice));
    END;

    LOCAL PROCEDURE CreateAndRefreshProductionOrder@5(VAR ProductionOrder@1000 : Record 5405;Status@1001 : Option;SourceNo@1002 : Code[20];Quantity@1003 : Decimal;LocationCode@1004 : Code[10];BinCode@1005 : Code[20]);
    BEGIN
      LibraryManufacturing.CreateProductionOrder(ProductionOrder,Status,ProductionOrder."Source Type"::Item,SourceNo,Quantity);
      ProductionOrder.VALIDATE("Location Code",LocationCode);
      ProductionOrder.VALIDATE("Bin Code",BinCode);
      ProductionOrder.MODIFY(TRUE);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
    END;

    LOCAL PROCEDURE CreateItemsSetup@4(VAR Item@1005 : Record 27;VAR Item2@1001 : Record 27;QuantityPer@1002 : Integer);
    VAR
      ProductionBOMHeader@1000 : Record 99000771;
    BEGIN
      // Create Child Item.
      LibraryInventory.CreateItem(Item2);
      Item2.VALIDATE("Unit Cost",LibraryRandom.RandDec(100,2));
      Item2.MODIFY(TRUE);

      // Create Production BOM, Parent Item and attach Production BOM.
      CreateCertifiedProductionBOM(ProductionBOMHeader,Item2,QuantityPer);
      CreateProductionItem(Item,ProductionBOMHeader."No.");
    END;

    LOCAL PROCEDURE CreateCertifiedProductionBOM@3(VAR ProductionBOMHeader@1001 : Record 99000771;Item@1002 : Record 27;QuantityPer@1003 : Integer);
    VAR
      ProductionBOMLine@1000 : Record 99000772;
    BEGIN
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,Item."Base Unit of Measure");
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,Item."No.",QuantityPer);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateProductionItem@66(VAR Item@1000 : Record 27;ProductionBOMNo@1001 : Code[20]);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Unit Cost",LibraryRandom.RandDec(100,2));
      Item.VALIDATE("Replenishment System",Item."Replenishment System"::"Prod. Order");
      Item.VALIDATE("Production BOM No.",ProductionBOMNo);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateCustomer@19() : Code[20];
    VAR
      Customer@1000 : Record 18;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      EXIT(Customer."No.");
    END;

    LOCAL PROCEDURE CreateCurrencyWithExchangeRate@29(VAR Currency@1001 : Record 4);
    VAR
      GLAccount@1002 : Record 15;
    BEGIN
      LibraryERM.FindGLAccount(GLAccount);
      LibraryERM.CreateCurrency(Currency);
      Currency.VALIDATE("Residual Gains Account",GLAccount."No.");
      Currency.VALIDATE("Residual Losses Account",GLAccount."No.");
      Currency.MODIFY(TRUE);
      LibraryERM.CreateRandomExchangeRate(Currency.Code);
    END;

    LOCAL PROCEDURE CreateItemJournalLineWithGlobalDim@8(VAR ItemJournalBatch@1007 : Record 233;VAR ItemJournalLine@1002 : Record 83;Item@1003 : Record 27);
    VAR
      GeneralLedgerSetup@1005 : Record 98;
      DimVal@1006 : Record 349;
    BEGIN
      LibraryInventory.CreateItemJournalBatchByType(ItemJournalBatch,ItemJournalBatch."Template Type"::Item);
      LibraryPatterns.MAKEItemJournalLine(ItemJournalLine,ItemJournalBatch,Item,'','',WORKDATE,
        ItemJournalLine."Entry Type"::Purchase,LibraryRandom.RandInt(10),LibraryRandom.RandInt(10));

      GeneralLedgerSetup.GET;

      DimVal.SETRANGE("Dimension Code",GeneralLedgerSetup."Global Dimension 1 Code");
      DimVal.SETRANGE("Dimension Value Type",DimVal."Dimension Value Type"::Standard);
      DimVal.FINDFIRST;
      ItemJournalLine.VALIDATE("Shortcut Dimension 1 Code",DimVal.Code);

      DimVal.SETRANGE("Dimension Code",GeneralLedgerSetup."Global Dimension 2 Code");
      DimVal.SETRANGE("Dimension Value Type",DimVal."Dimension Value Type"::Standard);
      DimVal.FINDFIRST;
      ItemJournalLine.VALIDATE("Shortcut Dimension 2 Code",DimVal.Code);

      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemUnitOfMeasure@58(VAR ItemUnitOfMeasure@1000 : Record 5404;ItemNo@1002 : Code[20];QtyPerUnitOfMeasure@1003 : Integer);
    BEGIN
      LibraryInventory.CreateItemUnitOfMeasureCode(ItemUnitOfMeasure,ItemNo,QtyPerUnitOfMeasure);
    END;

    LOCAL PROCEDURE CreateOutputJournal@86(VAR ItemJournalLine@1000 : Record 83;ItemNo@1002 : Code[20];ProductionOrderNo@1001 : Code[20];OperationNo@1005 : Code[10];OutputQuantity@1006 : Decimal;AppliesToEntry@1007 : Integer);
    VAR
      ItemJournalTemplate@1003 : Record 82;
      ItemJournalBatch@1004 : Record 233;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Output);
      SelectAndClearItemJournalBatch(ItemJournalBatch,ItemJournalBatch."Template Type"::Output);
      LibraryManufacturing.CreateOutputJournal(ItemJournalLine,ItemJournalTemplate,ItemJournalBatch,ItemNo,ProductionOrderNo);
      ItemJournalLine.VALIDATE("Operation No.",OperationNo);
      ItemJournalLine.VALIDATE("Output Quantity",OutputQuantity);
      ItemJournalLine.VALIDATE("Applies-to Entry",AppliesToEntry);
      ItemJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreatePurchaseDocument@65(VAR PurchaseLine@1000 : Record 39;DocumentType@1004 : Option;ItemNo@1003 : Code[20];VariantCode@1001 : Code[10];VendorNo@1006 : Code[20];Quantity@1007 : Decimal;OrderDate@1008 : Date);
    VAR
      PurchaseHeader@1002 : Record 38;
      GLAccount@1011 : Record 15;
      GeneralPostingSetup@1012 : Record 252;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,DocumentType,VendorNo);
      PurchaseHeader.VALIDATE("Order Date",OrderDate);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity);
      PurchaseLine.VALIDATE("Variant Code",VariantCode);
      PurchaseLine.MODIFY(TRUE);

      // Update 'Invt. Accrual Acc. (Interim)' in General Posting Setup.
      LibraryERM.FindGLAccount(GLAccount);
      GeneralPostingSetup.GET(PurchaseLine."Gen. Bus. Posting Group",PurchaseLine."Gen. Prod. Posting Group");
      GeneralPostingSetup.VALIDATE("Invt. Accrual Acc. (Interim)",GLAccount."No.");
      GeneralPostingSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreatePurchaseOrderWithCurrency@114(VAR PurchaseLine@1000 : Record 39;No@1001 : Code[20];CurrencyCode@1002 : Code[10];PostingDate@1006 : Date;DirectUnitCost@1008 : Decimal;Quantity@1005 : Decimal);
    VAR
      PurchaseHeader@1007 : Record 38;
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,CreateVendor);
      PurchaseHeader.VALIDATE("Posting Date",PostingDate);
      PurchaseHeader.VALIDATE("Currency Code",CurrencyCode);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,No,Quantity);
      PurchaseLine.VALIDATE("Direct Unit Cost",DirectUnitCost);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateRoutingSetup@166(WorkCenterNo@1001 : Code[20];RoutingLinkCode@1000 : Code[10]) : Code[20];
    VAR
      RoutingHeader@1002 : Record 99000763;
      RoutingLine@1004 : Record 99000764;
    BEGIN
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);
      CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenterNo);
      RoutingLine.VALIDATE("Routing Link Code",RoutingLinkCode);
      RoutingLine.MODIFY(TRUE);
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
      EXIT(RoutingHeader."No.");
    END;

    LOCAL PROCEDURE CreateRoutingLine@165(VAR RoutingLine@1003 : Record 99000764;RoutingHeader@1000 : Record 99000763;CenterNo@1002 : Code[20]);
    VAR
      OperationNo@1001 : Code[10];
    BEGIN
      // Random value used so that the Next Operation No is greater than the previous Operation No.
      OperationNo := FindLastOperationNo(RoutingHeader."No.") + FORMAT(LibraryRandom.RandInt(5));
      LibraryManufacturing.CreateRoutingLineSetup(
        RoutingLine,RoutingHeader,CenterNo,OperationNo,LibraryRandom.RandInt(5),LibraryRandom.RandInt(5));
    END;

    LOCAL PROCEDURE CreateSalesDocument@87(VAR SalesHeader@1000 : Record 36;VAR SalesLine@1003 : Record 37;DocumentType@1007 : Option;Type@1005 : Option;ItemNo@1004 : Code[20];VariantCode@1002 : Code[10];Quantity@1001 : Decimal);
    VAR
      ReasonCode@1006 : Record 231;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,DocumentType,CreateCustomer);
      IF SalesHeader."Document Type" IN [SalesHeader."Document Type"::"Return Order",SalesHeader."Document Type"::"Credit Memo"]
      THEN BEGIN
        LibraryERM.CreateReasonCode(ReasonCode);
        SalesHeader.VALIDATE("Reason Code",ReasonCode.Code);
        SalesHeader.MODIFY;
      END;

      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,Type,ItemNo,Quantity);
      SalesLine.VALIDATE("Unit Price",LibraryRandom.RandInt(10));
      SalesLine.VALIDATE("Variant Code",VariantCode);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateVendor@11() : Code[20];
    VAR
      Vendor@1000 : Record 23;
    BEGIN
      LibraryPurchase.CreateVendor(Vendor);
      EXIT(Vendor."No.");
    END;

    LOCAL PROCEDURE ExecuteUIHandlers@1033();
    BEGIN
      // Generate Dummy message. Required for executing the test case successfully.
      MESSAGE('');
      IF CONFIRM('') THEN;
    END;

    LOCAL PROCEDURE FindCapacityLedgerEntry@59(VAR CapacityLedgerEntry@1000 : Record 5832;OrderNo@1001 : Code[20]);
    BEGIN
      CapacityLedgerEntry.SETRANGE("Order Type",CapacityLedgerEntry."Order Type"::Production);
      CapacityLedgerEntry.SETRANGE("Order No.",OrderNo);
      CapacityLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindItemLedgerEntry@35(VAR ItemLedgerEntry@1000 : Record 32;EntryType@1001 : Option;OrderNo@1002 : Code[20]);
    BEGIN
      ItemLedgerEntry.SETRANGE("Entry Type",EntryType);
      ItemLedgerEntry.SETRANGE("Order Type",ItemLedgerEntry."Order Type"::Production);
      ItemLedgerEntry.SETRANGE("Order No.",OrderNo);
      ItemLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FindLastOperationNo@170(RoutingNo@1000 : Code[20]) : Code[10];
    VAR
      RoutingLine@1001 : Record 99000764;
    BEGIN
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      IF RoutingLine.FINDLAST THEN
        EXIT(RoutingLine."Operation No.");
      EXIT('');
    END;

    LOCAL PROCEDURE FindReleasedProdOrderLine@218(VAR ProdOrderLine@1001 : Record 5406;ItemNo@1000 : Code[20]);
    BEGIN
      ProdOrderLine.SETRANGE(Status,ProdOrderLine.Status::Released);
      ProdOrderLine.SETRANGE("Item No.",ItemNo);
      ProdOrderLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindSalesLine@34(VAR SalesLine@1002 : Record 37;DocumentType@1000 : Option;DocumentNo@1001 : Code[20]);
    BEGIN
      SalesLine.SETRANGE("Document Type",DocumentType);
      SalesLine.SETRANGE("Document No.",DocumentNo);
      SalesLine.SETRANGE(Type,SalesLine.Type::Item);
      SalesLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindShipmentLine@75(VAR SalesShipmentLine@1000 : Record 111;No@1001 : Code[20]);
    BEGIN
      SalesShipmentLine.SETRANGE("No.",No);
      SalesShipmentLine.FINDFIRST;
    END;

    LOCAL PROCEDURE FindValueEntry@52(VAR ValueEntry@1007 : Record 5802;DocumentNo@1006 : Code[20];ItemChargeNo@1005 : Code[20];LocationCode@1004 : Code[10];Adjustment@1003 : Boolean;ItemLedgerEntryType@1002 : Option);
    BEGIN
      ValueEntry.SETRANGE("Item Ledger Entry Type",ItemLedgerEntryType);
      ValueEntry.SETRANGE(Adjustment,Adjustment);
      ValueEntry.SETRANGE("Item Charge No.",ItemChargeNo);
      ValueEntry.SETRANGE("Location Code",LocationCode);
      ValueEntry.SETRANGE("Document No.",DocumentNo);
      ValueEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE FilterValueEntry@143(VAR ValueEntry@1003 : Record 5802;DocumentNo@1001 : Code[20];ItemLedgerEntryType@1002 : Option);
    BEGIN
      ValueEntry.SETRANGE("Item Ledger Entry Type",ItemLedgerEntryType);
      ValueEntry.SETRANGE("Document No.",DocumentNo);
    END;

    LOCAL PROCEDURE GetOperationNo@62(OrderNo@1001 : Code[20]) : Code[10];
    VAR
      CapacityLedgerEntry@1000 : Record 5832;
    BEGIN
      FindCapacityLedgerEntry(CapacityLedgerEntry,OrderNo);
      EXIT(CapacityLedgerEntry."Operation No.");
    END;

    LOCAL PROCEDURE PostPurchaseDocument@63(PurchaseLine@1000 : Record 39;Invoice@1002 : Boolean) : Code[20];
    VAR
      PurchaseHeader@1001 : Record 38;
    BEGIN
      PurchaseHeader.GET(PurchaseLine."Document Type",PurchaseLine."Document No.");
      EXIT(LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,Invoice));
    END;

    LOCAL PROCEDURE SelectAndClearItemJournalBatch@95(VAR ItemJournalBatch@1000 : Record 233;TemplateType@1002 : Option);
    VAR
      ItemJournalTemplate@1001 : Record 82;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,TemplateType);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
    END;

    LOCAL PROCEDURE SetupForAdjustCostOnACY@225(VAR SalesHeader@1004 : Record 36;ItemNo@1006 : Code[20];CurrencyCode@1008 : Code[10]);
    VAR
      Item@1009 : Record 27;
      InventorySetup@1007 : Record 313;
      SalesHeader2@1005 : Record 36;
      SalesLine@1001 : Record 37;
      PurchaseLine@1003 : Record 39;
      UnitPrice@1000 : Decimal;
      PosAdjQty@1010 : Decimal;
    BEGIN
      // Create Item Journal and Post, create Purchase Order and Receive.
      UpdateGeneralLedgerSetupForACY(CurrencyCode);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,InventorySetup."Automatic Cost Adjustment",InventorySetup."Average Cost Calc. Type",
        InventorySetup."Average Cost Period");
      Item.GET(ItemNo);
      PosAdjQty := LibraryRandom.RandDec(100,2);
      LibraryPatterns.POSTPositiveAdjustment(Item,'','','',LibraryRandom.RandInt(10) + 10,WORKDATE,PosAdjQty);
      CreatePurchaseOrderWithCurrency(
        PurchaseLine,ItemNo,CurrencyCode,CALCDATE('<1M + ' + FORMAT(LibraryRandom.RandInt(3)) + 'D>',WORKDATE),
        LibraryRandom.RandInt(50),PosAdjQty + LibraryRandom.RandInt(40));
      // Use random value for Direct Unit Cost.
      PostPurchaseDocument(PurchaseLine,TRUE);

      // Create Sales Order and Ship, Purchase Order Invoiced.
      CreateSalesDocument(
        SalesHeader,SalesLine,SalesHeader."Document Type"::Order,SalesLine.Type::Item,ItemNo,'',PurchaseLine.Quantity);
      UnitPrice := PurchaseLine."Direct Unit Cost" + LibraryRandom.RandInt(50); // Required Unit Price more than Direct Unti Cost.
      UpdateSalesDocument(
        SalesLine,SalesHeader,CALCDATE('<1M + ' + FORMAT(LibraryRandom.RandInt(3)) + 'D>',WORKDATE),CurrencyCode,UnitPrice);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);

      // Undo Sale Shipment, update blank Currency in Sales Order and Post.
      UndoSalesShipment(SalesLine);
      UpdateSalesDocument(SalesLine,SalesHeader,CALCDATE('<1D>',SalesHeader."Posting Date"),'',UnitPrice);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);

      // Create Credit Memo without Currency Code and Post.
      CreateSalesDocument(
        SalesHeader2,SalesLine,SalesHeader2."Document Type"::"Credit Memo",SalesLine.Type::Item,ItemNo,'',SalesLine.Quantity);
      UpdateSalesDocument(SalesLine,SalesHeader2,CALCDATE('<1D>',SalesHeader."Posting Date"),'',UnitPrice);
      LibrarySales.PostSalesDocument(SalesHeader2,TRUE,TRUE);
    END;

    LOCAL PROCEDURE SetupForPostOutputJournal@69(VAR ProductionOrder@1000 : Record 5405;ItemNo@1002 : Code[20]);
    VAR
      Item@1001 : Record 27;
      ItemJournalLine@1003 : Record 83;
      PurchaseLine@1004 : Record 39;
      PurchaseLine2@1005 : Record 39;
    BEGIN
      // Create Finished Item.
      Item.GET(CreateAndModifyItem('',Item."Costing Method"::FIFO,Item."Flushing Method"::Backward,
          Item."Replenishment System"::"Prod. Order",0)); // Finished Item.

      // Update BOM and Routing on Item, create and post two Purchase Order with different 'Unit Cost'.
      UpdateItemWithCertifiedBOMAndRouting(Item,ItemNo);
      CreateAndPostPurchaseOrder(PurchaseLine,ItemNo,LibraryRandom.RandDec(100,2),0,TRUE);

      CreatePurchaseDocument(
        PurchaseLine2,PurchaseLine2."Document Type"::Order,PurchaseLine."No.",'',CreateVendor,LibraryRandom.RandInt(10),
        WORKDATE);  // Used Random for Quantity.
      PurchaseLine2.VALIDATE("Direct Unit Cost",(PurchaseLine2."Direct Unit Cost" + LibraryRandom.RandInt(10)));  // 'Direct Unit Cost' required more than previous Purchase Order.
      PurchaseLine2.MODIFY(TRUE);
      PostPurchaseDocument(PurchaseLine2,TRUE);

      // Create Released Production Order and create Output Journal, Explode Routing and Post.
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,Item."No.",
        LibraryRandom.RandInt(10));   // Used Random Int for Quantity.
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      CreateOutputJournal(ItemJournalLine,Item."No.",ProductionOrder."No.",'',0,0);  // 0s are used for 'Output Quantity' and 'Apply to Entry'.
      CODEUNIT.RUN(CODEUNIT::"Output Jnl.-Expl. Route",ItemJournalLine);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE UndoSalesShipment@17(SalesLine@1000 : Record 37);
    VAR
      SalesShipmentLine@1001 : Record 111;
    BEGIN
      FindShipmentLine(SalesShipmentLine,SalesLine."No.");
      LibrarySales.UndoSalesShipmentLine(SalesShipmentLine);
    END;

    LOCAL PROCEDURE UpdateItemWithCertifiedBOMAndRouting@32(VAR Item@1000 : Record 27;ItemNo@1002 : Code[20]);
    VAR
      ProductionBOMHeader@1001 : Record 99000771;
      RoutingLink@1005 : Record 99000777;
      WorkCenter@1007 : Record 99000754;
    BEGIN
      RoutingLink.FINDFIRST;
      WorkCenter.FINDFIRST;

      // Create Production BOM with Raouting Link Code.
      CreateAndCertifyProductionBOM(ProductionBOMHeader,Item."Base Unit of Measure",ItemNo,RoutingLink.Code);

      // Update Item with Prodouction BOM No. and Routing No.
      Item.VALIDATE("Production BOM No.",ProductionBOMHeader."No.");
      Item.VALIDATE("Routing No.",CreateRoutingSetup(WorkCenter."No.",RoutingLink.Code));
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateItemOverheadRate@139(VAR Item@1000 : Record 27);
    BEGIN
      Item.VALIDATE("Overhead Rate",LibraryRandom.RandInt(5));
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateGeneralLedgerSetupForACY@16(CurrencyCode@1001 : Code[10]);
    VAR
      GeneralLedgerSetup@1000 : Record 98;
    BEGIN
      GeneralLedgerSetup.GET;
      GeneralLedgerSetup."Additional Reporting Currency" := CurrencyCode;
      GeneralLedgerSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateProdOrderLineUnitOfMeasureCode@7(VAR ProdOrderLine@1000 : Record 5406;ItemNo@1001 : Code[20];UnitOfMeasureCode@1002 : Code[10]);
    BEGIN
      FindReleasedProdOrderLine(ProdOrderLine,ItemNo);
      ProdOrderLine.VALIDATE("Unit of Measure Code",UnitOfMeasureCode);
      ProdOrderLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateSalesDocument@98(VAR SalesLine@1001 : Record 37;SalesHeader@1000 : Record 36;PostingDate@1002 : Date;CurrencyCode@1003 : Code[10];UnitPrice@1004 : Decimal);
    BEGIN
      SalesHeader.VALIDATE("Posting Date",PostingDate);
      SalesHeader.VALIDATE("Currency Code",CurrencyCode);
      SalesHeader.MODIFY(TRUE);
      SalesLine.VALIDATE("Unit Price",UnitPrice);
      SalesLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE VerifyGLEntry@207(DocumentType@1004 : Option;DocumentNo@1001 : Code[20];Amount@1002 : Decimal;GenPostingType@1003 : Option);
    VAR
      GLEntry@1000 : Record 17;
      ActualAmount@1005 : Decimal;
    BEGIN
      GLEntry.SETRANGE("Document Type",DocumentType);
      GLEntry.SETRANGE("Document No.",DocumentNo);
      GLEntry.SETRANGE("Gen. Posting Type",GenPostingType);
      GLEntry.FINDSET;
      REPEAT
        ActualAmount := GLEntry.Amount;
      UNTIL GLEntry.NEXT = 0;
      Assert.AreNearlyEqual(Amount,ActualAmount,LibraryERM.GetAmountRoundingPrecision,'Wrong amount in GL entry.');
    END;

    LOCAL PROCEDURE VerifyValueEntry@28(ItemLedgerEntryType@1001 : Option;DocumentNo@1002 : Code[20];ItemNo@1003 : Code[20]);
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      FindValueEntry(ValueEntry,DocumentNo,'','',FALSE,ItemLedgerEntryType);
      ValueEntry.TESTFIELD("Item No.",ItemNo);
    END;

    LOCAL PROCEDURE VerifyValueEntryQtyAmt@140(VAR ValueEntry@1000 : Record 5802;ItemLedgerEntryQuantity@1002 : Decimal;CostPostedToGL@1003 : Decimal;InvoicedQuantity@1004 : Decimal;CostPerUnit@1005 : Decimal;CostAmountActual@1006 : Decimal);
    BEGIN
      ValueEntry.TESTFIELD("Item Ledger Entry Quantity",ItemLedgerEntryQuantity);
      ValueEntry.TESTFIELD("Cost Posted to G/L",CostPostedToGL);
      ValueEntry.TESTFIELD("Invoiced Quantity",InvoicedQuantity);
      ValueEntry.TESTFIELD("Cost per Unit",CostPerUnit);
      ValueEntry.TESTFIELD("Cost Amount (Actual)",CostAmountActual);
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@25(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@21(Message@1000 : Text[1024]);
    BEGIN
    END;

    BEGIN
    {
      // [FEATURE] [SCM]
    }
    END.
  }
}

