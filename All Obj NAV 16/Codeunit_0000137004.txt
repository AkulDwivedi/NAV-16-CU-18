OBJECT Codeunit 137004 SCM WIP Costing Production-II
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVIN9.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LibraryUtility@1003 : Codeunit 131000;
      LibraryCosting@1014 : Codeunit 132200;
      LibraryPurchase@1013 : Codeunit 130512;
      LibraryPlanning@1016 : Codeunit 132203;
      LibraryInventory@1015 : Codeunit 132201;
      LibraryManufacturing@1001 : Codeunit 132202;
      LibraryERM@1006 : Codeunit 131300;
      Assert@1004 : Codeunit 130000;
      LibraryRandom@1012 : Codeunit 130440;
      isInitialized@1000 : Boolean;
      ErrMessageNotFoundZeroAmt@1005 : TextConst 'ENU=The sum of amounts must be zero.';
      ErrMessageAmountDoNotMatch@1002 : TextConst 'ENU=The WIP amount totals must be equal.';
      FlushingMethod@1011 : 'Manual,Forward,Backward';
      SubcontractFlushingMethod@1010 : 'Manual,Forward,Backward';
      CostingMethod@1009 : 'FIFO,LIFO,Specific,Average,Standard';
      UnitCostCalculation@1008 : 'Time,Units';
      ProductionOrderStatus@1007 : 'Simulated,Planned,Firm Planned,Released,Finished';

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE StdSubconMan@25();
    BEGIN
      // [FEATURE] [Cost Standard]
      // [SCENARIO] Test Standard Costing of Subcontracting Order with Flushing method - Manual.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Manual,SubcontractFlushingMethod::Manual,CostingMethod::Standard,
        ProductionOrderStatus::Released,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE StdManualCostDiff@20();
    BEGIN
      // [FEATURE] [Cost Standard]
      // [SCENARIO] Test Standard Costing of Flushing method - Manual Cost different from Expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Units,FlushingMethod::Manual,SubcontractFlushingMethod,CostingMethod::Standard,
        ProductionOrderStatus::Released,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE StdSubconManCostDiff@6();
    BEGIN
      // [FEATURE] [Cost Standard]
      // [SCENARIO] Test Standard Costing of Subcontracting Order with Flushing method - Manual. Subcontract and Output Cost different from Expected.
      SCMWIPCostingProductionII(
        UnitCostCalculation::Units,FlushingMethod::Manual,SubcontractFlushingMethod::Manual,CostingMethod::Standard,
        ProductionOrderStatus::Released,TRUE,FALSE,FALSE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE StdSubconBackward@76();
    BEGIN
      // [FEATURE] [Cost Standard]
      // [SCENARIO] Test Standard Costing of Subcontracting Order with Flushing method - Backward and of Subcontract Work center as Manual.
      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Backward,SubcontractFlushingMethod::Manual,CostingMethod::Standard,
        ProductionOrderStatus::Released,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE StdForwardProdOrderComp@77();
    BEGIN
      // [FEATURE] [Cost Standard]
      // [SCENARIO] Test Standard Costing with Flushing method Forward for Planned Production Order.Replace Production Component.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Units,FlushingMethod::Forward,SubcontractFlushingMethod,CostingMethod::Standard,
        ProductionOrderStatus::Planned,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AvgSubconBackward@24();
    BEGIN
      // [FEATURE] [Cost Average]
      // [SCENARIO] Test Average Costing of Subcontracting Order with Flushing method - Backward and of Subcontract Work center as Manual.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Backward,SubcontractFlushingMethod::Manual,CostingMethod::Average,
        ProductionOrderStatus::Released,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AvgSubconManCostDiff@29();
    BEGIN
      // [FEATURE] [Cost Average]
      // [SCENARIO] Test Average Costing of Subcontracting Order with Flushing method - Manual. Subcontract and Output Cost different from Expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Units,FlushingMethod::Manual,SubcontractFlushingMethod::Backward,CostingMethod::Average,
        ProductionOrderStatus::Released,TRUE,FALSE,FALSE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE StdSubconManCostDiffAddCurr@23();
    BEGIN
      // [FEATURE] [Cost Standard]
      // [SCENARIO] Test Standard Costing for Additional Currency of Subcontracting Order with Flushing method - Manual. Subcontract and Output Cost different from Expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Units,FlushingMethod::Manual,SubcontractFlushingMethod::Manual,CostingMethod::Standard,
        ProductionOrderStatus::Released,TRUE,FALSE,TRUE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE StdSubconBackwardAddCurr@34();
    BEGIN
      // [FEATURE] [Cost Standard]
      // [SCENARIO] Test Standard Costing for Additional Currency of Subcontracting Order with Flushing method - Backward and of Subcontract Work center as Manual.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Backward,SubcontractFlushingMethod::Manual,CostingMethod::Standard,
        ProductionOrderStatus::Released,TRUE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOForward@41();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test FIFO Costing of Flushing method - Forward.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Forward,SubcontractFlushingMethod,CostingMethod::FIFO,
        ProductionOrderStatus::Planned,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOManCapCostDiff@68();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test FIFO Costing of Flushing method - Manual, Cost, consumption Run Time and Setup Time is  different from Expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Manual,SubcontractFlushingMethod,CostingMethod::FIFO,
        ProductionOrderStatus::Released,FALSE,FALSE,FALSE,FALSE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOForwardProductionComponent@39();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test FIFO Costing with Flushing method Forward, replacing production order component.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Forward,SubcontractFlushingMethod,CostingMethod::FIFO,
        ProductionOrderStatus::Planned,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOSubconBackward@44();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test FIFO Costing of Subcontracting Order with Flushing method - Backward and of Subcontract Work center as Manual.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Backward,SubcontractFlushingMethod::Manual,CostingMethod::FIFO,
        ProductionOrderStatus::Released,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOSubconManCostDiff@48();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test FIFO Costing of Subcontracting Order with Flushing method - Manual. Output Cost and Subcontract Cost are different from expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Manual,SubcontractFlushingMethod::Manual,CostingMethod::FIFO,
        ProductionOrderStatus::Released,TRUE,FALSE,FALSE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AvgForwardAddCurr@54();
    BEGIN
      // [FEATURE] [Cost Average]
      // [SCENARIO] Test Average Costing for Additional Currency of Flushing method - Forward.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Forward,SubcontractFlushingMethod,CostingMethod::Average,
        ProductionOrderStatus::Planned,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AvgManCapCostDiffAddCurr@66();
    BEGIN
      // [FEATURE] [Cost Average]
      // [SCENARIO] Test Average Costing for Additional Currency of Flushing method - Manual. Output cost, consumption Cost, Run Time and Setup Time is  different from Expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Manual,SubcontractFlushingMethod,CostingMethod::Average,
        ProductionOrderStatus::Released,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,TRUE,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AvgForwardProdOrderCompAddCurr@69();
    BEGIN
      // [FEATURE] [Cost Average]
      // [SCENARIO] Test Average Costing for Additional Currency Of Flushing method Forward for Planned Production Order. Delete one Production Component.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Units,FlushingMethod::Forward,SubcontractFlushingMethod,CostingMethod::Average,
        ProductionOrderStatus::Planned,FALSE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AvgManualRoutingDiffAddCurr@91();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test Average Costing for Additional Currency of Flushing method - Manual. Update Production order routing.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Manual,SubcontractFlushingMethod,CostingMethod::FIFO,
        ProductionOrderStatus::Released,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AvgSubconBackwardAddCurr@79();
    BEGIN
      // [FEATURE] [Cost Average]
      // [SCENARIO] Test Average Costing for Additional Currency of Subcontracting Order with Flushing method - Backward. Subcontract Work center as Manual.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Backward,SubcontractFlushingMethod::Manual,CostingMethod::Average,
        ProductionOrderStatus::Released,TRUE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE AvgSubconManCostDiffAddCurr@78();
    BEGIN
      // [FEATURE] [Cost Average]
      // [SCENARIO] Test Average Costing for Additional Currency of Subcontracting Order with Flushing method - Manual. Subcontract Work center as Backward.Subcontract and Output Cost different from Expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Units,FlushingMethod::Manual,SubcontractFlushingMethod::Backward,CostingMethod::Average,
        ProductionOrderStatus::Released,TRUE,FALSE,TRUE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOManCapConsCostDiffAddCurr@56();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test Average Costing for Additional Currency of Flushing method - Manual. Output cost, consumption Cost, Run Time and Setup Time is  different from Expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Manual,SubcontractFlushingMethod,CostingMethod::FIFO,
        ProductionOrderStatus::Released,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,TRUE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOSubconBackCostDiffAddCurr@52();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test Average Costing for Additional Currency of Subcontracting Order with Flushing method - Manual. Subcontract Work center as Backward.Subcontract and Output Cost different from Expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Units,FlushingMethod::Manual,SubcontractFlushingMethod::Backward,CostingMethod::FIFO,
        ProductionOrderStatus::Released,TRUE,FALSE,TRUE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOForwardAddCurr@64();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test FIFO Costing of Flushing method - Forward.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Forward,SubcontractFlushingMethod,CostingMethod::FIFO,
        ProductionOrderStatus::Planned,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOManCapCostDiffAddCurr@63();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test FIFO Costing Flushing method - Manual, Cost, consumption Run Time and Setup Time different from Expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Manual,SubcontractFlushingMethod,CostingMethod::FIFO,
        ProductionOrderStatus::Released,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOForwardNewComponentAddCurr@62();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test FIFO Costing Flushing method - Forward, replace old Production component with a new one.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Forward,SubcontractFlushingMethod,CostingMethod::FIFO,
        ProductionOrderStatus::Planned,FALSE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOSubconBackwardAddCurr@61();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test FIFO Costing : Subcontracting Order with Flushing method - Backward and Subcontract Work center - Manual.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Backward,SubcontractFlushingMethod::Manual,CostingMethod::FIFO,
        ProductionOrderStatus::Released,TRUE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,MessageHandler)]
    PROCEDURE FIFOSubconManCostDiffAddCurr@60();
    BEGIN
      // [FEATURE] [FIFO]
      // [SCENARIO] Test FIFO Costing : Subcontracting Order with Flushing method - Manual. Output Cost and Subcontract Cost are different from expected.

      SCMWIPCostingProductionII(
        UnitCostCalculation::Time,FlushingMethod::Manual,SubcontractFlushingMethod::Manual,CostingMethod::FIFO,
        ProductionOrderStatus::Released,TRUE,FALSE,TRUE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler)]
    PROCEDURE StandardCostItemRoundingCost@5();
    VAR
      ParentItem@1000 : Record 27;
      ChildItem@1001 : Record 27;
      ProductionBOMHeader@1002 : Record 99000771;
      WorkCenter@1003 : Record 99000754;
      RoutingHeader@1006 : Record 99000763;
      PurchaseHeader@1009 : Record 38;
      PurchaseLine@1010 : Record 39;
      ProductionOrder@1011 : Record 5405;
    BEGIN
      // [SCENARIO 377973] Rounding error should be added to total output cost for an item with Standard costing mwthod

      Initialize;

      // [GIVEN] Component item "I1" with FIFO costing method
      CreateItemNoIndirectCost(ChildItem,ChildItem."Costing Method"::FIFO,1,'','',ChildItem."Replenishment System"::Purchase);
      LibraryManufacturing.CreateCertifiedProductionBOM(ProductionBOMHeader,ChildItem."No.",0.138);
      // [GIVEN] Work center "W", unit cost = 1.49967
      CreateWorkCenterWithCalendar(WorkCenter,1.49967);
      CreateCertifiedRouting(RoutingHeader,WorkCenter."No.",1);

      // [GIVEN] Manufactured item "I2" with standard costing method, "I1" as a component and a routing including work center "W"
      CreateItemNoIndirectCost(
        ParentItem,ParentItem."Costing Method"::Standard,0.01,RoutingHeader."No.",
        ProductionBOMHeader."No.",ParentItem."Replenishment System"::"Prod. Order");
      CalcItemStandardCost(ParentItem."No.");

      // [GIVEN] Create purchase order: Item = "I1", Quantity = 69.24441, Unit cost = 5.66933
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ChildItem."No.",69.24441);
      UpdateUnitCostInPurchaseLine(PurchaseLine,5.66933);

      // [GIVEN] Post purchase receipt
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);

      // [GIVEN] Released production order for item "I2", quantity = 500
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Released,ProductionOrder."Source Type"::Item,ParentItem."No.",500);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // [GIVEN] Post production order output, output quantity = 250, run time = 15.17
      PostProdOrderOutput(ProductionOrder,250,15.17);
      // [GIVEN] Post production order output, output quantity = 250, run time = 106.22
      PostProdOrderOutput(ProductionOrder,250,106.22);
      // [GIVEN] Post consumption from production order: consume full stock of item "I1" of 69.24441 pcs
      PostConsumptionFromProdOrder(ChildItem."No.",ProductionOrder."No.",69.24441);

      // [GIVEN] Finish production order
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");
      // [GIVEN] Run Adjust Cost - Item Entries
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ChildItem."No.",ParentItem."No."),'');

      // [GIVEN] Update unit cost in production order line. New cost = 22.67760
      PurchaseLine.FIND;
      UpdateUnitCostInPurchaseLine(PurchaseLine,22.6776);

      // [GIVEN] Post purchase invoice
      PurchaseHeader.VALIDATE("Vendor Invoice No.",LibraryUtility.GenerateGUID);
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,FALSE,TRUE);

      // [WHEN] Run Adjust Cost - Item Entries
      LibraryCosting.AdjustCostItemEntries(STRSUBSTNO('%1|%2',ChildItem."No.",ParentItem."No."),'');

      // [THEN] Cost of work in process is 0
      Assert.AreEqual(0,CalcProdOrderWIPAmount(ProductionOrder."No."),ErrMessageNotFoundZeroAmt);
    END;

    LOCAL PROCEDURE Initialize@38();
    VAR
      LibraryERMCountryData@1002 : Codeunit 131305;
    BEGIN
      // Lazy Setup.
      IF isInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.CreateGeneralPostingSetupData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      isInitialized := TRUE;
      COMMIT;
    END;

    [Normal]
    LOCAL PROCEDURE SCMWIPCostingProductionII@43(UnitCostCalculation@1032 : Option;FlushingMethod@1000 : Option;SubcontractFlushingMethod@1004 : Option;CostingMethod@1033 : 'FIFO,LIFO,Specific,Average,Standard';ProductionOrderStatus@1037 : Option;Subcontract@1031 : Boolean;UpdateProductionComponent@1038 : Boolean;AdditionalCurrencyExist@1006 : Boolean;SubcontractCostDiff@1045 : Boolean;OutputCostDiff@1046 : Boolean;RunSetupTimeCostDiff@1040 : Boolean;DeleteConsumptionJrnl@1047 : Boolean;ConsumptionCostDiff@1048 : Boolean;UpdateProdOrderRouting@1049 : Boolean;AdjustExchangeRatesGLSetup@1036 : Boolean);
    VAR
      CapacityUnitOfMeasure@1030 : Record 99000780;
      InventorySetup@1029 : Record 313;
      ItemJournalBatch@1028 : Record 233;
      ManufacturingSetup@1027 : Record 99000765;
      WorkCenterGroup@1026 : Record 99000756;
      WorkCenter@1025 : Record 99000754;
      MachineCenter@1035 : Record 99000758;
      Item@1024 : Record 27;
      ProductionBOMHeader@1023 : Record 99000771;
      PurchaseHeader@1021 : Record 38;
      PurchaseLine@1020 : Record 39;
      ProductionOrder@1019 : Record 5405;
      TempPurchaseLine@1018 : TEMPORARY Record 39;
      NoSeriesManagement@1017 : Codeunit 396;
      CalculateStandardCost@1016 : Codeunit 5812;
      ShopCalendarCode@1015 : Code[10];
      ProductionBOMNo@1014 : Code[20];
      MachineCenterNo@1013 : Code[20];
      MachineCenterNo2@1034 : Code[20];
      MachineCenterNo3@1050 : Code[20];
      WorkCenterNo@1012 : Code[20];
      WorkCenterNo2@1011 : Code[20];
      RoutingNo@1010 : Code[20];
      ItemNo@1009 : Code[20];
      ItemNo2@1008 : Code[20];
      ItemNo3@1007 : Code[20];
      CurrencyCode@1043 : Code[10];
      ProductionOrderNo@1039 : Code[20];
      Type@1005 : ' ,100/Hour,Minutes,Hours,Days';
      AutomaticCostAdjustment@1003 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1002 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1001 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      ProductionOrderRoutingType@1051 : 'Work Center,Machine Center';
      SetupTime@1041 : Decimal;
      RunTime@1042 : Decimal;
    BEGIN
      // Steps describing the sequence of actions for Test Case.

      // 1. Create required WIP setups with Flushing method as Manual with Subcontract.
      // Update Manufacturing Setup, Inventory Setup and Update Shop Calendar Working Days based on Work Shift code.
      Initialize;
      RaiseConfirmHandler;
      LibraryManufacturing.CreateWorkCenterGroup(WorkCenterGroup);
      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,Type::Minutes);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LibraryManufacturing.UpdateManufacturingSetup(ManufacturingSetup,'','',TRUE,TRUE,TRUE);
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarWorkingDays;
      IF AdditionalCurrencyExist THEN
        CurrencyCode := UpdateAddnlReportingCurrency
      ELSE
        LibraryERM.SetAddReportingCurrency('');

      // Create Work Center and Machine Center with Flushing method -Manual.
      // Create Work Center for Subcontractor with Flushing method -Manual.
      // Create Routing.
      CreateWorkCenter(WorkCenterNo,ShopCalendarCode,FlushingMethod,FALSE,UnitCostCalculation,'');
      CreateMachineCenter(MachineCenterNo,WorkCenterNo,FlushingMethod);
      CreateMachineCenter(MachineCenterNo2,WorkCenterNo,FlushingMethod);
      IF UpdateProdOrderRouting THEN
        CreateMachineCenter(MachineCenterNo3,WorkCenterNo,FlushingMethod);
      IF Subcontract THEN
        CreateWorkCenter(WorkCenterNo2,ShopCalendarCode,SubcontractFlushingMethod,TRUE,UnitCostCalculation,CurrencyCode)
      ELSE
        CreateWorkCenter(WorkCenterNo2,ShopCalendarCode,FlushingMethod,FALSE,UnitCostCalculation,CurrencyCode);
      RoutingNo := NoSeriesManagement.GetNextNo(ManufacturingSetup."Routing Nos.",WORKDATE,TRUE);
      CreateRouting(RoutingNo,MachineCenterNo,MachineCenterNo2,WorkCenterNo,WorkCenterNo2);

      // Create Items with Flushing method - Manual with the Parent Item containing Routing No. and Production BOM No.
      CreateItem(Item,CostingMethod,Item."Reordering Policy"::"Lot-for-Lot",FlushingMethod,'','');
      ItemNo := Item."No.";
      CLEAR(Item);
      CreateItem(Item,CostingMethod,Item."Reordering Policy"::"Lot-for-Lot",FlushingMethod,'','');
      ItemNo2 := Item."No.";
      CLEAR(Item);
      IF UpdateProductionComponent THEN BEGIN
        CreateItem(Item,Item."Costing Method"::Standard,Item."Reordering Policy"::"Lot-for-Lot",FlushingMethod,'','');
        ItemNo3 := Item."No.";
        CLEAR(Item);
      END;
      ProductionBOMNo :=
        LibraryManufacturing.CreateCertifProdBOMWithTwoComp(
          ProductionBOMHeader,ItemNo,ItemNo2,1); // value imporatant.
      CreateItem(Item,CostingMethod,Item."Reordering Policy"::"Lot-for-Lot",FlushingMethod,RoutingNo,ProductionBOMNo);

      // Calculate Standard Cost for Parent Item, if Costing Method is Standard.
      // Calculate Calendar for Work Center with dates having a difference of 5 weeks.
      // Create and Post Purchase Order as Receive and Invoice.
      IF  Item."Costing Method" = Item."Costing Method"::Standard THEN
        CalculateStandardCost.CalcItem(Item."No.",FALSE);
      CalculateCalendar(MachineCenterNo,MachineCenterNo2,WorkCenterNo,WorkCenterNo2);
      IF NOT AdditionalCurrencyExist THEN
        CreatePurchaseOrder(
          PurchaseHeader,PurchaseLine,ItemNo,ItemNo2,ItemNo3,LibraryRandom.RandInt(100) + 10,
          LibraryRandom.RandInt(100) + 10,LibraryRandom.RandInt(100) + 50,UpdateProductionComponent)
      ELSE
        CreatePurchaseOrderAddnlCurr(PurchaseHeader,PurchaseLine,CurrencyCode,ItemNo,ItemNo2,ItemNo3,
          LibraryRandom.RandInt(100) + 10,UpdateProductionComponent);

      IF AdjustExchangeRatesGLSetup THEN BEGIN
        UpdateExchangeRate(CurrencyCode);
        LibraryERM.RunAdjustExchangeRates(
          CurrencyCode,WORKDATE,WORKDATE,PurchaseHeader."No.",WORKDATE,LibraryUtility.GenerateGUID,TRUE);
      END;

      // Create and Refresh Production Order.
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrderStatus,ProductionOrder."Source Type"::Item,Item."No.",LibraryRandom.RandInt(10) + 5);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      IF UpdateProdOrderRouting THEN BEGIN
        MachineCenter.GET(MachineCenterNo3);
        LibraryManufacturing.CalculateMachCenterCalendar(MachineCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<1M>',WORKDATE));
        AddProdOrderRoutingLine(ProductionOrder,ProductionOrderRoutingType::"Machine Center",MachineCenterNo3);
        LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,FALSE,FALSE,TRUE,FALSE);
      END;

      // Create Subcontracting Worksheet, Make order and Post Subcontracting Purchase Order.
      IF Subcontract THEN BEGIN
        LibraryManufacturing.CalculateSubcontractOrder(WorkCenter);
        MakeSubconPurchOrder(ProductionOrder."No.",WorkCenterNo2);
        PostSubconPurchOrder(TempPurchaseLine,ProductionOrder."No.",SubcontractCostDiff);
      END;

      // Remove one component from Production Order and Replace it with a New Component.
      IF UpdateProductionComponent THEN
        ReplaceProdOrderComponent(ProductionOrder."No.",ItemNo2,Item."No.",ItemNo3);

      // Create, Calculate and Post Consumption Journal, Explode Routing and Post Output Journal.
      IF Item."Flushing Method" = Item."Flushing Method"::Manual THEN BEGIN
        LibraryInventory.CreateItemJournal(
          ItemJournalBatch,ItemNo,ItemJournalBatch."Template Type"::Consumption,ProductionOrder."No.");
        IF DeleteConsumptionJrnl THEN
          RemoveProdOrderComponent(ProductionOrder."No.",ItemNo);
        IF ConsumptionCostDiff THEN
          UpdateQtyConsumptionJournal(ProductionOrder."No.",ItemNo2);
        LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
        LibraryInventory.CreateItemJournal(ItemJournalBatch,ItemNo3,ItemJournalBatch."Template Type"::Output,ProductionOrder."No.");
        IF OutputCostDiff THEN
          UpdateLessQtyOutputJournal(ProductionOrder."No.",ProductionOrder.Quantity);
        IF RunSetupTimeCostDiff THEN BEGIN
          SetupTime := 1;
          RunTime := 1;
          UpdateSetupRunTime(ProductionOrder."No.",SetupTime,RunTime);
        END;
        LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
      END;

      // Change Production Order Status.
      IF ProductionOrder.Status = ProductionOrder.Status::Planned THEN
        ProductionOrderNo :=
          LibraryManufacturing.ChangeStatusPlannedToFinished(ProductionOrder."No.") // Change Status from Planned to Finished.
      ELSE
        LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrder."No.");
      // Change Status of Production Order from Released to Finished.

      // 2. Execute Adjust Cost Item Entries report and Post Inventory Cost to G/L report.
      ProductionOrder.SETRANGE(Status,ProductionOrder.Status::Finished);
      IF ProductionOrderNo <> '' THEN
        ProductionOrder.SETRANGE("No.",ProductionOrderNo)
      ELSE
        ProductionOrder.SETRANGE("No.",ProductionOrder."No.");
      ProductionOrder.FINDFIRST;
      AdjustCostPostInventoryCostGL(ItemNo + '..' + ItemNo3);

      // 3. Verify GL Entry : Total amount and Positive amount entries for WIP Account.
      VerifyGLEntryForWIPAccounts(
        TempPurchaseLine,ItemNo,ProductionOrder."No.",CurrencyCode,SetupTime,RunTime,AdditionalCurrencyExist);

      // 4.Tear Down.
      TearDown(AdditionalCurrencyExist,Subcontract,Item."No.");
    END;

    LOCAL PROCEDURE CalcItemStandardCost@144(ItemNo@1000 : Code[20]);
    VAR
      CalculateStdCost@1001 : Codeunit 5812;
    BEGIN
      CalculateStdCost.SetProperties(WORKDATE,TRUE,FALSE,FALSE,'',FALSE);
      CalculateStdCost.CalcItem(ItemNo,FALSE);
    END;

    LOCAL PROCEDURE CalcProdOrderWIPAmount@120(ProdOrderNo@1001 : Code[20]) WIPAmount : Decimal;
    VAR
      ValueEntry@1000 : Record 5802;
    BEGIN
      ValueEntry.SETRANGE("Order Type",ValueEntry."Order Type"::Production);
      ValueEntry.SETRANGE("Order No.",ProdOrderNo);
      ValueEntry.SETRANGE("Entry Type",ValueEntry."Entry Type"::"Direct Cost");

      ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::Consumption);
      ValueEntry.CALCSUMS("Cost Amount (Actual)");
      WIPAmount += ValueEntry."Cost Amount (Actual)";

      ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::" ");
      ValueEntry.CALCSUMS("Cost Amount (Actual)");
      WIPAmount -= ValueEntry."Cost Amount (Actual)";

      ValueEntry.SETRANGE("Item Ledger Entry Type",ValueEntry."Item Ledger Entry Type"::Output);
      ValueEntry.CALCSUMS("Cost Amount (Actual)");
      WIPAmount += ValueEntry."Cost Amount (Actual)";
    END;

    [Normal]
    LOCAL PROCEDURE CreateWorkCenter@1(VAR WorkCenterNo@1005 : Code[20];ShopCalendarCode@1011 : Code[10];FlushingMethod@1004 : Option;Subcontract@1000 : Boolean;UnitCostCalculation@1001 : Option;CurrencyCode@1003 : Code[10]);
    VAR
      WorkCenter@1002 : Record 99000754;
      GenProductPostingGroup@1009 : Record 251;
      VATPostingSetup@1143 : Record 325;
    BEGIN
      // Create Work Center with required fields where random is used, values not important for test.
      GenProductPostingGroup.FINDFIRST;
      LibraryManufacturing.CreateWorkCenter(WorkCenter);
      WorkCenter.VALIDATE("Flushing Method",FlushingMethod);
      WorkCenter.VALIDATE("Direct Unit Cost",LibraryRandom.RandDec(10,2));
      WorkCenter.VALIDATE("Indirect Cost %",LibraryRandom.RandDec(5,1));
      WorkCenter.VALIDATE("Overhead Rate",LibraryRandom.RandDec(5,1));
      WorkCenter.VALIDATE("Gen. Prod. Posting Group",GenProductPostingGroup.Code);
      WorkCenter.VALIDATE(Capacity,1);
      WorkCenter.VALIDATE("Shop Calendar Code",ShopCalendarCode);
      WorkCenter.VALIDATE("Unit Cost Calculation",UnitCostCalculation);
      IF Subcontract THEN BEGIN
        LibraryERM.FindVATPostingSetup(VATPostingSetup,VATPostingSetup."VAT Calculation Type"::"Normal VAT");
        GenProductPostingGroup.FINDFIRST;
        GenProductPostingGroup.VALIDATE("Def. VAT Prod. Posting Group",VATPostingSetup."VAT Prod. Posting Group");
        GenProductPostingGroup.MODIFY(TRUE);
        WorkCenter.VALIDATE("Subcontractor No.",CreateSubcontractorWithCurrency(CurrencyCode));
      END;
      WorkCenter.MODIFY(TRUE);
      WorkCenterNo := WorkCenter."No.";
    END;

    LOCAL PROCEDURE CreateWorkCenterWithFixedCost@87(VAR WorkCenter@1000 : Record 99000754;ShopCalendarCode@1004 : Code[10];DirectUnitCost@1006 : Decimal);
    BEGIN
      LibraryManufacturing.CreateWorkCenter(WorkCenter);
      WorkCenter.VALIDATE("Direct Unit Cost",DirectUnitCost);
      WorkCenter.VALIDATE(Capacity,1);
      WorkCenter.VALIDATE("Shop Calendar Code",ShopCalendarCode);
      WorkCenter.VALIDATE("Unit Cost Calculation",UnitCostCalculation);
      WorkCenter.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateWorkCenterWithCalendar@142(VAR WorkCenter@1001 : Record 99000754;DirectUnitCost@1002 : Decimal);
    VAR
      ShopCalendarCode@1000 : Code[10];
    BEGIN
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarFullWorkingWeekCustomTime(080000T,160000T);
      CreateWorkCenterWithFixedCost(WorkCenter,ShopCalendarCode,DirectUnitCost);
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,CALCDATE('<-1W>',WORKDATE),WORKDATE);
    END;

    [Normal]
    LOCAL PROCEDURE CreateMachineCenter@8(VAR MachineCenterNo@1000 : Code[20];WorkCenterNo@1002 : Code[20];FlushingMethod@1004 : Option);
    VAR
      MachineCenter@1001 : Record 99000758;
      GenProductPostingGroup@1003 : Record 251;
    BEGIN
      // Create Machine Center with required fields where random is used, values not important for test.
      GenProductPostingGroup.FINDFIRST;
      LibraryManufacturing.CreateMachineCenter(MachineCenter,WorkCenterNo,LibraryRandom.RandDec(10,1));
      MachineCenter.VALIDATE(Name,MachineCenter."No.");
      MachineCenter.VALIDATE("Direct Unit Cost",LibraryRandom.RandDec(5,1));
      MachineCenter.VALIDATE("Indirect Cost %",LibraryRandom.RandDec(5,1));
      MachineCenter.VALIDATE("Overhead Rate",1);
      MachineCenter.VALIDATE("Flushing Method",FlushingMethod);
      MachineCenter.VALIDATE("Gen. Prod. Posting Group",GenProductPostingGroup.Code);
      MachineCenter.VALIDATE(Efficiency,100);
      MachineCenter.MODIFY(TRUE);
      MachineCenterNo := MachineCenter."No.";
    END;

    [Normal]
    LOCAL PROCEDURE CreateRouting@9(VAR RoutingNo@1000 : Code[20];MachineCenterNo@1002 : Code[20];MachineCenterNo2@1005 : Code[20];WorkCenterNo@1004 : Code[20];WorkCenterNo2@1003 : Code[20]);
    VAR
      RoutingHeader@1001 : Record 99000763;
      RoutingLine@1006 : Record 99000764;
    BEGIN
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);

      CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenterNo);
      CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenterNo2);
      RoutingLine.Type := RoutingLine.Type::"Machine Center";
      CreateRoutingLine(RoutingLine,RoutingHeader,MachineCenterNo);
      CreateRoutingLine(RoutingLine,RoutingHeader,MachineCenterNo2);

      // Certify Routing after Routing lines creation.
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
      RoutingNo := RoutingHeader."No.";
    END;

    [Normal]
    LOCAL PROCEDURE CreateRoutingLine@17(VAR RoutingLine@1003 : Record 99000764;RoutingHeader@1000 : Record 99000763;CenterNo@1002 : Code[20]);
    VAR
      CapacityUnitOfMeasure@1004 : Record 99000780;
      OperationNo@1001 : Code[10];
    BEGIN
      // Create Routing Lines with required fields.
      CapacityUnitOfMeasure.SETRANGE(Type,CapacityUnitOfMeasure.Type::Minutes);
      CapacityUnitOfMeasure.FINDFIRST;

      // Random used such that the Next Operation No is greater than the Previous Operation No.
      OperationNo := FindLastOperationNo(RoutingHeader."No.") + FORMAT(LibraryRandom.RandInt(5));

      // Random is used, values not important for test.
      LibraryManufacturing.CreateRoutingLineSetup(
        RoutingLine,RoutingHeader,CenterNo,OperationNo,LibraryRandom.RandInt(5),LibraryRandom.RandInt(5));

      RoutingLine.VALIDATE("Run Time Unit of Meas. Code",CapacityUnitOfMeasure.Code);
      RoutingLine.VALIDATE("Setup Time Unit of Meas. Code",CapacityUnitOfMeasure.Code);
      RoutingLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateCertifiedRouting@112(VAR RoutingHeader@1000 : Record 99000763;WorkCenterNo@1002 : Code[20];RunTime@1003 : Decimal);
    VAR
      RoutingLine@1001 : Record 99000764;
    BEGIN
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);
      LibraryManufacturing.CreateRoutingLine(
        RoutingHeader,RoutingLine,'',LibraryUtility.GenerateGUID,RoutingLine.Type::"Work Center",WorkCenterNo);
      RoutingLine.VALIDATE("Run Time",RunTime);
      RoutingLine.MODIFY(TRUE);

      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CreateItem@7(VAR Item@1008 : Record 27;ItemCostingMethod@1001 : 'Standard,Average';ItemReorderPolicy@1002 : Option;FlushingMethod@1003 : Option;RoutingNo@1004 : Code[20];ProductionBOMNo@1005 : Code[20]);
    BEGIN
      // Create Item with required fields where random values not important for test.
      LibraryManufacturing.CreateItemManufacturing(
        Item,ItemCostingMethod,LibraryRandom.RandInt(10),ItemReorderPolicy,FlushingMethod,RoutingNo,ProductionBOMNo);
      Item.VALIDATE("Overhead Rate",LibraryRandom.RandDec(5,2));
      Item.VALIDATE("Indirect Cost %",LibraryRandom.RandDec(5,2));
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemNoIndirectCost@114(VAR Item@1000 : Record 27;CostingMethod@1001 : Option;RoundingPrecision@1002 : Decimal;RoutingNo@1003 : Code[20];ProdBOMNo@1004 : Code[20];ReplenishmentSystem@1005 : Option);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Costing Method",CostingMethod);
      Item.VALIDATE("Rounding Precision",RoundingPrecision);
      Item.VALIDATE("Routing No.",RoutingNo);
      Item.VALIDATE("Production BOM No.",ProdBOMNo);
      Item.VALIDATE("Replenishment System",ReplenishmentSystem);
      Item.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchaseOrderAddnlCurr@99(VAR PurchaseHeader@1002 : Record 38;VAR PurchaseLine@1003 : Record 39;CurrencyCode@1007 : Code[10];ItemNo@1000 : Code[20];ItemNo2@1001 : Code[20];ItemNo3@1004 : Code[20];Qty@1005 : Decimal;UpdateProductionComponent@1006 : Boolean);
    VAR
      Type@1008 : ' ,G/L Account,Item,,Fixed Asset,Charge (Item)';
    BEGIN
      CreatePurchaseHeaderAddnlCurr(PurchaseHeader,CurrencyCode);
      CreatePurchaseLine(PurchaseHeader,PurchaseLine,Type::Item,ItemNo,Qty);
      CreatePurchaseLine(PurchaseHeader,PurchaseLine,Type::Item,ItemNo2,Qty);
      IF UpdateProductionComponent THEN
        CreatePurchaseLine(PurchaseHeader,PurchaseLine,Type::Item,ItemNo3,Qty);
    END;

    [Normal]
    LOCAL PROCEDURE CreatePurchaseHeaderAddnlCurr@98(VAR PurchaseHeader@1000 : Record 38;CurrencyCode@1001 : Code[10]);
    BEGIN
      LibraryPurchase.CreatePurchHeader(
        PurchaseHeader,PurchaseHeader."Document Type"::Order,CreateSubcontractorWithCurrency(CurrencyCode));
    END;

    LOCAL PROCEDURE CreatePurchaseLine@9111(VAR PurchaseHeader@1001 : Record 38;VAR PurchaseLine@1000 : Record 39;Type@1002 : Option;ItemNo@1003 : Code[20];Qty@1004 : Decimal);
    BEGIN
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,Type,ItemNo,Qty);
    END;

    LOCAL PROCEDURE CreateCurrency@31() : Code[10];
    VAR
      Currency@1001 : Record 4;
      CurrencyExchangeRate@1144 : Record 330;
      GLAccount@1000 : Record 15;
    BEGIN
      // Create new currency and validate the required GL Accounts.
      LibraryERM.CreateCurrency(Currency);
      LibraryERM.FindDirectPostingGLAccount(GLAccount);
      Currency.VALIDATE("Residual Gains Account",GLAccount."No.");
      Currency.VALIDATE("Residual Losses Account",GLAccount."No.");
      Currency.VALIDATE("Realized G/L Gains Account",GLAccount."No.");
      Currency.VALIDATE("Realized G/L Losses Account",GLAccount."No.");
      Currency.MODIFY(TRUE);
      COMMIT;  // Required to run the Test Case on RTC.

      // Create Currency Exchange Rate.
      LibraryERM.CreateExchRate(CurrencyExchangeRate,Currency.Code,WORKDATE);

      // Using RANDOM Exchange Rate Amount and Adjustment Exchange Rate, between 100 and 400 (Standard Value).
      CurrencyExchangeRate.VALIDATE("Exchange Rate Amount",100 * LibraryRandom.RandInt(4));
      CurrencyExchangeRate.VALIDATE("Adjustment Exch. Rate Amount",CurrencyExchangeRate."Exchange Rate Amount");

      // Relational Exch. Rate Amount and Relational Adjmt Exch Rate Amt always greater than Exchange Rate Amount.
      CurrencyExchangeRate.VALIDATE("Relational Exch. Rate Amount",2 * CurrencyExchangeRate."Exchange Rate Amount");
      CurrencyExchangeRate.VALIDATE("Relational Adjmt Exch Rate Amt",CurrencyExchangeRate."Relational Exch. Rate Amount");
      CurrencyExchangeRate.MODIFY(TRUE);
      EXIT(Currency.Code);
    END;

    LOCAL PROCEDURE UpdateExchangeRate@33(CurrencyCode@1000 : Code[10]);
    VAR
      CurrencyExchangeRate@1001 : Record 330;
      NewExchangeRateAmount@1003 : Decimal;
    BEGIN
      SelectCurrencyExchangeRate(CurrencyExchangeRate,CurrencyCode);
      NewExchangeRateAmount := CurrencyExchangeRate."Exchange Rate Amount" * LibraryRandom.RandInt(5);
      CurrencyExchangeRate.VALIDATE("Exchange Rate Amount",NewExchangeRateAmount);
      CurrencyExchangeRate.VALIDATE("Adjustment Exch. Rate Amount",CurrencyExchangeRate."Exchange Rate Amount");
      CurrencyExchangeRate.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE FindLastOperationNo@19(RoutingNo@1000 : Code[20]) : Code[10];
    VAR
      RoutingLine@1001 : Record 99000764;
    BEGIN
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      IF RoutingLine.FINDLAST THEN
        EXIT(RoutingLine."Operation No.");
    END;

    [Normal]
    LOCAL PROCEDURE CalculateCalendar@13(MachineCenterNo@1002 : Code[20];MachineCenterNo2@1005 : Code[20];WorkCenterNo@1001 : Code[20];WorkCenterNo2@1000 : Code[20]);
    VAR
      WorkCenter@1003 : Record 99000754;
      MachineCenter@1004 : Record 99000758;
    BEGIN
      MachineCenter.GET(MachineCenterNo);
      LibraryManufacturing.CalculateMachCenterCalendar(MachineCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<1M>',WORKDATE));
      MachineCenter.GET(MachineCenterNo2);
      LibraryManufacturing.CalculateMachCenterCalendar(MachineCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<1M>',WORKDATE));
      WorkCenter.GET(WorkCenterNo);
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<1M>',WORKDATE));
      WorkCenter.GET(WorkCenterNo2);
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,CALCDATE('<-1M>',WORKDATE),CALCDATE('<1M>',WORKDATE));
    END;

    [Normal]
    LOCAL PROCEDURE UpdateAddnlReportingCurrency@94() CurrencyCode : Code[10];
    VAR
      GeneralLedgerSetup@1001 : Record 98;
    BEGIN
      // Create new Currency code and set Residual Gains Account and Residual Losses Account for Currency.
      CurrencyCode := CreateCurrency;
      COMMIT;

      // Update Additional Reporting Currency on G/L setup to execute Adjust Additional Reporting Currency report.
      GeneralLedgerSetup.GET;
      GeneralLedgerSetup."Additional Reporting Currency" := CurrencyCode;
      GeneralLedgerSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreatePurchaseOrder@26(VAR PurchaseHeader@1002 : Record 38;VAR PurchaseLine@1003 : Record 39;ItemNo@1000 : Code[20];ItemNo2@1001 : Code[20];ItemNo3@1006 : Code[20];Quantity@1004 : Decimal;Quantity2@1005 : Decimal;Quantity3@1007 : Decimal;UpdateProductionComponent@1008 : Boolean);
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      CreatePurchaseLine(PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,ItemNo,Quantity);
      CreatePurchaseLine(PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,ItemNo2,Quantity2);
      IF UpdateProductionComponent THEN
        CreatePurchaseLine(PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,ItemNo3,Quantity3);
    END;

    [Normal]
    LOCAL PROCEDURE AddProdOrderRoutingLine@50(ProductionOrder@1000 : Record 5405;ProdOrderRoutingLineType@1001 : Option;MachineCenterNo@1003 : Code[20]);
    VAR
      ProdOrderRoutingLine@1002 : Record 5409;
    BEGIN
      ProdOrderRoutingLine.INIT;
      ProdOrderRoutingLine.VALIDATE(Status,ProductionOrder.Status);
      ProdOrderRoutingLine.VALIDATE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderRoutingLine.VALIDATE("Routing No.",ProductionOrder."Routing No.");
      ProdOrderRoutingLine.VALIDATE("Routing Reference No.",SelectRoutingRefNo(ProductionOrder."No.",ProductionOrder."Routing No."));
      ProdOrderRoutingLine.VALIDATE(
        "Operation No.",
        COPYSTR(
          LibraryUtility.GenerateRandomCode(ProdOrderRoutingLine.FIELDNO("Operation No."),DATABASE::"Prod. Order Routing Line"),1,
          MAXSTRLEN(ProdOrderRoutingLine."Operation No.") - 1));
      ProdOrderRoutingLine.INSERT(TRUE);
      ProdOrderRoutingLine.VALIDATE(Type,ProdOrderRoutingLineType);
      ProdOrderRoutingLine.VALIDATE("No.",MachineCenterNo);
      ProdOrderRoutingLine.VALIDATE("Setup Time",LibraryRandom.RandInt(5));
      ProdOrderRoutingLine.VALIDATE("Run Time",LibraryRandom.RandInt(5));
      ProdOrderRoutingLine.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE ReplaceProdOrderComponent@45(ProductionOrderNo@1000 : Code[20];ItemNo@1002 : Code[20];ItemNo2@1003 : Code[20];NewItemNo@1005 : Code[20]);
    VAR
      ProdOrderComponent@1001 : Record 5407;
      ProdOrderLine@1004 : Record 5406;
    BEGIN
      ProdOrderComponent.SETRANGE(Status,ProdOrderComponent.Status::Planned);
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderComponent.SETRANGE("Item No.",ItemNo);
      ProdOrderComponent.FINDFIRST;
      ProdOrderComponent.DELETE(TRUE);
      COMMIT;

      ProdOrderLine.SETRANGE(Status,ProdOrderComponent.Status::Planned);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderLine.SETRANGE("Item No.",ItemNo2);
      ProdOrderLine.FINDFIRST;
      CreateProdOrderComponent(ProdOrderLine,ProdOrderComponent,NewItemNo,1); // value important for test.
    END;

    LOCAL PROCEDURE CreateProdOrderComponent@15(VAR ProdOrderLine@1001 : Record 5406;VAR ProdOrderComponent@1000 : Record 5407;ItemNo@1002 : Code[20];QuantityPer@1003 : Decimal);
    VAR
      RecRef@1004 : RecordRef;
    BEGIN
      ProdOrderComponent.INIT;
      ProdOrderComponent.VALIDATE(Status,ProdOrderLine.Status);
      ProdOrderComponent.VALIDATE("Prod. Order No.",ProdOrderLine."Prod. Order No.");
      ProdOrderComponent.VALIDATE("Prod. Order Line No.",ProdOrderLine."Line No.");
      RecRef.GETTABLE(ProdOrderComponent);
      ProdOrderComponent.VALIDATE("Line No.",LibraryUtility.GetNewLineNo(RecRef,ProdOrderComponent.FIELDNO("Line No.")));
      ProdOrderComponent.INSERT(TRUE);
      ProdOrderComponent.VALIDATE("Item No.",ItemNo);
      ProdOrderComponent.VALIDATE("Quantity per",QuantityPer);
      ProdOrderComponent.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE MakeSubconPurchOrder@32(ProductionOrderNo@1003 : Code[20];WorkCenterNo@1002 : Code[20]);
    VAR
      RequisitionLine@1000 : Record 246;
      Vendor@1500000 : Record 23;
    BEGIN
      // Update Direct unit Cost and Make Order,random is used values not important for test.
      RequisitionLine.SETRANGE("Prod. Order No.",ProductionOrderNo);
      RequisitionLine.SETRANGE("Work Center No.",WorkCenterNo);
      RequisitionLine.FINDFIRST;
      RequisitionLine.VALIDATE("Direct Unit Cost",LibraryRandom.RandInt(10));
      RequisitionLine.MODIFY(TRUE);
      Vendor.GET(RequisitionLine."Vendor No.");
      LibraryPurchase.CreateSetupForSubContracting(Vendor);
      LibraryPlanning.CarryOutAMSubcontractWksh(RequisitionLine);
    END;

    LOCAL PROCEDURE PostConsumptionFromProdOrder@82(ItemNo@1001 : Code[20];ProdOrderNo@1002 : Code[20];Quantity@1004 : Decimal);
    VAR
      ItemJournalBatch@1000 : Record 233;
      ItemJournalLine@1003 : Record 83;
    BEGIN
      LibraryInventory.CreateItemJournal(
        ItemJournalBatch,ItemNo,ItemJournalBatch."Template Type"::Consumption,ProdOrderNo);
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE(Quantity,Quantity);
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    LOCAL PROCEDURE PostProdOrderOutput@106(ProductionOrder@1001 : Record 5405;OutputQty@1003 : Decimal;RunTime@1004 : Decimal);
    VAR
      ItemJournalBatch@1000 : Record 233;
      ItemJournalLine@1002 : Record 83;
    BEGIN
      LibraryInventory.CreateItemJournal(
        ItemJournalBatch,ProductionOrder."Source No.",ItemJournalBatch."Template Type"::Output,ProductionOrder."No.");
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE("Output Quantity",OutputQty);
      ItemJournalLine.VALIDATE("Run Time",RunTime);
      ItemJournalLine.MODIFY(TRUE);

      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
    END;

    [Normal]
    LOCAL PROCEDURE PostSubconPurchOrder@18(VAR TempPurchaseLine@1004 : TEMPORARY Record 39;ProductionOrder@1000 : Code[20];SubconCostDiff@1002 : Boolean);
    VAR
      PurchaseLine@1001 : Record 39;
      PurchaseHeader@1003 : Record 38;
    BEGIN
      // Find Subcontracting Purchase Order and Post.
      PurchaseLine.SETRANGE("Prod. Order No.",ProductionOrder);
      PurchaseLine.FINDFIRST;

      // If Expected Cost is different.
      IF SubconCostDiff THEN BEGIN
        PurchaseLine.VALIDATE("Direct Unit Cost",LibraryRandom.RandInt(5) + 5);
        PurchaseLine.MODIFY(TRUE);
      END;
      TempPurchaseLine := PurchaseLine;
      TempPurchaseLine.INSERT;

      PurchaseHeader.GET(PurchaseLine."Document Type"::Order,PurchaseLine."Document No.");
      PurchaseHeader.VALIDATE(
        "Vendor Invoice No.",LibraryUtility.GenerateRandomCode(PurchaseHeader.FIELDNO("Vendor Invoice No."),
          DATABASE::"Purchase Header"));
      PurchaseHeader.MODIFY(TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE RemoveProdOrderComponent@51(ProductionOrderNo@1000 : Code[20];ItemNo@1002 : Code[20]);
    VAR
      ItemJournalLine@1001 : Record 83;
    BEGIN
      ItemJournalLine.SETRANGE("Order Type",ItemJournalLine."Order Type"::Production);
      ItemJournalLine.SETRANGE("Order No.",ProductionOrderNo);
      ItemJournalLine.SETRANGE("Item No.",ItemNo);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.DELETE(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE UpdateQtyConsumptionJournal@59(ProductionOrderNo@1003 : Code[20];ItemNo@1001 : Code[20]);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      ItemJournalLine.SETRANGE("Order Type",ItemJournalLine."Order Type"::Production);
      ItemJournalLine.SETRANGE("Order No.",ProductionOrderNo);
      ItemJournalLine.SETRANGE("Item No.",ItemNo);
      ItemJournalLine.FINDSET;
      REPEAT
        ItemJournalLine.VALIDATE(Quantity,ItemJournalLine.Quantity + 1);
        ItemJournalLine.MODIFY(TRUE);
      UNTIL ItemJournalLine.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE UpdateLessQtyOutputJournal@42(ProductionOrderNo@1003 : Code[20];ProductionOrderQuantity@1001 : Decimal);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      ItemJournalLine.SETRANGE("Order Type",ItemJournalLine."Order Type"::Production);
      ItemJournalLine.SETRANGE("Order No.",ProductionOrderNo);
      ItemJournalLine.FINDSET;
      REPEAT
        ItemJournalLine.VALIDATE("Output Quantity",ProductionOrderQuantity - 1);
        ItemJournalLine.MODIFY(TRUE);
      UNTIL ItemJournalLine.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE UpdateSetupRunTime@35(ProductionOrderNo@1003 : Code[20];SetupTime@1004 : Decimal;RunTime@1002 : Decimal);
    VAR
      ItemJournalLine@1000 : Record 83;
    BEGIN
      ItemJournalLine.SETRANGE("Order Type",ItemJournalLine."Order Type"::Production);
      ItemJournalLine.SETRANGE("Order No.",ProductionOrderNo);
      ItemJournalLine.FINDSET;

      REPEAT
        ItemJournalLine.VALIDATE("Run Time",RunTime);
        ItemJournalLine.VALIDATE("Setup Time",SetupTime);
        ItemJournalLine.MODIFY(TRUE);
      UNTIL ItemJournalLine.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE AdjustCostPostInventoryCostGL@30(ItemNoFilter@1111 : Text[250]);
    BEGIN
      LibraryCosting.AdjustCostItemEntries(ItemNoFilter,'');
      LibraryCosting.PostInvtCostToGL(FALSE,WORKDATE,'');
    END;

    LOCAL PROCEDURE CreateSubcontractorWithCurrency@40(CurrencyCode@1002 : Code[10]) : Code[20];
    VAR
      Vendor@1000 : Record 23;
    BEGIN
      // Create a Subcontractor Vendor.
      LibraryPurchase.CreateSubcontractor(Vendor);
      Vendor.VALIDATE("Currency Code",CurrencyCode);
      Vendor.MODIFY(TRUE);
      EXIT(Vendor."No.");
    END;

    [Normal]
    LOCAL PROCEDURE SelectRoutingRefNo@57(ProductionOrderNo@1000 : Code[20];ProdOrderRoutingNo@1001 : Code[20]) : Integer;
    VAR
      ProdOrderRoutingLine@1002 : Record 5409;
    BEGIN
      ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderRoutingLine.SETRANGE("Routing No.",ProdOrderRoutingNo);
      ProdOrderRoutingLine.FINDFIRST;
      EXIT(ProdOrderRoutingLine."Routing Reference No.");
    END;

    [Normal]
    LOCAL PROCEDURE SelectGLEntry@37(VAR GLEntry@1000 : Record 17;InventoryPostingSetupAccount@1002 : Code[20];ProductionOrderNo@1001 : Code[20];PurchaseInvoiceNo@1003 : Code[20]);
    BEGIN
      // Select set of G/L Entries for the specified Account.
      IF PurchaseInvoiceNo <> '' THEN
        GLEntry.SETFILTER("Document No.",'%1|%2',ProductionOrderNo,PurchaseInvoiceNo)
      ELSE
        GLEntry.SETFILTER("Document No.",ProductionOrderNo);
      GLEntry.SETRANGE("G/L Account No.",InventoryPostingSetupAccount);
      GLEntry.FINDSET;
    END;

    [Normal]
    LOCAL PROCEDURE SelectProductionOrderComponent@85(VAR ProductionOrder@1002 : Record 5405;VAR ProdOrderComponent@1000 : Record 5407;ProductionOrderNo@1001 : Code[20]);
    BEGIN
      ProductionOrder.GET(ProductionOrder.Status::Finished,ProductionOrderNo);
      ProdOrderComponent.SETRANGE(Status,ProductionOrder.Status);
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProductionOrder."No.");
      ProdOrderComponent.FINDSET;
    END;

    LOCAL PROCEDURE SelectCurrencyExchangeRate@55(VAR CurrencyExchangeRate@1000 : Record 330;CurrencyCode@1001 : Code[10]);
    BEGIN
      CurrencyExchangeRate.SETRANGE("Currency Code",CurrencyCode);
      CurrencyExchangeRate.FINDFIRST;
    END;

    [Normal]
    LOCAL PROCEDURE CalculateGLAmount@95(VAR GLEntry@1000 : Record 17;AdditionalCurrencyExist@1001 : Boolean) : Decimal;
    VAR
      CalculatedAmount@1002 : Decimal;
    BEGIN
      IF NOT AdditionalCurrencyExist THEN BEGIN
        GLEntry.SETFILTER(Amount,'>0');
        IF GLEntry.FINDSET THEN
          REPEAT
            CalculatedAmount += GLEntry.Amount;
          UNTIL GLEntry.NEXT = 0;
        EXIT(CalculatedAmount);
      END;

      GLEntry.SETFILTER("Additional-Currency Amount",'>0');
      IF GLEntry.FINDSET THEN
        REPEAT
          CalculatedAmount += GLEntry."Additional-Currency Amount";
        UNTIL GLEntry.NEXT = 0;

      EXIT(CalculatedAmount);
    END;

    [Normal]
    LOCAL PROCEDURE CheckSubconWorkCenter@10(ProductionOrderNo@1002 : Code[20]) : Boolean;
    VAR
      ProdOrderRoutingLine@1001 : Record 5409;
      WorkCenter@1000 : Record 99000754;
    BEGIN
      // Check Flushing Method On WorkCenter.
      ProdOrderRoutingLine.SETRANGE(Status,ProdOrderRoutingLine.Status::Finished);
      ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderRoutingLine.SETRANGE(Type,ProdOrderRoutingLine.Type::"Work Center");
      ProdOrderRoutingLine.FINDSET;
      REPEAT
        WorkCenter.GET(ProdOrderRoutingLine."No.");
        IF WorkCenter."Subcontractor No." <> '' THEN
          EXIT(TRUE);
      UNTIL ProdOrderRoutingLine.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE TimeSubTotalWorkCenter@47(ProdOrderRoutingLine@1002 : Record 5409;Quantity@1003 : Decimal;SetupTime@1005 : Decimal;RunTime@1001 : Decimal) : Decimal;
    VAR
      WorkCenter@1004 : Record 99000754;
    BEGIN
      IF ProdOrderRoutingLine.Type = ProdOrderRoutingLine.Type::"Machine Center" THEN
        EXIT;

      IF SetupTime = 0 THEN
        SetupTime := ProdOrderRoutingLine."Setup Time";
      IF RunTime = 0 THEN
        RunTime := ProdOrderRoutingLine."Run Time";

      WorkCenter.GET(ProdOrderRoutingLine."No.");
      IF (WorkCenter."Subcontractor No." <> '') AND (WorkCenter."Flushing Method" <> WorkCenter."Flushing Method"::Backward) THEN
        EXIT;
      IF WorkCenter."Unit Cost Calculation" = WorkCenter."Unit Cost Calculation"::Time THEN BEGIN
        IF WorkCenter."Flushing Method" = WorkCenter."Flushing Method"::Manual THEN
          EXIT(SetupTime + RunTime);
        IF (WorkCenter."Flushing Method" = WorkCenter."Flushing Method"::Backward) AND (WorkCenter."Subcontractor No." <> '') THEN
          EXIT(Quantity);
        EXIT(SetupTime + Quantity * RunTime);
      END;

      EXIT(Quantity);
    END;

    [Normal]
    LOCAL PROCEDURE TimeSubTotalMachineCenter@46(ProdOrderRoutingLine@1002 : Record 5409;Quantity@1003 : Decimal;SetupTime@1005 : Decimal;RunTime@1001 : Decimal) : Decimal;
    VAR
      MachineCenter@1004 : Record 99000758;
    BEGIN
      IF ProdOrderRoutingLine.Type = ProdOrderRoutingLine.Type::"Work Center" THEN
        EXIT;

      IF SetupTime = 0 THEN
        SetupTime := ProdOrderRoutingLine."Setup Time";
      IF RunTime = 0 THEN
        RunTime := ProdOrderRoutingLine."Run Time";

      MachineCenter.GET(ProdOrderRoutingLine."No.");
      IF MachineCenter."Flushing Method" = MachineCenter."Flushing Method"::Manual THEN
        EXIT(SetupTime + RunTime);
      EXIT(SetupTime + Quantity * RunTime);
    END;

    [Normal]
    LOCAL PROCEDURE CalculateSubconCost@3(TempPurchaseLine@1000 : TEMPORARY Record 39) : Decimal;
    VAR
      GeneralLedgerSetup@1003 : Record 98;
      SubcontractorAmount@1002 : Decimal;
    BEGIN
      // Calculate Subcontractor Cost.
      GeneralLedgerSetup.GET;
      SubcontractorAmount :=
        (TempPurchaseLine.Quantity * TempPurchaseLine."Direct Unit Cost") +
        (TempPurchaseLine.Quantity *
         ((TempPurchaseLine."Indirect Cost %" / 100) * TempPurchaseLine."Direct Unit Cost" + TempPurchaseLine."Overhead Rate"));
      EXIT(ROUND(SubcontractorAmount,GeneralLedgerSetup."Amount Rounding Precision"));
    END;

    [Normal]
    LOCAL PROCEDURE CalculateSubconCostAddCurr@4(TempPurchaseLine@1006 : TEMPORARY Record 39) : Decimal;
    VAR
      Currency@1000 : Record 4;
      CurrencyExchangeRate@1001 : Record 330;
      GeneralLedgerSetup@1005 : Record 98;
      DirectCost@1003 : Decimal;
      IndirectCost@1004 : Decimal;
      SubcontractorCostAddCurr@1002 : Decimal;
    BEGIN
      // Calculate Subcontractor Cost. Values used are important for test.
      GeneralLedgerSetup.GET;
      Currency.GET(TempPurchaseLine."Currency Code");
      SelectCurrencyExchangeRate(CurrencyExchangeRate,Currency.Code);
      IndirectCost :=
        ROUND(
          (TempPurchaseLine."Unit Cost" - TempPurchaseLine."Overhead Rate") / (100 / TempPurchaseLine."Indirect Cost %" + 1) ,
          GeneralLedgerSetup."Amount Rounding Precision");
      DirectCost :=
        ROUND(
          TempPurchaseLine."Unit Cost" - TempPurchaseLine."Overhead Rate" - IndirectCost,
          GeneralLedgerSetup."Amount Rounding Precision");
      SubcontractorCostAddCurr :=
        TempPurchaseLine.Quantity *
        DirectCost +
        (TempPurchaseLine.Quantity * ((TempPurchaseLine."Indirect Cost %" / 100) * DirectCost + TempPurchaseLine."Overhead Rate"));
      EXIT(
        ROUND(
          (CurrencyExchangeRate."Relational Exch. Rate Amount" / CurrencyExchangeRate."Exchange Rate Amount") *
          SubcontractorCostAddCurr,GeneralLedgerSetup."Amount Rounding Precision"));
    END;

    [Normal]
    LOCAL PROCEDURE DirectIndirectMachineCntrCost@21(RoutingNo@1000 : Code[20];Quantity@1004 : Decimal;SetupTime@1008 : Decimal;RunTime@1007 : Decimal) : Decimal;
    VAR
      ProdOrderRoutingLine@1006 : Record 5409;
      MachineCenter@1003 : Record 99000758;
      TimeSubtotal@1002 : Decimal;
      MachineCenterAmount@1001 : Decimal;
    BEGIN
      // Calculate Cost Amount for Machine Center.
      ProdOrderRoutingLine.SETRANGE("Routing No.",RoutingNo);
      ProdOrderRoutingLine.SETRANGE(Type,ProdOrderRoutingLine.Type::"Machine Center");
      IF ProdOrderRoutingLine.FINDSET THEN
        REPEAT
          MachineCenter.GET(ProdOrderRoutingLine."No.");
          TimeSubtotal := TimeSubTotalMachineCenter(ProdOrderRoutingLine,Quantity,SetupTime,RunTime);
          MachineCenterAmount +=
            (TimeSubtotal * MachineCenter."Direct Unit Cost") +
            (TimeSubtotal * ((MachineCenter."Indirect Cost %" / 100) * MachineCenter."Direct Unit Cost" +
                             MachineCenter."Overhead Rate"));
        UNTIL ProdOrderRoutingLine.NEXT = 0;
      EXIT(MachineCenterAmount);
    END;

    [Normal]
    LOCAL PROCEDURE DirectIndirectWorkCntrCost@28(RoutingNo@1000 : Code[20];Quantity@1001 : Decimal;SetupTime@1008 : Decimal;RunTime@1006 : Decimal) : Decimal;
    VAR
      ProdOrderRoutingLine@1004 : Record 5409;
      WorkCenter@1007 : Record 99000754;
      TimeSubtotal@1005 : Decimal;
      WorkCenterAmount@1003 : Decimal;
    BEGIN
      // Calculate Cost Amount for Work Center.
      ProdOrderRoutingLine.SETRANGE("Routing No.",RoutingNo);
      ProdOrderRoutingLine.SETRANGE(Type,ProdOrderRoutingLine.Type::"Work Center");
      IF ProdOrderRoutingLine.FINDSET THEN
        REPEAT
          WorkCenter.GET(ProdOrderRoutingLine."No.");
          IF WorkCenter."Subcontractor No." = '' THEN BEGIN
            TimeSubtotal := TimeSubTotalWorkCenter(ProdOrderRoutingLine,Quantity,SetupTime,RunTime);
            WorkCenterAmount +=
              (TimeSubtotal * WorkCenter."Direct Unit Cost") +
              (TimeSubtotal * ((WorkCenter."Indirect Cost %" / 100) * WorkCenter."Direct Unit Cost" + WorkCenter."Overhead Rate"));
          END;
        UNTIL ProdOrderRoutingLine.NEXT = 0;
      EXIT(WorkCenterAmount);
    END;

    [Normal]
    LOCAL PROCEDURE DirectIndirectSubconCost@11(VAR TempPurchaseLine@1000 : TEMPORARY Record 39;AdditionalCurrencyExist@1003 : Boolean) : Decimal;
    VAR
      SubcontractorCost@1002 : Decimal;
    BEGIN
      IF NOT AdditionalCurrencyExist THEN
        SubcontractorCost := CalculateSubconCost(TempPurchaseLine)
      ELSE
        SubcontractorCost := CalculateSubconCostAddCurr(TempPurchaseLine);
      EXIT(SubcontractorCost);
    END;

    LOCAL PROCEDURE UpdateUnitCostInPurchaseLine@149(VAR PurchaseLine@1000 : Record 39;UnitCost@1001 : Decimal);
    BEGIN
      PurchaseLine.VALIDATE("Direct Unit Cost",UnitCost);
      PurchaseLine.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyGLEntryForWIPAccounts@14(TempPurchaseLine@1009 : TEMPORARY Record 39;ItemNo@1000 : Code[20];ProductionOrderNo@1001 : Code[20];CurrencyCode@1006 : Code[10];SetupTime@1008 : Decimal;RunTime@1007 : Decimal;AdditionalCurrencyExist@1005 : Boolean);
    VAR
      Item@1002 : Record 27;
      InventoryPostingSetup@1004 : Record 5813;
      GLEntry@1010 : Record 17;
      PurchInvHeader@1003 : Record 122;
    BEGIN
      Item.GET(ItemNo);
      InventoryPostingSetup.SETRANGE("Invt. Posting Group Code",Item."Inventory Posting Group");
      InventoryPostingSetup.FINDFIRST;

      // Verify total amount in G/L Entry for WIP Account is Zero.
      VerifyTotalWIPAccountAmount(GLEntry);

      // Verify positive WIP Account amount is equal to calculated amount.
      PurchInvHeader.SETRANGE("Order No.",TempPurchaseLine."Document No.");
      PurchInvHeader.FINDFIRST;
      SelectGLEntry(GLEntry,InventoryPostingSetup."WIP Account",ProductionOrderNo,PurchInvHeader."No.");

      // True if Flushing is backward in a subcontract Work center.
      VerifyWIPAmounts(
        GLEntry,TempPurchaseLine,ProductionOrderNo,CurrencyCode,SetupTime,RunTime,CheckSubconWorkCenter(ProductionOrderNo),
        AdditionalCurrencyExist);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyTotalWIPAccountAmount@2(VAR GLEntry@1001 : Record 17);
    VAR
      TotalAmount@1002 : Decimal;
    BEGIN
      REPEAT
        TotalAmount += GLEntry.Amount;
      UNTIL GLEntry.NEXT = 0;

      // Verify total WIP Account amount is Zero.
      Assert.AreEqual(TotalAmount,0,ErrMessageNotFoundZeroAmt);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyWIPAmounts@16(VAR GLEntry@1003 : Record 17;TempPurchaseLine@1015 : TEMPORARY Record 39;ProductionOrderNo@1001 : Code[20];CurrencyCode@1006 : Code[10];SetupTime@1013 : Decimal;RunTime@1012 : Decimal;CheckSubcontractWorkCenter@1002 : Boolean;AdditionalCurrencyExist@1004 : Boolean);
    VAR
      GeneralLedgerSetup@1011 : Record 98;
      ProductionOrder@1008 : Record 5405;
      ProdOrderLine@1016 : Record 5406;
      ProdOrderComponent@1007 : Record 5407;
      Item@1014 : Record 27;
      CalculatedWIPAmount@1005 : Decimal;
      TotalConsumptionValue@1009 : Decimal;
      TotalAmount@1000 : Decimal;
    BEGIN
      GeneralLedgerSetup.GET;
      TotalAmount := CalculateGLAmount(GLEntry,AdditionalCurrencyExist);

      SelectProductionOrderComponent(ProductionOrder,ProdOrderComponent,ProductionOrderNo);
      REPEAT
        Item.GET(ProdOrderComponent."Item No.");
        ProdOrderComponent.CALCFIELDS("Act. Consumption (Qty)");
        IF Item."Costing Method" = Item."Costing Method"::Standard THEN
          TotalConsumptionValue += ProdOrderComponent."Act. Consumption (Qty)" * Item."Standard Cost"
        ELSE
          TotalConsumptionValue += ProdOrderComponent."Act. Consumption (Qty)" * Item."Unit Cost"
      UNTIL ProdOrderComponent.NEXT = 0;

      ProdOrderLine.SETRANGE(Status,ProdOrderLine.Status::Finished);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderLine.FINDFIRST;

      CalculatedWIPAmount :=
        TotalConsumptionValue +
        DirectIndirectMachineCntrCost(ProductionOrder."Routing No.",ProdOrderLine."Finished Quantity",SetupTime,RunTime) +
        DirectIndirectWorkCntrCost(ProductionOrder."Routing No.",ProdOrderLine."Finished Quantity",SetupTime,RunTime);

      IF CheckSubcontractWorkCenter THEN
        CalculatedWIPAmount +=
          DirectIndirectSubconCost(TempPurchaseLine,AdditionalCurrencyExist);

      // Verify WIP Account amounts and calculated WIP amounts are equal.
      IF NOT AdditionalCurrencyExist THEN
        Assert.AreNearlyEqual(
          ROUND(CalculatedWIPAmount,GeneralLedgerSetup."Amount Rounding Precision"),TotalAmount,
          2 * GeneralLedgerSetup."Amount Rounding Precision",ErrMessageAmountDoNotMatch)
      ELSE
        VerifyWIPAmountsAddCurr(CurrencyCode,TotalAmount,CalculatedWIPAmount);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyWIPAmountsAddCurr@27(CurrencyCode@1006 : Code[10];TotalAmount@1000 : Decimal;CalculatedWIPAmount@1001 : Decimal);
    VAR
      Currency@1011 : Record 4;
      CurrencyExchangeRate@1012 : Record 330;
    BEGIN
      Currency.GET(CurrencyCode);
      SelectCurrencyExchangeRate(CurrencyExchangeRate,CurrencyCode);
      Assert.AreNearlyEqual(
        ROUND(
          CurrencyExchangeRate."Exchange Rate Amount" / CurrencyExchangeRate."Relational Exch. Rate Amount" * CalculatedWIPAmount,
          Currency."Amount Rounding Precision"),TotalAmount,Currency."Invoice Rounding Precision",ErrMessageAmountDoNotMatch);
    END;

    [Normal]
    LOCAL PROCEDURE TearDown@53(AdditionalCurrencyExist@1003 : Boolean;Subcontract@1004 : Boolean;ItemNo@1000 : Code[20]);
    VAR
      GenProductPostingGroup@1001 : Record 251;
      Item@1002 : Record 27;
    BEGIN
      IF AdditionalCurrencyExist THEN
        LibraryERM.SetAddReportingCurrency('');

      IF Subcontract THEN BEGIN
        Item.GET(ItemNo);
        GenProductPostingGroup.GET(Item."Gen. Prod. Posting Group");
        GenProductPostingGroup.VALIDATE("Def. VAT Prod. Posting Group",'');
        GenProductPostingGroup.MODIFY(TRUE);
      END;
    END;

    [Normal]
    LOCAL PROCEDURE RaiseConfirmHandler@1142();
    BEGIN
      IF CONFIRM('') THEN;
    END;

    [StrMenuHandler]
    PROCEDURE CalcStdCostMenuHandler@22(Option@1000 : Text[1024];VAR Choice@1001 : Integer;Instruction@1002 : Text[1024]);
    BEGIN
      // Calculate Standard Cost for All Level.
      Choice := 2;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@12(ConfirmText@1000 : Text[1024];VAR Confirm@1001 : Boolean);
    BEGIN
      Confirm := TRUE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@36(Msg@1000 : Text[1024]);
    BEGIN
    END;

    BEGIN
    {
      // [FEATURE] [Adjust Cost Item Entries] [Post Inventory to G/L] [SCM]
      Unsupported version tags:
      US: Unable to Execute
      DE: Unable to Execute
      CA: Unable to Execute
      IT: Unable to Execute
      IN: Unable to Execute
      CH: Unable to Execute (TFS ID: 51233)

      Test for WIP Costing:
         1. Test Standard Costing of Subcontracting Order with Flushing method - Manual.
         2. Test Standard Costing of Flushing method - Manual Cost different from Expected.
         3. Test Standard Costing of Subcontracting Order with Flushing method - Manual. Subcontract Cost different from Expected.
         4. Test Standard Costing of Subcontracting Order with Flushing method - Backward and of Subcontract Work center as Manual.
         5. Test Standard Costing with Flushing method Forward for Planned Production Order.Replace Production Component.
         6. Test Average Costing of Subcontracting Order with Flushing method - Backward and of Subcontract Work center as Manual.
         7. Test Average Costing of Subcontracting Order with Flushing method - Manual. Subcontract Cost different from Expected.
         8. Test Standard Costing for Additional Currency of Subcontracting Order with Flushing method - Manual.
            Subcontract Cost different from Expected.
         9. Test Standard Costing for Additional Currency of Subcontracting Order with Flushing method - Backward and
            of Subcontract Work center as Manual.
        10. Test FIFO Costing of Flushing method - Forward.
        11. Test FIFO Costing of Flushing method - Manual,  Output cost and Capacity Cost is  different from Expected.
        12. Test FIFO Costing with Flushing method Forward, replacing production order component.
        13. Test FIFO Costing of Subcontracting Order with Flushing method - Backward and of Subcontract Work center as Manual.
        14. Test FIFO Costing of Subcontracting Order with Flushing method - Manual. Subcontract Cost different from Expected.
        15. Test Average Costing for Additional Currency of Flushing method - Forward.Update Exchange Rates.
        16. Test Average Costing for Additional Currency of Flushing method - Manual, Output cost, Consumption Cost Run Time and Setup
            Time is  different from Expected. Update Exchange Rates.
        17. Test Average Costing for Additional Currency Of Flushing method Forward for Planned Production Order.
            Delete one Production Component.Update Exchange Rates.
        18. Test Average Costing for Additional Currency of Flushing method - Manual. Update Production order routing.
            Update Exchange Rates.
        19. Test Average Costing for Additional Currency of Subcontracting Order with Flushing method - Backward and
            of Subcontract Work center as Manual.Update Exchange Rates.
        20. Test Average Costing for Additional Currency of Subcontracting Order with Flushing method - Manual.
            Subcontract Cost different from Expected.Update Exchange Rates.
        21. Test FIFO Costing for Additional Currency of Flushing method - Manual, Output cost, consumption Cost, Run Time and Setup
            Time is different from Expected. Update Exchange Rates.
        22. Test FIFO Costing for Additional Currency of Subcontracting Order with Flushing method - Manual.
            Subcontract Cost different from Expected.
        23. Test FIFO Costing with Additional Currency of Flushing method - Forward.
        24. Test FIFO Costing with Additional Currency of Flushing method - Manual,
            Output cost and Capacity Cost is different from Expected.
        25. Test FIFO Costing with Additional Currency of Flushing method Forward, replacing old production component with new one.
        26. Test FIFO Costing with Additional Currency for Subcontracting Order with Flushing method - Backward,
            and Subcontract Work center as Manual.
        27. Test FIFO Costing with Additional Currency for Subcontracting Order with Flushing method - Manual,
            and Subcontract Cost different from Expected.

      This test code unit replaces Manual Test Suite (19684).
      TFS_TS_ID = 19684
      Covers Test cases:
        TC0313 TFS_TC_ID = 32230 and 12620
        TC0314 TFS_TC_ID = 32234 and 12624
        TC0323 TFS_TC_ID = 3457,3458 and 12619
        TC1313 TFS_TC_ID = 3649,3650 and 12616
        TC0333 TFS_TC_ID = 3485,3302,3303,3304,3305,3306,3307 and 3308.
        TC1323 TFS_TC_ID = 21355,4300,4301,4302,4303,4304,4305,4306 and 4307.
        TC335A TFS_TC_ID = 21356 and 11738,11739,11740,11741,11742,11743,11744,11745,11746,11747 and 11748.
        TC1333 TFS_TC_ID = 3659,3660,3661,4308,4309,4310,4311,4312,4313.
    }
    END.
  }
}

