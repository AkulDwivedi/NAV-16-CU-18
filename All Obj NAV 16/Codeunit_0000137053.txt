OBJECT Codeunit 137053 SCM Costing Average Cost
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            IsInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      Assert@1001 : Codeunit 130000;
      LibraryInventory@1002 : Codeunit 132201;
      LibraryUtility@1003 : Codeunit 131000;
      LibraryCosting@1004 : Codeunit 132200;
      LibraryPurchase@1005 : Codeunit 130512;
      LibrarySales@1006 : Codeunit 130509;
      LibraryPatterns@1008 : Codeunit 132212;
      IsInitialized@1007 : Boolean;

    LOCAL PROCEDURE Initialize@1();
    VAR
      LibraryERMCountryData@1004 : Codeunit 131305;
    BEGIN
      // Lazy Setup.
      IF IsInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      IsInitialized := TRUE;
      SetupInvtAdjmt;

      COMMIT;
    END;

    LOCAL PROCEDURE SetupInvtAdjmt@2();
    VAR
      InventorySetup@1000 : Record 313;
    BEGIN
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,FALSE,FALSE,
        InventorySetup."Automatic Cost Adjustment"::Never,
        InventorySetup."Average Cost Calc. Type"::Item,
        InventorySetup."Average Cost Period"::Day);
    END;

    LOCAL PROCEDURE CreateItemWithAvg@3(VAR Item@1000 : Record 27);
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Costing Method",Item."Costing Method"::Average);
      Item.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateItemJnlLine@4(VAR ItemJnlLine@1000 : Record 83;Item@1001 : Record 27;Quantity@1002 : Decimal;Cost@1003 : Decimal);
    VAR
      ItemJournalTemplate@1004 : Record 82;
      ItemJournalBatch@1005 : Record 233;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Item);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type::Item,ItemJournalTemplate.Name);
      LibraryInventory.ClearItemJournal(ItemJournalTemplate,ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(
        ItemJnlLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,ItemJnlLine."Entry Type",Item."No.",Quantity);

      IF Cost <> 0 THEN BEGIN
        ItemJnlLine.VALIDATE("Unit Cost",Cost);
        ItemJnlLine.MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateItemJnlLineWithFixAppl@5(VAR ItemJnlLine@1000 : Record 83;Item@1001 : Record 27;Quantity@1002 : Decimal;ItemLedgerEntryNo@1003 : Integer);
    BEGIN
      CreateItemJnlLine(ItemJnlLine,Item,Quantity,0);
      ItemJnlLine.VALIDATE("Applies-to Entry",ItemLedgerEntryNo);
      ItemJnlLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntry@6(ItemLedgerEntry@1000 : Record 32;CostAmountActual@1001 : Decimal);
    BEGIN
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Actual)");
      Assert.AreEqual(CostAmountActual,ItemLedgerEntry."Cost Amount (Actual)",'');
    END;

    LOCAL PROCEDURE PostingInbdOutBndInbd@8(VAR ItemLedgerEntry@1000 : ARRAY [3] OF Record 32;Item@1001 : Record 27);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      // post Positive Adjmt 1 UoM, per 5
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,5);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // post Negative Adjmt, 1 UoM
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Negative Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,0);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[1].FINDLAST;

      // post Positive Adjmt 1 UoM, per 7
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,7);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[2].FINDLAST;

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
    END;

    LOCAL PROCEDURE PostingOutboundWithFixApp@9(VAR ItemLedgerEntry@1000 : ARRAY [3] OF Record 32;Item@1001 : Record 27;Quantity@1002 : Decimal);
    VAR
      ItemJournalLine@1003 : Record 83;
    BEGIN
      // post Negative Adjmt, 1 UoM
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Negative Adjmt.";
      CreateItemJnlLineWithFixAppl(ItemJournalLine,Item,Quantity,ItemLedgerEntry[2]."Entry No.");
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[2].FINDLAST;
    END;

    LOCAL PROCEDURE PostingCoupleInbdOutbound@10(VAR ItemLedgerEntry@1000 : ARRAY [3] OF Record 32;Item@1001 : Record 27);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      // post Positive Adjmt 1 UoM, per 11
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,11);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // post Negative Adjmt, 1 UoM
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Negative Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,0);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[3].FINDLAST;

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
    END;

    LOCAL PROCEDURE CreateAndPostRevalutionJournal@11(VAR Item@1000 : Record 27;UnitCostReval@1001 : Decimal);
    VAR
      ItemJournalTemplate@1002 : Record 82;
      ItemJournalBatch@1003 : Record 233;
      ItemJournalLine@1004 : Record 83;
    BEGIN
      LibraryInventory.SelectItemJournalTemplateName(ItemJournalTemplate,ItemJournalTemplate.Type::Revaluation);
      LibraryInventory.SelectItemJournalBatchName(ItemJournalBatch,ItemJournalTemplate.Type,ItemJournalTemplate.Name);
      IF ItemJournalBatch."No. Series" <> '' THEN BEGIN
        ItemJournalBatch.VALIDATE("No. Series",'');
        ItemJournalBatch.MODIFY(TRUE);
      END;

      ItemJournalLine.VALIDATE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.VALIDATE("Journal Batch Name",ItemJournalBatch.Name);
      Item.SETRANGE("No.",Item."No.");
      LibraryCosting.CalculateInventoryValue(ItemJournalLine,Item,WORKDATE,LibraryUtility.GenerateGUID,1,FALSE,FALSE,FALSE,0,FALSE);

      // change cost for the item
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.FINDLAST;
      ItemJournalLine.VALIDATE("Unit Cost (Revalued)",UnitCostReval);
      ItemJournalLine.MODIFY(TRUE);

      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
    END;

    LOCAL PROCEDURE Posting2InbdAndOutbnd@12(VAR ItemLedgerEntry@1000 : ARRAY [3] OF Record 32;Item@1001 : Record 27);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      // post Positive Adjmt 1 UoM, per 1
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,1);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // post Positive Adjmt 1 UoM, per 2
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,2);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // post Negative Adjmt 1 UoM
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Negative Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,0);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[1].FINDLAST;

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
    END;

    LOCAL PROCEDURE PostingInbdOutbndWithFixApp@13(VAR ItemLedgerEntry@1000 : ARRAY [3] OF Record 32;Item@1001 : Record 27);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      // post Positive Adjmt 2 UoM, per 3
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,2,3);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[2].FINDLAST;

      PostingOutboundWithFixApp(ItemLedgerEntry,Item,1);

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
    END;

    LOCAL PROCEDURE CreatePurchaseHeader@14(VAR PurchaseHeader@1000 : Record 38);
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
      PurchaseHeader.VALIDATE("Vendor Invoice No.",PurchaseHeader."No.");
      PurchaseHeader.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreatePurchaseLine@15(PurchaseHeader@1000 : Record 38;VAR PurchaseLine@1001 : Record 39;Type@1002 : Option;No@1003 : Code[20];Quantity@1004 : Decimal;DirUnitCost@1005 : Decimal);
    BEGIN
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,Type,No,Quantity);
      PurchaseLine.VALIDATE("Direct Unit Cost",DirUnitCost);
      PurchaseLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrderForItem@16(Item@1000 : Record 27;Quantity@1001 : Decimal;DirUnitCost@1002 : Decimal);
    VAR
      PurchaseHeader@1003 : Record 38;
      PurchaseLine@1004 : Record 39;
    BEGIN
      CreatePurchaseHeader(PurchaseHeader);
      CreatePurchaseLine(PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,Item."No.",Quantity,DirUnitCost);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE CreateAndPostPurchaseOrderForCharge@17(Quantity@1000 : Decimal;DirUnitCost@1001 : Decimal;ApplyToEntry@1002 : Integer;ChargeForPurchReceipt@1008 : Boolean);
    VAR
      PurchaseHeader@1003 : Record 38;
      PurchaseLine@1004 : Record 39;
      ReturnReceiptLine@1006 : Record 6661;
      ItemChargeAssignmentPurch@1007 : Record 5805;
      PurchRcptLine@1009 : Record 121;
    BEGIN
      CreatePurchaseHeader(PurchaseHeader);
      CreatePurchaseLine(
        PurchaseHeader,PurchaseLine,PurchaseLine.Type::"Charge (Item)",
        LibraryInventory.CreateItemChargeNo,Quantity,DirUnitCost);

      IF ChargeForPurchReceipt THEN BEGIN
        // charge for purchase receipt
        PurchRcptLine.SETCURRENTKEY("Item Rcpt. Entry No.");
        PurchRcptLine.SETRANGE("Item Rcpt. Entry No.",ApplyToEntry);
        PurchRcptLine.FINDFIRST;

        LibraryInventory.CreateItemChargeAssignPurchase(
          ItemChargeAssignmentPurch,PurchaseLine,ItemChargeAssignmentPurch."Applies-to Doc. Type"::Receipt,
          PurchRcptLine."Document No.",PurchRcptLine."Line No.",PurchRcptLine."No.");
      END ELSE BEGIN
        // charge for purchase return receipt
        ReturnReceiptLine.SETCURRENTKEY("Item Rcpt. Entry No.");
        ReturnReceiptLine.SETRANGE("Item Rcpt. Entry No.",ApplyToEntry);
        ReturnReceiptLine.FINDFIRST;

        LibraryInventory.CreateItemChargeAssignPurchase(
          ItemChargeAssignmentPurch,PurchaseLine,ItemChargeAssignmentPurch."Applies-to Doc. Type"::"Return Receipt",
          ReturnReceiptLine."Document No.",ReturnReceiptLine."Line No.",ReturnReceiptLine."No.");
      END;

      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
    END;

    LOCAL PROCEDURE CreateSalesHeader@18(VAR SalesHeader@1000 : Record 36;DocType@1001 : Option;CustomerNo@1002 : Code[20]);
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,DocType,CustomerNo);
    END;

    LOCAL PROCEDURE CreateSalesLine@19(SalesHeader@1000 : Record 36;VAR SalesLine@1001 : Record 37;No@1002 : Code[20];Quantity@1003 : Decimal;ApplytoEntry@1004 : Integer);
    BEGIN
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,No,Quantity);
      IF ApplytoEntry > 0 THEN BEGIN
        SalesLine.VALIDATE("Appl.-to Item Entry",ApplytoEntry);
        SalesLine.MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateAndPostSalesOrder@20(VAR SalesHeader@1000 : Record 36;VAR ItemLedgerEntry@1001 : Record 32;CustomerNo@1002 : Code[20];Item@1003 : Record 27;Quantity@1004 : Decimal;ApplytoEntry@1005 : Integer);
    VAR
      SalesLine@1006 : Record 37;
    BEGIN
      CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CustomerNo);
      CreateSalesLine(SalesHeader,SalesLine,Item."No.",Quantity,ApplytoEntry);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      ItemLedgerEntry.FINDLAST;
    END;

    LOCAL PROCEDURE CreateAndPostSalesReturnOrder@21(VAR SalesHeader@1000 : Record 36;VAR ItemLedgerEntry@1001 : Record 32;CustomerNo@1002 : Code[20];ApplyToEntry@1003 : Integer);
    VAR
      SalesShipmentLine@1004 : Record 111;
      CopyDocumentMgt@1005 : Codeunit 6620;
      LinesNotCopied@1006 : Integer;
      MissingExCostRevLink@1007 : Boolean;
    BEGIN
      CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::"Return Order",CustomerNo);

      // Get Posted Document Line to Reverse
      SalesShipmentLine.SETCURRENTKEY("Item Shpt. Entry No.");
      SalesShipmentLine.SETRANGE("Item Shpt. Entry No.",ApplyToEntry);
      SalesShipmentLine.FINDFIRST;

      CopyDocumentMgt.SetProperties(FALSE,TRUE,FALSE,FALSE,TRUE,TRUE,TRUE);
      CopyDocumentMgt.CopySalesShptLinesToDoc(SalesHeader,SalesShipmentLine,LinesNotCopied,MissingExCostRevLink);

      LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      ItemLedgerEntry.FINDLAST;
    END;

    LOCAL PROCEDURE Posting2InBndPartialOutbnd@22(VAR ItemLedgerEntry@1000 : ARRAY [3] OF Record 32;Item@1001 : Record 27);
    VAR
      ItemJournalLine@1002 : Record 83;
    BEGIN
      // post Positive Adjmt 1 UoM, per 50
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,50);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");

      // post Positive Adjmt 1 UoM, per 70
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,70);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[2].FINDLAST;

      // post Negative Adjmt 1.5 UoM
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Negative Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1.5,0);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[1].FINDLAST;

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
    END;

    LOCAL PROCEDURE SalesPurchaseSalesWithDifferentDays@23(Item@1000 : Record 27;VAR ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;Invoice@1002 : Boolean;RevaluationBeforeFA@1003 : Boolean);
    VAR
      SalesHeader@1004 : Record 36;
      SalesLine@1005 : Record 37;
      PurchaseHeader@1006 : Record 38;
      PurchaseLine@1007 : Record 39;
      OrigWorkdate@1009 : Date;
      CustomerNo@1010 : Code[20];
    BEGIN
      OrigWorkdate := WORKDATE;

      CustomerNo := LibrarySales.CreateCustomerNo;
      CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CustomerNo);
      CreateSalesLine(SalesHeader,SalesLine,Item."No.",1,0);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,Invoice);
      ItemLedgerEntry[1].FINDLAST;

      WORKDATE := OrigWorkdate + 1;

      CreatePurchaseHeader(PurchaseHeader);
      CreatePurchaseLine(PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,Item."No.",11,40);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,FALSE);
      ItemLedgerEntry[2].FINDLAST;

      IF NOT RevaluationBeforeFA THEN BEGIN
        WORKDATE := OrigWorkdate + 2;
        CLEAR(SalesHeader);
        CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CustomerNo);
        CreateSalesLine(SalesHeader,SalesLine,Item."No.",1,ItemLedgerEntry[2]."Entry No.");
        LibrarySales.PostSalesDocument(SalesHeader,TRUE,Invoice);
        ItemLedgerEntry[3].FINDLAST;
      END;

      // reopen purchase
      WORKDATE := OrigWorkdate + 3;
      LibraryPurchase.ReopenPurchaseDocument(PurchaseHeader);
      PurchaseLine.GET(PurchaseLine."Document Type",PurchaseLine."Document No.",PurchaseLine."Line No.");
      PurchaseLine.VALIDATE("Direct Unit Cost",50);
      PurchaseLine.MODIFY(TRUE);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // adjustment
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Revaluation
      WORKDATE := OrigWorkdate + 1;
      CreateAndPostRevalutionJournal(Item,41);

      IF RevaluationBeforeFA THEN BEGIN
        WORKDATE := OrigWorkdate + 2;
        CLEAR(SalesHeader);
        CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,CustomerNo);
        CreateSalesLine(SalesHeader,SalesLine,Item."No.",1,ItemLedgerEntry[2]."Entry No.");
        LibrarySales.PostSalesDocument(SalesHeader,TRUE,Invoice);
        ItemLedgerEntry[3].FINDLAST;
      END;

      // adjustment
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
      WORKDATE := OrigWorkdate;
    END;

    LOCAL PROCEDURE VerifyItemLedgerEntryExpected@24(ItemLedgerEntry@1000 : Record 32;CostAmountActual@1001 : Decimal);
    BEGIN
      ItemLedgerEntry.CALCFIELDS("Cost Amount (Expected)");
      Assert.AreEqual(CostAmountActual,ItemLedgerEntry."Cost Amount (Expected)",'');
    END;

    LOCAL PROCEDURE PostingInbOutbndOutbndWithFixAppl@25(Item@1000 : Record 27;VAR ItemLedgerEntry@1001 : ARRAY [3] OF Record 32);
    VAR
      ItemJournalLine@1002 : Record 83;
      OrigWorkdate@1003 : Date;
    BEGIN
      // post Negative Adjmt 1 UoM
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Negative Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,0);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[1].FINDLAST;

      // post Positive Adjmt 1 UoM, per 1
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,11,50);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[2].FINDLAST;

      // Adjustment
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Revaluation
      CreateAndPostRevalutionJournal(Item,41);

      // sale with fix application one day later
      OrigWorkdate := WORKDATE;
      WORKDATE := OrigWorkdate + 1;
      PostingOutboundWithFixApp(ItemLedgerEntry,Item,1);
      WORKDATE := OrigWorkdate;
    END;

    LOCAL PROCEDURE Posting2Purchase2SalesWithFixAppl@26(Item@1001 : Record 27;VAR ItemLedgerEntry@1000 : ARRAY [3] OF Record 32);
    VAR
      ItemJournalLine@1002 : Record 83;
      OrigWorkdate@1003 : Date;
    BEGIN
      OrigWorkdate := WORKDATE;

      // post Positive Adjmt 1 UoM, per 1.1
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,1.1);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[2].FINDLAST;

      WORKDATE := OrigWorkdate + 1;
      // post Positive Adjmt 1 UoM, per 2.3
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Positive Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,2.3);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[1].FINDLAST;

      // sale with fix application three days later
      WORKDATE := OrigWorkdate + 3;
      PostingOutboundWithFixApp(ItemLedgerEntry,Item,1);

      // Adjustment
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      WORKDATE := OrigWorkdate + 2;
      // post Negative Adjmt 1 UoM
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Negative Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,0);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[3].FINDLAST;

      WORKDATE := OrigWorkdate;
    END;

    LOCAL PROCEDURE PurchSaleRevalSaleItemCharge@27(Item@1000 : Record 27;VAR ItemLedgerEntry@1001 : ARRAY [3] OF Record 32);
    VAR
      PurchaseHeader@1002 : Record 38;
      PurchaseLine@1003 : Record 39;
      ItemJournalLine@1005 : Record 83;
      OrigWorkdate@1004 : Date;
    BEGIN
      OrigWorkdate := WORKDATE;
      CreatePurchaseHeader(PurchaseHeader);
      CreatePurchaseLine(PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,Item."No.",3,10);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      ItemLedgerEntry[1].FINDLAST;

      // post Negative Adjmt 1 UoM
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Negative Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,0);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[2].FINDLAST;

      WORKDATE := OrigWorkdate + 2;
      // post Negative Adjmt 1 UoM
      ItemJournalLine."Entry Type" := ItemJournalLine."Entry Type"::"Negative Adjmt.";
      CreateItemJnlLine(ItemJournalLine,Item,1,0);
      LibraryInventory.PostItemJournalLine(ItemJournalLine."Journal Template Name",ItemJournalLine."Journal Batch Name");
      ItemLedgerEntry[3].FINDLAST;

      // Adjustment
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      WORKDATE := OrigWorkdate;
      // Revaluation
      CreateAndPostRevalutionJournal(Item,15);

      WORKDATE := OrigWorkdate + 3;
      // item charge
      CreateAndPostPurchaseOrderForCharge(1,99,ItemLedgerEntry[1]."Entry No.",TRUE);

      // Adjustment
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      WORKDATE := OrigWorkdate;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@31(Message@1000 : Text[1024]);
    BEGIN
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@32(Question@1000 : Text[1024];VAR Confirm@1001 : Boolean);
    BEGIN
      Confirm := TRUE;
    END;

    LOCAL PROCEDURE ExecuteUIHandlers@33();
    BEGIN
      // Generate dummy messages.
      MESSAGE('');
      IF CONFIRM('') THEN ;
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE SimpleScenario2Purchase1Sale@41();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: positive adjmt - negative adjmt - positive adjmt, then run Adust Cost

      // purchase, sale, purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      PostingInbdOutBndInbd(ItemLedgerEntry,Item);

      // verify cost of outbound entry
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-6);  // (5 + 7) / 2
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE SimpleScenarioWithFixedAppl@42();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: positive adjmt - negative adjmt - positive adjmt - negative adjmt with fix application to the second positive adjmt, then run Adust Cost

      // purchase, sale, purchase, sale with fix application to the second purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      PostingInbdOutBndInbd(ItemLedgerEntry,Item);

      // Fix Application
      PostingOutboundWithFixApp(ItemLedgerEntry,Item,1);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-5);
      VerifyItemLedgerEntry(ItemLedgerEntry[2],-7);
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE ComplexScenarioWithFixedAppl@43();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: positive adjmt - negative adjmt - positive adjmt - negative adjmt with fix application to the second positive adjmt - positive adjmt - negative adjmt, then run Adust Cost

      // purchase, sale, purchase, sale with fix application to the second purchase, purchase, sale
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      PostingInbdOutBndInbd(ItemLedgerEntry,Item);
      // Fix Application
      PostingOutboundWithFixApp(ItemLedgerEntry,Item,1);
      PostingCoupleInbdOutbound(ItemLedgerEntry,Item);

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-8);  // (5 + 11) / 2
      VerifyItemLedgerEntry(ItemLedgerEntry[2],-7);
      VerifyItemLedgerEntry(ItemLedgerEntry[3],-8);  // (5 + 11) / 2
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE SimpleScenarioWithRevalAndFixedAppl@44();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: positive adjmt - negative adjmt - positive adjmt - revaluation - negative adjmt with fix application to the second positive adjmt, then run Adust Cost

      // purchase, sale, purchase, revaluation, sale with fix application to the second purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      PostingInbdOutBndInbd(ItemLedgerEntry,Item);

      // Revaluation
      CreateAndPostRevalutionJournal(Item,8);
      // Fix Application
      PostingOutboundWithFixApp(ItemLedgerEntry,Item,1);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-5); // -5, -1, +1
      VerifyItemLedgerEntry(ItemLedgerEntry[2],-9); // -7, -2
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE ComplexScenarioWithRevalAndFixedAppl@45();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: positive adjmt - negative adjmt - positive adjmt - revaluation - negative adjmt with fix appl. to the second positive adjmt - positive adjmt - negative adjmt, then run Adust Cost

      // purchase, sale, purchase, revaluation, sale with fix application to the second purchase, purchase, sale
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      PostingInbdOutBndInbd(ItemLedgerEntry,Item);

      // Revaluation
      CreateAndPostRevalutionJournal(Item,8);
      // Fix Application
      PostingOutboundWithFixApp(ItemLedgerEntry,Item,1);
      PostingCoupleInbdOutbound(ItemLedgerEntry,Item);

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-5); // -5, -1, +1
      VerifyItemLedgerEntry(ItemLedgerEntry[2],-9); // -7, -2
      VerifyItemLedgerEntry(ItemLedgerEntry[3],-11); // -11
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE ComplexScenarioWithRevalAndPartialFixedAppl@46();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: positive adjmt - positive adjmt - negative adjmt - revaluation - positive adjmt - negative adjmt with fix appl. to the third positive adjmt, then run Adust Cost.

      // purchase, purchase, sale, revaluation, purchase, sale with fix application to the third purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      Posting2InbdAndOutbnd(ItemLedgerEntry,Item);

      // Revaluation
      CreateAndPostRevalutionJournal(Item,2);
      // Fix Application
      PostingInbdOutbndWithFixApp(ItemLedgerEntry,Item);

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-1.5); // -1.5  (1 + 2 ) / 2
      VerifyItemLedgerEntry(ItemLedgerEntry[2],-3); // -3
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE ComplexScenarioWithRetOrderAndFixedApplAndItemCharge@47();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [4] OF Record 32;
      SalesHeader@1002 : Record 36;
      CustomerNo@1003 : Code[20];
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: purchase - sale - sales return - sale - sale with fix appl. to the return order - item charge to return order, then run Adust Cost.

      // purchase, sale, Sales Return to previous sale, sale, sale with fix application to the return order, item charge to return order
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);
      CustomerNo := LibrarySales.CreateCustomerNo;

      // purchase 2 UoM, per 1
      CreateAndPostPurchaseOrderForItem(Item,2,1);
      // sales 2 UoM
      CreateAndPostSalesOrder(SalesHeader,ItemLedgerEntry[1],CustomerNo,Item,2,0);
      // sales return order 2 UoM applied to previous sales shipment
      CreateAndPostSalesReturnOrder(SalesHeader,ItemLedgerEntry[2],CustomerNo,ItemLedgerEntry[1]."Entry No.");
      // sales 1 UoM
      CreateAndPostSalesOrder(SalesHeader,ItemLedgerEntry[3],CustomerNo,Item,1,0);
      // sales 1 UoM applied to sales return order
      CreateAndPostSalesOrder(SalesHeader,ItemLedgerEntry[4],CustomerNo,Item,1,ItemLedgerEntry[2]."Entry No.");
      // purchase order with item charge applied to sales return
      CreateAndPostPurchaseOrderForCharge(1,1,ItemLedgerEntry[2]."Entry No.",FALSE);

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-2); // should be -2
      VerifyItemLedgerEntry(ItemLedgerEntry[2],3); // Return 3 (2 and item charge 1)
      VerifyItemLedgerEntry(ItemLedgerEntry[3],-1.5); // -1.50 (-1 and -0.50)
      VerifyItemLedgerEntry(ItemLedgerEntry[4],-1.5); // -1.50 (-1 and -0.50)
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE SimpleScenarioWithRevalAndPartialFixedAppl@48();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: positive adjmt - positive adjmt - negative adjmt - revaluation - neg. adjmt with fix appln. to the second positive adjmt, then run Adust Cost.

      // purchase, purchase, partial sale, revaluation, sale with fix application to the second purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      Posting2InBndPartialOutbnd(ItemLedgerEntry,Item);

      // Revaluation
      CreateAndPostRevalutionJournal(Item,80);
      // Fix Application
      PostingOutboundWithFixApp(ItemLedgerEntry,Item,0.5);

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-85); // -85
      VerifyItemLedgerEntry(ItemLedgerEntry[2],-45); // -45
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE TestRevalAfterFixAppl@49();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: ship sale - receive purchase - ship sale with fix application to purchase later - revaluation purchase - adjust.

      // sale, purchase, sale with fix application to purchase later, revaluation purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      SalesPurchaseSalesWithDifferentDays(Item,ItemLedgerEntry,FALSE,FALSE);

      // verify cost of outbound entries
      VerifyItemLedgerEntryExpected(ItemLedgerEntry[1],-50); // should be -50
      VerifyItemLedgerEntry(ItemLedgerEntry[2],460); // purchase 10 * 41 + 1 * 50
      VerifyItemLedgerEntryExpected(ItemLedgerEntry[3],-41); // -40, -10, +9
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE TestRevalAfterFixApplWithFullyInvoiced@50();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: sale - receive purchase - sale with fix application to purchase later - revaluation purchase - adjust.

      // sale, purchase, sale with fix application to purchase later, revaluation purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      SalesPurchaseSalesWithDifferentDays(Item,ItemLedgerEntry,TRUE,FALSE);

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-50); // should be -50
      VerifyItemLedgerEntry(ItemLedgerEntry[2],460); // purchase 10 * 41 + 1 * 50
      VerifyItemLedgerEntry(ItemLedgerEntry[3],-41); // -40, -10, +9
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE TestRevalBeforeFixApplWithFullyInvoiced@51();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: sale - receive purchase - revaluation purchase - sale with fix application to purchase - adjust.

      // sale, purchase, revaluation purchase, sale with fix application to purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      SalesPurchaseSalesWithDifferentDays(Item,ItemLedgerEntry,TRUE,TRUE);

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-50); // should be -50
      VerifyItemLedgerEntry(ItemLedgerEntry[2],460); // purchase 10 * 41 + 1 * 50
      VerifyItemLedgerEntry(ItemLedgerEntry[3],-41); // -40, -10, +9
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE TestRevalWithFixAppl@52();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: negative adjmt - positive adjmt - adust cost - revaluation - negative adjmt - adjust cost.

      // sale, purchase, sale with fix application to purchase later, revaluation purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      // posting sale, purchase, sale with fix application to purchase
      PostingInbOutbndOutbndWithFixAppl(Item,ItemLedgerEntry);

      // Adjustment
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],-50); // should be -50
      VerifyItemLedgerEntry(ItemLedgerEntry[2],-41); // -50, +9
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE TestFixAppl@53();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: positive adjmt - positive adjmt - negative adjmt with fix application to prev. adjmt - adjust cost - negative adjmt - adjust cost.

      // sale, purchase, sale with fix application to purchase later, revaluation purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      // posting puchase, purchase, sale and sale with fix application to purchase 1 all posting in different days
      Posting2Purchase2SalesWithFixAppl(Item,ItemLedgerEntry);

      // Adjustment
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],2.3); // purchase 2.3
      VerifyItemLedgerEntry(ItemLedgerEntry[2],-1.1); // fix application -1.1
      VerifyItemLedgerEntry(ItemLedgerEntry[3],-2.3); // cost of purchase -2.3
    END;

    [Test]
    [HandlerFunctions(MessageHandler,ConfirmHandler)]
    PROCEDURE TestRevalWithItemCharge@54();
    VAR
      Item@1000 : Record 27;
      ItemLedgerEntry@1001 : ARRAY [3] OF Record 32;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: purchase - negative adjmt - negative adjmt - adjust cost - revaluation purchase - item charge to purchase - adjust cost.

      // purchase, sale, revaluation purchase, sale, item charge to purchase
      Initialize;
      ExecuteUIHandlers;
      CreateItemWithAvg(Item);

      PurchSaleRevalSaleItemCharge(Item,ItemLedgerEntry);

      // verify cost of outbound entries
      VerifyItemLedgerEntry(ItemLedgerEntry[1],139); // purchase 30 + reval 10 + charge 99
      VerifyItemLedgerEntry(ItemLedgerEntry[2],-43); // sale -10, charge -33
      VerifyItemLedgerEntry(ItemLedgerEntry[3],-48); // sale -10, -38
    END;

    [Test]
    PROCEDURE TestPartialInvoiceAfterReval@29();
    VAR
      Item@1000 : Record 27;
      PurchaseHeader@1001 : Record 38;
      PurchaseLine@1003 : Record 39;
      SalesHeader@1004 : Record 36;
      ItemJnlBatch@1005 : Record 233;
      PostingDate@1002 : Date;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: purchase (full receive, part invoice) - sales - adjust cost - revaluation - adjust cost - sales - purchase (remaining invoice) - sales - adjust cost.

      CreateItemWithAvg(Item);

      PostingDate := WORKDATE;

      // Purchase Receive 3, Invoice 1
      LibraryPatterns.MAKEPurchaseOrder(PurchaseHeader,PurchaseLine,Item,'','',3,PostingDate,10);
      PurchaseLine.VALIDATE("Qty. to Invoice",2);
      PurchaseLine.MODIFY;
      PurchaseHeader.VALIDATE("Vendor Invoice No.",LibraryUtility.GenerateGUID);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      // Sell 1
      LibraryPatterns.POSTSalesOrder(SalesHeader,Item,'','',1,PostingDate,0,TRUE,TRUE);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      // Revalue
      LibraryPatterns.CalculateInventoryValueRun(ItemJnlBatch,Item,PostingDate,1,FALSE,FALSE,FALSE,0,FALSE,'','');
      LibraryPatterns.ModifyPostRevaluation(ItemJnlBatch,2);
      LibraryCosting.AdjustCostItemEntries(Item."No.",'');

      PostingDate += 1;

      // Sell 1
      LibraryPatterns.POSTSalesOrder(SalesHeader,Item,'','',1,PostingDate,0,TRUE,TRUE);

      PostingDate += 1;
      // Purchase Invoice Remaining 2
      PurchaseHeader.FIND;
      PurchaseHeader.VALIDATE("Posting Date",PostingDate);
      PurchaseHeader.MODIFY;
      PurchaseLine.FIND;
      PurchaseLine.VALIDATE("Direct Unit Cost",12);
      PurchaseLine.MODIFY;
      PurchaseHeader.VALIDATE("Vendor Invoice No.",LibraryUtility.GenerateGUID);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);

      PostingDate += 1;
      // Sell 1
      LibraryPatterns.POSTSalesOrder(SalesHeader,Item,'','',1,PostingDate,0,TRUE,TRUE);

      LibraryCosting.AdjustCostItemEntries(Item."No.",'');
      LibraryCosting.CheckAdjustment(Item);
    END;

    [Test]
    PROCEDURE TestFixApplWithDoubleRevallAndRounding@28();
    VAR
      Item@1000 : Record 27;
      ItemJournalBatch@1002 : Record 233;
      ItemJournalLine@1003 : Record 83;
      ItemLedgerEntry@1004 : ARRAY [6] OF Record 32;
      PostingDate@1001 : Date;
    BEGIN
      // [SCENARIO] Verify ILE "Cost Amount (Actual)" after posting: purchase - sale - sale - adjust cost - revaluation - sale - sale with fix application to the purchase - adjust cost - revaluation - sale - adjust cost.

      CreateItemWithAvg(Item);

      PostingDate := WORKDATE;

      // Purchase 5 @ 1 each
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::Purchase,Item,'','','',5,PostingDate,1);
      ItemLedgerEntry[1].FINDLAST;

      // Sell 1
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::Sale,Item,'','','',1,PostingDate,1);
      ItemLedgerEntry[2].FINDLAST;

      // Sell 1, Fixed Application
      LibraryPatterns.POSTItemJournalLineWithApplication(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::Sale,Item,'','',1,PostingDate,1,
        ItemLedgerEntry[1]."Entry No.");
      ItemLedgerEntry[3].FINDLAST;

      // Revalue Inventory Qty 3 to Value 10 to create rounding scenario
      LibraryCosting.AdjustCostItemEntries('','');
      RevalueToFixedInvValue(Item,PostingDate,10);

      // Sell 1
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::Sale,Item,'','','',1,PostingDate,1);
      ItemLedgerEntry[4].FINDLAST;

      // Sell 1, Fixed Application
      LibraryPatterns.POSTItemJournalLineWithApplication(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::Sale,Item,'','',1,PostingDate,1,
        ItemLedgerEntry[1]."Entry No.");
      ItemLedgerEntry[5].FINDLAST;

      // Revalue remaining qty to 1
      LibraryCosting.AdjustCostItemEntries('','');
      RevalueToFixedInvValue(Item,PostingDate,1);

      // Sell 1
      LibraryPatterns.POSTItemJournalLine(
        ItemJournalBatch."Template Type"::Item,ItemJournalLine."Entry Type"::Sale,Item,'','','',1,PostingDate,1);
      LibraryCosting.AdjustCostItemEntries('','');
      ItemLedgerEntry[6].FINDLAST;

      VerifyItemLedgerEntry(ItemLedgerEntry[1],9.67); // purchase 5 + reval 7 + reval -2.33
      VerifyItemLedgerEntry(ItemLedgerEntry[2],-1);
      VerifyItemLedgerEntry(ItemLedgerEntry[3],-1);
      VerifyItemLedgerEntry(ItemLedgerEntry[4],-3.34); // 10 / 3 + rounding 0.01
      VerifyItemLedgerEntry(ItemLedgerEntry[5],-3.33); // 10 / 3
      VerifyItemLedgerEntry(ItemLedgerEntry[6],-1); // remaining value after final revaluation
    END;

    LOCAL PROCEDURE RevalueToFixedInvValue@40(Item@1000 : Record 27;PostingDate@1001 : Date;RevaluedInvValue@1002 : Decimal);
    VAR
      ItemJournalBatch@1004 : Record 233;
      ItemJournalLine@1003 : Record 83;
    BEGIN
      LibraryPatterns.CalculateInventoryValueRun(ItemJournalBatch,Item,PostingDate,1,FALSE,FALSE,FALSE,0,FALSE,'','');
      ItemJournalLine.SETRANGE("Journal Template Name",ItemJournalBatch."Journal Template Name");
      ItemJournalLine.SETRANGE("Journal Batch Name",ItemJournalBatch.Name);
      ItemJournalLine.FINDFIRST;
      ItemJournalLine.VALIDATE("Inventory Value (Revalued)",RevaluedInvValue);
      ItemJournalLine.MODIFY;
      LibraryInventory.PostItemJournalBatch(ItemJournalBatch);
    END;

    BEGIN
    {
      // [FEATURE] [Adjust Cost Item Entries] [Cost Average] [SCM]
    }
    END.
  }
}

