OBJECT Codeunit 134006 ERM Apply Unapply Customer
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Permissions=TableData 21=rimd;
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      LibrarySales@1006 : Codeunit 130509;
      LibraryERM@1002 : Codeunit 131300;
      LibraryVariableStorage@1009 : Codeunit 131004;
      LibraryInventory@1016 : Codeunit 132201;
      LibraryPmtDiscSetup@1024 : Codeunit 131303;
      LibraryRandom@1001 : Codeunit 130440;
      LibrarySetupStorage@1023 : Codeunit 131009;
      Assert@1005 : Codeunit 130000;
      isInitialized@1000 : Boolean;
      AdditionalCurrencyErr@1008 : TextConst '@@@=<Locked>;ENU=Additional Currency Amount must be %1.';
      TotalAmountErr@1003 : TextConst '@@@=<Locked>;ENU=Total Amount must be %1 in %2 table for %3 field : %4.';
      UnappliedErr@1004 : TextConst '@@@=<Locked>;ENU=%1 %2 field must be true after Unapply entries.';
      ApplicationEntryErr@1007 : TextConst '@@@=<Locked>;ENU=%1 No. %2 does not have an application entry.';
      UnapplyErr@1010 : TextConst '@@@=<Locked>;ENU="%1 must be equal to ''Application''  in %2: %3=%4. Current value is ''Initial Entry''."';
      UnapplyErrorDetailedEntryErr@1011 : TextConst '@@@=<Locked>;ENU="Unapplied must be equal to ''No''  in %1: %2=%3. Current value is ''Yes''."';
      AmountErr@1012 : TextConst '@@@=<Locked>;ENU=%1 must be %2 in %3.';
      UapplyExchangeRateErr@1015 : TextConst '@@@=<Locked>;ENU=You cannot unapply the entry with the posting date %1, because the exchange rate for the additional reporting currency has been changed.';
      WrongFieldErr@1017 : TextConst '@@@=<Locked>;ENU=Wrong value of field %1 in table %2.';
      UnnecessaryVATEntriesFoundErr@1018 : TextConst '@@@=<Locked>;ENU=Unnecessary VAT Entries found.';
      PaymentMethodCodeErr@1019 : TextConst '@@@=<Locked>;ENU="Open must be equal to ''Yes''  in Cust. Ledger Entry: Entry No.=%1. Current value is ''No''."';
      NonzeroACYErr@1020 : TextConst '@@@=<Locked>;ENU=Non-zero Additional Currency Amount in G/L Entry.';
      GLEntryCntErr@1021 : TextConst 'ENU=Wrong count of created G/L Entries.';
      DimBalanceErr@1022 : TextConst 'ENU=Wrong balance by Dimension.';
      SelectionFilterErr@1025 : TextConst '@@@="%1: original selection filter;%2: returned selection filter";ENU=Problem with selection filter: Original selection: %1. Returned selection: %2.';
      NoEntriesAppliedErr@1026 : TextConst 'ENU=Cannot post because you did not specify which entry to apply. You must specify an entry in the Applies-to ID field for one or more open entries.';

    [Test]
    PROCEDURE ApplyUnapplyPayment@19();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check that Detailed Ledger Unapplied field is set to TRUE and Customer Ledger Entry and G/L entry have correct
      // Remaining Amount and Additional Currency amount after Apply and Unapply Ledger Entry as well.
      Initialize;
      ApplyUnapplyCustEntries(
        GenJournalLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandInt(500));
    END;

    [Test]
    PROCEDURE ApplyUnapplyRefund@10();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check that Detailed Ledger Unapplied field is set to TRUE and Customer Ledger Entry and G/L entry have correct
      // Remaining Amount and Additional Currency amount for Credit Memo and Refund after Apply and Unapply Ledger Entry as well.
      Initialize;
      ApplyUnapplyCustEntries(
        GenJournalLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandInt(500));
    END;

    LOCAL PROCEDURE ApplyUnapplyCustEntries@13(DocumentType@1000 : Option;DocumentType2@1001 : Option;Amount@1004 : Decimal);
    VAR
      GenJournalLine@1003 : Record 81;
    BEGIN
      // Setup.
      LibraryERM.SetAddReportingCurrency(CreateCurrency);

      // Create, Post, Apply and Unapply General journal Lines.
      PostApplyUnapplyGenJournalLine(GenJournalLine,DocumentType,DocumentType2,Amount);

      // Verify: Detailed Ledger Unapplied field is set to TRUE, Customer Ledger Entry for Remaining amount
      // after Unapply applied entries and Additional Currency Amount on G/L Entry.
      VerifyUnappliedDtldLedgEntry(GenJournalLine."Document No.",DocumentType);
      VerifyCustLedgerEntryForRemAmt(GenJournalLine."Document Type",GenJournalLine."Document No.");
      VerifyAddCurrencyAmount(GenJournalLine."Document No.");
    END;

    [Test]
    PROCEDURE ApplyUnapplyAndApplyPayment@18();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check that Detailed Customer Ledger Entry and G/L entry have Amount Zero and Additional Currency amount after
      // Apply, Unapply and again Apply Unapplied Ledger Entry as well.
      Initialize;
      ApplyUnapplyApplyCustEntries(
        GenJournalLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandInt(500));
    END;

    [Test]
    PROCEDURE ApplyUnapplyApplyRefund@30();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check that Detailed Customer Ledger Entry and G/L entry have Amount Zero and Additional Currency amount for Credit Memo
      // and Refund Entries after Apply, Unapply and again Apply Unapplied Ledger Entry as well.
      Initialize;
      ApplyUnapplyApplyCustEntries(
        GenJournalLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandInt(500));
    END;

    LOCAL PROCEDURE ApplyUnapplyApplyCustEntries@55(DocumentType@1000 : Option;DocumentType2@1001 : Option;Amount@1004 : Decimal);
    VAR
      GenJournalLine@1003 : Record 81;
    BEGIN
      // Setup.
      LibraryERM.SetAddReportingCurrency(CreateCurrency);

      // Create, Post, Apply, Unapply and again Apply Unapplied General journal Lines.
      PostApplyUnapplyGenJournalLine(GenJournalLine,DocumentType,DocumentType2,Amount);
      ApplyAndPostCustomerEntry(
        GenJournalLine."Document No.",GenJournalLine."Document No.",-GenJournalLine.Amount,DocumentType,DocumentType2);

      // Verify: Detailed Customer Ledger Entry for Total Amount and Additional Currency Amount on G/L Entry.
      VerifyDetailedLedgerEntry(GenJournalLine."Document No.",DocumentType);
      VerifyAddCurrencyAmount(GenJournalLine."Document No.");
    END;

    LOCAL PROCEDURE PostApplyUnapplyGenJournalLine@12(VAR GenJournalLine@1003 : Record 81;DocumentType@1000 : Option;DocumentType2@1004 : Option;Amount@1005 : Decimal);
    VAR
      NoOfLines@1001 : Integer;
    BEGIN
      NoOfLines := 2 * LibraryRandom.RandInt(2);
      CreateAndPostGenJournalLine(GenJournalLine,DocumentType,DocumentType2,NoOfLines,Amount);

      // Exercise: Apply and Unapply Posted General Lines for Customer Ledger Entry.
      ApplyAndPostCustomerEntry(
        GenJournalLine."Document No.",GenJournalLine."Document No.",-GenJournalLine.Amount,DocumentType,DocumentType2);
      UnapplyCustLedgerEntry(DocumentType2,GenJournalLine."Document No.");
    END;

    [Test]
    PROCEDURE UnapplyInvFromCustLedger@21();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Unapply Invoice from Customer Ledger Entry and verify error message.
      // Use Random Number Generator for Amount.
      Initialize;
      UnapplyFromCustLedgerEntry(GenJournalLine."Document Type"::Invoice,LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE UnapplyPaymentFromCustLedger@25();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Unapply Payment from Customer Ledger Entry and verify error message.
      // Use Random Number Generator for Amount.
      Initialize;
      UnapplyFromCustLedgerEntry(GenJournalLine."Document Type"::Payment,-LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE UnapplyCrMemoFromCustLedger@32();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Unapply Credit Memo from Customer Ledger Entry and verify error message.
      // Use Random Number Generator for Amount.
      Initialize;
      UnapplyFromCustLedgerEntry(GenJournalLine."Document Type"::"Credit Memo",-LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE UnapplyRefundFromCustLedger@34();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Unapply Refund from Customer Ledger Entry and verify error message.
      // Use Random Number Generator for Amount.
      Initialize;
      UnapplyFromCustLedgerEntry(GenJournalLine."Document Type"::Refund,LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE UnapplyFromCustLedgerEntry@4(DocumentType@1006 : Option;Amount@1007 : Decimal);
    VAR
      Customer@1000 : Record 18;
      GenJournalLine@1002 : Record 81;
      CustLedgerEntry@1003 : Record 21;
      GenJournalBatch@1001 : Record 232;
      CustEntryApplyPostedEntries@1005 : Codeunit 226;
    BEGIN
      // Setup: Create Customer,create and post General Journal Line,find Customer Ledger Entry.
      // Using 1 to create single General Journal Line.
      LibrarySales.CreateCustomer(Customer);
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      CreateGeneralJournalLines(GenJournalLine,GenJournalBatch,1,Customer."No.",DocumentType,Amount);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,DocumentType,GenJournalLine."Document No.");

      // Exercise: Unapply Invoice/Payment/Credit Memo/Refund from Customer Ledger Entry.
      ASSERTERROR CustEntryApplyPostedEntries.UnApplyCustLedgEntry(CustLedgerEntry."Entry No.");

      // Verify: verify error message on Customer Ledger Entry.
      Assert.ExpectedError(STRSUBSTNO(ApplicationEntryErr,CustLedgerEntry.TABLECAPTION,CustLedgerEntry."Entry No."));
    END;

    [Test]
    PROCEDURE UnapplyInvFromDtldCustLedger@40();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Unapply Invoice from Detailed Customer Ledger Entry and verify error message.
      // Use Random Number Generator for Amount.
      Initialize;
      UnapplyFromDtldCustLedgerEntry(GenJournalLine."Document Type"::Invoice,LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE UnapplyPaymentDtldCustLedger@24();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Unapply Payment from Detailed Customer Ledger Entry and verify error message.
      // Use Random Number Generator for Amount.
      Initialize;
      UnapplyFromDtldCustLedgerEntry(GenJournalLine."Document Type"::Payment,-LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE UnapplyCrMemoDtldCustLedger@27();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Unapply Credit Memo from Detailed Customer Ledger Entry and verify error message.
      // Use Random Number Generator for Amount.
      Initialize;
      UnapplyFromDtldCustLedgerEntry(GenJournalLine."Document Type"::"Credit Memo",-LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE UnapplyRefundDtldCustLedger@31();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Unapply Refund from Detailed Customer Ledger Entry and verify error message.
      // Use Random Number Generator for Amount.
      Initialize;
      UnapplyFromDtldCustLedgerEntry(GenJournalLine."Document Type"::Refund,LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE UnapplyFromDtldCustLedgerEntry@38(DocumentType@1006 : Option;Amount@1007 : Decimal);
    VAR
      Customer@1000 : Record 18;
      GenJournalLine@1002 : Record 81;
      DetailedCustLedgEntry@1004 : Record 379;
      GenJournalBatch@1001 : Record 232;
      CustEntryApplyPostedEntries@1005 : Codeunit 226;
    BEGIN
      // Setup: Create Customer, create and post General Journal Line,find Detailed Customer Ledger Entry.
      // Using 1 to create single General Journal Line.
      LibrarySales.CreateCustomer(Customer);
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      CreateGeneralJournalLines(GenJournalLine,GenJournalBatch,1,Customer."No.",DocumentType,Amount);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
      FindDetailedCustLedgerEntry(
        DetailedCustLedgEntry,GenJournalLine."Document No.",DocumentType,DetailedCustLedgEntry."Entry Type"::"Initial Entry");

      // Exercise: Unapply Invoice/Payment/Credit Memo/Refund from Detailed Customer Ledger Entry.
      ASSERTERROR CustEntryApplyPostedEntries.UnApplyDtldCustLedgEntry(DetailedCustLedgEntry);

      // Verify: verify error message on Detailed Customer Ledger Entry.
      Assert.ExpectedError(
        STRSUBSTNO(
          UnapplyErr,DetailedCustLedgEntry.FIELDCAPTION("Entry Type"),DetailedCustLedgEntry.TABLECAPTION,
          DetailedCustLedgEntry.FIELDCAPTION("Entry No."),DetailedCustLedgEntry."Entry No."));
    END;

    [Test]
    PROCEDURE UnapplyInvoiceCustLedger@9();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Unapply Invoice from Customer Ledger Entry and Check that Detailed Ledger Unapplied field is set to TRUE and G/L entry have
      // correct Additional Currency amount.
      Initialize;
      UnapplyCustEntries(
        GenJournalLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandInt(500));
    END;

    [Test]
    PROCEDURE UnapplyCreditMemoCustLedger@6();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Unapply Credit Memo from Customer Ledger Entry and Check that Detailed Ledger Unapplied field is set to TRUE and G/L entry have
      // correct Additional Currency amount.
      Initialize;
      UnapplyCustEntries(
        GenJournalLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandInt(500));
    END;

    LOCAL PROCEDURE UnapplyCustEntries@69(DocumentType@1002 : Option;DocumentType2@1003 : Option;Amount@1004 : Decimal);
    VAR
      GenJournalLine@1001 : Record 81;
      NoOfLines@1005 : Integer;
    BEGIN
      // Setup.
      NoOfLines := 2 * LibraryRandom.RandInt(2);
      LibraryERM.SetAddReportingCurrency(CreateCurrency);
      CreateAndPostGenJournalLine(GenJournalLine,DocumentType,DocumentType2,NoOfLines,Amount);

      // Exercise: Apply and Unapply Posted General Lines for Customer Ledger Entry.
      ApplyAndPostCustomerEntry(
        GenJournalLine."Document No.",GenJournalLine."Document No.",-GenJournalLine.Amount,DocumentType,DocumentType2);
      UnapplyCustLedgerEntry(DocumentType,GenJournalLine."Document No.");

      // Verify: Detailed Ledger Unapplied field is set to TRUE after Unapply applied entries and Additional Currency Amount on G/L Entry.
      VerifyUnappliedDtldLedgEntry(GenJournalLine."Document No.",DocumentType);
      VerifyAddCurrencyAmount(GenJournalLine."Document No.");
    END;

    [Test]
    PROCEDURE LedgerEntryInvoiceUnapplyError@37();
    VAR
      GenJournalLine@1001 : Record 81;
    BEGIN
      // Check Unapply Error on Customer Ledger Entry when do the Unapply again on Unapplied Entries.
      Initialize;
      ApplyAndUnapplyLedgerEntry(
        GenJournalLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE LedgerEntryCrMemoUnapplyError@36();
    VAR
      GenJournalLine@1001 : Record 81;
    BEGIN
      // Check Unapply Error on Customer Ledger Entry when do the Unapply again on Unapplied Entries for Credit Memo.
      Initialize;
      ApplyAndUnapplyLedgerEntry(
        GenJournalLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE ApplyAndUnapplyLedgerEntry@35(DocumentType@1007 : Option;DocumentType2@1008 : Option;Amount@1009 : Decimal);
    VAR
      CustLedgerEntry@1003 : Record 21;
      CustEntryApplyPostedEntries@1002 : Codeunit 226;
      DocumentNo@1004 : Code[20];
    BEGIN
      // Setup: Apply and Unapply Posted General Lines.
      DocumentNo := CreateLinesApplyAndUnapply(DocumentType,DocumentType2,Amount);

      // Exercise: Find Customer Ledger Entry and Try to Unapply Again.
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,DocumentType,DocumentNo);
      ASSERTERROR CustEntryApplyPostedEntries.UnApplyCustLedgEntry(CustLedgerEntry."Entry No.");

      // Verify: Verify Unapply Error on Customer Ledger Entry.
      Assert.ExpectedError(STRSUBSTNO(ApplicationEntryErr,CustLedgerEntry.TABLECAPTION,CustLedgerEntry."Entry No."));
    END;

    [Test]
    PROCEDURE DetldEntryInvoiceUnapplyError@33();
    VAR
      GenJournalLine@1001 : Record 81;
    BEGIN
      // Check Unapply Error on Detailed Customer Ledger Entry when do the Unapply again on Unapplied Entries.
      Initialize;
      ApplyAndUnapplyDetldEntry(
        GenJournalLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE DetldEntryCrMemoUnapplyError@28();
    VAR
      GenJournalLine@1001 : Record 81;
    BEGIN
      // Check Unapply Error on Detailed Customer Ledger Entry when do the Unapply again on Unapplied Entries for Credit Memo.
      Initialize;
      ApplyAndUnapplyDetldEntry(
        GenJournalLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE ApplyAndUnapplyDetldEntry@22(DocumentType@1010 : Option;DocumentType2@1009 : Option;Amount@1008 : Decimal);
    VAR
      DetailedCustLedgEntry@1004 : Record 379;
      CustEntryApplyPostedEntries@1002 : Codeunit 226;
      DocumentNo@1007 : Code[20];
    BEGIN
      // Setup: Apply and Unapply Posted General Lines.
      DocumentNo := CreateLinesApplyAndUnapply(DocumentType,DocumentType2,Amount);

      // Exercise: Find Detailed Ledger Entry and Try to Unapply.
      DetailedCustLedgEntry.SETRANGE("Entry Type",DetailedCustLedgEntry."Entry Type"::Application);
      DetailedCustLedgEntry.SETRANGE("Document No.",DocumentNo);
      DetailedCustLedgEntry.FINDFIRST;
      ASSERTERROR CustEntryApplyPostedEntries.UnApplyDtldCustLedgEntry(DetailedCustLedgEntry);

      // Verify: Verify Unapply Error on Detailed Customer Ledger Entry.
      Assert.ExpectedError(
        STRSUBSTNO(
          UnapplyErrorDetailedEntryErr,DetailedCustLedgEntry.TABLECAPTION,DetailedCustLedgEntry.FIELDCAPTION("Entry No."),
          DetailedCustLedgEntry."Entry No."));
    END;

    [Test]
    PROCEDURE ApplySalesInvoice@44();
    VAR
      SalesLine@1002 : Record 37;
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check Detailed Customer Ledger Entry after Creating and Post Sales Invoice and Apply with Payment.
      Initialize;
      CreateAndApplySales(
        SalesLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE ApplySalesCreditMemo@43();
    VAR
      SalesLine@1002 : Record 37;
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check Detailed Customer Ledger Entry after Creating and Post Sales Credit Memo and Apply with Refund.
      Initialize;
      CreateAndApplySales(
        SalesLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE CreateAndApplySales@47(DocumentType@1006 : Option;DocumentType2@1007 : Option;UnitPrice@1008 : Decimal);
    VAR
      GenJournalLine@1000 : Record 81;
      DetailedCustLedgEntry@1001 : Record 379;
    BEGIN
      // Create and Post Sales Document with Apply Payment.
      CreatePostSalesAndGenLine(GenJournalLine,DocumentType,DocumentType2,UnitPrice);

      // Verify: Verify Detailed Ledger Entry after Apply.
      VerifyInvDetailedLedgerEntry(
        GenJournalLine."Document No.",DocumentType2,GenJournalLine.Amount,DetailedCustLedgEntry."Entry Type"::Application);
    END;

    [Test]
    PROCEDURE ApplyUnapplySalesInvoice@42();
    VAR
      SalesLine@1002 : Record 37;
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check Detailed Customer Ledger Entry after Creating and Post Sales Invoice and Apply then Unapply with Payment.
      Initialize;
      CreateAndApplyUnapplySales(
        SalesLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE ApplyUnapplySalesCreditMemo@41();
    VAR
      SalesLine@1002 : Record 37;
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check Detailed Customer Ledger Entry after Creating and Post Sales Credit Memo and Apply then Unapply with Refund.
      Initialize;
      CreateAndApplyUnapplySales(
        SalesLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE CreateAndApplyUnapplySales@46(DocumentType@1008 : Option;DocumentType2@1007 : Option;UnitPrice@1006 : Decimal);
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Create and Post Sales Document with Apply Payment.
      CreatePostSalesAndGenLine(GenJournalLine,DocumentType,DocumentType2,UnitPrice);

      // Exericse: Unapply Applied Entries.
      UnapplyCustLedgerEntry(GenJournalLine."Document Type",GenJournalLine."Document No.");

      // Verify: Verify Detailed Ledger Entry after Apply and Unapply.
      VerifyDetailedLedgerEntry(GenJournalLine."Document No.",GenJournalLine."Document Type");
    END;

    [Test]
    PROCEDURE UnapplyPaymentCheckSourceCode@49();
    VAR
      GenJournalLine@1002 : Record 81;
    BEGIN
      // Test that correct Source Code updated on Detailed Customer Ledger Entry after Unapply Payment from Customer Ledger Entry.
      // Use Random Number Generator for Amount.
      Initialize;
      ApplyUnapplyAndCheckSourceCode(
        GenJournalLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE UnapplyRefundCheckSourceCode@57();
    VAR
      GenJournalLine@1002 : Record 81;
    BEGIN
      // Test that correct Source Code updated on Detailed Customer Ledger Entry after Unapply Refund from Customer Ledger Entry.
      // Use Random Number Generator for Amount.
      Initialize;
      ApplyUnapplyAndCheckSourceCode(
        GenJournalLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE ApplyUnapplyAndCheckSourceCode@78(DocumentType@1005 : Option;DocumentType2@1006 : Option;Amount@1004 : Decimal);
    VAR
      SourceCode@1001 : Record 230;
      GenJournalLine@1002 : Record 81;
    BEGIN
      // Setup: Create Source Code, update Source Code Setup, create and post General Journal Lines.
      LibraryERM.CreateSourceCode(SourceCode);
      CreateAndUpdateSourceCodeSetup(SourceCode.Code);
      CreateAndPostGenJournalLine(GenJournalLine,DocumentType,DocumentType2,1,Amount);
      // Using 1 to create one line for Payment/Refund.

      // Exercise: Apply and Unapply Payment/Refund from Customer Ledger Entry.
      ApplyAndPostCustomerEntry(
        GenJournalLine."Document No.",GenJournalLine."Document No.",-GenJournalLine.Amount,DocumentType,DocumentType2);
      UnapplyCustLedgerEntry(GenJournalLine."Document Type",GenJournalLine."Document No.");

      // Verify: Verify that correct Source Code updated on Detailed Customer Ledger Entry.
      VerifySourceCodeDtldCustLedger(DocumentType,GenJournalLine."Document No.",SourceCode.Code);
    END;

    [Test]
    PROCEDURE ChangeExchRateUnapplyPayment@52();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check that Payment cannot be Unapplied after Exchange Rate has been changed.
      // Use Random Nunber Generator for Amount.
      Initialize;
      ChangeExchRateUnapply(
        GenJournalLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandInt(500));
    END;

    [Test]
    PROCEDURE ChangeExchRateUnapplyRefund@68();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check that Refund cannot be Unapplied after Exchange Rate has been changed.
      // Use Random Nunber Generator for Amount.
      Initialize;
      ChangeExchRateUnapply(
        GenJournalLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandInt(500));
    END;

    LOCAL PROCEDURE ChangeExchRateUnapply@65(DocumentType@1003 : Option;DocumentType2@1004 : Option;Amount@1007 : Decimal);
    VAR
      GenJournalLine@1000 : Record 81;
      DetailedCustLedgEntry@1002 : Record 379;
      CustEntryApplyPostedEntries@1006 : Codeunit 226;
      PostingDate@1005 : Date;
    BEGIN
      // Setup: Update General Ledger Setup, Create and post General Journal Lines, Apply Payment/Refund from Customer Ledger Entry.
      LibraryERM.SetAddReportingCurrency(CreateCurrency);
      PostingDate := CALCDATE('<' + FORMAT(LibraryRandom.RandInt(10)) + 'M>',WORKDATE);
      CreateAndPostGenJournalLine(GenJournalLine,DocumentType,DocumentType2,1,Amount);  // Using 1 to create single Payment/Refund line.
      ApplyAndPostCustomerEntry(
        GenJournalLine."Document No.",GenJournalLine."Document No.",-GenJournalLine.Amount,DocumentType,DocumentType2);
      CreateNewExchangeRate(PostingDate);
      FindDetailedCustLedgerEntry(
        DetailedCustLedgEntry,GenJournalLine."Document No.",DocumentType,DetailedCustLedgEntry."Entry Type"::Application);

      // Exercise: Unapply Payment/Refund from Customer Ledger Entry.
      ASSERTERROR CustEntryApplyPostedEntries.PostUnApplyCustomer(DetailedCustLedgEntry,GenJournalLine."Document No.",PostingDate);

      // Verify: Verify error on Unapply after Exchange Rate has been changed.
      Assert.ExpectedError(STRSUBSTNO(UapplyExchangeRateErr,WORKDATE));
    END;

    [Test]
    PROCEDURE PaymentDiscApplyInvoice@60();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check Payment Discount Entry for Customer after Apply Payment with Invoice.
      Initialize;
      ApplyPaymentDiscount(
        GenJournalLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE PaymentDiscApplyCM@59();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check Payment Discount Entry for Customer after Apply Refund with Credit Memo.
      Initialize;
      ApplyPaymentDiscount(
        GenJournalLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE ApplyPaymentDiscount@64(DocumentType@1001 : Option;DocumentType2@1002 : Integer;Amount@1003 : Decimal);
    VAR
      DetailedCustLedgEntry@1006 : Record 379;
      DocumentNo@1005 : Code[20];
    BEGIN
      // Check Payment Discount Entry for Customer after Apply Payment with Invoice.
      Amount := CreateAndApplyGenLines(DocumentNo,DocumentType,DocumentType2,Amount);

      // Verify: Verify Detailed Customer Ledger Entry for Payment Discount Amount after Apply.
      VerifyInvDetailedLedgerEntry(DocumentNo,DocumentType2,-Amount,DetailedCustLedgEntry."Entry Type"::"Payment Discount");
    END;

    [Test]
    PROCEDURE PaymentDiscApplyUnapplyInvoice@58();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check Payment Discount Entry for Customer after Apply and Unapply Payment with Invoice.
      Initialize;
      ApplyUnapplyPaymentDiscount(
        GenJournalLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE PaymentDiscApplyUnapplyCM@56();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check Payment Discount Entry for Customer after Apply and Unapply Refund with Credit Memo.
      Initialize;
      ApplyUnapplyPaymentDiscount(
        GenJournalLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE ApplyUnapplyPaymentDiscount@70(DocumentType@1003 : Option;DocumentType2@1002 : Integer;Amount@1001 : Decimal);
    VAR
      DetailedCustLedgEntry@1006 : Record 379;
      DocumentNo@1005 : Code[20];
    BEGIN
      // Check Payment Discount Entry for Customer after Apply and Unapply Payment with Invoice.
      Amount := CreateAndApplyGenLines(DocumentNo,DocumentType,DocumentType2,Amount);

      // Exercise.
      UnapplyCustLedgerEntry(DocumentType2,DocumentNo);

      // Verify: Verify Detailed Customer Ledger Entry for Payment Discount Amount after Apply and Unapply.
      VerifyInvDetailedLedgerEntry(DocumentNo,DocumentType2,-Amount,DetailedCustLedgEntry."Entry Type"::"Payment Discount");
    END;

    [Test]
    PROCEDURE ChangeDocumentNoUnapplyPayment@67();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check Document No can be change when Unapply Payment from Customer Ledger Entry.
      // Use Random Number Generator for Amount.
      Initialize;
      ChangeDocumentNoAndUnapply(
        GenJournalLine."Document Type"::Invoice,GenJournalLine."Document Type"::Payment,LibraryRandom.RandDec(100,2));
    END;

    [Test]
    PROCEDURE ChangeDocumentNoUnapplyRefund@73();
    VAR
      GenJournalLine@1000 : Record 81;
    BEGIN
      // Check Document No can be change when Unapply Refund from Customer Ledger Entry.
      // Use Random Number Generator for Amount.
      Initialize;
      ChangeDocumentNoAndUnapply(
        GenJournalLine."Document Type"::"Credit Memo",GenJournalLine."Document Type"::Refund,-LibraryRandom.RandDec(100,2));
    END;

    LOCAL PROCEDURE ChangeDocumentNoAndUnapply@66(DocumentType@1001 : Option;DocumentType2@1004 : Option;Amount@1007 : Decimal);
    VAR
      GenJournalLine@1000 : Record 81;
      DetailedCustLedgEntry@1002 : Record 379;
      CustEntryApplyPostedEntries@1006 : Codeunit 226;
      DocumentNo@1003 : Code[20];
    BEGIN
      // Setup: Create and post General Journal Lines, Apply Payment/Refund from Customer Ledger Entry.
      CreateAndPostGenJournalLine(GenJournalLine,DocumentType,DocumentType2,1,Amount);  // Using 1 to create single Payment/Refund line.
      ApplyAndPostCustomerEntry(
        GenJournalLine."Document No.",GenJournalLine."Document No.",-GenJournalLine.Amount,DocumentType,DocumentType2);
      FindDetailedCustLedgerEntry(
        DetailedCustLedgEntry,GenJournalLine."Document No.",DocumentType,DetailedCustLedgEntry."Entry Type"::Application);
      DocumentNo := GenJournalLine."Account No.";

      // Exercise: Change Document No and Unapply Payment/Refund from Customer Ledger Entry.
      CustEntryApplyPostedEntries.PostUnApplyCustomer(
        DetailedCustLedgEntry,GenJournalLine."Account No.",GenJournalLine."Posting Date");

      // Verify: Verify Detailed Customer Ledger Entry with updated Document No exist after Unapply.
      FindDetailedCustLedgerEntry(DetailedCustLedgEntry,DocumentNo,DocumentType,DetailedCustLedgEntry."Entry Type"::Application);
    END;

    [Test]
    [HandlerFunctions(ApplyCustomerEntriesPageHandler)]
    PROCEDURE RemainingAmountOnCustLedgerEntryWithoutCurrency@5();
    VAR
      Customer@1000 : Record 18;
      CustLedgerEntry@1007 : Record 21;
      GenJournalBatch@1006 : Record 232;
      GenJournalLine@1005 : Record 81;
      SalesHeader@1001 : Record 36;
      PostedDocumentNo@1004 : Code[20];
      Amount@1009 : Decimal;
    BEGIN
      // Check Remaining Amount on Customer Ledger Entry after Creating and Posting Sales Invoice without Currency and Apply with Partial Payment.

      // Setup: Create and Post Sales Invoice, Create a Customer Payment and apply it to posted Invoice.
      Initialize;
      LibrarySales.CreateCustomer(Customer);
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Invoice,Customer."No.");
      CreateAndModifySalesLine(SalesHeader,LibraryRandom.RandDec(10,2),LibraryRandom.RandDec(100,2));
      PostedDocumentNo := LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      CreateGeneralJournalLines(
        GenJournalLine,GenJournalBatch,1,SalesHeader."Sell-to Customer No.",GenJournalLine."Document Type"::Payment,0);  // Taken 1 and 0 to create only one General Journal line with zero amount.
      Amount := OpenGeneralJournalPage(GenJournalLine."Document No.",GenJournalLine."Document Type");
      GenJournalLine.FIND;
      GenJournalLine.VALIDATE(Amount,GenJournalLine.Amount + Amount);
      GenJournalLine.MODIFY(TRUE);

      // Exericse.
      LibraryERM.PostGeneralJnlLine(GenJournalLine);

      // Verify: Verify Remaining Amount on Customer Ledger Entry.
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,SalesHeader."Document Type",PostedDocumentNo);
      CustLedgerEntry.CALCFIELDS("Remaining Amount");
      CustLedgerEntry.TESTFIELD("Remaining Amount",Amount);
    END;

    [Test]
    PROCEDURE RemainingAmountOnCustLedgerEntryWithCurrency@14();
    VAR
      CustLedgerEntry@1008 : Record 21;
      GenJournalBatch@1006 : Record 232;
      GenJournalLine@1005 : Record 81;
      SalesHeader@1004 : Record 36;
      PostedDocumentNo@1001 : Code[20];
      Amount@1000 : Decimal;
    BEGIN
      // Check Remaining Amount on Customer Ledger Entry after Creating and Posting Sales Invoice with Currency and Apply with Partial Payment.

      // Setup: Create and Post Sales Invoice with Currency, Create a Customer Payment without Currency and apply it to posted Invoice after modifying Payment Amount.
      Initialize;
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Invoice,CreateCustomerWithCurrency(CreateCurrency));
      ModifyCurrency(SalesHeader."Currency Code",LibraryRandom.RandDec(10,2));  // Taken Random value for Rounding Precision.
      Amount := CreateAndModifySalesLine(SalesHeader,LibraryRandom.RandDec(10,2),LibraryRandom.RandDec(100,2));
      Amount := LibraryERM.ConvertCurrency(Amount,SalesHeader."Currency Code",'',WORKDATE);
      PostedDocumentNo := LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE);
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      CreateGeneralJournalLines(
        GenJournalLine,GenJournalBatch,1,SalesHeader."Sell-to Customer No.",GenJournalLine."Document Type"::Payment,0);  // Taken 1 and 0 to create only one General Journal line with zero amount.
      UpdateGenJournalLine(GenJournalLine,'',PostedDocumentNo,-Amount);

      // Exericse.
      LibraryERM.PostGeneralJnlLine(GenJournalLine);

      // Verify: Verify Remaining Amount on Customer Ledger Entry.
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,SalesHeader."Document Type",PostedDocumentNo);
      CustLedgerEntry.CALCFIELDS("Remaining Amount");
      CustLedgerEntry.TESTFIELD("Remaining Amount",0);  // Taken 0 for Remaining Amount as after application it must be zero due to Currency's Appln. Rounding Precision.
    END;

    [Test]
    PROCEDURE SalesOrderUsingPaymentMethodWithBalanceAccount@81();
    VAR
      Customer@1004 : Record 18;
      CustLedgerEntry@1008 : Record 21;
      SalesHeader@1000 : Record 36;
      SalesLine@1001 : Record 37;
      DocumentNo@1007 : Code[20];
    BEGIN
      // Check General Ledger, Customer Ledger and Detailed Customer ledger entries after Posting Sales Order with Currency and Payment method with a balance account.

      // Setup: Modify General Ledger setup for Appln. Rounding Precision and Create Customer with Currency and with Payment method with a balance account.
      Initialize;
      LibraryERM.SetApplnRoundingPrecision(LibraryRandom.RandDec(10,2));  // Taken Random value for Rounding Precision.
      CreateAndModifyCustomer(Customer,Customer."Application Method"::Manual,FindPaymentMethodWithBalanceAccount);  // Taken Zero value for Currency Application Rounding Precision.

      // Exercise: Create and post Sales Order with Random Quantity and Unit Price.
      DocumentNo :=
        CreateAndPostSalesDocument(
          SalesLine,WORKDATE,Customer."No.",LibraryInventory.CreateItemNo,SalesHeader."Document Type"::Order,
          LibraryRandom.RandDec(10,2),LibraryRandom.RandDec(100,2));

      // Verify: Verify GL, Customer and Detailed Customer ledger entries.
      VerifyEntriesAfterPostingSalesDocument(CustLedgerEntry."Document Type"::Payment,DocumentNo,DocumentNo);
    END;

    [Test]
    PROCEDURE ModifyPaymentMethodCodeInCustLedgEntryClosed@199();
    VAR
      Customer@1004 : Record 18;
      SalesHeader@1000 : Record 36;
      SalesLine@1001 : Record 37;
      DocumentNo@1007 : Code[20];
    BEGIN
      // Setup.
      Initialize;
      CreateAndModifyCustomer(Customer,Customer."Application Method"::Manual,FindPaymentMethodWithBalanceAccount);

      // Exercise: Create and post Sales Order.
      DocumentNo :=
        CreateAndPostSalesDocument(
          SalesLine,WORKDATE,Customer."No.",LibraryInventory.CreateItemNo,SalesHeader."Document Type"::Order,
          LibraryRandom.RandDec(10,2),LibraryRandom.RandDec(100,2));

      // Verify: Try to modify Payment Method Code in Customer Ledger Entry.
      VerifyErrorAfterModifyPaymentMethod(DocumentNo);
    END;

    [Test]
    PROCEDURE SalesDocumentUsingApplicationMethodApplyToOldest@82();
    VAR
      Customer@1006 : Record 18;
      CustLedgerEntry@1005 : Record 21;
      Item@1004 : Record 27;
      PaymentMethod@1008 : Record 289;
      SalesHeader@1003 : Record 36;
      SalesLine@1002 : Record 37;
      DocumentNo@1000 : Code[20];
      DocumentNo2@1007 : Code[20];
    BEGIN
      // Check General Ledger, Customer Ledger and Detailed Customer ledger entries after posting Sales documents with Currency and Apply to Oldest Application Method.

      // Setup: Modify General Ledger setup for Appln. Rounding Precision and Create Customer with Currency and with Apply to Oldest Application Method, Create and post Sales Invoice with Random Quantity and Unit Price.
      Initialize;
      LibraryERM.SetApplnRoundingPrecision(LibraryRandom.RandDec(10,2));  // Taken Random value for Rounding Precision.
      LibraryERM.FindPaymentMethod(PaymentMethod);
      CreateAndModifyCustomer(Customer,Customer."Application Method"::"Apply to Oldest",PaymentMethod.Code);
      ModifyCurrency(Customer."Currency Code",LibraryRandom.RandDec(10,2));  // Taken Random value for Rounding Precision.
      LibraryInventory.CreateItem(Item);
      DocumentNo :=
        CreateAndPostSalesDocument(
          SalesLine,WORKDATE,Customer."No.",Item."No.",SalesHeader."Document Type"::Invoice,
          LibraryRandom.RandDec(10,2),LibraryRandom.RandDec(100,2));

      // Exercise: Create and post Sales Credit Memo.
      DocumentNo2 :=
        CreateAndPostSalesDocument(
          SalesLine,WORKDATE,Customer."No.",Item."No.",SalesHeader."Document Type"::"Credit Memo",
          SalesLine.Quantity,SalesLine."Unit Price");

      // Verify: Verify GL, Customer and Detailed Customer ledger entries.
      VerifyEntriesAfterPostingSalesDocument(CustLedgerEntry."Document Type"::"Credit Memo",DocumentNo,DocumentNo2);
    END;

    [Test]
    [HandlerFunctions(CustomerLedgerEntriesPageHandler,ApplyCustomerEntriesPageHandler)]
    PROCEDURE AmountToApplyAfterApplyToEntryForInvoice@86();
    VAR
      Item@1006 : Record 27;
      GenJournalBatch@1007 : Record 232;
      GenJournalLine@1005 : Record 81;
      SalesHeader@1004 : Record 36;
      SalesLine@1003 : Record 37;
      Customer@1002 : Record 18;
      DocumentNo@1000 : Code[20];
    BEGIN
      // Verify Amount To Apply on Customer Ledger Entries after Invoking Apply Customer Entries for Invoice.

      // Setup: Post Invoice and Payment for Customer.
      Initialize;
      LibrarySales.CreateCustomer(Customer);
      DocumentNo :=
        CreateAndPostSalesDocument(
          SalesLine,WORKDATE,
          Customer."No.",LibraryInventory.CreateItem(Item),SalesHeader."Document Type"::Invoice,
          LibraryRandom.RandDec(10,2),LibraryRandom.RandDec(100,2));
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      CreateGeneralJournalLines(
        GenJournalLine,GenJournalBatch,1,Customer."No.",GenJournalLine."Document Type"::Payment,
        -1 * LibraryRandom.RandDec(100,2));
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
      LibraryVariableStorage.Enqueue(FALSE); // Do not invoke set applies to ID action

      // Exercise: Run Page Customer Ledger Entries to invoke Apply Customer Entries.
      RunCustomerLedgerEntries(Customer."No.",DocumentNo);

      // Verify: Verify Amount To Apply on Customer Ledger Entries for Document Type Invoice.
      VerifyAmountToApplyOnCustomerLedgerEntries(DocumentNo,SalesHeader."Document Type"::Invoice);
    END;

    [Test]
    [HandlerFunctions(CustomerLedgerEntriesPageHandler,ApplyCustomerEntriesPageHandler)]
    PROCEDURE AmountToApplyAfterApplyToEntryForPayment@85();
    VAR
      Item@1006 : Record 27;
      GenJournalBatch@1005 : Record 232;
      GenJournalLine@1004 : Record 81;
      SalesHeader@1003 : Record 36;
      SalesLine@1002 : Record 37;
      Customer@1001 : Record 18;
    BEGIN
      // Verify Amount To Apply on Customer Ledger Entries after Invoking Apply Customer Entries for Payment.

      // Setup: Post Invoice and Payment for Customer.
      Initialize;
      LibrarySales.CreateCustomer(Customer);
      CreateAndPostSalesDocument(
        SalesLine,WORKDATE,Customer."No.",LibraryInventory.CreateItem(Item),SalesHeader."Document Type"::Invoice,
        LibraryRandom.RandDec(10,2),LibraryRandom.RandDec(100,2));
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      CreateGeneralJournalLines(
        GenJournalLine,GenJournalBatch,1,Customer."No.",GenJournalLine."Document Type"::Payment,
        -1 * LibraryRandom.RandDec(100,2));
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
      LibraryVariableStorage.Enqueue(FALSE); // Do not invoke set applies to ID action

      // Exercise: Run Page Customer Ledger Entries to invoke Apply Customer Entries.
      RunCustomerLedgerEntries(Customer."No.",GenJournalLine."Document No.");

      // Verify: Verify Amount To Apply on Customer Ledger Entries for Document Type Payment.
      VerifyAmountToApplyOnCustomerLedgerEntries(GenJournalLine."Document No.",GenJournalLine."Document Type"::Payment);
    END;

    [Test]
    [HandlerFunctions(CustomerLedgerEntriesPageHandler,ApplyAndVerifyCustomerEntriesPageHandler)]
    PROCEDURE AppliedAmountDifferentCurrencies@190();
    VAR
      GenJournalBatch@1007 : Record 232;
      GenJournalLine@1005 : Record 81;
      Customer@1000 : Record 18;
      CurrencyCode@1003 : Code[10];
      ExchangeRateAmount@1001 : Decimal;
      InvoiceAmount@1004 : Decimal;
      PaymentAmount@1008 : Decimal;
    BEGIN
      // Verify Applied Amount on Apply Entries Page when applying entries in different currencies

      // Setup
      Initialize;
      LibrarySales.CreateCustomer(Customer);
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      ExchangeRateAmount := LibraryRandom.RandDecInRange(10,50,2);
      CurrencyCode := LibraryERM.CreateCurrencyWithExchangeRate(WORKDATE,ExchangeRateAmount,ExchangeRateAmount);
      PaymentAmount := LibraryRandom.RandDecInRange(100,1000,2);
      InvoiceAmount := PaymentAmount * LibraryRandom.RandIntInRange(3,5);

      // Exercise
      CreateAndPostGenJnlLineWithCurrency(
        GenJournalLine,GenJournalBatch,GenJournalLine."Document Type"::Invoice,
        Customer."No.",'',InvoiceAmount);
      CreateAndPostGenJnlLineWithCurrency(
        GenJournalLine,GenJournalBatch,GenJournalLine."Document Type"::"Credit Memo",
        Customer."No.",'',-PaymentAmount);
      CreateAndPostGenJnlLineWithCurrency(
        GenJournalLine,GenJournalBatch,GenJournalLine."Document Type"::Payment,
        Customer."No.",CurrencyCode,-PaymentAmount);

      LibraryVariableStorage.Enqueue(PaymentAmount);
      LibraryVariableStorage.Enqueue(InvoiceAmount);
      LibraryVariableStorage.Enqueue(ExchangeRateAmount);

      // Verify: verification in page handler
      RunCustomerLedgerEntries(Customer."No.",GenJournalLine."Document No.");
    END;

    [Test]
    PROCEDURE CheckDiscountValueWithPmtDiscExclVATWithBalAccTypeVAT@107();
    BEGIN
      // To verify that program calculate correct payment discount value in customer ledger entry when Pmt. Disc. Excl. VAT is true while Bal Account Type having VAT.
      Initialize;
      CreateAndPostGenJournalLineWithPmtDiscExclVAT(TRUE,LibraryERM.CreateGLAccountWithSalesSetup);
    END;

    [Test]
    PROCEDURE CheckDiscountValueWithPmtDiscExclVATWithOutBalAccTypeVAT@106();
    BEGIN
      // To verify that program calculate correct payment discount value in customer ledger entry when Pmt. Disc. Excl. VAT is true while Bal Account Type does not having VAT.
      Initialize;
      CreateAndPostGenJournalLineWithPmtDiscExclVAT(TRUE,LibraryERM.CreateGLAccountNo);
    END;

    [Test]
    PROCEDURE CheckDiscountValueWithOutPmtDiscExclVATWithBalAccTypeVAT@102();
    BEGIN
      // To verify that program calculate correct payment discount value in customer ledger entry when Pmt. Disc. Excl. VAT is false while Bal Account Type having VAT.
      Initialize;
      CreateAndPostGenJournalLineWithPmtDiscExclVAT(FALSE,LibraryERM.CreateGLAccountWithSalesSetup);
    END;

    [Test]
    PROCEDURE CheckDiscountValueWithOutPmtDiscExclVATWithOutBalAccTypeVAT@88();
    BEGIN
      // To verify that program calculate correct payment discount value in customer ledger entry when Pmt. Disc. Excl. VAT is false while Bal Account Type does not having VAT.
      Initialize;
      CreateAndPostGenJournalLineWithPmtDiscExclVAT(FALSE,LibraryERM.CreateGLAccountNo);
    END;

    [Test]
    PROCEDURE CheckDiscountValueWithPmtDiscExclVatWithBalVATAmount@87();
    VAR
      Customer@1000 : Record 18;
      GenJournalLine@1001 : Record 81;
      PaymentTerms@1002 : Record 3;
      LibraryPmtDiscSetup@1010 : Codeunit 131303;
      PmtDiscAmount@1005 : Decimal;
    BEGIN
      // To verify that program calculate correct payment discount value in customer ledger entry when Pmt. Disc. Excl. VAT is true while Bal VAT. Amount is not equal to zero.

      // Setup: Create customer and Create Gen Journal Line with Bal Account No.
      Initialize;
      LibraryPmtDiscSetup.SetAdjustForPaymentDisc(FALSE);
      LibraryPmtDiscSetup.SetPmtDiscExclVAT(TRUE);
      CreateCustomerWithPaymentTerm(Customer);

      // Exercise:Create - Post Gen. Journal Line.
      CreatePostGenJnlLineWithBalAccount(GenJournalLine,Customer."No.");

      // Verify: Verify Customer Ledger Entry.
      PaymentTerms.GET(Customer."Payment Terms Code");
      PmtDiscAmount :=
        ROUND((GenJournalLine.Amount + ABS(GenJournalLine."Bal. VAT Amount (LCY)")) * PaymentTerms."Discount %" / 100);
      VerifyDiscountValueInCustomerLedger(GenJournalLine,PmtDiscAmount);
    END;

    [Test]
    PROCEDURE ApplyUnapplySalesInvoicesWithDimVals@89();
    BEGIN
      // Verify that Dimension Set ID and Global Dimension values are correct after unapply of Customer Ledger Entries with different Dimension Set IDs.
      Initialize;
      ApplyUnapplyCustEntriesWithMiscDimSetIDs(LibraryRandom.RandIntInRange(3,10));
    END;

    [Test]
    [HandlerFunctions(ApplyCustomerEntriesPHAndPageControlValuesVerification)]
    PROCEDURE RoundingAndBalanceAmountsOnInvoiceApplication@152();
    VAR
      Customer@1000 : Record 18;
      Currency@1009 : Record 4;
      SalesHeader@1005 : Record 36;
      SalesLine@1004 : Record 37;
      GenJournalLine@1003 : Record 81;
      GenJournalBatch@1006 : Record 232;
      Item@1001 : Record 27;
      LineAmount@1007 : Decimal;
      CurrencyFactor@1002 : Decimal;
      ApplicationRoundingPrecision@1010 : Decimal;
    BEGIN
      // Verify Application Rounding and Balance amounts
      // Setup.
      ApplicationRoundingPrecision := 1;
      LineAmount := 99;
      // prime numbers are required to obtain non-whole number after currency conversion
      CurrencyFactor := 7 / 3;
      LibraryERM.SetApplnRoundingPrecision(ApplicationRoundingPrecision);
      LibraryERM.CreateCurrency(Currency);
      Currency.VALIDATE("Invoice Rounding Precision",0.01);
      Currency.MODIFY(TRUE);
      LibraryERM.CreateExchangeRate(Currency.Code,WORKDATE,CurrencyFactor,CurrencyFactor);
      LibrarySales.CreateCustomer(Customer);
      Customer.VALIDATE("Currency Code",Currency.Code);
      Customer.MODIFY(TRUE);
      SelectGenJournalBatch(GenJournalBatch,FALSE);

      // Excercise
      CreateAndPostSalesDocument(
        SalesLine,WORKDATE,Customer."No.",LibraryInventory.CreateItem(Item),SalesHeader."Document Type"::Invoice,
        1,LineAmount);
      LineAmount := SalesLine."Amount Including VAT";
      CreateGeneralJournalLines(
        GenJournalLine,GenJournalBatch,1,Customer."No.",GenJournalLine."Document Type"::Payment,
        -1 * ROUND(LineAmount / CurrencyFactor,ApplicationRoundingPrecision,'<'));
      GenJournalLine.VALIDATE("Currency Code",'');
      GenJournalLine.MODIFY(TRUE);

      // Verify is done in page handler
      LibraryVariableStorage.Enqueue(ROUND(LineAmount / CurrencyFactor,Currency."Invoice Rounding Precision"));
      LibraryVariableStorage.Enqueue(GenJournalLine.Amount);
      CODEUNIT.RUN(CODEUNIT::"Gen. Jnl.-Apply",GenJournalLine);
    END;

    [Test]
    PROCEDURE SetAppliesToCrMemoDocNoForRefund@117();
    VAR
      Customer@1002 : Record 18;
      GenJnlBatch@1000 : Record 232;
      GenJnlLine@1001 : Record 81;
      CustLedgEntry@1003 : Record 21;
    BEGIN
      // Verify that "Applies To Doc. No." can be validated with "Credit Memo" for Refund journal line.

      // Setup: Post credit memo and create empty refund line without customer and amount.
      Initialize;
      SelectGenJournalBatch(GenJnlBatch,FALSE);
      LibrarySales.CreateCustomer(Customer);
      CreateGeneralJournalLines(
        GenJnlLine,GenJnlBatch,1,Customer."No.",GenJnlLine."Document Type"::"Credit Memo",-LibraryRandom.RandDec(100,2));
      LibraryERM.PostGeneralJnlLine(GenJnlLine);
      LibraryERM.FindCustomerLedgerEntry(
        CustLedgEntry,CustLedgEntry."Document Type"::"Credit Memo",GenJnlLine."Document No.");

      CreateGeneralJournalLines(GenJnlLine,GenJnlBatch,1,'',GenJnlLine."Document Type"::Refund,0);

      // Exercise: Set open Credit Memo No. for "Applies To Doc. No".
      GenJnlLine.VALIDATE("Applies-to Doc. No.",CustLedgEntry."Document No.");
      GenJnlLine.MODIFY(TRUE);

      // Verify: Customer No. and "Applies To Doc. Type" are filled correctly.
      Assert.AreEqual(
        CustLedgEntry."Customer No.",GenJnlLine."Account No.",
        STRSUBSTNO(WrongFieldErr,GenJnlLine.FIELDCAPTION("Account No."),GenJnlLine.TABLECAPTION));
    END;

    [Test]
    PROCEDURE NoVATEntriesWhenUnapplyZeroDiscEntryWithAdjForPmtDisc@90();
    VAR
      SalesLine@1005 : Record 37;
      GenJnlLine@1004 : Record 81;
      CustLedgEntry@1003 : Record 21;
      PostedDocumentNo@1001 : Code[20];
      EmptyDocumentType@1000 : Option;
    BEGIN
      // Verify that no VAT are entries creates when unapplies the entry without discount but with "Adjust For Payment Discount"

      // Setup: Set "Adjust For Payment Discount" option.
      Initialize;
      EmptyDocumentType := 0;
      LibraryPmtDiscSetup.SetAdjustForPaymentDisc(TRUE);

      // Exercise: Find and modify Reverse Charge VAT posting setup with "Adjust For Payment Disc." and post invoice.
      PostedDocumentNo :=
        CreatePostSalesInvWithReverseChargeVATAdjForPmtDisc(SalesLine);
      LibraryERM.FindCustomerLedgerEntry(CustLedgEntry,CustLedgEntry."Document Type"::Invoice,PostedDocumentNo);
      CustLedgEntry.CALCFIELDS("Amount (LCY)");

      // Exercise: Post and apply document with empty type.
      CreateGenJnlLineWithPostingGroups(GenJnlLine,SalesLine."Sell-to Customer No.",
        EmptyDocumentType,-CustLedgEntry."Amount (LCY)",SalesLine);
      GenJnlLine.VALIDATE("Applies-to Doc. Type",GenJnlLine."Applies-to Doc. Type"::Invoice);
      GenJnlLine.VALIDATE("Applies-to Doc. No.",PostedDocumentNo);
      GenJnlLine.MODIFY(TRUE);
      LibraryERM.PostGeneralJnlLine(GenJnlLine);

      // Exericse: Unapply the empty document application.
      LibraryERM.FindCustomerLedgerEntry(CustLedgEntry,EmptyDocumentType,GenJnlLine."Document No.");
      LibraryERM.UnapplyCustomerLedgerEntry(CustLedgEntry);

      // Verify: Make sure that no entries have been created on unapplication.
      VerifyNoVATEntriesOnUnapplication(EmptyDocumentType,GenJnlLine."Document No.");

      // Cleanup: Return back the old value of "Adjust For Payment Discount".
      LibraryPmtDiscSetup.ClearAdjustPmtDiscInVATSetup;
    END;

    [Test]
    [HandlerFunctions(UnapplyCustomerEntriesModalPageHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE ConsistentUnapplyInvoiceToPayment@160();
    VAR
      SalesLine@1001 : Record 37;
      GenJournalLine@1003 : Record 81;
      CustLedgerEntry@1007 : Record 21;
      CustEntryApplyPostedEntries@1011 : Codeunit 226;
      CustomerNo@1009 : Code[20];
      ItemNo@1002 : Code[20];
      AdditionalCurrencyCode@1005 : Code[10];
      ForeignCurrencyCode@1006 : Code[10];
      DocumentNo@1008 : Code[20];
      InvoiceDate@1010 : Date;
    BEGIN
      // [SCENARIO] Apply / Unapply Payment in additional currency to Invoice in foreigh currency with certain exchange rates

      // [GIVEN] No VAT setup, Foreign Currency and Additional Currency.
      Initialize;
      SetupSpecificExchRates(ForeignCurrencyCode,AdditionalCurrencyCode,InvoiceDate);
      CreateCustomerAndItem(CustomerNo,ItemNo,ForeignCurrencyCode);
      LibraryERM.SetAddReportingCurrency(AdditionalCurrencyCode);

      // [GIVEN] Posted Sales Invoice for Customer with foreigh currency
      DocumentNo :=
        CreateAndPostSalesDocument(
          SalesLine,InvoiceDate,CustomerNo,ItemNo,SalesLine."Document Type"::Invoice,1,5000);
      // [GIVEN] Payment in ACY applied to Sales Invoice
      PostApplyPaymentForeignCurrency(
        GenJournalLine,CustomerNo,AdditionalCurrencyCode,-4132.91,
        GenJournalLine."Applies-to Doc. Type"::Invoice,DocumentNo);

      // [WHEN] Invoice unapplied from payment
      LibraryERM.FindCustomerLedgerEntry(
        CustLedgerEntry,CustLedgerEntry."Document Type"::Payment,GenJournalLine."Document No.");
      CustEntryApplyPostedEntries.UnApplyCustLedgEntry(CustLedgerEntry."Entry No."); // cannot repro via LibraryERM.UnapplyCustomerLedgerEntry

      // [THEN] Reversal G/L Entries have zero ACY Amounts
      VerifyACYInGLEntriesOnUnapplication(0,CustLedgerEntry."Document Type"::Payment,GenJournalLine."Document No.");
    END;

    [Test]
    [HandlerFunctions(UnapplyCustomerEntriesModalPageHandler,ConfirmHandler,MessageHandler)]
    PROCEDURE ApplyUnapplySeveralInvAndPmtWithDifferentDimValues@120();
    VAR
      GenJournalBatch@1004 : Record 232;
      GenJournalLine@1003 : Record 81;
      Customer@1011 : Record 18;
      CustLedgEntry@1005 : Record 21;
      GLEntry@1014 : Record 17;
      LibraryPmtDiscSetup@1012 : Codeunit 131303;
      CustEntryApplyPostedEntries@1009 : Codeunit 226;
      InvDimSetIDs@1008 : ARRAY [10] OF Integer;
      PmtDimSetIDs@1010 : ARRAY [10] OF Integer;
      Amounts@1007 : ARRAY [10] OF Decimal;
      DiscountedAmounts@1006 : ARRAY [10] OF Decimal;
      DiscountPercent@1015 : Integer;
      NoOfDocuments@1000 : Integer;
      LastGLEntryNo@1013 : Integer;
      i@1001 : Integer;
    BEGIN
      // [SCENARIO 121881] Verify balance by dimensions = 0 after Apply/Unapply several Payments to Invoices with different dimensions
      Initialize;

      // [GIVEN] Last "G/L Entry" = LastGLEntryNo
      GLEntry.FINDLAST;
      LastGLEntryNo := GLEntry."Entry No.";

      // [GIVEN] Customer with possible discount
      DiscountPercent := LibraryRandom.RandIntInRange(1,10);
      LibraryPmtDiscSetup.SetAdjustForPaymentDisc(TRUE);
      CreateCustomerWithGivenPaymentTerm(Customer,CreatePaymentTermsWithDiscount(DiscountPercent));

      NoOfDocuments := LibraryRandom.RandIntInRange(3,10);
      FOR i := 1 TO NoOfDocuments DO BEGIN
        Amounts[i] := 100 * LibraryRandom.RandIntInRange(1,100);
        DiscountedAmounts[i] := Amounts[i] * (100 - DiscountPercent) / 100;
      END;

      // [GIVEN] Post "N" Invoices with different dimensions "InvDims[i]" and amounts "Amounts[i]"
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      CreatePostGenJnlLinesWithDimSetIDs(
        GenJournalLine,GenJournalBatch,InvDimSetIDs,NoOfDocuments,
        Customer."No.",GenJournalLine."Document Type"::Invoice,Amounts,1);

      // [GIVEN] Create "N" Gen. Journal Lines with different dimensions "PmtDims[i]" and "Document Type" = Payment
      CreateGenJnlLinesWithDimSetIDs(
        GenJournalLine,GenJournalBatch,PmtDimSetIDs,NoOfDocuments,
        Customer."No.",GenJournalLine."Document Type"::Payment,DiscountedAmounts,-1);

      // [GIVEN] Set Gen. Journal Lines "Applies-to ID" and select customer Invoices Ledger Entries
      ApplyCustLedgerEntriesToID(Customer."No.",GenJournalLine."Document No.",DiscountedAmounts);

      // [GIVEN] Post Gen. Journal Lines
      LibraryERM.PostGeneralJnlLine(GenJournalLine);

      // [WHEN] Unapply "N" Invoices Ledger Entries
      FOR i := 1 TO NoOfDocuments DO BEGIN
        FindClosedInvLedgerEntry(CustLedgEntry,Customer."No.");
        CustEntryApplyPostedEntries.UnApplyCustLedgEntry(CustLedgEntry."Entry No.");
      END;

      // [THEN] Count of created "G/L Entries" with "Entry No." > LastGLEntryNo is "N" * (2 (Inv) + 3 (Apply) + 2 (UnApply))
      GLEntry.SETFILTER("Entry No.",'>%1',LastGLEntryNo);
      Assert.AreEqual(NoOfDocuments * (2 + 3 + 2),GLEntry.COUNT,GLEntryCntErr);

      // [THEN] Balance by "InvDims[i]" and "PmtDims[i]" = 0 for the "Entry No." > LastGLEntryNo
      FOR i := 1 TO NoOfDocuments DO BEGIN
        Assert.AreEqual(0,CalcBalanceByDimension(GLEntry,InvDimSetIDs[i]),DimBalanceErr);
        Assert.AreEqual(0,CalcBalanceByDimension(GLEntry,PmtDimSetIDs[i]),DimBalanceErr);
      END;

      // [THEN] Balance by "InvDims[i]" = 0 for the Invoice "G/L Entries" with "Entry No." in [LastGLEntryNo + 1,LastGLEntryNo + 2 * "N"]
      GLEntry.SETRANGE("Entry No.",LastGLEntryNo + 1,LastGLEntryNo + 2 * NoOfDocuments);
      FOR i := 1 TO NoOfDocuments DO
        Assert.AreEqual(0,CalcBalanceByDimension(GLEntry,InvDimSetIDs[i]),DimBalanceErr);

      // [THEN] Balance by "InvDims[i]" = 0, by "PmtDims[i]" = 0 for the Apply "G/L Entries" with "Entry No." in [LastGLEntryNo + 2 * "N" + 1,LastGLEntryNo + (2 + 3) * "N"]
      GLEntry.SETRANGE("Entry No.",LastGLEntryNo + 2 * NoOfDocuments + 1,LastGLEntryNo + (2 + 3) * NoOfDocuments);
      FOR i := 1 TO NoOfDocuments DO BEGIN
        Assert.AreEqual(0,CalcBalanceByDimension(GLEntry,InvDimSetIDs[i]),DimBalanceErr);
        Assert.AreEqual(0,CalcBalanceByDimension(GLEntry,PmtDimSetIDs[i]),DimBalanceErr);
      END;

      // [THEN] Balance by "InvDims[i]" = 0, by "PmtDims[i]" = 0 for the UnApply "G/L Entries" with "Entry No." in [LastGLEntryNo + (2 + 3) * "N" + 1,LastGLEntryNo + (2 + 3 + 2) * "N"]
      GLEntry.SETRANGE("Entry No.",LastGLEntryNo + (2 + 3) * NoOfDocuments + 1,LastGLEntryNo + (2 + 3 + 2) * NoOfDocuments);
      FOR i := 1 TO NoOfDocuments DO BEGIN
        Assert.AreEqual(0,CalcBalanceByDimension(GLEntry,InvDimSetIDs[i]),DimBalanceErr);
        Assert.AreEqual(0,CalcBalanceByDimension(GLEntry,PmtDimSetIDs[i]),DimBalanceErr);
      END;
    END;

    [Test]
    PROCEDURE ApplyPaymentToInvoiceCreditMemoWithPaymentDisc@130();
    VAR
      GenJournalBatch@1007 : Record 232;
      GenJournalLine@1005 : Record 81;
      CustLedgerEntry@1000 : Record 21;
      Amount@1002 : Decimal;
      RemainingAmount@1001 : Decimal;
    BEGIN
      // [FEATURE] [Payment Discount]
      // [SCENARIO 364591] Application of Payment to Invoice and Credit Memo with Payment Discount

      Initialize;
      SelectGenJournalBatch(GenJournalBatch,FALSE);

      // [GIVEN] Posted Sales Invoice with Amount "X", Payment Discount Amount = "D".
      Amount := LibraryRandom.RandDec(1000,2);
      LibraryERM.CreateGeneralJnlLine(
        GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,GenJournalLine."Document Type"::Invoice,
        GenJournalLine."Account Type"::Customer,CreateCustomer,Amount);

      // [GIVEN] Posted Sales Credit Memo with Amount "Y" < "X"
      LibraryERM.CreateGeneralJnlLine(
        GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,GenJournalLine."Document Type"::"Credit Memo",
        GenJournalLine."Account Type"::Customer,GenJournalLine."Account No.",
        -LibraryRandom.RandDecInDecimalRange(1,Amount,2));

      // [GIVEN] Posted Payment with Amount "Z" ("X" - "Y")
      LibraryERM.CreateGeneralJnlLine(
        GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,GenJournalLine."Document Type"::Payment,
        GenJournalLine."Account Type"::Customer,GenJournalLine."Account No.",-Amount - GenJournalLine.Amount);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);

      // [WHEN] Payment is applied to both Invoice and Credit Memo
      ApplyAndPostMultipleCustEntries(GenJournalLine."Document Type"::Payment,GenJournalLine."Document No.",GenJournalLine.Amount);

      CustLedgerEntry.SETRANGE("Customer No.",GenJournalLine."Account No.");

      // [THEN] Customer Ledger Entries for Invoice and Credit Memo are closed and "Remaining Pmt. Disc. Possible" = 0
      VerifyCLEPaymentDisc(CustLedgerEntry,CustLedgerEntry."Document Type"::Invoice,FALSE,0,0);
      RemainingAmount := -CustLedgerEntry."Original Pmt. Disc. Possible";
      VerifyCLEPaymentDisc(CustLedgerEntry,CustLedgerEntry."Document Type"::"Credit Memo",FALSE,0,0);
      // [THEN] Customer Ledger Entries for Payment is Opened. Remaining Amount = "D".
      VerifyCLEPaymentDisc(CustLedgerEntry,CustLedgerEntry."Document Type"::Payment,TRUE,0,RemainingAmount);
    END;

    [Test]
    PROCEDURE ApplyRefundToInvoiceCreditMemoWithPaymentDisc@135();
    VAR
      GenJournalBatch@1007 : Record 232;
      GenJournalLine@1005 : Record 81;
      CustLedgerEntry@1000 : Record 21;
      Amount@1002 : Decimal;
      RemainingAmount@1001 : Decimal;
    BEGIN
      // [FEATURE] [Payment Discount]
      // [SCENARIO 364591] Application of Refund to Credit Memo and Invoice with Payment Discount

      Initialize;
      SelectGenJournalBatch(GenJournalBatch,FALSE);

      // [GIVEN] Posted Sales Credit Memo with Amount "X", Payment Discount Amount = "D".
      Amount := LibraryRandom.RandDec(1000,2);
      LibraryERM.CreateGeneralJnlLine(
        GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,GenJournalLine."Document Type"::"Credit Memo",
        GenJournalLine."Account Type"::Customer,CreateCustomer,-Amount);

      // [GIVEN] Posted Sales Invoice with Amount "Y" < "X"
      LibraryERM.CreateGeneralJnlLine(
        GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,GenJournalLine."Document Type"::Invoice,
        GenJournalLine."Account Type"::Customer,GenJournalLine."Account No.",
        LibraryRandom.RandDecInDecimalRange(1,Amount,2));

      // [GIVEN] Posted Refund with Amount "Z" ("X" - "Y")
      LibraryERM.CreateGeneralJnlLine(
        GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,GenJournalLine."Document Type"::Refund,
        GenJournalLine."Account Type"::Customer,GenJournalLine."Account No.",Amount - GenJournalLine.Amount);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);

      // [WHEN] Refund is applied to both Credit Memo and Invoice
      ApplyAndPostMultipleCustEntries(GenJournalLine."Document Type"::Refund,GenJournalLine."Document No.",GenJournalLine.Amount);

      CustLedgerEntry.SETRANGE("Customer No.",GenJournalLine."Account No.");

      // [THEN] Customer Ledger Entries for Invoice and Credit Memo are closed and "Remaining Pmt. Disc. Possible" = 0
      VerifyCLEPaymentDisc(CustLedgerEntry,CustLedgerEntry."Document Type"::"Credit Memo",FALSE,0,0);
      RemainingAmount := -CustLedgerEntry."Original Pmt. Disc. Possible";
      VerifyCLEPaymentDisc(CustLedgerEntry,CustLedgerEntry."Document Type"::Invoice,FALSE,0,0);
      // [THEN] Customer Ledger Entries for Payment is Opened. Remaining Amount = "D".
      VerifyCLEPaymentDisc(CustLedgerEntry,CustLedgerEntry."Document Type"::Refund,TRUE,0,RemainingAmount);
    END;

    [Test]
    PROCEDURE GetSelectionFilterForCustomerWithSortDescending@15();
    VAR
      Customer@1001 : Record 18;
      SelectionFilterManagement@1000 : Codeunit 46;
      OriginalSelection@1002 : Text;
      ReturnedSelection@1004 : Text;
    BEGIN
      // [FEATURE] [Selection Filter Management]
      // [SCENARIO 379971] When select filter for customers with sort descending, filter must shows selection result
      Initialize;

      // [GIVEN] Customer record with descending order
      Customer.ASCENDING(FALSE);

      // [GIVEN] Customer's filter on "No." field = "1000..1001"
      OriginalSelection := SetFilterForCustomerWithSortDescending(Customer);

      // [WHEN] Call
      ReturnedSelection := SelectionFilterManagement.GetSelectionFilterForCustomer(Customer);

      // [THEN] Return filter = "1000..1001"
      Assert.AreEqual(OriginalSelection,ReturnedSelection,STRSUBSTNO(SelectionFilterErr,OriginalSelection,ReturnedSelection));
    END;

    [Test]
    PROCEDURE GetSelectionFilterForCustomerWithSortAscending@93();
    VAR
      Customer@1001 : Record 18;
      SelectionFilterManagement@1000 : Codeunit 46;
      OriginalSelection@1002 : Text;
      ReturnedSelection@1004 : Text;
    BEGIN
      // [FEATURE] [Selection Filter Management]
      // [SCENARIO 379971] When select filter for customers with sort ascending, filter must shows selection result
      Initialize;

      // [GIVEN] Customer record with ascending order the default

      // [GIVEN] Customer's filter on "No." field = "1000..1001"
      OriginalSelection := SetFilterForCustomerWithSortDescending(Customer);

      // [WHEN] Call
      ReturnedSelection := SelectionFilterManagement.GetSelectionFilterForCustomer(Customer);

      // [THEN] Return filter = "1000..1001"
      Assert.AreEqual(OriginalSelection,ReturnedSelection,STRSUBSTNO(SelectionFilterErr,OriginalSelection,ReturnedSelection));
    END;

    [Test]
    PROCEDURE ErrorMessageOnApplyWithoutAplliesToID@104();
    VAR
      CustLedgerEntry@1006 : Record 21;
      GenJournalBatch@1002 : Record 232;
      GenJournalLine@1003 : Record 81;
      GenJournalTemplate@1001 : Record 80;
      CustEntryApplyPostedEntries@1005 : Codeunit 226;
      Amount@1004 : Decimal;
      CustomerNo@1000 : Code[20];
      DocNo@1008 : Code[20];
    BEGIN
      // [SCENARIO 380040] During application, if there is no "Applies-to ID", then "The application could not be posted, because no entry
      // [SCENARIO] has been selected to be applied / for none of the open entries the "Applies-to ID" has been specfied." error message should appear

      Initialize;

      // [GIVEN] Customer CCC
      CustomerNo := LibrarySales.CreateCustomerNo;

      // [GIVEN] Gen. Journal Batch GJB with two lines
      // [GIVEN] Gen. Journal Line JL1: an invoice for Custmer CCC with "Document No" = 123 and "Amount" = -1000
      LibraryERM.CreateGenJournalTemplate(GenJournalTemplate);
      LibraryERM.CreateGenJournalBatch(GenJournalBatch,GenJournalTemplate.Name);
      Amount := LibraryRandom.RandDec(1000,2);
      LibraryERM.CreateGeneralJnlLineWithBalAcc(
        GenJournalLine,GenJournalTemplate.Name,GenJournalBatch.Name,GenJournalLine."Document Type"::Invoice,
        GenJournalLine."Account Type"::"G/L Account",LibraryERM.CreateGLAccountNo,
        GenJournalLine."Bal. Account Type"::Customer,CustomerNo,-Amount);
      DocNo := GenJournalLine."Document No.";

      // [GIVEN] Gen. Journal Line JL2: a payment for Custmer CCC with "Document No" = 123 (same as JL1) and "Amount" = 1000
      LibraryERM.CreateGeneralJnlLineWithBalAcc(
        GenJournalLine,GenJournalTemplate.Name,GenJournalBatch.Name,GenJournalLine."Document Type"::Payment,
        GenJournalLine."Account Type"::"G/L Account",LibraryERM.CreateGLAccountNo,
        GenJournalLine."Bal. Account Type"::Customer,CustomerNo,Amount);
      GenJournalLine.VALIDATE("Document No.",DocNo);
      GenJournalLine.MODIFY(TRUE);

      // [GIVEN] Batch GJB posted
      LibraryERM.PostGeneralJnlLine(GenJournalLine);

      // [GIVEN] Openned Customer Ledger Entries for Customer CCC, selected Payment JL2 and called action "Apply Entries"
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,CustLedgerEntry."Document Type"::Payment,DocNo);

      // [WHEN] Apply Payment to Invoice
      ASSERTERROR CustEntryApplyPostedEntries.Apply(CustLedgerEntry,DocNo,WORKDATE);

      // [THEN] The following message appears: Cannot post because you did not specify which entry to apply. You must specify an entry in the Applies-to ID field for one or more open entries.
      Assert.ExpectedError(NoEntriesAppliedErr);
    END;

    LOCAL PROCEDURE Initialize@8();
    VAR
      LibraryERMCountryData@1001 : Codeunit 131305;
    BEGIN
      LibrarySetupStorage.Restore;
      LibraryVariableStorage.Clear;

      // Lazy Setup.
      IF isInitialized THEN
        EXIT;

      LibrarySales.SetInvoiceRounding(FALSE);
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateSalesReceivablesSetup;
      LibraryERMCountryData.CreateGeneralPostingSetupData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      LibraryERMCountryData.UpdateAccountInCustomerPostingGroup;
      LibraryERMCountryData.RemoveBlankGenJournalTemplate;
      LibraryERMCountryData.UpdateGeneralLedgerSetup;
      isInitialized := TRUE;
      LibrarySetupStorage.Save(DATABASE::"General Ledger Setup");
      LibrarySetupStorage.Save(DATABASE::"Source Code Setup");
      COMMIT;
    END;

    LOCAL PROCEDURE ApplyAndPostCustomerEntry@7(DocumentNo@1002 : Code[20];DocumentNo2@1005 : Code[20];AmountToApply@1003 : Decimal;DocumentType@1001 : Option;DocumentType2@1006 : Option);
    VAR
      CustLedgerEntry@1000 : Record 21;
      CustLedgerEntry2@1004 : Record 21;
    BEGIN
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,DocumentType,DocumentNo);
      LibraryERM.SetApplyCustomerEntry(CustLedgerEntry,AmountToApply);
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry2,DocumentType2,DocumentNo2);
      CustLedgerEntry2.FINDSET;
      REPEAT
        CustLedgerEntry2.CALCFIELDS("Remaining Amount");
        CustLedgerEntry2.VALIDATE("Amount to Apply",CustLedgerEntry2."Remaining Amount");
        CustLedgerEntry2.MODIFY(TRUE);
      UNTIL CustLedgerEntry2.NEXT = 0;

      LibraryERM.SetAppliestoIdCustomer(CustLedgerEntry2);
      LibraryERM.PostCustLedgerApplication(CustLedgerEntry);
    END;

    LOCAL PROCEDURE CreateAndModifyCustomer@136(VAR Customer@1000 : Record 18;ApplicationMethod@1002 : Option;PaymentMethodCode@1001 : Code[10]);
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      Customer.VALIDATE("Payment Method Code",PaymentMethodCode);
      Customer.VALIDATE("Application Method",ApplicationMethod);
      Customer.VALIDATE("Currency Code",CreateCurrency);
      Customer.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateAndApplyGenLines@62(VAR DocumentNo@1010 : Code[20];DocumentType@1007 : Option;DocumentType2@1008 : Option;Amount@1009 : Decimal) : Decimal;
    VAR
      GenJournalLine@1000 : Record 81;
      GenJournalBatch@1003 : Record 232;
      CustLedgerEntry@1004 : Record 21;
    BEGIN
      // Setup: Create 1 Invoice General Line and Post it.
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      CreateGeneralJournalLines(GenJournalLine,GenJournalBatch,1,CreateCustomer,DocumentType,Amount);
      DocumentNo := GenJournalLine."Document No.";
      LibraryERM.PostGeneralJnlLine(GenJournalLine);

      // Find Discount Amount and Post 1 Payment General Line.
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,DocumentType,GenJournalLine."Document No.");
      CreateGeneralJournalLines(
        GenJournalLine,GenJournalBatch,1,GenJournalLine."Account No.",DocumentType2,
        -GenJournalLine.Amount + CustLedgerEntry."Original Pmt. Disc. Possible");
      LibraryERM.PostGeneralJnlLine(GenJournalLine);

      // Exercise: Apply Posted Entry.
      ApplyAndPostCustomerEntry(GenJournalLine."Document No.",DocumentNo,GenJournalLine.Amount,DocumentType2,DocumentType);
      DocumentNo := GenJournalLine."Document No.";
      EXIT(CustLedgerEntry."Original Pmt. Disc. Possible");
    END;

    LOCAL PROCEDURE CreateAndPostGenJournalLineWithPmtDiscExclVAT@108(PmtDiscExclVAT@1000 : Boolean;GLAccountNo@1001 : Code[20]);
    VAR
      GenJournalLine@1005 : Record 81;
      Customer@1004 : Record 18;
      LibraryPmtDiscSetup@1010 : Codeunit 131303;
    BEGIN
      // Setup:Update Pmt. Disc. Excl. VAT in General Ledger & Create Customer with Payment Terms & Create Gen. Journal Line.
      LibraryPmtDiscSetup.SetAdjustForPaymentDisc(FALSE);
      LibraryPmtDiscSetup.SetPmtDiscExclVAT(PmtDiscExclVAT);
      CreateCustomerWithPaymentTerm(Customer);

      // Exercise:Create - Post Gen. Journal Line.
      CreatePostBalancedGenJnlLines(GenJournalLine,Customer."No.",GLAccountNo);

      // Verify: Verify Customer Ledger Entry.
      VerifyDiscountValueInCustomerLedger(
        GenJournalLine,GetPaymentDiscountAmount(GenJournalLine,GetPaymentTermsDiscount(Customer."Payment Terms Code"),PmtDiscExclVAT));
    END;

    LOCAL PROCEDURE CreatePostSalesAndGenLine@61(VAR GenJournalLine@1001 : Record 81;DocumentType@1006 : Option;DocumentType2@1005 : Option;UnitPrice@1004 : Decimal);
    VAR
      GenJournalBatch@1003 : Record 232;
      SalesLine@1002 : Record 37;
      DocumentNo@1000 : Code[20];
    BEGIN
      // Setup: Create and Post Sales Document and done 1 Payment with Posted Document.
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      DocumentNo :=
        CreateAndPostSalesDocument(
          SalesLine,WORKDATE,LibrarySales.CreateCustomerNo,LibraryInventory.CreateItemNo,DocumentType,
          LibraryRandom.RandInt(100),ABS(UnitPrice));
      CreateGeneralJournalLines(GenJournalLine,GenJournalBatch,1,SalesLine."Sell-to Customer No.",DocumentType2,-UnitPrice);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);

      // Exericse.
      ApplyAndPostCustomerEntry(GenJournalLine."Document No.",DocumentNo,GenJournalLine.Amount,DocumentType2,DocumentType);
    END;

    LOCAL PROCEDURE CreateAndPostSalesDocument@45(VAR SalesLine@1001 : Record 37;PostingDate@1007 : Date;CustomerNo@1003 : Code[20];ItemNo@1004 : Code[20];DocumentType@1002 : Option;Quantity@1005 : Decimal;UnitPrice@1006 : Decimal) : Code[20];
    VAR
      SalesHeader@1000 : Record 36;
    BEGIN
      LibrarySales.CreateSalesHeader(SalesHeader,DocumentType,CustomerNo);
      SalesHeader.VALIDATE("Posting Date",PostingDate);
      SalesHeader.MODIFY(TRUE);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,Quantity);
      SalesLine.VALIDATE("Unit Price",UnitPrice);
      SalesLine.MODIFY(TRUE);
      EXIT(LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE));
    END;

    LOCAL PROCEDURE CreatePostGenJnlLineWithBalAccount@112(VAR GenJournalLine@1001 : Record 81;CustomerNo@1002 : Code[20]);
    VAR
      GenJournalBatch@1000 : Record 232;
    BEGIN
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      CreateGenJnlLine(
        GenJournalLine,GenJournalBatch,GenJournalLine."Account Type"::Customer,CustomerNo,LibraryRandom.RandInt(100));
      GenJournalLine.VALIDATE("Bal. Account No.",LibraryERM.CreateGLAccountWithSalesSetup);
      GenJournalLine.VALIDATE("Sales/Purch. (LCY)",0);
      GenJournalLine.MODIFY(TRUE);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
    END;

    LOCAL PROCEDURE CreatePostBalancedGenJnlLines@129(VAR GenJournalLine@1000 : Record 81;CustomerNo@1002 : Code[20];GLAccountNo@1003 : Code[20]);
    VAR
      GenJournalTemplate@1006 : Record 80;
      GenJournalBatch@1005 : Record 232;
      DocumentNo@1004 : Code[20];
    BEGIN
      LibraryERM.CreateGenJournalTemplate(GenJournalTemplate);
      LibraryERM.CreateGenJournalBatch(GenJournalBatch,GenJournalTemplate.Name);
      CreateGenJnlLine(
        GenJournalLine,GenJournalBatch,GenJournalLine."Account Type"::Customer,CustomerNo,LibraryRandom.RandInt(100));
      DocumentNo := GenJournalLine."Document No.";
      CreateGenJnlLine(GenJournalLine,GenJournalBatch,GenJournalLine."Account Type"::"G/L Account",GLAccountNo,-GenJournalLine.Amount);
      GenJournalLine.VALIDATE("Document No.",DocumentNo);
      GenJournalLine.MODIFY(TRUE);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
    END;

    LOCAL PROCEDURE CreatePostSalesInvWithReverseChargeVATAdjForPmtDisc@133(VAR SalesLine@1000 : Record 37) : Code[20];
    VAR
      GeneralPostingSetup@1002 : Record 252;
      VATPostingSetup@1003 : Record 325;
      SalesHeader@1001 : Record 36;
      ItemNo@1004 : Code[20];
      VendNo@1005 : Code[20];
    BEGIN
      LibraryERM.FindGeneralPostingSetupInvtFull(GeneralPostingSetup);
      LibraryERM.FindVATPostingSetup(VATPostingSetup,VATPostingSetup."VAT Calculation Type"::"Reverse Charge VAT");
      VATPostingSetup.VALIDATE("Adjust for Payment Discount",TRUE);
      VATPostingSetup.MODIFY(TRUE);
      VendNo :=
        CreateCustomerWithPostingSetup(GeneralPostingSetup."Gen. Bus. Posting Group",VATPostingSetup."VAT Bus. Posting Group");
      ItemNo :=
        CreateItemWithPostingSetup(GeneralPostingSetup."Gen. Prod. Posting Group",VATPostingSetup."VAT Prod. Posting Group");
      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Invoice,VendNo);
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,ItemNo,LibraryRandom.RandInt(100));
      SalesLine.VALIDATE("Unit Price",LibraryRandom.RandDec(100,2));
      SalesLine.MODIFY(TRUE);
      EXIT(LibrarySales.PostSalesDocument(SalesHeader,TRUE,TRUE));
    END;

    LOCAL PROCEDURE CreateItemWithPostingSetup@119(GenProdPostingGroup@1002 : Code[10];VATProductPostingGroup@1000 : Code[10]) : Code[20];
    VAR
      Item@1001 : Record 27;
    BEGIN
      LibraryInventory.CreateItem(Item);
      Item.VALIDATE("Gen. Prod. Posting Group",GenProdPostingGroup);
      Item.VALIDATE("VAT Prod. Posting Group",VATProductPostingGroup);
      Item.MODIFY(TRUE);
      EXIT(Item."No.");
    END;

    LOCAL PROCEDURE CreateCurrency@29() : Code[10];
    VAR
      Currency@1007 : Record 4;
    BEGIN
      LibraryERM.CreateCurrency(Currency);
      LibraryERM.SetCurrencyGainLossAccounts(Currency);
      Currency.VALIDATE("Residual Gains Account",Currency."Realized Gains Acc.");
      Currency.VALIDATE("Residual Losses Account",Currency."Realized Losses Acc.");
      Currency.MODIFY(TRUE);
      LibraryERM.CreateRandomExchangeRate(Currency.Code);
      EXIT(Currency.Code);
    END;

    LOCAL PROCEDURE CreateCurrencyAndExchangeRate@181(Rate@1000 : Decimal;RelationalRate@1002 : Decimal;FromDate@1003 : Date) : Code[10];
    VAR
      Currency@1007 : Record 4;
    BEGIN
      LibraryERM.CreateCurrency(Currency);
      LibraryERM.SetCurrencyGainLossAccounts(Currency);
      WITH Currency DO BEGIN
        VALIDATE("Residual Gains Account","Realized Gains Acc.");
        VALIDATE("Residual Losses Account","Realized Losses Acc.");
        MODIFY(TRUE);
        CreateExchangeRate(Code,Rate,RelationalRate,FromDate);
        EXIT(Code);
      END;
    END;

    LOCAL PROCEDURE CreateExchangeRate@182(CurrencyCode@1000 : Code[10];Rate@1001 : Decimal;RelationalRate@1002 : Decimal;FromDate@1004 : Date);
    VAR
      CurrencyExchangeRate@1003 : Record 330;
    BEGIN
      WITH CurrencyExchangeRate DO BEGIN
        LibraryERM.CreateExchRate(CurrencyExchangeRate,CurrencyCode,FromDate);
        VALIDATE("Exchange Rate Amount",Rate);
        VALIDATE("Adjustment Exch. Rate Amount",Rate);
        VALIDATE("Relational Exch. Rate Amount",RelationalRate);
        VALIDATE("Relational Adjmt Exch Rate Amt",RelationalRate);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreateCustomer@54() : Code[20];
    VAR
      Customer@1000 : Record 18;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      Customer.VALIDATE("Payment Terms Code",CreatePaymentTerms);
      Customer.MODIFY(TRUE);
      EXIT(Customer."No.");
    END;

    LOCAL PROCEDURE CreateCustomerWithPostingSetup@134(GenBusPostingGroupCode@1002 : Code[10];VATBusPostingGroupCode@1003 : Code[10]) : Code[20];
    VAR
      Customer@1001 : Record 18;
    BEGIN
      WITH Customer DO BEGIN
        LibrarySales.CreateCustomer(Customer);
        VALIDATE("Gen. Bus. Posting Group",GenBusPostingGroupCode);
        VALIDATE("VAT Bus. Posting Group",VATBusPostingGroupCode);
        MODIFY(TRUE);
        EXIT("No.");
      END;
    END;

    LOCAL PROCEDURE CreateCustomerWithCurrency@72(CurrencyCode@1001 : Code[10]) : Code[20];
    VAR
      Customer@1000 : Record 18;
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      Customer.VALIDATE("Currency Code",CurrencyCode);
      Customer.MODIFY(TRUE);
      EXIT(Customer."No.");
    END;

    LOCAL PROCEDURE CreateBankAccountWithCurrency@183(CurrencyCode@1000 : Code[10]) : Code[20];
    VAR
      BankAccount@1001 : Record 270;
    BEGIN
      LibraryERM.CreateBankAccount(BankAccount);
      WITH BankAccount DO BEGIN
        VALIDATE("Currency Code",CurrencyCode);
        MODIFY;
        EXIT("No.");
      END;
    END;

    LOCAL PROCEDURE CreateCustomerWithPaymentTerm@111(VAR Customer@1000 : Record 18);
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      Customer.VALIDATE("Payment Terms Code",CreatePaymentTermCode);
      Customer.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateGeneralJournalLines@23(VAR GenJournalLine@1007 : Record 81;GenJournalBatch@1001 : Record 232;NoofLines@1005 : Integer;CustomerNo@1002 : Code[20];DocumentType@1000 : Option;Amount@1003 : Decimal);
    VAR
      Counter@1004 : Integer;
    BEGIN
      FOR Counter := 1 TO NoofLines DO
        LibraryERM.CreateGeneralJnlLine(
          GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,DocumentType,
          GenJournalLine."Account Type"::Customer,CustomerNo,Amount);
    END;

    LOCAL PROCEDURE CreateGenJnlLine@132(VAR GenJournalLine@1000 : Record 81;GenJournalBatch@1004 : Record 232;AccountType@1001 : Option;AccountNo@1006 : Code[20];Amount@1005 : Decimal);
    BEGIN
      LibraryERM.CreateGeneralJnlLine(
        GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,GenJournalLine."Document Type"::Invoice,
        AccountType,AccountNo,Amount);
    END;

    LOCAL PROCEDURE CreateAndPostGenJnlLineWithCurrency@97(VAR GenJournalLine@1000 : Record 81;GenJournalBatch@1004 : Record 232;DocumentType@1003 : Option;AccountNo@1006 : Code[20];CurrencyCode@1005 : Code[10];Amount@1002 : Decimal);
    BEGIN
      LibraryERM.CreateGeneralJnlLine(
        GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,DocumentType,
        GenJournalLine."Account Type"::Customer,AccountNo,Amount);
      GenJournalLine.VALIDATE("Currency Code",CurrencyCode);
      GenJournalLine.MODIFY(TRUE);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
    END;

    LOCAL PROCEDURE CreatePaymentTerms@63() : Code[10];
    VAR
      PaymentTerms@1000 : Record 3;
    BEGIN
      // Take Random Values for Payment Terms.
      LibraryERM.CreatePaymentTermsDiscount(PaymentTerms,TRUE);
      EXIT(PaymentTerms.Code);
    END;

    LOCAL PROCEDURE CreateAndPostGenJournalLine@17(VAR GenJournalLine@1001 : Record 81;DocumentType@1006 : Option;DocumentType2@1005 : Option;NoOfLines@1007 : Integer;Amount@1004 : Decimal);
    VAR
      Customer@1000 : Record 18;
      GenJournalBatch@1002 : Record 232;
    BEGIN
      // Create Customer, General Journal Line for 1 Invoice, Credit Memo and more than 1 for Payment, Refund
      // and Random Amount for General Journal Line.
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      LibrarySales.CreateCustomer(Customer);
      CreateGeneralJournalLines(GenJournalLine,GenJournalBatch,1,Customer."No.",DocumentType,Amount);
      CreateGeneralJournalLines(
        GenJournalLine,GenJournalBatch,NoOfLines,GenJournalLine."Account No.",DocumentType2,-GenJournalLine.Amount / NoOfLines);
      LibraryERM.PostGeneralJnlLine(GenJournalLine);
    END;

    LOCAL PROCEDURE CreateAndModifySalesLine@74(SalesHeader@1002 : Record 36;LineQuantity@1001 : Decimal;LinePrice@1004 : Decimal) : Decimal;
    VAR
      Customer@1003 : Record 18;
      SalesLine@1000 : Record 37;
    BEGIN
      // Create Sales line using Random Quantity and Amount.
      Customer.GET(SalesHeader."Sell-to Customer No.");
      LibrarySales.CreateSalesLine(
        SalesLine,SalesHeader,
        SalesLine.Type::"G/L Account",CreateNoVATPostingGLAccount(Customer."VAT Bus. Posting Group"),
        LineQuantity);
      SalesLine.VALIDATE("Unit Price",LinePrice);
      SalesLine.MODIFY(TRUE);
      EXIT(SalesLine."Line Amount");
    END;

    LOCAL PROCEDURE CreateLinesApplyAndUnapply@39(DocumentType@1004 : Option;DocumentType2@1007 : Option;Amount@1008 : Decimal) : Code[20];
    VAR
      GenJournalLine@1001 : Record 81;
      NoOfLines@1000 : Integer;
    BEGIN
      // Setup: Apply and Unapply Posted General Lines for Customer Ledger Entry.
      NoOfLines := 2 * LibraryRandom.RandInt(2);
      CreateAndPostGenJournalLine(GenJournalLine,DocumentType,DocumentType2,NoOfLines,Amount);
      ApplyAndPostCustomerEntry(
        GenJournalLine."Document No.",GenJournalLine."Document No.",-GenJournalLine.Amount,DocumentType,DocumentType2);
      UnapplyCustLedgerEntry(DocumentType,GenJournalLine."Document No.");
      EXIT(GenJournalLine."Document No.");
    END;

    LOCAL PROCEDURE CreateAndUpdateSourceCodeSetup@50(UnappliedSalesEntryAppln@1001 : Code[10]);
    VAR
      SourceCodeSetup@1002 : Record 242;
    BEGIN
      SourceCodeSetup.GET;
      SourceCodeSetup.VALIDATE("Unapplied Sales Entry Appln.",UnappliedSalesEntryAppln);
      SourceCodeSetup.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateNewExchangeRate@53(PostingDate@1000 : Date);
    VAR
      CurrencyExchangeRate@1002 : Record 330;
    BEGIN
      // Use Random Number Generator for Exchange Rate.
      CurrencyExchangeRate.SETRANGE("Currency Code",LibraryERM.GetAddReportingCurrency);
      CurrencyExchangeRate.FINDFIRST;
      LibraryERM.CreateExchRate(CurrencyExchangeRate,LibraryERM.GetAddReportingCurrency,PostingDate);
      CurrencyExchangeRate.VALIDATE("Exchange Rate Amount",LibraryRandom.RandInt(100));
      CurrencyExchangeRate.VALIDATE("Adjustment Exch. Rate Amount",CurrencyExchangeRate."Exchange Rate Amount");
      CurrencyExchangeRate.VALIDATE("Relational Exch. Rate Amount",CurrencyExchangeRate."Exchange Rate Amount");
      CurrencyExchangeRate.VALIDATE("Relational Adjmt Exch Rate Amt",CurrencyExchangeRate."Exchange Rate Amount");
      CurrencyExchangeRate.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE CreateNoVATPostingGLAccount@76(VATBusPostingGroup@1001 : Code[10]) : Code[20];
    VAR
      GLAccount@1000 : Record 15;
      VATPostingSetup@1003 : Record 325;
    BEGIN
      VATPostingSetup."VAT Bus. Posting Group" := VATBusPostingGroup;
      VATPostingSetup."VAT Prod. Posting Group" := FindNoVATPostingSetup(VATBusPostingGroup);
      EXIT(LibraryERM.CreateGLAccountWithVATPostingSetup(VATPostingSetup,GLAccount."Gen. Posting Type"::Sale));
    END;

    LOCAL PROCEDURE CreateCustomerAndItem@184(VAR CustomerNo@1000 : Code[20];VAR ItemNo@1001 : Code[20];ForeignCurrencyCode@1002 : Code[10]);
    VAR
      GeneralPostingSetup@1004 : Record 252;
      VATPostingSetup@1005 : Record 325;
      Customer@1003 : Record 18;
    BEGIN
      LibraryERM.FindGeneralPostingSetupInvtFull(GeneralPostingSetup);
      CreateVATPostingSetup(VATPostingSetup,0);

      ItemNo :=
        CreateItemWithPostingSetup(
          GeneralPostingSetup."Gen. Prod. Posting Group",VATPostingSetup."VAT Prod. Posting Group");
      CustomerNo :=
        CreateCustomerWithPostingSetup(
          GeneralPostingSetup."Gen. Bus. Posting Group",VATPostingSetup."VAT Bus. Posting Group");
      WITH Customer DO BEGIN
        GET(CustomerNo);
        VALIDATE("Currency Code",ForeignCurrencyCode);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE SetupSpecificExchRates@185(VAR ForeignCurrencyCode@1002 : Code[10];VAR AdditionalCurrencyCode@1000 : Code[10];VAR DocumentDate@1001 : Date);
    BEGIN
      DocumentDate := CALCDATE('<-' + FORMAT(LibraryRandom.RandIntInRange(10,20)) + 'D>',WORKDATE);
      ForeignCurrencyCode := CreateCurrencyAndExchangeRate(100,46.0862,DocumentDate);
      AdditionalCurrencyCode := CreateCurrencyAndExchangeRate(100,55.7551,DocumentDate);
      CreateExchangeRate(AdditionalCurrencyCode,100,50,WORKDATE);
    END;

    LOCAL PROCEDURE SetAppliesToIDAndPostEntry@138(VAR CustLedgerEntry@1000 : Record 21;CustLedgerEntry2@1001 : Record 21);
    BEGIN
      LibraryERM.SetAppliestoIdCustomer(CustLedgerEntry);
      LibraryERM.PostCustLedgerApplication(CustLedgerEntry2);
    END;

    LOCAL PROCEDURE SetApplyCustEntry@122(VAR CustLedgerEntry@1000 : Record 21;DocumentType@1001 : Option;DocumentNo@1002 : Code[20];AmountToApply@1003 : Decimal);
    BEGIN
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,DocumentType,DocumentNo);
      LibraryERM.SetApplyCustomerEntry(CustLedgerEntry,AmountToApply);
    END;

    LOCAL PROCEDURE CreateVATPostingSetup@187(VAR VATPostingSetup@1002 : Record 325;VATPercent@1003 : Decimal);
    VAR
      VATBusinessPostingGroup@1000 : Record 323;
      VATProductPostingGroup@1001 : Record 324;
    BEGIN
      LibraryERM.CreateVATBusinessPostingGroup(VATBusinessPostingGroup);
      LibraryERM.CreateVATProductPostingGroup(VATProductPostingGroup);
      LibraryERM.CreateVATPostingSetup(
        VATPostingSetup,VATBusinessPostingGroup.Code,VATProductPostingGroup.Code);
      WITH VATPostingSetup DO BEGIN
        VALIDATE("VAT %",VATPercent);
        VALIDATE("Sales VAT Account",LibraryERM.CreateGLAccountNo);
        VALIDATE("Purchase VAT Account",LibraryERM.CreateGLAccountNo);
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE CreatePaymentTermCode@116() : Code[10];
    VAR
      PaymentTerms@1001 : Record 3;
    BEGIN
      LibraryERM.CreatePaymentTerms(PaymentTerms);
      PaymentTerms.VALIDATE("Discount %",LibraryRandom.RandDec(5,2));
      PaymentTerms.MODIFY(TRUE);
      EXIT(PaymentTerms.Code);
    END;

    LOCAL PROCEDURE FindDetailedCustLedgerEntry@16(VAR DetailedCustLedgEntry@1000 : Record 379;DocumentNo@1001 : Code[20];DocumentType@1002 : Option;EntryType@1003 : Option);
    BEGIN
      DetailedCustLedgEntry.SETRANGE("Entry Type",EntryType);
      DetailedCustLedgEntry.SETRANGE("Document No.",DocumentNo);
      DetailedCustLedgEntry.SETRANGE("Document Type",DocumentType);
      DetailedCustLedgEntry.FINDSET;
    END;

    LOCAL PROCEDURE FindNoVATPostingSetup@77(VATBusPostingGroup@1001 : Code[10]) : Code[10];
    VAR
      VATPostingSetup@1000 : Record 325;
    BEGIN
      WITH VATPostingSetup DO BEGIN
        SETRANGE("VAT %",0);
        SETRANGE("VAT Bus. Posting Group",VATBusPostingGroup);
        SETRANGE("VAT Calculation Type","VAT Calculation Type"::"Normal VAT");
        FINDFIRST;
        IF "Sales VAT Account" = '' THEN
          VALIDATE("Sales VAT Account",LibraryERM.CreateGLAccountNo);
        IF "Purchase VAT Account" = '' THEN
          VALIDATE("Purchase VAT Account",LibraryERM.CreateGLAccountNo);
        MODIFY(TRUE);
        EXIT("VAT Prod. Posting Group");
      END;
    END;

    LOCAL PROCEDURE FindPaymentMethodWithBalanceAccount@98() : Code[10];
    VAR
      PaymentMethod@1001 : Record 289;
    BEGIN
      PaymentMethod.SETFILTER("Bal. Account No.",'<>''''');
      PaymentMethod.FINDFIRST;
      EXIT(PaymentMethod.Code);
    END;

    LOCAL PROCEDURE FindClosedInvLedgerEntry@121(VAR CustLedgerEntry@1000 : Record 21;CustomerNo@1001 : Code[20]);
    BEGIN
      CustLedgerEntry.SETRANGE(Open,FALSE);
      CustLedgerEntry.SETRANGE("Customer No.",CustomerNo);
      CustLedgerEntry.FINDFIRST;
    END;

    LOCAL PROCEDURE GetPaymentDiscountAmount@114(GenJournalLine@1004 : Record 81;DiscountPercentage@1001 : Decimal;PmtDiscExclVAT@1000 : Boolean) : Decimal;
    BEGIN
      IF PmtDiscExclVAT THEN
        EXIT(ROUND(-GenJournalLine."VAT Base Amount" * DiscountPercentage / 100));
      EXIT(ROUND(-GenJournalLine.Amount * DiscountPercentage / 100))
    END;

    LOCAL PROCEDURE GetPaymentTermsDiscount@115(PaymentTermsCode@1001 : Code[10]) : Decimal;
    VAR
      PaymentTerms@1000 : Record 3;
    BEGIN
      PaymentTerms.GET(PaymentTermsCode);
      EXIT(PaymentTerms."Discount %");
    END;

    LOCAL PROCEDURE ModifyCurrency@75(Code@1000 : Code[10];ApplnRoundingPrecision@1002 : Decimal);
    VAR
      Currency@1001 : Record 4;
    BEGIN
      Currency.GET(Code);
      Currency.VALIDATE("Appln. Rounding Precision",ApplnRoundingPrecision);
      Currency.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE OpenGeneralJournalPage@51(DocumentNo@1001 : Code[20];DocumentType@1002 : Option) Amount : Decimal;
    VAR
      GeneralJournal@1000 : TestPage 39;
    BEGIN
      GeneralJournal.OPENEDIT;
      GeneralJournal.FILTER.SETFILTER("Document No.",DocumentNo);
      GeneralJournal.FILTER.SETFILTER("Document Type",FORMAT(DocumentType));
      LibraryVariableStorage.Enqueue(TRUE); // Invoke set applies to ID action
      GeneralJournal."Apply Entries".INVOKE;
      Amount := LibraryRandom.RandDec(10,2);  // Used Random value to make difference in General Journal line Amount.
      GeneralJournal.OK.INVOKE;
    END;

    LOCAL PROCEDURE PostApplyPaymentForeignCurrency@188(VAR GenJournalLine@1000 : Record 81;CustomerNo@1006 : Code[20];CurrencyCode@1001 : Code[10];PaymentAmount@1002 : Decimal;AppliedDocumentType@1003 : Option;AppliedDocumentNo@1004 : Code[20]);
    VAR
      GenJournalBatch@1005 : Record 232;
    BEGIN
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      WITH GenJournalLine DO BEGIN
        CreateGeneralJournalLines(
          GenJournalLine,GenJournalBatch,1,CustomerNo,"Document Type"::Payment,0);
        VALIDATE("Currency Code",CurrencyCode);
        VALIDATE(Amount,PaymentAmount);
        VALIDATE("Applies-to Doc. Type",AppliedDocumentType);
        VALIDATE("Applies-to Doc. No.",AppliedDocumentNo);
        VALIDATE("Bal. Account Type","Bal. Account Type"::"Bank Account");
        VALIDATE("Bal. Account No.",CreateBankAccountWithCurrency(CurrencyCode));
        MODIFY(TRUE);
        LibraryERM.PostGeneralJnlLine(GenJournalLine);
      END;
    END;

    LOCAL PROCEDURE RunCustomerLedgerEntries@94(CustomerNo@1000 : Code[20];DocumentNo@1001 : Code[20]);
    VAR
      CustLedgerEntry@1003 : Record 21;
    BEGIN
      CustLedgerEntry.SETRANGE("Customer No.",CustomerNo);
      CustLedgerEntry.SETRANGE("Document No.",DocumentNo);
      PAGE.RUN(PAGE::"Customer Ledger Entries",CustLedgerEntry);
    END;

    LOCAL PROCEDURE SelectGenJournalBatch@26(VAR GenJournalBatch@1000 : Record 232;SetNoSeries@1001 : Boolean);
    BEGIN
      // Select General Journal Batch and clear General Journal Lines to make sure that no line exits before creating
      // General Journal Lines.
      LibraryERM.SelectGenJnlBatch(GenJournalBatch);
      IF SetNoSeries THEN BEGIN
        GenJournalBatch.VALIDATE("No. Series",LibraryERM.CreateNoSeriesCode);
        GenJournalBatch.MODIFY(TRUE);
      END;
      LibraryERM.ClearGenJournalLines(GenJournalBatch)
    END;

    LOCAL PROCEDURE SetFilterForCustomerWithSortDescending@118(VAR Customer@1000 : Record 18) : Text;
    VAR
      SelectionFilterManagement@1001 : Codeunit 46;
      SelectionString@1002 : Text;
    BEGIN
      SelectionString :=
        SelectionFilterManagement.AddQuotes(LibrarySales.CreateCustomerNo) + '..' +
        SelectionFilterManagement.AddQuotes(LibrarySales.CreateCustomerNo);
      Customer.SETFILTER("No.",SelectionString);
      EXIT(SelectionString);
    END;

    LOCAL PROCEDURE UpdateGenJournalLine@79(VAR GenJournalLine@1000 : Record 81;CurrencyCode@1001 : Code[10];AppliestoDocNo@1002 : Code[20];Amount@1003 : Decimal);
    BEGIN
      GenJournalLine.VALIDATE("Currency Code",CurrencyCode);
      GenJournalLine.VALIDATE("Applies-to Doc. Type",GenJournalLine."Applies-to Doc. Type"::Invoice);
      GenJournalLine.VALIDATE("Applies-to Doc. No.",AppliestoDocNo);
      GenJournalLine.VALIDATE(Amount,Amount + LibraryRandom.RandDec(5,2));  // Modify Amount using Random value.
      GenJournalLine.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UnapplyCustLedgerEntry@20(DocumentType@1001 : Option;DocumentNo@1002 : Code[20]);
    VAR
      CustLedgerEntry@1000 : Record 21;
    BEGIN
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,DocumentType,DocumentNo);
      LibraryERM.UnapplyCustomerLedgerEntry(CustLedgerEntry);
    END;

    LOCAL PROCEDURE CalcBalanceByDimension@144(VAR GLEntry@1001 : Record 17;DimSetID@1000 : Integer) Result : Integer;
    BEGIN
      Result := 0;
      WITH GLEntry DO BEGIN
        SETRANGE("Dimension Set ID",DimSetID);
        IF FINDSET THEN
          REPEAT
            Result += Amount;
          UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE VerifyAmountToApplyOnCustomerLedgerEntries@103(DocumentNo@1001 : Code[20];DocumentType@1002 : Option);
    VAR
      CustLedgerEntry@1003 : Record 21;
    BEGIN
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,DocumentType,DocumentNo);
      CustLedgerEntry.TESTFIELD("Amount to Apply",0);
    END;

    LOCAL PROCEDURE VerifyEntriesAfterPostingSalesDocument@83(DocumentType@1001 : Option;DocumentNo@1002 : Code[20];DocumentNo2@1003 : Code[20]);
    VAR
      CustLedgerEntry@1000 : Record 21;
    BEGIN
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,CustLedgerEntry."Document Type"::Invoice,DocumentNo);
      CustLedgerEntry.TESTFIELD(Open,FALSE);
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,DocumentType,DocumentNo2);
      CustLedgerEntry.TESTFIELD(Open,FALSE);
      VerifyGLEntries(DocumentNo2);
      VerifyDetailedLedgerEntry(DocumentNo2,DocumentType);
    END;

    LOCAL PROCEDURE VerifyErrorAfterModifyPaymentMethod@145(DocumentNo@1000 : Code[20]);
    VAR
      CustLedgerEntry@1001 : Record 21;
    BEGIN
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,CustLedgerEntry."Document Type"::Invoice,DocumentNo);
      ASSERTERROR CustLedgerEntry.VALIDATE("Payment Method Code",'');
      Assert.ExpectedError(
        STRSUBSTNO(PaymentMethodCodeErr,CustLedgerEntry."Entry No."));
    END;

    LOCAL PROCEDURE VerifyInvDetailedLedgerEntry@48(DocumentNo@1003 : Code[20];DocumentType@1004 : Option;Amount@1000 : Decimal;EntryType@1002 : Option);
    VAR
      DetailedCustLedgEntry@1001 : Record 379;
    BEGIN
      FindDetailedCustLedgerEntry(DetailedCustLedgEntry,DocumentNo,DocumentType,EntryType);
      Assert.AreEqual(
        Amount,DetailedCustLedgEntry.Amount,
        STRSUBSTNO(AmountErr,DetailedCustLedgEntry.FIELDCAPTION(Amount),Amount,DetailedCustLedgEntry.TABLECAPTION));
    END;

    LOCAL PROCEDURE VerifyDetailedLedgerEntry@1(DocumentNo@1003 : Code[20];DocumentType@1004 : Option);
    VAR
      DetailedCustLedgEntry@1001 : Record 379;
      TotalAmount@1002 : Decimal;
    BEGIN
      FindDetailedCustLedgerEntry(DetailedCustLedgEntry,DocumentNo,DocumentType,DetailedCustLedgEntry."Entry Type"::Application);
      REPEAT
        TotalAmount += DetailedCustLedgEntry.Amount;
      UNTIL DetailedCustLedgEntry.NEXT = 0;
      Assert.AreEqual(
        0,TotalAmount,
        STRSUBSTNO(
          TotalAmountErr,0,DetailedCustLedgEntry.TABLECAPTION,DetailedCustLedgEntry.FIELDCAPTION("Entry Type"),
          DetailedCustLedgEntry."Entry Type"));
    END;

    LOCAL PROCEDURE VerifyDiscountValueInCustomerLedger@113(GenJournalLine@1001 : Record 81;Amount@1002 : Decimal);
    VAR
      CustLedgerEntry@1004 : Record 21;
    BEGIN
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,GenJournalLine."Document Type"::Invoice,GenJournalLine."Document No.");
      CustLedgerEntry.TESTFIELD("Original Pmt. Disc. Possible",ROUND(Amount));
      CustLedgerEntry.TESTFIELD("Remaining Pmt. Disc. Possible",CustLedgerEntry."Original Pmt. Disc. Possible");
    END;

    LOCAL PROCEDURE VerifyUnappliedDtldLedgEntry@11(DocumentNo@1002 : Code[20];DocumentType@1003 : Option);
    VAR
      DetailedCustLedgEntry@1001 : Record 379;
    BEGIN
      FindDetailedCustLedgerEntry(DetailedCustLedgEntry,DocumentNo,DocumentType,DetailedCustLedgEntry."Entry Type"::Application);
      REPEAT
        Assert.IsTrue(
          DetailedCustLedgEntry.Unapplied,STRSUBSTNO(UnappliedErr,DetailedCustLedgEntry.TABLECAPTION,DetailedCustLedgEntry.Unapplied));
      UNTIL DetailedCustLedgEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyCustLedgerEntryForRemAmt@3(DocumentType@1001 : Option;DocumentNo@1003 : Code[20]);
    VAR
      CustLedgerEntry@1002 : Record 21;
    BEGIN
      LibraryERM.FindCustomerLedgerEntry(CustLedgerEntry,DocumentType,DocumentNo);
      REPEAT
        CustLedgerEntry.CALCFIELDS("Remaining Amount",Amount);
        CustLedgerEntry.TESTFIELD("Remaining Amount",CustLedgerEntry.Amount);
      UNTIL CustLedgerEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifyGLEntries@80(DocumentNo@1002 : Code[20]);
    VAR
      GLEntry@1000 : Record 17;
      TotalAmount@1001 : Decimal;
    BEGIN
      GLEntry.SETRANGE("Document No.",DocumentNo);
      GLEntry.FINDSET;
      REPEAT
        TotalAmount += GLEntry.Amount;
      UNTIL GLEntry.NEXT = 0;
      Assert.AreEqual(
        0,TotalAmount,STRSUBSTNO(TotalAmountErr,0,GLEntry.TABLECAPTION,GLEntry.FIELDCAPTION("Document No."),GLEntry."Document No."));
    END;

    LOCAL PROCEDURE VerifyAddCurrencyAmount@2(DocumentNo@1002 : Code[20]);
    VAR
      GLEntry@1000 : Record 17;
      Currency@1003 : Record 4;
      AddCurrAmt@1005 : Decimal;
    BEGIN
      Currency.GET(LibraryERM.GetAddReportingCurrency);
      Currency.InitRoundingPrecision;
      GLEntry.SETRANGE("Document No.",DocumentNo);
      GLEntry.FINDSET;
      REPEAT
        AddCurrAmt := LibraryERM.ConvertCurrency(GLEntry.Amount,'',Currency.Code,WORKDATE);
        Assert.AreNearlyEqual(
          AddCurrAmt,GLEntry."Additional-Currency Amount",Currency."Amount Rounding Precision",
          STRSUBSTNO(AdditionalCurrencyErr,AddCurrAmt));
      UNTIL GLEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE VerifySourceCodeDtldCustLedger@84(DocumentType@1001 : Option;DocumentNo@1002 : Code[20];SourceCode@1003 : Code[10]);
    VAR
      DetailedCustLedgEntry@1000 : Record 379;
    BEGIN
      DetailedCustLedgEntry.SETRANGE("Document No.",DocumentNo);
      DetailedCustLedgEntry.SETRANGE("Document Type",DocumentType);
      DetailedCustLedgEntry.SETRANGE("Source Code",SourceCode);
      Assert.IsTrue(DetailedCustLedgEntry.FINDFIRST,'Detailed Customer Ledger Entry must found.');
    END;

    LOCAL PROCEDURE VerifyNoVATEntriesOnUnapplication@161(DocType@1000 : Option;DocNo@1001 : Code[20]);
    VAR
      VATEntry@1002 : Record 254;
    BEGIN
      WITH VATEntry DO BEGIN
        SETRANGE("Document Type",DocType);
        SETRANGE("Document No.",DocNo);
        SETRANGE("Transaction No.",GetTransactionNoFromUnappliedDtldEntry(DocType,DocNo));
        Assert.IsTrue(ISEMPTY,UnnecessaryVATEntriesFoundErr);
      END;
    END;

    LOCAL PROCEDURE VerifyACYInGLEntriesOnUnapplication@189(ExpectedACY@1003 : Decimal;DocType@1000 : Option;DocNo@1001 : Code[20]);
    VAR
      GLEntry@1002 : Record 17;
    BEGIN
      WITH GLEntry DO BEGIN
        SETRANGE("Document Type",DocType);
        SETRANGE("Document No.",DocNo);
        SETRANGE("Transaction No.",GetTransactionNoFromUnappliedDtldEntry(DocType,DocNo));
        FINDSET;
        REPEAT
          Assert.AreEqual(ExpectedACY,"Additional-Currency Amount",NonzeroACYErr);
        UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE VerifyCLEPaymentDisc@142(VAR CustLedgerEntry@1000 : Record 21;DocType@1001 : Option;CustLedgEntryIsOpen@1002 : Boolean;RemPaymentDiscPossible@1003 : Decimal;RemainingAmount@1004 : Decimal);
    BEGIN
      WITH CustLedgerEntry DO BEGIN
        SETRANGE("Document Type",DocType);
        FINDFIRST;
        Assert.AreEqual(CustLedgEntryIsOpen,Open,FIELDCAPTION(Open));
        Assert.AreEqual(RemPaymentDiscPossible,"Remaining Pmt. Disc. Possible",FIELDCAPTION("Remaining Pmt. Disc. Possible"));
        CALCFIELDS("Remaining Amount");
        Assert.AreEqual(RemainingAmount,"Remaining Amount",FIELDCAPTION("Remaining Amount"));
      END;
    END;

    LOCAL PROCEDURE ApplyUnapplyCustEntriesWithMiscDimSetIDs@92(NoOfLines@1004 : Integer);
    VAR
      Customer@1005 : Record 18;
      LibraryPmtDiscSetup@1000 : Codeunit 131303;
      DimSetIDs@1002 : ARRAY [10] OF Integer;
      DiscountPercent@1003 : Integer;
      Amounts@1007 : ARRAY [10] OF Decimal;
      DiscountedAmounts@1013 : ARRAY [10] OF Decimal;
      DocNo@1015 : Code[20];
      i@1006 : Integer;
    BEGIN
      // Setup
      LibraryPmtDiscSetup.SetAdjustForPaymentDisc(TRUE);
      DiscountPercent := LibraryRandom.RandIntInRange(1,10);
      CreateCustomerWithGivenPaymentTerm(Customer,CreatePaymentTermsWithDiscount(DiscountPercent));

      FOR i := 1 TO NoOfLines DO BEGIN
        Amounts[i] := 100 * LibraryRandom.RandIntInRange(1,100);
        DiscountedAmounts[i] := Amounts[i] * (100 - DiscountPercent) / 100;
      END;

      // Exercise
      DocNo := ApplyUnapplyWithDimSetIDs(NoOfLines,Customer."No.",DimSetIDs,Amounts,DiscountedAmounts);

      // Exercise and Verify
      FOR i := 1 TO NoOfLines DO
        Amounts[i] -= DiscountedAmounts[i];
      VerifyGLEntriesWithDimSetIDs(DocNo,Amounts,DimSetIDs,NoOfLines);
    END;

    LOCAL PROCEDURE CreateGenJnlLinesWithDimSetIDs@127(VAR GenJournalLine@1007 : Record 81;GenJournalBatch@1006 : Record 232;VAR DimSetIDs@1005 : ARRAY [10] OF Integer;NoOfDocuments@1004 : Integer;CustomerNo@1003 : Code[20];DocumentType@1002 : Option;Amounts@1001 : ARRAY [10] OF Decimal;SignFactor@1000 : Integer);
    VAR
      i@1008 : Integer;
    BEGIN
      FOR i := 1 TO NoOfDocuments DO
        CreateGenJnlLineWithDimSetID(GenJournalLine,GenJournalBatch,DimSetIDs[i],CustomerNo,DocumentType,Amounts[i] * SignFactor);
    END;

    LOCAL PROCEDURE CreatePostGenJnlLinesWithDimSetIDs@123(VAR GenJournalLine@1007 : Record 81;GenJournalBatch@1006 : Record 232;VAR DimSetIDs@1005 : ARRAY [10] OF Integer;NoOfDocuments@1004 : Integer;CustomerNo@1003 : Code[20];DocumentType@1002 : Option;Amounts@1001 : ARRAY [10] OF Decimal;SignFactor@1000 : Integer);
    VAR
      i@1008 : Integer;
    BEGIN
      FOR i := 1 TO NoOfDocuments DO BEGIN
        CreateGenJnlLineWithDimSetID(GenJournalLine,GenJournalBatch,DimSetIDs[i],CustomerNo,DocumentType,Amounts[i] * SignFactor);
        LibraryERM.PostGeneralJnlLine(GenJournalLine);
      END;
    END;

    LOCAL PROCEDURE CreateGenJnlLineWithDimSetID@105(VAR GenJournalLine@1007 : Record 81;GenJournalBatch@1001 : Record 232;VAR DimSetID@1006 : Integer;CustomerNo@1002 : Code[20];DocumentType@1000 : Option;Amount@1003 : Decimal);
    VAR
      DimVal@1010 : Record 349;
      LibraryDimension@1009 : Codeunit 131001;
    BEGIN
      LibraryERM.CreateGeneralJnlLine(
        GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,DocumentType,
        GenJournalLine."Account Type"::Customer,CustomerNo,Amount);
      LibraryDimension.CreateDimensionValue(DimVal,LibraryERM.GetGlobalDimensionCode(1));
      WITH GenJournalLine DO BEGIN
        VALIDATE("Applies-to ID","Document No.");
        VALIDATE("Shortcut Dimension 1 Code",DimVal.Code);
        MODIFY(TRUE);
        DimSetID := "Dimension Set ID";
      END;
    END;

    LOCAL PROCEDURE CreateGenJnlLinesWithGivenDimSetIDs@141(VAR GenJournalLine@1007 : Record 81;GenJournalBatch@1001 : Record 232;DimSetIDs@1006 : ARRAY [10] OF Integer;NoOfLines@1005 : Integer;CustomerNo@1002 : Code[20];DocumentType@1000 : Option;Amounts@1003 : ARRAY [10] OF Decimal);
    VAR
      DimMgt@1012 : Codeunit 408;
      Counter@1008 : Integer;
    BEGIN
      FOR Counter := 1 TO NoOfLines DO BEGIN
        LibraryERM.CreateGeneralJnlLine(
          GenJournalLine,GenJournalBatch."Journal Template Name",GenJournalBatch.Name,DocumentType,
          GenJournalLine."Account Type"::Customer,CustomerNo,-Amounts[Counter]);
        WITH GenJournalLine DO BEGIN
          VALIDATE("Bal. Account No.",'');
          VALIDATE("Applies-to ID","Document No.");
          VALIDATE("Dimension Set ID",DimSetIDs[Counter]);
          DimMgt.UpdateGlobalDimFromDimSetID(
            "Dimension Set ID","Shortcut Dimension 1 Code","Shortcut Dimension 2 Code");
          MODIFY(TRUE);
        END;
      END;
    END;

    LOCAL PROCEDURE CreateGenJnlLineWithPostingGroups@101(VAR GenJnlLine@1004 : Record 81;VendorNo@1002 : Code[20];DocumentType@1001 : Option;Amount@1000 : Decimal;SalesLine@1003 : Record 37);
    VAR
      GenJournalBatch@1005 : Record 232;
    BEGIN
      SelectGenJournalBatch(GenJournalBatch,FALSE);
      CreateGeneralJournalLines(GenJnlLine,GenJournalBatch,1,VendorNo,DocumentType,Amount);
      WITH GenJnlLine DO BEGIN
        VALIDATE("Bal. Gen. Posting Type","Bal. Gen. Posting Type"::Sale);
        VALIDATE("Bal. Gen. Bus. Posting Group",SalesLine."Gen. Bus. Posting Group");
        VALIDATE("Bal. Gen. Prod. Posting Group",SalesLine."Gen. Prod. Posting Group");
        VALIDATE("Bal. VAT Bus. Posting Group",SalesLine."VAT Bus. Posting Group");
        VALIDATE("Bal. VAT Prod. Posting Group",SalesLine."VAT Prod. Posting Group");
        MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE ApplyCustLedgerEntriesToID@95(CustomerNo@1003 : Code[20];AppliesToID@1000 : Code[50];AmountsToApply@1001 : ARRAY [10] OF Decimal);
    VAR
      CustLedgerEntry@1002 : Record 21;
      i@1004 : Integer;
    BEGIN
      WITH CustLedgerEntry DO BEGIN
        SETRANGE("Customer No.",CustomerNo);
        IF FINDSET THEN
          REPEAT
            i += 1;
            VALIDATE("Applying Entry",TRUE);
            VALIDATE("Applies-to ID",AppliesToID);
            VALIDATE("Amount to Apply",AmountsToApply[i]);
            MODIFY(TRUE);
          UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE CreatePaymentTermsWithDiscount@96(DiscountPercent@1001 : Decimal) : Code[10];
    VAR
      PaymentTerms@1000 : Record 3;
    BEGIN
      LibraryERM.CreatePaymentTermsDiscount(PaymentTerms,TRUE);
      PaymentTerms.VALIDATE("Discount %",DiscountPercent);
      PaymentTerms.MODIFY(TRUE);
      EXIT(PaymentTerms.Code);
    END;

    LOCAL PROCEDURE CreateCustomerWithGivenPaymentTerm@99(VAR Customer@1000 : Record 18;PaymentTermsCode@1001 : Code[10]);
    BEGIN
      LibrarySales.CreateCustomer(Customer);
      Customer.VALIDATE("Payment Terms Code",PaymentTermsCode);
      Customer.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE VerifyGLEntriesWithDimSetIDs@124(DocumentNo@1002 : Code[20];Amounts@1003 : ARRAY [10] OF Decimal;DimSetIDs@1004 : ARRAY [10] OF Integer;DimSetArrLen@1001 : Integer);
    VAR
      GLEntry@1000 : Record 17;
      Index@1006 : Integer;
      Sum@1005 : Decimal;
    BEGIN
      WITH GLEntry DO BEGIN
        SETCURRENTKEY("Transaction No.");
        SETRANGE("Document No.",DocumentNo);
        FINDLAST;
        SETRANGE("Transaction No.","Transaction No.");
        Assert.RecordCount(GLEntry,DimSetArrLen + 1);
        FINDSET;
        FOR Index := 1 TO DimSetArrLen DO BEGIN
          Assert.AreEqual(DimSetIDs[1],"Dimension Set ID",FIELDCAPTION("Dimension Set ID"));
          Assert.AreEqual(-Amounts[Index],Amount,FIELDCAPTION(Amount));
          Sum += Amounts[Index];
          NEXT;
        END;
        Assert.AreEqual(DimSetIDs[1],"Dimension Set ID",FIELDCAPTION("Dimension Set ID"));
        Assert.AreEqual(Sum,Amount,FIELDCAPTION(Amount));
      END;
    END;

    LOCAL PROCEDURE GetTransactionNoFromUnappliedDtldEntry@162(DocType@1000 : Option;DocNo@1001 : Code[20]) : Integer;
    VAR
      DtldCustLedgEntry@1002 : Record 379;
    BEGIN
      WITH DtldCustLedgEntry DO BEGIN
        SETRANGE("Document Type",DocType);
        SETRANGE("Document No.",DocNo);
        SETRANGE(Unapplied,TRUE);
        FINDLAST;
        EXIT("Transaction No.");
      END;
    END;

    LOCAL PROCEDURE ApplyUnapplyWithDimSetIDs@100(NoOfLines@1000 : Integer;CustomerNo@1001 : Code[20];VAR DimSetIDs@1002 : ARRAY [10] OF Integer;Amounts@1003 : ARRAY [10] OF Decimal;DiscountedAmounts@1004 : ARRAY [10] OF Decimal) : Code[20];
    VAR
      GenJournalBatch@1005 : Record 232;
      GenJournalLine@1006 : Record 81;
      BankAccount@1009 : Record 270;
      TotalDiscountedAmount@1007 : Decimal;
      i@1008 : Integer;
    BEGIN
      SelectGenJournalBatch(GenJournalBatch,TRUE);
      CreatePostGenJnlLinesWithDimSetIDs(
        GenJournalLine,GenJournalBatch,DimSetIDs,NoOfLines,
        CustomerNo,GenJournalLine."Document Type"::Invoice,Amounts,1);

      CreateGenJnlLinesWithGivenDimSetIDs(
        GenJournalLine,GenJournalBatch,DimSetIDs,NoOfLines,
        CustomerNo,GenJournalLine."Document Type"::Payment,DiscountedAmounts);
      ApplyCustLedgerEntriesToID(CustomerNo,GenJournalLine."Document No.",DiscountedAmounts);

      FOR i := 1 TO NoOfLines DO
        TotalDiscountedAmount += DiscountedAmounts[i];

      CreateGeneralJournalLines(
        GenJournalLine,GenJournalBatch,1,CustomerNo,
        GenJournalLine."Document Type"::Payment,TotalDiscountedAmount);
      BankAccount.SETRANGE(Blocked,FALSE);
      BankAccount.FINDFIRST;
      WITH GenJournalLine DO BEGIN
        VALIDATE("Account Type","Account Type"::"Bank Account");
        VALIDATE("Account No.",BankAccount."No.");
        VALIDATE("Bal. Account No.",'');
        MODIFY(TRUE);
      END;
      LibraryERM.PostGeneralJnlLine(GenJournalLine);

      UnapplyCustLedgerEntry(GenJournalLine."Document Type"::Payment,GenJournalLine."Document No.");
      EXIT(GenJournalLine."Document No.");
    END;

    [ModalPageHandler]
    PROCEDURE ApplyCustomerEntriesPageHandler@71(VAR ApplyCustomerEntries@1000 : TestPage 232);
    VAR
      SetAppliesToIDValue@1002 : Variant;
      SetAppliesToID@1001 : Boolean;
    BEGIN
      LibraryVariableStorage.Dequeue(SetAppliesToIDValue);
      SetAppliesToID := SetAppliesToIDValue;  // Assign Variant to Boolean.
      IF SetAppliesToID THEN
        ApplyCustomerEntries."Set Applies-to ID".INVOKE;
      ApplyCustomerEntries.OK.INVOKE;
    END;

    LOCAL PROCEDURE ApplyAndPostMultipleCustEntries@137(DocumentType@1002 : Option;DocumentNo@1003 : Code[20];AmountToApply@1004 : Decimal);
    VAR
      GLRegister@1005 : Record 45;
      ApplyingCustLedgerEntry@1001 : Record 21;
      CustLedgerEntry@1000 : Record 21;
    BEGIN
      SetApplyCustEntry(ApplyingCustLedgerEntry,DocumentType,DocumentNo,AmountToApply);
      GLRegister.FINDLAST;
      CustLedgerEntry.SETRANGE("Entry No.",GLRegister."From Entry No.",GLRegister."To Entry No.");
      CustLedgerEntry.SETRANGE("Applying Entry",FALSE);
      CustLedgerEntry.FINDSET;
      REPEAT
        CustLedgerEntry.CALCFIELDS("Remaining Amount");
        CustLedgerEntry.VALIDATE("Amount to Apply",CustLedgerEntry."Remaining Amount");
        CustLedgerEntry.MODIFY(TRUE);
      UNTIL CustLedgerEntry.NEXT = 0;
      SetAppliesToIDAndPostEntry(CustLedgerEntry,ApplyingCustLedgerEntry);
    END;

    [ModalPageHandler]
    PROCEDURE ApplyAndVerifyCustomerEntriesPageHandler@131(VAR ApplyCustomerEntries@1000 : TestPage 232);
    VAR
      QueueValue@1003 : Variant;
      PaymentAmount@1008 : Decimal;
      InvoiceAmount@1007 : Decimal;
      ExchangeRate@1006 : Decimal;
    BEGIN
      WITH LibraryVariableStorage DO BEGIN
        Dequeue(QueueValue);
        PaymentAmount := QueueValue;
        Dequeue(QueueValue);
        InvoiceAmount := QueueValue;
        Dequeue(QueueValue);
        ExchangeRate := QueueValue;
      END;

      WITH ApplyCustomerEntries DO BEGIN
        // verify cr. memo entry
        "Set Applies-to ID".INVOKE; // apply entry
        AppliedAmount.ASSERTEQUALS(ROUND(-PaymentAmount * ExchangeRate,LibraryERM.GetAmountRoundingPrecision));
        "Set Applies-to ID".INVOKE; // unapply

        // verify invoice entry
        NEXT;
        "Set Applies-to ID".INVOKE; // apply next entry
        AppliedAmount.ASSERTEQUALS(ROUND(InvoiceAmount * ExchangeRate,LibraryERM.GetAmountRoundingPrecision));

        OK.INVOKE;
      END;
    END;

    [ModalPageHandler]
    PROCEDURE ApplyCustomerEntriesPHAndPageControlValuesVerification@154(VAR ApplyCustomerEntries@1000 : TestPage 232);
    VAR
      Value@1003 : Variant;
      SalesLineAmountLCY@1002 : Decimal;
      JournalLineAmount@1001 : Decimal;
      PageControlValue@1004 : Decimal;
    BEGIN
      LibraryVariableStorage.Dequeue(Value);
      SalesLineAmountLCY := Value;
      LibraryVariableStorage.Dequeue(Value);
      JournalLineAmount := Value;
      ApplyCustomerEntries."Set Applies-to ID".INVOKE;

      EVALUATE(PageControlValue,ApplyCustomerEntries.ApplnRounding.VALUE);
      Assert.AreEqual(
        SalesLineAmountLCY + JournalLineAmount,-PageControlValue,ApplyCustomerEntries.ApplnRounding.CAPTION);

      EVALUATE(PageControlValue,ApplyCustomerEntries.ControlBalance.VALUE);
      Assert.AreEqual(
        0,PageControlValue,ApplyCustomerEntries.ControlBalance.CAPTION);

      ApplyCustomerEntries.OK.INVOKE;
    END;

    [PageHandler]
    PROCEDURE CustomerLedgerEntriesPageHandler@91(VAR CustomerLedgerEntries@1000 : TestPage 25);
    BEGIN
      CustomerLedgerEntries."Apply Entries".INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE UnapplyCustomerEntriesModalPageHandler@200(VAR UnapplyCustomerEntries@1000 : TestPage 623);
    BEGIN
      UnapplyCustomerEntries.Unapply.INVOKE;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@201(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [MessageHandler]
    PROCEDURE MessageHandler@202(Message@1000 : Text[1024]);
    BEGIN
    END;

    BEGIN
    {
      // [FEATURE] [Apply] [Unapply] [Sales]
      Unsupported version tags:
      NA: Unable to Execute
      ES: Unable to Execute

      Test for ERM - Check Additional Currency Amount, Remaining Amount with Apply and Unapply Customer Ledger Entry.
        1. Create Currency, Customer, General Journal 1 Line for Invoice and More than 1 lines for Payment and Post them and Check Customer Ledger Entry for Remaining Amount and G/L Entry for Additional Currency Amount.
        2. Create Currency, Customer, General Journal 1 Line for Invoice and More than 1 lines for Payment and Post them and Check Detailed Customer Ledger Entry for Amount Zero for Entry Type Application and G/L Entry for Additional Currency Amount.
        3. Create Currency, Customer, General Journal 1 Line for Credit Memo and More than 1 lines for Refund and Post them and Check Detailed Customer Ledger Entry for Amount Zero and Unapplied field for Entry Type Application and G/L Entry for
           Additional Currency Amount.
        4. Create Currency, Customer, General Journal 1 Line for Credit Memo and More than 1 lines for Refund and Post them and Check Detailed Customer Ledger Entry for Amount Zero for Entry Type Application and G/L Entry for
           Additional Currency Amount.
        5. Unapply Invoice from Customer Ledger Entry and verify error message.
        6. Unapply Payment from Customer Ledger Entry and verify error message.
        7. Unapply Credit Memo from Customer Ledger Entry and verify error message.
        8. Unapply Refund from Customer Ledger Entry and verify error message.
        9. Unapply Invoice from Detailed Customer Ledger Entry and verify error message.
        10.Unapply Payment from Detailed Customer Ledger Entry and verify error message.
        11.Unapply Credit Memo from Detailed Customer Ledger Entry and verify error message.
        12.Unapply Refund from Detailed Customer Ledger Entry and verify error message.
        13.Unapply Invoice from Customer Ledger Entry and Check that Detailed Ledger Unapplied field is set to TRUE and G/L entry have correct Additional Currency Amount.
        14.Unapply Credit Memo from Customer Ledger Entry and Check that Detailed Ledger Unapplied field is set to TRUE and G/L entry have correct Additional Currency Amount.
        15.Check Unapply Error on Customer Ledger Entry when do the Unapply again on Unapplied Entries.
        16.Check Unapply Error on Customer Ledger Entry when do the Unapply again on Unapplied Entries for Credit Memo.
        17.Check Unapply Error on Detailed Customer Ledger Entry when do the Unapply again on Unapplied Entries.
        18.Check Unapply Error on Detailed Customer Ledger Entry when do the Unapply again on Unapplied Entries for Credit Memo.
        19.Test that correct Source Code updated on Detailed Customer Ledger Entry after Unapply Payment from Customer Ledger Entry.
        20.Test that correct Source Code updated on Detailed Customer Ledger Entry after Unapply Refund from Customer Ledger Entry.
        21.Check that Payment cannot be Unapplied after Exchanged Rate has been changed.
        22.Check that Refund cannot be Unapplied after Exchanged Rate has been changed.
        23.Check Payment Discount Entry for Customer after Apply Payment with Invoice.
        24.Check Payment Discount Entry for Customer after Apply Refund with Credit Memo.
        25.Check Payment Discount Entry for Customer after Apply and Unapply Payment with Invoice.
        26.Check Payment Discount Entry for Customer after Apply and Unapply Refund with Credit Memo.
        27.Check Document No can be change when Unapply Payment from Customer Ledger Entry.
        28.Check Document No can be change when Unapply Refund from Customer Ledger Entry.
        29.Check Remaining Amount on Customer Ledger Entry after Creating and Posting Sales Invoice without Currency and Apply with Partial Payment.
        30.Check Remaining Amount on Customer Ledger Entry after Creating and Posting Sales Invoice with Currency and Apply with Partial Payment.
        31.Check General Ledger, Customer Ledger and Detailed Customer ledger entries after Posting Sales Order with Currency and Payment method with a balance account.
        32.Check General Ledger, Customer Ledger and Detailed Customer ledger entries after posting Sales documents with Currency and Apply to Oldest Application Method.
        33.Verify Amount To Apply on Customer Ledger Entries after Invoking Apply Customer Entries for Invoice.
        34.Verify Amount To Apply on Customer Ledger Entries after Invoking Apply Customer Entries for Payment.
        35.To verify that program calculate correct payment discount value in customer ledger entry when Pmt. Disc. Excl. VAT is true while Bal Account Type having VAT.
        36.To verify that program calculate correct payment discount value in customer ledger entry when Pmt. Disc. Excl. VAT is true while Bal Account Type does not having VAT.
        37 To verify that program calculate correct payment discount value in customer ledger entry when Pmt. Disc. Excl. VAT is false while Bal Account Type having VAT.
        38 To verify that program calculate correct payment discount value in customer ledger entry when Pmt. Disc. Excl. VAT is false while Bal Account Type does not having VAT.
        39 To verify that program calculate correct payment discount value in customer ledger entry when Pmt. Disc. Excl. VAT is true while Bal. VAT Amount (LCY) not equal to zero.
        40 Verify that Dimension Set ID and Global Dimension values are correct after unapply of Customer Ledger Entries with different Dimension Set IDs.
        41 Apply / Unapply Payment in additional currency to Invoice in foreigh currency with certain exchange rates.

      Covers Test Cases for WI - 21564
        ------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                  TFS ID
        ------------------------------------------------------------------------------------------------------------------------
        ApplyUnapplyPayment                                                 5259,5260,5262,5263,5264,5265,5266,5267 and 5268
        ApplyUnapplyAndApplyPayment                                         5259,5260,5261,5262,5263,5264,5265,5266,5267 and 5268
        ApplyUnapplyRefund                                                  5269,5270,5272,5273,5274,5275,5276,5277 and 5278
        ApplyUnapplyApplyRefund                                             5269,5270,5271,5272,5273,5274,5275,5276,5277 and 5278

      Covers Test Cases for WI - 235708
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                  TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        UnapplyInvFromCustLedger                                            126059, 126060
        UnapplyPaymentFromCustLedger                                        126059, 126062
        UnapplyCrMemoFromCustLedger                                         126059, 126066
        UnapplyRefundFromCustLedger                                         126059, 126064
        UnapplyInvFromDtldCustLedger                                        126059, 126061
        UnapplyPaymentDtldCustLedger                                        126059, 126063
        UnapplyCrMemoDtldCustLedger                                         126059, 126067
        UnapplyRefundDtldCustLedger                                         126059, 126065

      Covers Test Cases for WI - 236054
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                  TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        UnapplyInvoiceCustLedger                                             123801
        UnapplyCreditMemoCustLedger                                          123808

      Covers Test Cases for WI - 236799
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                  TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        LedgerEntryInvoiceUnapplyError                                    123783,123784,123788
        LedgerEntryCrMemoUnapplyError                                     123783,123786,123790
        DetldEntryInvoiceUnapplyError                                     123783,123785,123789
        DetldEntryCrMemoUnapplyError                                      123783,123787,123791

      Covers Test Cases for WI - 237098
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                  TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        ApplySalesInvoice                                                  121524,121525,121529
        ApplySalesCreditMemo                                               121524,121527,121531
        ApplyUnapplySalesInvoice                                           121524,121526,121530
        ApplyUnapplySalesCreditMemo                                        121524,121528,121531

      Covers Test Cases for WI - 237579
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                  TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        UnapplyPaymentCheckSourceCode                                       123768, 123770
        UnapplyRefundCheckSourceCode                                        123768, 123771

      Covers Test Cases for WI - 236505
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                  TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        ChangeExchRateUnapplyPayment                                        123747, 123748
        ChangeExchRateUnapplyRefund                                         123747, 123748

      Covers Test Cases for WI - 237099
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                  TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        PaymentDiscApplyInvoice                                           123753,123754
        PaymentDiscApplyCM                                                123753,123755
        PaymentDiscApplyUnapplyInvoice                                    123753,123756
        PaymentDiscApplyUnapplyCM                                         123753,123757

      Covers Test Cases for WI - 237430
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                  TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        ChangeDocumentNoUnapplyPayment                                     123760, 123761
        ChangeDocumentNoUnapplyRefund                                      123760, 123762

      Covers Test Cases for WI - 264911
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                                               TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        RemainingAmountOnCustLedgerEntryWithoutCurrency, RemainingAmountOnCustLedgerEntryWithCurrency     259888

      Covers Test Cases for WI - 268235
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                                                TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        SalesOrderUsingPaymentMethodWithBalanceAccount, SalesDocumentUsingApplicationMethodApplyToOldest      265761,265762

      Covers Test Cases for Bug ID - 326479
        -------------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                                               TFS ID
        -------------------------------------------------------------------------------------------------------------------------
        AmountToApplyAfterApplyToEntryForInvoice,AmountToApplyAfterApplyToEntryForPayment                326480

      BUG ID 330822
      --------------------------------------------------------------------------------------------------------------------
      Test Function Name
      --------------------------------------------------------------------------------------------------------------------
      CheckDiscountValueWithPmtDiscExclVATWithBalAccTypeVAT,CheckDiscountValueWithPmtDiscExclVATWithOutBalAccTypeVAT
      CheckDiscountValueWithOutPmtDiscExclVATWithBalAccTypeVAT,CheckDiscountValueWithOutPmtDiscExclVATWithOutBalAccTypeVAT
      CheckDiscountValueWithPmtDiscExclVatWithBalVATAmount

      BUG ID 46294
      --------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      --------------------------------------------------------------------------------------------------------------------
      ApplyUnapplySalesInvoicesWithDimVals                                                               46294

      Covers Test Cases for RFH - 358519
      -------------------------------------------------------------------------------------------------------------------------
      Test Function Name                                                                                 TFS ID
      -------------------------------------------------------------------------------------------------------------------------
      SetAppliesToCrMemoDocNoForRefund                                                                   358519

      NoVATEntriesWhenUnapplyZeroDiscEntryWithAdjForPmtDisc                                              358839
      AppliedAmountDifferentCurrencies                                                                   358752

      Covers Test Cases for BUG ID 360396
        --------------------------------------------------------------------------------------------------------------------
        Test Function Name                                                                                 TFS ID
        --------------------------------------------------------------------------------------------------------------------
        ConsistentUnapplyInvoiceToPayment                                                                  360396
      AppliedAmountDifferentCurrencies                                                                   103781
    }
    END.
  }
}

