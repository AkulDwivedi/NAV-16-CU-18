OBJECT Codeunit 137006 SCM PAC Output Consumption
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      Assert@1009 : Codeunit 130000;
      LibraryERM@1013 : Codeunit 131300;
      LibraryUtility@1003 : Codeunit 131000;
      LibraryPurchase@1011 : Codeunit 130512;
      LibraryInventory@1012 : Codeunit 132201;
      LibraryManufacturing@1001 : Codeunit 132202;
      LibraryRandom@1010 : Codeunit 130440;
      isInitialized@1000 : Boolean;
      ErrMessageConsumptionMissing@1002 : TextConst 'ENU=The Actual consumption Quantity must be same as Expected Consumption quantity';
      ErrMessagePartialOutput@1006 : TextConst 'ENU=There must be some Output Missing';
      ErrMessageRefreshComponentEql@1004 : TextConst 'ENU=No of Component must be equal';
      ErrMessageRefreshNotEql@1005 : TextConst 'ENU=Number of Component cannot be equal';
      ErrMessageRefreshRoutingEql@1008 : TextConst 'ENU=Number of Routing must be equal';
      ErrMessageRefreshRoutingNotEql@1007 : TextConst 'ENU=Number of Routing cannot be equal';

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler,ConfirmHandler)]
    PROCEDURE StdForwardPostOutput@4();
    VAR
      CapacityUnitOfMeasure@1001 : Record 99000780;
      InventorySetup@1002 : Record 313;
      ItemJournalBatch@1012 : Record 233;
      ManufacturingSetup@1006 : Record 99000765;
      WorkCenterGroup@1000 : Record 99000756;
      Item@1025 : Record 27;
      ProductionBOMHeader@1029 : Record 99000771;
      PurchaseHeader@1033 : Record 38;
      PurchaseLine@1034 : Record 39;
      ProductionOrder@1035 : Record 5405;
      RoutingLink@1016 : Record 99000777;
      CalculateStandardCost@1032 : Codeunit 5812;
      ShopCalendarCode@1038 : Code[10];
      ProductionBOMNo@1027 : Code[20];
      RoutingLinkCode@1014 : Code[10];
      MachineCenterNo@1018 : Code[20];
      WorkCenterNo@1008 : Code[20];
      WorkCenterNo2@1007 : Code[20];
      RoutingNo@1019 : Code[20];
      ItemNo@1024 : Code[20];
      ItemNo2@1023 : Code[20];
      ItemNo3@1022 : Code[20];
      ReleasedProductionOrderNo@1036 : Code[20];
      Type@1030 : ' ,100/Hour,Minutes,Hours,Days';
      FlushingMethod@1015 : 'Manual,Forward,Backward';
      AutomaticCostAdjustment@1005 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1004 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1003 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      UnitCostCalculation@1013 : 'Time,Units';
      Status@1017 : 'Simulated,Planned,Firm Planned,Released,Finished';
      ProdOrderQuantity@1010 : Decimal;
    BEGIN
      // [FEATURE] [Output] [Flushing Method] [Forward]
      // Covers documents TFS_TC_ID 3282 and 11842.
      // Steps describing the sequence of actions for Test Case.

      // 1. Create required setups.
      // Update Manufacturing Setup, Inventory Setup and Update Shop Calendar Working Days based on Work Shift code.
      Initialize;
      LibraryManufacturing.CreateWorkCenterGroup(WorkCenterGroup);
      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,Type::Minutes);
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LibraryManufacturing.UpdateManufacturingSetup(ManufacturingSetup,'','',TRUE,TRUE,TRUE);
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarWorkingDays;

      // Create Work Centers and Machine Center with Flushing method -Manual.
      // Create Routing Link code and Routing.
      CreateWorkCenter(WorkCenterNo,ShopCalendarCode,FlushingMethod::Manual,UnitCostCalculation::Time);
      CreateMachineCenter(MachineCenterNo,WorkCenterNo,FlushingMethod::Manual);
      CreateWorkCenter(WorkCenterNo2,ShopCalendarCode,FlushingMethod::Manual,UnitCostCalculation::Time);
      RoutingLinkCode := CreateRoutingLinkCode(RoutingLink);
      CreateRouting(RoutingNo,MachineCenterNo,WorkCenterNo,WorkCenterNo2,RoutingLinkCode,'',FALSE);

      // Create Items with Flushing method - Forward with the third Item containing Routing No. and Production BOM No.
      // Update Routing link Code on specified BOM component Lines.
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo := Item."No.";
      CLEAR(Item);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo2 := Item."No.";
      CLEAR(Item);
      ProductionBOMNo :=
        LibraryManufacturing.CreateCertifProdBOMWithTwoComp(
          ProductionBOMHeader,ItemNo,ItemNo2,LibraryRandom.RandInt(1));
      UpdateBOMHeader(ProductionBOMNo,ItemNo2,RoutingLinkCode);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,RoutingNo,ProductionBOMNo);
      ItemNo3 := Item."No.";

      // Calculate Standard Cost for third Item.
      // Calculate Calendar for Work Center with dates having a difference of 5 weeks.
      // Create and Post Purchase Order as Receive and Invoice.
      // Create Refresh and Update Planned Production Order.
      CalculateStandardCost.CalcItem(ItemNo3,FALSE);
      CalculateMachCenterCalendar(MachineCenterNo,WorkCenterNo,WorkCenterNo2);
      CreatePurchOrderTwoPurchLine(
        PurchaseHeader,PurchaseLine,ItemNo,ItemNo2,LibraryRandom.RandInt(100) + 10,LibraryRandom.RandInt(100) + 10);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      ProdOrderQuantity := LibraryRandom.RandInt(10);
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Planned,ProductionOrder."Source Type"::Item,ItemNo3,ProdOrderQuantity);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      UpdatePlannedProductionOrder(ProductionOrder."No.");

      // 2.1 Execute : Change Status of Production Order from Planned to Released.
      ReleasedProductionOrderNo := ChangeStatusPlannedToReleased(ProductionOrder."No.");

      // 3.1 Verify Item Ledger Entry : Consumption booked for Item without Routing Link Code.
      VerifyConsumptionQuantity(ReleasedProductionOrderNo,ItemNo,'',Status::Released,FALSE);

      // 2.2 Execute : Create, Calculate and Post Consumption Journal.
      // Create, Explode Routing, Update and Post Output Journal.
      LibraryInventory.CreateItemJournal(
        ItemJournalBatch,ItemNo,ItemJournalBatch."Template Type"::Consumption,ReleasedProductionOrderNo);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);
      LibraryInventory.CreateItemJournal(ItemJournalBatch,ItemNo3,ItemJournalBatch."Template Type"::Output,ReleasedProductionOrderNo);
      UpdateLessQtyOutputJournal(ReleasedProductionOrderNo);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);

      // 3.2 Verify Item Ledger Entry : All Consumption booked.
      VerifyConsumptionQuantity(ReleasedProductionOrderNo,'','',Status::Released,FALSE);

      // 2.3 Execute : Change Status of Production Order from Released to Finished.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ReleasedProductionOrderNo);

      // 3.3 Verify Item Ledger Entry : Partial output.
      VerifyFinishedItemLedgerEntry(ReleasedProductionOrderNo,ItemNo3,ProdOrderQuantity);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler,ConfirmHandler)]
    PROCEDURE StdBackwardPostOutput@14();
    VAR
      CapacityUnitOfMeasure@1001 : Record 99000780;
      InventorySetup@1002 : Record 313;
      ItemJournalBatch@1012 : Record 233;
      ManufacturingSetup@1006 : Record 99000765;
      WorkCenterGroup@1000 : Record 99000756;
      Item@1025 : Record 27;
      ProductionBOMHeader@1029 : Record 99000771;
      PurchaseHeader@1033 : Record 38;
      PurchaseLine@1034 : Record 39;
      ProductionOrder@1035 : Record 5405;
      RoutingLink@1016 : Record 99000777;
      CalculateStandardCost@1032 : Codeunit 5812;
      ShopCalendarCode@1038 : Code[10];
      ProductionBOMNo@1027 : Code[20];
      RoutingLinkCode@1014 : Code[10];
      MachineCenterNo@1018 : Code[20];
      WorkCenterNo@1008 : Code[20];
      WorkCenterNo2@1007 : Code[20];
      RoutingNo@1019 : Code[20];
      ItemNo@1024 : Code[20];
      ItemNo2@1023 : Code[20];
      ItemNo3@1022 : Code[20];
      ProductionOrderNo@1036 : Code[20];
      Type@1030 : ' ,100/Hour,Minutes,Hours,Days';
      FlushingMethod@1015 : 'Manual,Forward,Backward';
      AutomaticCostAdjustment@1005 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1004 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1003 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      UnitCostCalculation@1013 : 'Time,Units';
      Status@1017 : 'Simulated,Planned,Firm Planned,Released,Finished';
      ProductionOrderQuantity@1011 : Decimal;
    BEGIN
      // [FEATURE] [Output] [Flushing Method] [Backward]
      // Covers documents TFS_TC_ID 3283 and 11842.
      // Steps describing the sequence of actions for Test Case.

      // 1. Create required setups.
      // Update Manufacturing Setup, Inventory Setup and Update Shop Calendar Working Days based on Work Shift code.
      Initialize;
      LibraryManufacturing.CreateWorkCenterGroup(WorkCenterGroup);
      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,Type::Minutes);
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LibraryManufacturing.UpdateManufacturingSetup(ManufacturingSetup,'','',TRUE,TRUE,TRUE);
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarWorkingDays;

      // Create Work Centers and Machine Center with Flushing method -Manual.
      // Create Routing Link code and Routing.
      CreateWorkCenter(WorkCenterNo,ShopCalendarCode,FlushingMethod::Manual,UnitCostCalculation::Time);
      CreateMachineCenter(MachineCenterNo,WorkCenterNo,FlushingMethod::Manual);
      CreateWorkCenter(WorkCenterNo2,ShopCalendarCode,FlushingMethod::Manual,UnitCostCalculation::Time);
      RoutingLinkCode := CreateRoutingLinkCode(RoutingLink);
      CreateRouting(RoutingNo,MachineCenterNo,WorkCenterNo,WorkCenterNo2,RoutingLinkCode,'',FALSE);

      // Create Items with Flushing method - Backward with the third Item containing Routing No. and Production BOM No.
      // Update Routing link Code on specified BOM component Lines.
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Backward,'','');
      ItemNo := Item."No.";
      CLEAR(Item);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Backward,'','');
      ItemNo2 := Item."No.";
      CLEAR(Item);
      ProductionBOMNo :=
        LibraryManufacturing.CreateCertifProdBOMWithTwoComp(
          ProductionBOMHeader,ItemNo,ItemNo2,LibraryRandom.RandInt(10));
      UpdateBOMHeader(ProductionBOMNo,ItemNo2,RoutingLinkCode);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Backward,RoutingNo,ProductionBOMNo);
      ItemNo3 := Item."No.";

      // Calculate Standard Cost for third Item.
      // Calculate Calendar for Work Center with dates having a difference of 5 weeks.
      // Create and Post Purchase Order as Receive and Invoice.
      // Create Refresh and Update Planned Production Order.
      CalculateStandardCost.CalcItem(ItemNo3,FALSE);
      CalculateMachCenterCalendar(MachineCenterNo,WorkCenterNo,WorkCenterNo2);
      CreatePurchOrderTwoPurchLine(
        PurchaseHeader,PurchaseLine,ItemNo,ItemNo2,LibraryRandom.RandInt(100) + 10,LibraryRandom.RandInt(100) + 10);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      ProductionOrderQuantity := LibraryRandom.RandInt(10);
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Planned,ProductionOrder."Source Type"::Item,ItemNo3,ProductionOrderQuantity);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      UpdatePlannedProductionOrder(ProductionOrder."No.");

      // 2.1 Execute : Change Status of Production Order from Planned to Released.
      // Create, Explode Routing, Update and Post Output Journal.
      ProductionOrderNo := ChangeStatusPlannedToReleased(ProductionOrder."No.");
      LibraryInventory.CreateItemJournal(ItemJournalBatch,ItemNo3,ItemJournalBatch."Template Type"::Output,ProductionOrderNo);
      UpdateLessQtyOutputJournal(ProductionOrderNo);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);

      // 3.1 Verify Item Ledger Entry : Consumption booked for Item with Routing Link Code.
      VerifyConsumptionQuantity(ProductionOrderNo,ItemNo2,RoutingLinkCode,Status::Released,TRUE);

      // 2.2 Execute : Change Status of Production Order from Released to Finished.
      LibraryManufacturing.ChangeStatusReleasedToFinished(ProductionOrderNo);

      // 3.2 Verify Item Ledger Entry : All Consumption booked with or without Routing Link Code.
      // Verify Item Ledger Entry : Partial output.
      VerifyConsumptionQuantity(ProductionOrderNo,'',RoutingLinkCode,Status::Finished,FALSE);
      VerifyFinishedItemLedgerEntry(ProductionOrderNo,ItemNo3,ProductionOrderQuantity);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler)]
    PROCEDURE StdManualPostConsumption@35();
    VAR
      CapacityUnitOfMeasure@1001 : Record 99000780;
      InventorySetup@1002 : Record 313;
      ItemJournalBatch@1012 : Record 233;
      ManufacturingSetup@1006 : Record 99000765;
      WorkCenterGroup@1000 : Record 99000756;
      Item@1025 : Record 27;
      ProductionBOMHeader@1029 : Record 99000771;
      PurchaseHeader@1033 : Record 38;
      PurchaseLine@1034 : Record 39;
      ProductionOrder@1035 : Record 5405;
      RoutingLink@1016 : Record 99000777;
      CalculateStandardCost@1032 : Codeunit 5812;
      ShopCalendarCode@1038 : Code[10];
      ProductionBOMNo@1027 : Code[20];
      RoutingLinkCode@1014 : Code[10];
      MachineCenterNo@1018 : Code[20];
      WorkCenterNo@1008 : Code[20];
      WorkCenterNo2@1007 : Code[20];
      RoutingNo@1019 : Code[20];
      ItemNo@1024 : Code[20];
      ItemNo2@1023 : Code[20];
      ItemNo3@1022 : Code[20];
      ReleasedProductionOrderNo@1036 : Code[20];
      Type@1030 : ' ,100/Hour,Minutes,Hours,Days';
      FlushingMethod@1015 : 'Manual,Forward,Backward';
      AutomaticCostAdjustment@1005 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1004 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1003 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      UnitCostCalculation@1013 : 'Time,Units';
      Status@1017 : 'Simulated,Planned,Firm Planned,Released,Finished';
      ProductionOrderQuantity@1010 : Decimal;
    BEGIN
      // [FEATURE] [Output] [Flushing Method] [Manual]
      // Covers documents TFS_TC_ID 3284 and 11842.
      // Steps describing the sequence of actions for Test Case.

      // 1. Create required setups.
      // Update Manufacturing Setup, Inventory Setup and Update Shop Calendar Working Days based on Work Shift code.
      Initialize;
      LibraryManufacturing.CreateWorkCenterGroup(WorkCenterGroup);
      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,Type::Minutes);
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LibraryManufacturing.UpdateManufacturingSetup(ManufacturingSetup,'','',TRUE,TRUE,TRUE);
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarWorkingDays;

      // Create Work Centers and Machine Center with Flushing method -Forward.
      // Create Routing Link code and Routing.
      CreateWorkCenter(WorkCenterNo,ShopCalendarCode,FlushingMethod::Forward,UnitCostCalculation::Time);
      CreateMachineCenter(MachineCenterNo,WorkCenterNo,FlushingMethod::Forward);
      CreateWorkCenter(WorkCenterNo2,ShopCalendarCode,FlushingMethod::Forward,UnitCostCalculation::Time);
      RoutingLinkCode := CreateRoutingLinkCode(RoutingLink);
      CreateRouting(RoutingNo,MachineCenterNo,WorkCenterNo,WorkCenterNo2,RoutingLinkCode,'',FALSE);

      // Create Items with Flushing method - Manual with the third Item containing Routing No. and Production BOM No.
      // Update Routing link Code on required BOM component Lines.
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Manual,'','');
      ItemNo := Item."No.";
      CLEAR(Item);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Manual,'','');
      ItemNo2 := Item."No.";
      CLEAR(Item);
      ProductionBOMNo :=
        LibraryManufacturing.CreateCertifProdBOMWithTwoComp(
          ProductionBOMHeader,ItemNo,ItemNo2,LibraryRandom.RandInt(1));
      UpdateBOMHeader(ProductionBOMNo,ItemNo2,RoutingLinkCode);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Manual,
        RoutingNo,ProductionBOMNo);
      ItemNo3 := Item."No.";

      // Calculate Standard Cost for third Item.
      // Calculate Calendar for Work Center with dates having a difference of 5 weeks.
      // Create and Post Purchase Order as Receive and Invoice.
      // Create Refresh and Update Planned Production Order.
      CalculateStandardCost.CalcItem(ItemNo3,FALSE);
      CalculateMachCenterCalendar(MachineCenterNo,WorkCenterNo,WorkCenterNo2);
      CreatePurchOrderTwoPurchLine(
        PurchaseHeader,PurchaseLine,ItemNo,ItemNo2,LibraryRandom.RandInt(100) + 10,LibraryRandom.RandInt(100) + 10);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      ProductionOrderQuantity := LibraryRandom.RandInt(10);
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Planned,ProductionOrder."Source Type"::Item,ItemNo3,ProductionOrderQuantity);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      UpdatePlannedProductionOrder(ProductionOrder."No.");

      // 2. Execute : Change Status of Production Order from Planned to Released.
      // Create, Calculate and Post Consumption Journal,Explode Routing and Post Output Journal.
      ReleasedProductionOrderNo := ChangeStatusPlannedToReleased(ProductionOrder."No.");
      LibraryInventory.CreateItemJournal(
        ItemJournalBatch,ItemNo,ItemJournalBatch."Template Type"::Consumption,ReleasedProductionOrderNo);
      LibraryInventory.PostItemJournalLine(ItemJournalBatch."Journal Template Name",ItemJournalBatch.Name);

      // 3. Verify Item Ledger Entry : All Consumption booked with or without Routing Link Code.
      VerifyConsumptionQuantity(ReleasedProductionOrderNo,'',RoutingLinkCode,Status::Released,FALSE);
    END;

    [Test]
    PROCEDURE StdForwardTwoRoutingLinkCode@31();
    VAR
      CapacityUnitOfMeasure@1001 : Record 99000780;
      InventorySetup@1002 : Record 313;
      ManufacturingSetup@1006 : Record 99000765;
      WorkCenterGroup@1000 : Record 99000756;
      Item@1025 : Record 27;
      ProductionBOMHeader@1029 : Record 99000771;
      ProductionBOMLine@1020 : Record 99000772;
      PurchaseHeader@1033 : Record 38;
      PurchaseLine@1034 : Record 39;
      ProductionOrder@1035 : Record 5405;
      RoutingLink@1016 : Record 99000777;
      CalculateStandardCost@1032 : Codeunit 5812;
      ShopCalendarCode@1038 : Code[10];
      ProductionBOMNo@1027 : Code[20];
      RoutingLinkCode@1014 : Code[10];
      RoutingLinkCode2@1010 : Code[10];
      MachineCenterNo@1018 : Code[20];
      WorkCenterNo@1008 : Code[20];
      WorkCenterNo2@1007 : Code[20];
      RoutingNo@1019 : Code[20];
      ItemNo@1024 : Code[20];
      ItemNo2@1023 : Code[20];
      ItemNo3@1022 : Code[20];
      ItemNo4@1011 : Code[20];
      ReleasedProductionOrderNo@1036 : Code[20];
      Type@1030 : ' ,100/Hour,Minutes,Hours,Days';
      FlushingMethod@1015 : 'Manual,Forward,Backward';
      AutomaticCostAdjustment@1005 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1004 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1003 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      UnitCostCalculation@1013 : 'Time,Units';
      Status@1017 : 'Simulated,Planned,Firm Planned,Released,Finished';
      ProductionOrderQuantity@1012 : Decimal;
    BEGIN
      // [FEATURE] [Output] [Flushing Method] [Forward]
      // Covers documents TFS_TC_ID 3285, 3286 and 11842.
      // Steps describing the sequence of actions for Test Case.

      // 1. Create required setups.
      // Update Manufacturing Setup, Inventory Setup and Update Shop Calendar Working Days based on Work Shift code.
      Initialize;
      LibraryManufacturing.CreateWorkCenterGroup(WorkCenterGroup);
      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,Type::Minutes);
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LibraryManufacturing.UpdateManufacturingSetup(ManufacturingSetup,'','',TRUE,TRUE,TRUE);
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarWorkingDays;

      // Create Work Centers and Machine Center with Flushing method -Backward.
      // Create Routing Link code and Routing.
      CreateWorkCenter(WorkCenterNo,ShopCalendarCode,FlushingMethod::Backward,UnitCostCalculation::Time);
      CreateMachineCenter(MachineCenterNo,WorkCenterNo,FlushingMethod::Backward);
      CreateWorkCenter(WorkCenterNo2,ShopCalendarCode,FlushingMethod::Backward,UnitCostCalculation::Time);
      RoutingLinkCode := CreateRoutingLinkCode(RoutingLink);
      RoutingLinkCode2 := CreateRoutingLinkCode(RoutingLink);
      CreateRouting(RoutingNo,MachineCenterNo,WorkCenterNo,WorkCenterNo2,RoutingLinkCode,RoutingLinkCode2,TRUE);

      // Create Items with Flushing method - Forward with the Fourth Item containing Routing No. and Production BOM No.
      // Update Routing link Code on required BOM component Lines.
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo := Item."No.";
      CLEAR(Item);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo2 := Item."No.";
      CLEAR(Item);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo3 := Item."No.";
      CLEAR(Item);
      ProductionBOMNo :=
        CreateProductionBOM(
          ProductionBOMHeader,ProductionBOMLine,ItemNo,ItemNo2,ItemNo3,LibraryRandom.RandInt(1));
      UpdateBOMHeader(ProductionBOMNo,ItemNo2,RoutingLinkCode);
      UpdateBOMHeader(ProductionBOMNo,ItemNo3,RoutingLinkCode2);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,RoutingNo,ProductionBOMNo);
      ItemNo4 := Item."No.";

      // Calculate Standard Cost for third Item.
      // Calculate Calendar for Work Center with dates having a difference of 5 weeks.
      // Create and Post Purchase Order as Receive and Invoice.
      // Create Refresh and Update Planned Production Order.
      CalculateStandardCost.CalcItem(ItemNo3,FALSE);
      CalculateMachCenterCalendar(MachineCenterNo,WorkCenterNo,WorkCenterNo2);
      CreatePurchOrderThreePurchLine(
        PurchaseHeader,PurchaseLine,ItemNo,ItemNo2,ItemNo3,LibraryRandom.RandInt(100) + 10,
        LibraryRandom.RandInt(100) + 10,LibraryRandom.RandInt(100) + 10);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      ProductionOrderQuantity := LibraryRandom.RandInt(10);
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Planned,ProductionOrder."Source Type"::Item,ItemNo4,ProductionOrderQuantity);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      UpdatePlannedProductionOrder(ProductionOrder."No.");

      // 2. Execute : Change Status of Production Order from Planned to Released.
      ReleasedProductionOrderNo := ChangeStatusPlannedToReleased(ProductionOrder."No.");

      // 3. Verify Item Ledger Entry : All Consumption booked with or without Routing Link Code.
      VerifyConsumptionQuantity(ReleasedProductionOrderNo,'',RoutingLinkCode,Status::Released,FALSE);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler)]
    PROCEDURE RefreshComponentRouting@15();
    VAR
      CapacityUnitOfMeasure@1001 : Record 99000780;
      InventorySetup@1002 : Record 313;
      ManufacturingSetup@1006 : Record 99000765;
      WorkCenterGroup@1000 : Record 99000756;
      Item@1025 : Record 27;
      ProductionBOMHeader@1029 : Record 99000771;
      PurchaseHeader@1033 : Record 38;
      PurchaseLine@1034 : Record 39;
      ProductionOrder@1035 : Record 5405;
      CalculateStandardCost@1032 : Codeunit 5812;
      ShopCalendarCode@1038 : Code[10];
      ProductionBOMNo@1027 : Code[20];
      MachineCenterNo@1018 : Code[20];
      WorkCenterNo@1008 : Code[20];
      WorkCenterNo2@1007 : Code[20];
      RoutingNo@1019 : Code[20];
      ItemNo@1024 : Code[20];
      ItemNo2@1023 : Code[20];
      ItemNo3@1022 : Code[20];
      Type@1013 : ' ,100/Hour,Minutes,Hours,Days';
      FlushingMethod@1012 : 'Manual,Forward,Backward';
      AutomaticCostAdjustment@1010 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1005 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1004 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      UnitCostCalculation@1003 : 'Time,Units';
      CountProductionOrderComponent@1011 : Integer;
      CountProductionOrderRouting@1020 : Integer;
      ProductionOrderQuantity@1014 : Decimal;
    BEGIN
      // [FEATURE] [Component] [Routing]
      // Covers documents TFS_TC_ID 3287, 3288 and 11842.
      // Steps describing the sequence of actions for Test Case.

      // 1. Create required setups.
      // Update Manufacturing Setup, Inventory Setup and Update Shop Calendar Working Days based on Work Shift code.
      Initialize;
      LibraryManufacturing.CreateWorkCenterGroup(WorkCenterGroup);
      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,Type::Minutes);
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LibraryManufacturing.UpdateManufacturingSetup(ManufacturingSetup,'','',TRUE,TRUE,TRUE);
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarWorkingDays;

      // Create Work Centers and Machine Center with Flushing method -Forward.
      // Create Routing Link code and Routing.
      CreateWorkCenter(WorkCenterNo,ShopCalendarCode,FlushingMethod::Forward,UnitCostCalculation::Time);
      CreateMachineCenter(MachineCenterNo,WorkCenterNo,FlushingMethod::Forward);
      CreateWorkCenter(WorkCenterNo2,ShopCalendarCode,FlushingMethod::Forward,UnitCostCalculation::Time);
      CreateRouting(RoutingNo,MachineCenterNo,WorkCenterNo,WorkCenterNo2,'','',FALSE);

      // Create Items with Flushing method - Forward with the third Item containing Routing No. and Production BOM No.
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo := Item."No.";
      CLEAR(Item);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo2 := Item."No.";
      CLEAR(Item);
      ProductionBOMNo :=
        LibraryManufacturing.CreateCertifProdBOMWithTwoComp(
          ProductionBOMHeader,ItemNo,ItemNo2,LibraryRandom.RandInt(10));
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,RoutingNo,ProductionBOMNo);
      ItemNo3 := Item."No.";

      // Calculate Standard Cost for third Item.
      // Calculate Calendar for Work Center with dates having a difference of 5 weeks.
      // Create and Post Purchase Order as Receive and Invoice.
      // Create Refresh and Update Planned Production Order.
      CalculateStandardCost.CalcItem(ItemNo3,FALSE);
      CalculateMachCenterCalendar(MachineCenterNo,WorkCenterNo,WorkCenterNo2);
      CreatePurchOrderTwoPurchLine(
        PurchaseHeader,PurchaseLine,ItemNo,ItemNo2,LibraryRandom.RandInt(100) + 10,LibraryRandom.RandInt(100) + 10);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      ProductionOrderQuantity := LibraryRandom.RandInt(10);
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Planned,ProductionOrder."Source Type"::Item,ItemNo3,ProductionOrderQuantity);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // 2. Execute: Remove Component and Routing from Production Order,Refresh Production Order.
      // Count number of Production order component and Routing.
      RemoveProdOrderComponent(ProductionOrder."No.",ItemNo);
      RemoveProdOrderRoutingLine(ProductionOrder."No.",WorkCenterNo);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);
      CountProductionOrderComponent := CountProductionComponents(ProductionOrder."No.");
      CountProductionOrderRouting := CountProductionRoutingLines(ProductionOrder."No.");

      // 3. Verify : Production Components and Routing Lines.
      VerifyComponentAfterRefresh(ProductionBOMNo,CountProductionOrderComponent,TRUE);
      VerifyRoutingAfterRefresh(RoutingNo,CountProductionOrderRouting,TRUE);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler)]
    PROCEDURE RefreshComponent@25();
    VAR
      CapacityUnitOfMeasure@1001 : Record 99000780;
      InventorySetup@1002 : Record 313;
      ManufacturingSetup@1006 : Record 99000765;
      WorkCenterGroup@1000 : Record 99000756;
      Item@1025 : Record 27;
      ProductionBOMHeader@1029 : Record 99000771;
      PurchaseHeader@1033 : Record 38;
      PurchaseLine@1034 : Record 39;
      ProductionOrder@1035 : Record 5405;
      CalculateStandardCost@1032 : Codeunit 5812;
      ShopCalendarCode@1038 : Code[10];
      ProductionBOMNo@1027 : Code[20];
      MachineCenterNo@1018 : Code[20];
      WorkCenterNo@1008 : Code[20];
      WorkCenterNo2@1007 : Code[20];
      RoutingNo@1019 : Code[20];
      ItemNo@1024 : Code[20];
      ItemNo2@1023 : Code[20];
      ItemNo3@1022 : Code[20];
      Type@1030 : ' ,100/Hour,Minutes,Hours,Days';
      FlushingMethod@1015 : 'Manual,Forward,Backward';
      AutomaticCostAdjustment@1005 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1004 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1003 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      UnitCostCalculation@1013 : 'Time,Units';
      CountProductionOrderComponent@1011 : Integer;
      ProductionOrderQuantity@1012 : Decimal;
    BEGIN
      // [FEATURE] [Component]
      // Covers documents TFS_TC_ID 3282..3288 and 11842.
      // Steps describing the sequence of actions for Test Case.

      // 1. Create required setups.
      // Update Manufacturing Setup, Inventory Setup and Update Shop Calendar Working Days based on Work Shift code.
      Initialize;
      LibraryManufacturing.CreateWorkCenterGroup(WorkCenterGroup);
      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,Type::Minutes);
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LibraryManufacturing.UpdateManufacturingSetup(ManufacturingSetup,'','',TRUE,TRUE,TRUE);
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarWorkingDays;

      // Create Work Centers and Machine Center with Flushing method -Forward.
      // Create Routing Link code and Routing.
      CreateWorkCenter(WorkCenterNo,ShopCalendarCode,FlushingMethod::Forward,UnitCostCalculation::Time);
      CreateMachineCenter(MachineCenterNo,WorkCenterNo,FlushingMethod::Forward);
      CreateWorkCenter(WorkCenterNo2,ShopCalendarCode,FlushingMethod::Forward,UnitCostCalculation::Time);
      CreateRouting(RoutingNo,MachineCenterNo,WorkCenterNo,WorkCenterNo2,'','',FALSE);

      // Create Items with Flushing method - Forward with the third Item containing Routing No. and Production BOM No.
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo := Item."No.";
      CLEAR(Item);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo2 := Item."No.";
      CLEAR(Item);
      ProductionBOMNo :=
        LibraryManufacturing.CreateCertifProdBOMWithTwoComp(
          ProductionBOMHeader,ItemNo,ItemNo2,LibraryRandom.RandInt(1));
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,
        RoutingNo,ProductionBOMNo);
      ItemNo3 := Item."No.";

      // Calculate Standard Cost for third Item.
      // Calculate Calendar for Work Center with dates having a difference of 5 weeks.
      // Create and Post Purchase Order as Receive and Invoice.
      // Create Refresh and Update Planned Production Order.
      CalculateStandardCost.CalcItem(ItemNo3,FALSE);
      CalculateMachCenterCalendar(MachineCenterNo,WorkCenterNo,WorkCenterNo2);
      CreatePurchOrderTwoPurchLine(
        PurchaseHeader,PurchaseLine,ItemNo,ItemNo2,LibraryRandom.RandInt(100) + 10,LibraryRandom.RandInt(100) + 10);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      ProductionOrderQuantity := LibraryRandom.RandInt(10);
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Planned,ProductionOrder."Source Type"::Item,ItemNo3,ProductionOrderQuantity);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // 2. Execute: Remove one Component from Production Order and Refresh Production Order.
      // Count number of Production order component.
      RemoveProdOrderComponent(ProductionOrder."No.",ItemNo);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,FALSE,TRUE,FALSE,FALSE);
      CountProductionOrderComponent := CountProductionComponents(ProductionOrder."No.");

      // 3. Verify : Production Order Components.
      VerifyComponentAfterRefresh(ProductionBOMNo,CountProductionOrderComponent,FALSE);
    END;

    [Test]
    [HandlerFunctions(CalcStdCostMenuHandler)]
    PROCEDURE RefreshRouting@29();
    VAR
      CapacityUnitOfMeasure@1001 : Record 99000780;
      InventorySetup@1002 : Record 313;
      ManufacturingSetup@1006 : Record 99000765;
      WorkCenterGroup@1000 : Record 99000756;
      Item@1025 : Record 27;
      ProductionBOMHeader@1029 : Record 99000771;
      PurchaseHeader@1033 : Record 38;
      PurchaseLine@1034 : Record 39;
      ProductionOrder@1035 : Record 5405;
      CalculateStandardCost@1032 : Codeunit 5812;
      ShopCalendarCode@1038 : Code[10];
      ProductionBOMNo@1027 : Code[20];
      MachineCenterNo@1018 : Code[20];
      WorkCenterNo@1008 : Code[20];
      WorkCenterNo2@1007 : Code[20];
      RoutingNo@1019 : Code[20];
      ItemNo@1024 : Code[20];
      ItemNo2@1023 : Code[20];
      ItemNo3@1022 : Code[20];
      Type@1030 : ' ,100/Hour,Minutes,Hours,Days';
      FlushingMethod@1015 : 'Manual,Forward,Backward';
      AutomaticCostAdjustment@1005 : 'Never,Day,Week,Month,Quarter,Year,Always';
      AverageCostCalcType@1004 : ' ,Item,Item & Location & Variant';
      AverageCostPeriod@1003 : ' ,Day,Week,Month,Quarter,Year,Accounting Period';
      UnitCostCalculation@1013 : 'Time,Units';
      CountProdOrderRouting@1010 : Integer;
      ProductionOrderQuantity@1012 : Decimal;
    BEGIN
      // [FEATURE] [Routing]
      // Covers documents TFS_TC_ID 3282..3288 and 11842.
      // Steps describing the sequence of actions for Test Case.

      // 1. Create required setups.
      // Update Manufacturing Setup, Inventory Setup and Update Shop Calendar Working Days based on Work Shift code.
      Initialize;
      LibraryManufacturing.CreateWorkCenterGroup(WorkCenterGroup);
      LibraryManufacturing.CreateCapacityUnitOfMeasure(CapacityUnitOfMeasure,Type::Minutes);
      LibraryERM.SetUseLegacyGLEntryLocking(TRUE);
      LibraryInventory.UpdateInventorySetup(
        InventorySetup,TRUE,FALSE,AutomaticCostAdjustment::Never,AverageCostCalcType::Item,AverageCostPeriod::Day);
      LibraryManufacturing.UpdateManufacturingSetup(ManufacturingSetup,'','',TRUE,TRUE,TRUE);
      ShopCalendarCode := LibraryManufacturing.UpdateShopCalendarWorkingDays;

      // Create Work Centers and Machine Center with Flushing method -Forward.
      // Create Routing Link code and Routing.
      CreateWorkCenter(WorkCenterNo,ShopCalendarCode,FlushingMethod::Forward,UnitCostCalculation::Time);
      CreateMachineCenter(MachineCenterNo,WorkCenterNo,FlushingMethod::Forward);
      CreateWorkCenter(WorkCenterNo2,ShopCalendarCode,FlushingMethod::Forward,UnitCostCalculation::Time);
      CreateRouting(RoutingNo,MachineCenterNo,WorkCenterNo,WorkCenterNo2,'','',FALSE);

      // Create Items with Flushing method - Forward with the third Item containing Routing No. and Production BOM No.
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo := Item."No.";
      CLEAR(Item);
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,'','');
      ItemNo2 := Item."No.";
      CLEAR(Item);
      ProductionBOMNo :=
        LibraryManufacturing.CreateCertifProdBOMWithTwoComp(
          ProductionBOMHeader,ItemNo,ItemNo2,LibraryRandom.RandInt(1));
      LibraryManufacturing.CreateItemManufacturing(
        Item,Item."Costing Method"::Standard,LibraryRandom.RandInt(10),Item."Reordering Policy"::"Lot-for-Lot",
        FlushingMethod::Forward,RoutingNo,ProductionBOMNo);
      ItemNo3 := Item."No.";

      // Calculate Standard Cost for third Item.
      // Calculate Calendar for Work Center with dates having a difference of 5 weeks.
      // Create and Post Purchase Order as Receive and Invoice.
      // Create Refresh and Update Planned Production Order.
      CalculateStandardCost.CalcItem(ItemNo3,FALSE);
      CalculateMachCenterCalendar(MachineCenterNo,WorkCenterNo,WorkCenterNo2);
      CreatePurchOrderTwoPurchLine(
        PurchaseHeader,PurchaseLine,ItemNo,ItemNo2,LibraryRandom.RandInt(100) + 10,LibraryRandom.RandInt(100) + 10);
      LibraryPurchase.PostPurchaseDocument(PurchaseHeader,TRUE,TRUE);
      ProductionOrderQuantity := LibraryRandom.RandInt(10);
      LibraryManufacturing.CreateProductionOrder(
        ProductionOrder,ProductionOrder.Status::Planned,ProductionOrder."Source Type"::Item,ItemNo3,ProductionOrderQuantity);
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,TRUE,TRUE,TRUE,FALSE);

      // 2. Execute : Remove one Routing from Production Order and Refresh Production Order.
      // Count number of Production order Routing.
      RemoveProdOrderRoutingLine(ProductionOrder."No.",WorkCenterNo);
      UpdateOperationNo(ProductionOrder."No.");
      LibraryManufacturing.RefreshProdOrder(ProductionOrder,FALSE,FALSE,FALSE,TRUE,FALSE);
      CountProdOrderRouting := CountProductionRoutingLines(ProductionOrder."No.");

      // 3. Verify : Production Order Routing Lines.
      VerifyRoutingAfterRefresh(RoutingNo,CountProdOrderRouting,FALSE);
    END;

    LOCAL PROCEDURE Initialize@38();
    VAR
      LibraryERMCountryData@1007 : Codeunit 131305;
    BEGIN
      // Lazy Setup.
      IF isInitialized THEN
        EXIT;

      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;
      isInitialized := TRUE;
      COMMIT;
    END;

    [Normal]
    LOCAL PROCEDURE CreateWorkCenter@1(VAR WorkCenterNo@1005 : Code[20];ShopCalendarCode@1011 : Code[10];FlushingMethod@1004 : Option;UnitCostCalculation@1001 : Option);
    VAR
      WorkCenter@1002 : Record 99000754;
    BEGIN
      // Create Work Center with required fields where Capacity value : 1,  important for test.
      LibraryManufacturing.CreateWorkCenter(WorkCenter);
      WorkCenter.VALIDATE("Flushing Method",FlushingMethod);
      WorkCenter.VALIDATE("Direct Unit Cost",LibraryRandom.RandInt(10));
      WorkCenter.VALIDATE("Indirect Cost %",0);
      WorkCenter.VALIDATE("Overhead Rate",0);
      WorkCenter.VALIDATE(Capacity,1);
      WorkCenter.VALIDATE("Shop Calendar Code",ShopCalendarCode);
      WorkCenter.VALIDATE("Unit Cost Calculation",UnitCostCalculation);
      WorkCenter.MODIFY(TRUE);
      WorkCenterNo := WorkCenter."No.";
    END;

    [Normal]
    LOCAL PROCEDURE CreateMachineCenter@8(VAR MachineCenterNo@1000 : Code[20];WorkCenterNo@1002 : Code[20];FlushingMethod@1004 : Option);
    VAR
      MachineCenter@1001 : Record 99000758;
    BEGIN
      // Create Machine Center with required fields where random is used, random values and other values not important for test.
      LibraryManufacturing.CreateMachineCenter(MachineCenter,WorkCenterNo,LibraryRandom.RandInt(10));
      MachineCenter.VALIDATE(Name,MachineCenter."No.");
      MachineCenter.VALIDATE("Direct Unit Cost",0);
      MachineCenter.VALIDATE("Indirect Cost %",0);
      MachineCenter.VALIDATE("Overhead Rate",1);
      MachineCenter.VALIDATE("Flushing Method",FlushingMethod);
      MachineCenter.VALIDATE(Efficiency,100); // Value important to test
      MachineCenter.MODIFY(TRUE);
      MachineCenterNo := MachineCenter."No.";
    END;

    [Normal]
    LOCAL PROCEDURE CreateRoutingLinkCode@2(VAR RoutingLink@1000 : Record 99000777) : Code[10];
    BEGIN
      // Create Routing Link Code.
      RoutingLink.INIT;
      RoutingLink.VALIDATE(
        Code,LibraryUtility.GenerateRandomCode(RoutingLink.FIELDNO(Code),DATABASE::"Routing Link"));
      RoutingLink.INSERT(TRUE);
      RoutingLink.VALIDATE(Description,RoutingLink.Code);
      RoutingLink.MODIFY(TRUE);
      EXIT(RoutingLink.Code);
    END;

    [Normal]
    LOCAL PROCEDURE CreateRouting@18(VAR RoutingNo@1000 : Code[20];MachineCenterNo@1002 : Code[20];WorkCenterNo@1004 : Code[20];WorkCenterNo2@1003 : Code[20];RoutingLinkCode@1005 : Code[10];RoutingLinkCode2@1007 : Code[10];MultipleRoutingLinkCode@1008 : Boolean);
    VAR
      RoutingHeader@1001 : Record 99000763;
      RoutingLine@1006 : Record 99000764;
    BEGIN
      // Create Routing With Single and Multiple Routing Link Code.
      LibraryManufacturing.CreateRoutingHeader(RoutingHeader,RoutingHeader.Type::Serial);

      IF MultipleRoutingLinkCode THEN BEGIN
        RoutingLine.Type := RoutingLine.Type::"Work Center";
        CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenterNo2,RoutingLinkCode);
        CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenterNo,'');
        RoutingLine.Type := RoutingLine.Type::"Machine Center";
        CreateRoutingLine(RoutingLine,RoutingHeader,MachineCenterNo,RoutingLinkCode2);
      END ELSE BEGIN
        RoutingLine.Type := RoutingLine.Type::"Work Center";
        CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenterNo2,'');
        CreateRoutingLine(RoutingLine,RoutingHeader,WorkCenterNo,RoutingLinkCode);
        RoutingLine.Type := RoutingLine.Type::"Machine Center";
        CreateRoutingLine(RoutingLine,RoutingHeader,MachineCenterNo,'');
      END;

      // Certify Routing after Routing lines creation.
      RoutingHeader.VALIDATE(Status,RoutingHeader.Status::Certified);
      RoutingHeader.MODIFY(TRUE);
      RoutingNo := RoutingHeader."No.";
    END;

    [Normal]
    LOCAL PROCEDURE CreateRoutingLine@17(VAR RoutingLine@1003 : Record 99000764;RoutingHeader@1000 : Record 99000763;CenterNo@1002 : Code[20];RoutingLinkCode@1005 : Code[10]);
    VAR
      CapacityUnitOfMeasure@1004 : Record 99000780;
      OperationNo@1001 : Code[10];
    BEGIN
      // Create Routing Lines with required fields where random is used, values not important for test.
      CapacityUnitOfMeasure.SETRANGE(Type,CapacityUnitOfMeasure.Type::Minutes);
      CapacityUnitOfMeasure.FINDFIRST;
      // Random used such that the Next Operation No is greater than the Previous Operation No.
      OperationNo := FindLastOperationNo(RoutingHeader."No.") + FORMAT(RANDOM(5));

      // Random is used, values not important for test.
      LibraryManufacturing.CreateRoutingLineSetup(
        RoutingLine,RoutingHeader,CenterNo,OperationNo,LibraryRandom.RandInt(5),LibraryRandom.RandInt(5));

      RoutingLine.VALIDATE("Run Time Unit of Meas. Code",CapacityUnitOfMeasure.Code);
      RoutingLine.VALIDATE("Setup Time Unit of Meas. Code",CapacityUnitOfMeasure.Code);
      RoutingLine.VALIDATE("Routing Link Code",RoutingLinkCode);
      RoutingLine.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE FindLastOperationNo@19(RoutingNo@1000 : Code[20]) : Code[10];
    VAR
      RoutingLine@1001 : Record 99000764;
    BEGIN
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      IF RoutingLine.FINDLAST THEN
        EXIT(RoutingLine."Operation No.");
    END;

    [Normal]
    LOCAL PROCEDURE UpdateBOMHeader@3(ProductionBOMNo@1000 : Code[20];ItemNo@1004 : Code[20];RoutingLinkCode@1003 : Code[10]);
    VAR
      ProductionBOMHeader@1002 : Record 99000771;
      ProductionBOMLine@1001 : Record 99000772;
    BEGIN
      // Update Routing link Code on specified BOM component Lines.
      ProductionBOMHeader.SETRANGE("No.",ProductionBOMNo);
      ProductionBOMHeader.FINDFIRST;
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::"Under Development");
      ProductionBOMHeader.MODIFY(TRUE);
      UpdateBOMLineRoutingLinkCode(ProductionBOMHeader,ProductionBOMLine,ItemNo,RoutingLinkCode);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE UpdateBOMLineRoutingLinkCode@9(VAR ProductionBOMHeader@1002 : Record 99000771;VAR ProductionBOMLine@1001 : Record 99000772;ItemNo@1004 : Code[20];RoutingLinkCode@1003 : Code[10]);
    BEGIN
      ProductionBOMLine.SETRANGE("Production BOM No.",ProductionBOMHeader."No.");
      ProductionBOMLine.SETRANGE(Type,ProductionBOMLine.Type::Item);
      ProductionBOMLine.SETRANGE("No.",ItemNo);
      ProductionBOMLine.FINDFIRST;
      ProductionBOMLine.VALIDATE("Routing Link Code",RoutingLinkCode);
      ProductionBOMLine.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CalculateMachCenterCalendar@13(MachineCenterNo@1002 : Code[20];WorkCenterNo@1001 : Code[20];WorkCenterNo2@1000 : Code[20]);
    VAR
      WorkCenter@1003 : Record 99000754;
      MachineCenter@1004 : Record 99000758;
    BEGIN
      MachineCenter.GET(MachineCenterNo);
      LibraryManufacturing.CalculateMachCenterCalendar(MachineCenter,CALCDATE('<-3W>',WORKDATE),CALCDATE('<2W>',WORKDATE));
      WorkCenter.GET(WorkCenterNo);
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,CALCDATE('<-3W>',WORKDATE),CALCDATE('<2W>',WORKDATE));
      CLEAR(WorkCenter);
      WorkCenter.GET(WorkCenterNo2);
      LibraryManufacturing.CalculateWorkCenterCalendar(WorkCenter,CALCDATE('<-3W>',WORKDATE),CALCDATE('<2W>',WORKDATE));
    END;

    LOCAL PROCEDURE CreateProductionBOM@11(VAR ProductionBOMHeader@1001 : Record 99000771;VAR ProductionBOMLine@1000 : Record 99000772;ItemNo@1002 : Code[20];ItemNo2@1003 : Code[20];ItemNo3@1006 : Code[20];QuantityPer@1005 : Decimal) : Code[20];
    VAR
      Item@1007 : Record 27;
    BEGIN
      // Create Production BOM.
      Item.GET(ItemNo);
      LibraryManufacturing.CreateProductionBOMHeader(ProductionBOMHeader,Item."Base Unit of Measure");
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ItemNo,QuantityPer);
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ItemNo2,QuantityPer);
      LibraryManufacturing.CreateProductionBOMLine(
        ProductionBOMHeader,ProductionBOMLine,'',ProductionBOMLine.Type::Item,ItemNo3,QuantityPer);
      ProductionBOMHeader.VALIDATE(Status,ProductionBOMHeader.Status::Certified);
      ProductionBOMHeader.MODIFY(TRUE);
      EXIT(ProductionBOMHeader."No.");
    END;

    LOCAL PROCEDURE CreatePurchOrderThreePurchLine@26(VAR PurchaseHeader@1002 : Record 38;VAR PurchaseLine@1003 : Record 39;ItemNo@1000 : Code[20];ItemNo2@1001 : Code[20];ItemNo3@1006 : Code[20];Quantity@1004 : Decimal;Quantity2@1005 : Decimal;Quantity3@1007 : Decimal);
    BEGIN
      CreatePurchaseHeader(PurchaseHeader);

      // Create Three Purchase Lines.
      CreatePurchaseLines(PurchaseLine,PurchaseHeader,ItemNo,ItemNo2,Quantity,Quantity2);
      CreatePurchaseLine(PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,ItemNo3,Quantity3);
    END;

    LOCAL PROCEDURE CreatePurchOrderTwoPurchLine@39(VAR PurchaseHeader@1002 : Record 38;VAR PurchaseLine@1003 : Record 39;ItemNo@1000 : Code[20];ItemNo2@1001 : Code[20];Quantity@1004 : Decimal;Quantity2@1005 : Decimal);
    BEGIN
      CreatePurchaseHeader(PurchaseHeader);

      // Create Two Purchase Lines.
      CreatePurchaseLines(PurchaseLine,PurchaseHeader,ItemNo,ItemNo2,Quantity,Quantity2);
    END;

    LOCAL PROCEDURE CreatePurchaseHeader@43(VAR PurchaseHeader@1000 : Record 38);
    BEGIN
      LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
    END;

    LOCAL PROCEDURE CreatePurchaseLines@46(VAR PurchaseLine@1004 : Record 39;PurchaseHeader@1005 : Record 38;ItemNo@1003 : Code[20];ItemNo2@1002 : Code[20];Quantity@1001 : Decimal;Quantity2@1000 : Decimal);
    BEGIN
      // Create Two Purchase Lines.
      CreatePurchaseLine(PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,ItemNo,Quantity);
      CreatePurchaseLine(PurchaseHeader,PurchaseLine,PurchaseLine.Type::Item,ItemNo2,Quantity2);
    END;

    LOCAL PROCEDURE CreatePurchaseLine@9111(VAR PurchaseHeader@1001 : Record 38;VAR PurchaseLine@1000 : Record 39;Type@1002 : Option;ItemNo@1003 : Code[20];Qty@1004 : Decimal);
    BEGIN
      LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,Type,ItemNo,Qty);
    END;

    [Normal]
    LOCAL PROCEDURE UpdatePlannedProductionOrder@24(ProductionOrderNo@1001 : Code[20]);
    VAR
      ProdOrderLine@1000 : Record 5406;
    BEGIN
      // Create Planned Production Order with Random Quantity Greater than 1 and in Proportion to Purchased Items.
      ProdOrderLine.SETRANGE(Status,ProdOrderLine.Status::Planned);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderLine.FINDFIRST;
      ProdOrderLine.VALIDATE("Planning Flexibility",ProdOrderLine."Planning Flexibility"::None);
      ProdOrderLine.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE RemoveProdOrderComponent@45(ProductionOrderNo@1000 : Code[20];ItemNo@1002 : Code[20]);
    VAR
      ProdOrderComponent@1001 : Record 5407;
    BEGIN
      ProdOrderComponent.SETRANGE(Status,ProdOrderComponent.Status::Planned);
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderComponent.SETRANGE("Item No.",ItemNo);
      ProdOrderComponent.FINDFIRST;
      ProdOrderComponent.DELETE(TRUE);
      COMMIT;
    END;

    [Normal]
    LOCAL PROCEDURE RemoveProdOrderRoutingLine@16(ProductionOrderNo@1000 : Code[20];WorkCenterNo@1002 : Code[20]);
    VAR
      ProdOrderRoutingLine@1003 : Record 5409;
    BEGIN
      ProdOrderRoutingLine.SETRANGE(Status,ProdOrderRoutingLine.Status::Planned);
      ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderRoutingLine.SETRANGE(Type,ProdOrderRoutingLine.Type::"Work Center");
      ProdOrderRoutingLine.SETRANGE("No.",WorkCenterNo);
      ProdOrderRoutingLine.FINDFIRST;
      ProdOrderRoutingLine.DELETE(TRUE);
      COMMIT;
    END;

    [Normal]
    LOCAL PROCEDURE UpdateOperationNo@32(ProductionOrderNo@1000 : Code[20]);
    VAR
      ProdOrderRoutingLine@1003 : Record 5409;
    BEGIN
      ProdOrderRoutingLine.SETRANGE(Status,ProdOrderRoutingLine.Status::Planned);
      ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProductionOrderNo);
      ProdOrderRoutingLine.FINDSET;
      REPEAT
        ProdOrderRoutingLine.VALIDATE("Next Operation No.",'');
        ProdOrderRoutingLine.VALIDATE("Previous Operation No.",'');
        ProdOrderRoutingLine.MODIFY(TRUE);
      UNTIL ProdOrderRoutingLine.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE CountProductionComponents@23(ProductionNo@1000 : Code[20]) : Integer;
    VAR
      ProdOrderComponent@1001 : Record 5407;
      CountComponent@1002 : Integer;
    BEGIN
      ProdOrderComponent.SETRANGE(Status,ProdOrderComponent.Status::Planned);
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProductionNo);
      CountComponent := ProdOrderComponent.COUNT;
      EXIT(CountComponent);
    END;

    [Normal]
    LOCAL PROCEDURE CountProductionRoutingLines@21(ProductionNo@1003 : Code[20]) : Integer;
    VAR
      ProdOrderRoutingLine@1001 : Record 5409;
      CountRoutingLine@1002 : Integer;
    BEGIN
      ProdOrderRoutingLine.SETRANGE(Status,ProdOrderRoutingLine.Status::Planned);
      ProdOrderRoutingLine.SETRANGE("Prod. Order No.",ProductionNo);
      CountRoutingLine := ProdOrderRoutingLine.COUNT;
      EXIT(CountRoutingLine);
    END;

    LOCAL PROCEDURE ChangeStatusPlannedToReleased@30(ProductionOrderNo@1000 : Code[20]) : Code[20];
    VAR
      ProductionOrder@1001 : Record 5405;
      ProdOrderStatusManagement@1002 : Codeunit 5407;
    BEGIN
      ProductionOrder.GET(ProductionOrder.Status::Planned,ProductionOrderNo);
      ProdOrderStatusManagement.ChangeStatusOnProdOrder(ProductionOrder,ProductionOrder.Status::Released,WORKDATE,FALSE);
      ProductionOrder.SETRANGE(Status,ProductionOrder.Status::Released);
      ProductionOrder.SETRANGE("Source No.",ProductionOrder."Source No.");
      ProductionOrder.FINDFIRST;
      EXIT(ProductionOrder."No.");
    END;

    [Normal]
    LOCAL PROCEDURE UpdateLessQtyOutputJournal@34(ProductionOrderNo@1003 : Code[20]);
    VAR
      ProductionOrder@1001 : Record 5405;
      ItemJournalLine@1000 : Record 83;
    BEGIN
      ProductionOrder.GET(ProductionOrder.Status::Released,ProductionOrderNo);
      ItemJournalLine.SETRANGE("Order Type",ItemJournalLine."Order Type"::Production);
      ItemJournalLine.SETRANGE("Order No.",ProductionOrderNo);
      ItemJournalLine.FINDSET;
      REPEAT
        ItemJournalLine.VALIDATE("Output Quantity",ProductionOrder.Quantity - 1);
        ItemJournalLine.MODIFY(TRUE);
      UNTIL ItemJournalLine.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE CountBOMComponents@27(ProductionBOMNo@1000 : Code[20]) : Integer;
    VAR
      ProductionBOMLine@1001 : Record 99000772;
      CountBOMComponents@1002 : Integer;
    BEGIN
      ProductionBOMLine.SETRANGE("Production BOM No.",ProductionBOMNo);
      CountBOMComponents := ProductionBOMLine.COUNT;
      EXIT(CountBOMComponents);
    END;

    [Normal]
    LOCAL PROCEDURE CountRoutingLines@28(RoutingNo@1000 : Code[20]) : Integer;
    VAR
      RoutingLine@1001 : Record 99000764;
      CountRoutingLines@1002 : Integer;
    BEGIN
      RoutingLine.SETRANGE("Routing No.",RoutingNo);
      CountRoutingLines := RoutingLine.COUNT;
      EXIT(CountRoutingLines);
    END;

    [Normal]
    LOCAL PROCEDURE ActProdOrderComponentQuantity@20(ProductionOrderNo@1000 : Code[20];RoutingLinkCode@1001 : Code[20];Status@1007 : 'Simulated,Planned,Firm Planned,Released,Finished';RoutingLinkCodeExist@1003 : Boolean) : Decimal;
    VAR
      ProdOrderComponent@1004 : Record 5407;
      ActualProdOrderQuantity@1006 : Decimal;
    BEGIN
      IF Status <> Status::Released THEN
        ProdOrderComponent.SETRANGE(Status,Status::Finished)
      ELSE
        ProdOrderComponent.SETRANGE(Status,Status::Released);
      ProdOrderComponent.SETRANGE("Prod. Order No.",ProductionOrderNo);
      IF RoutingLinkCodeExist THEN
        ProdOrderComponent.SETRANGE("Routing Link Code",RoutingLinkCode);
      ProdOrderComponent.FINDSET;
      REPEAT
        ProdOrderComponent.CALCFIELDS("Act. Consumption (Qty)");
        ActualProdOrderQuantity += ProdOrderComponent."Act. Consumption (Qty)";
      UNTIL ProdOrderComponent.NEXT = 0;
      EXIT(ActualProdOrderQuantity);
    END;

    [Normal]
    LOCAL PROCEDURE ItemLedgerConsumptionQuantity@37(VAR ItemLedgerEntry@1000 : Record 32;ProductionOrderNo@1001 : Code[20];ItemNo@1002 : Code[20];RoutingLinkCodeExists@1004 : Boolean) : Decimal;
    VAR
      Quantity@1003 : Decimal;
    BEGIN
      // Select Item Ledger Entry with specified filters.
      ItemLedgerEntry.SETRANGE("Document No.",ProductionOrderNo);
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::Consumption);
      IF RoutingLinkCodeExists THEN
        ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.FINDSET;
      REPEAT
        Quantity += ItemLedgerEntry.Quantity;
      UNTIL ItemLedgerEntry.NEXT = 0;
      EXIT(ABS(Quantity));
    END;

    [Normal]
    LOCAL PROCEDURE ItemLedgerOutputQuantity@7(VAR ItemLedgerEntry@1000 : Record 32;ProductionOrderNo@1001 : Code[20];ItemNo@1002 : Code[20]) : Decimal;
    VAR
      Quantity@1003 : Decimal;
    BEGIN
      // Select Item Ledger Entry with specified filters.
      ItemLedgerEntry.SETRANGE("Document No.",ProductionOrderNo);
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::Output);
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.FINDSET;
      REPEAT
        Quantity += ItemLedgerEntry.Quantity;
      UNTIL ItemLedgerEntry.NEXT = 0;
      EXIT(Quantity);
    END;

    LOCAL PROCEDURE VerifyConsumptionQuantity@6(ProductionOrderNo@1001 : Code[20];ItemNo@1000 : Code[20];RoutingLinkCode@1010 : Code[10];Status@1002 : 'Simulated,Planned,Firm Planned,Released,Finished';RoutingLinkCodeExist@1009 : Boolean);
    VAR
      ItemLedgerEntry@1003 : Record 32;
      Assert@1005 : Codeunit 130000;
      CalculatedQuantity@1004 : Decimal;
      ActualConsumptionQuantity@1007 : Decimal;
    BEGIN
      // Select set of Item Ledger Entries for the specified Consumption Quantity.
      CalculatedQuantity := ItemLedgerConsumptionQuantity(ItemLedgerEntry,ProductionOrderNo,ItemNo,RoutingLinkCodeExist);

      IF RoutingLinkCodeExist THEN
        ActualConsumptionQuantity := ActProdOrderComponentQuantity(ProductionOrderNo,RoutingLinkCode,Status,TRUE)
      ELSE
        ActualConsumptionQuantity := ActProdOrderComponentQuantity(ProductionOrderNo,RoutingLinkCode,Status,FALSE);

      Assert.AreEqual(ActualConsumptionQuantity,CalculatedQuantity,ErrMessageConsumptionMissing);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyFinishedItemLedgerEntry@5(ProductionOrderNo@1001 : Code[20];ItemNo@1002 : Code[20];ProductionOrderQuantity@1004 : Decimal);
    VAR
      ItemLedgerEntry@1003 : Record 32;
      CalulatedOutputQuantity@1000 : Decimal;
    BEGIN
      CalulatedOutputQuantity := ItemLedgerOutputQuantity(ItemLedgerEntry,ProductionOrderNo,ItemNo);
      Assert.AreNotEqual(CalulatedOutputQuantity,ProductionOrderQuantity,ErrMessagePartialOutput)
    END;

    [Normal]
    LOCAL PROCEDURE VerifyComponentAfterRefresh@33(ProductionBOMNo@1003 : Code[20];CountProductionBomComponent@1004 : Integer;RefreshComponents@1001 : Boolean);
    VAR
      CountComponents@1000 : Integer;
    BEGIN
      // Count BOM Components of Item
      CountComponents := CountBOMComponents(ProductionBOMNo);

      // Verify :Compare BOM components with Production Order Components.
      IF RefreshComponents THEN
        Assert.AreEqual(CountProductionBomComponent,CountComponents,ErrMessageRefreshComponentEql)
      ELSE
        Assert.AreNotEqual(CountComponents,CountProductionBomComponent,ErrMessageRefreshNotEql);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyRoutingAfterRefresh@36(RoutingNo@1004 : Code[20];CountProductionRouting@1003 : Integer;RefreshRouting@1002 : Boolean);
    VAR
      CountRoutingLine@1000 : Integer;
    BEGIN
      // Count Routing Line of Item
      CountRoutingLine := CountRoutingLines(RoutingNo);

      // Verify :Compare Routing lines with Production Order routing line.
      IF RefreshRouting THEN
        Assert.AreEqual(CountProductionRouting,CountRoutingLine,ErrMessageRefreshRoutingEql)
      ELSE
        Assert.AreNotEqual(CountRoutingLine,CountProductionRouting,ErrMessageRefreshRoutingNotEql);
    END;

    [StrMenuHandler]
    PROCEDURE CalcStdCostMenuHandler@22(Option@1000 : Text[1024];VAR Choice@1001 : Integer;Instruction@1002 : Text[1024]);
    BEGIN
      // Calculate Standard Cost for All Level.
      Choice := 2;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@12(ConfirmText@1001 : Text[1024];VAR Confirm@1000 : Boolean);
    BEGIN
      Confirm := TRUE;
    END;

    BEGIN
    {
      // [FEATURE] [SCM]
      Test for WIP Costing:
        1. Test PAC with Flushing method - Forward and Partial Output.
        2. Test PAC with Flushing method - Backward and Partial Output.
        3. Test PAC with Flushing method - Manual.
        4. Test PAC with Flushing method -Forward With two routing Link code attached.
        5. Test PAC with Production Order Refresh report after Removing Component and Routing.
        6. Test PAC with Production Order Refresh report after Removing Component.
        7. Test PAC with Production Order Refresh report after Removing Routing.

      This test code unit replaces Manual Test Suite (19684).

      TFS_TS_ID = 19684
      Covers Test cases:
        TC0510 TFS_TC_ID = 3282,3283,3284,3285,3286,3287,3288 and 11842
    }
    END.
  }
}

