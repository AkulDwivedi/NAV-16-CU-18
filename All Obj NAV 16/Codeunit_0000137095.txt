OBJECT Codeunit 137095 SCM Kitting - Reservations
{
  OBJECT-PROPERTIES
  {
    Date=27-09-17;
    Time=12:00:00 PM;
    Version List=NAVW19.00.00,Test;
  }
  PROPERTIES
  {
    Subtype=Test;
    OnRun=BEGIN
            isInitialized := FALSE;
          END;

  }
  CODE
  {
    VAR
      ManufacturingSetup@1017 : Record 99000765;
      AssemblySetup@1015 : Record 905;
      AssemblyLine@1009 : Record 901;
      AssemblyHeader@1012 : Record 900;
      SalesLine@1013 : Record 37;
      Item@1001 : Record 27;
      LibraryERM@1006 : Codeunit 131300;
      LibraryUtility@1014 : Codeunit 131000;
      LibraryWarehouse@1003 : Codeunit 132204;
      LibraryInventory@1004 : Codeunit 132201;
      LibraryAssembly@1023 : Codeunit 132207;
      LibraryPurchase@1008 : Codeunit 130512;
      LibrarySales@1999 : Codeunit 130509;
      Assert@1002 : Codeunit 130000;
      LibraryRandom@1007 : Codeunit 130440;
      isInitialized@1000 : Boolean;
      GlobalSupplyType@1005 : 'Purchase Order,Assembly Order,Released Production Order,Firm Planned Production Order';
      ErrorChangeLine@1010 : TextConst 'ENU=%1 must not be changed when a quantity is reserved in Assembly Line Document Type';
      ErrorResQty@1011 : TextConst 'ENU=Reserved Quantity must be equal to ''0''';
      ErrorInventory@1018 : TextConst 'ENU=is not on inventory.';
      ErrorResAlways@1019 : TextConst 'ENU=Automatic reservation is not possible.';
      GlobalILESupply@1020 : Decimal;
      GlobalPOSupply@1021 : Decimal;
      GlobalAOSupply@1022 : Decimal;
      GlobalSupply@1025 : Decimal;
      GlobalCancelReservation@1026 : Boolean;
      GlobalSourceType@1027 : Integer;
      ErrorResNever@1028 : TextConst 'ENU=Reserve must not be Never in Assembly Line:';
      ErrorCancelRes@1029 : TextConst 'ENU=Do you want to cancel all reservations';
      ErrorInsufSupply@1024 : TextConst 'ENU=Full automatic Reservation is not possible';
      GlobalReserveTwice@1030 : Boolean;
      ErrorFullyReserved@1031 : TextConst 'ENU=Fully reserved.';
      ErrorNotAvail@1032 : TextConst 'ENU=There is nothing available to reserve.';
      WorkDate2@1033 : Date;
      MsgDueDateBeforeWorkDate@1034 : TextConst 'ENU=before work date';

    [Normal]
    LOCAL PROCEDURE Initialize@8();
    VAR
      PurchasesPayablesSetup@1002 : Record 312;
      LibraryERMCountryData@1001 : Codeunit 131305;
    BEGIN
      // Initialize setup.
      IF isInitialized THEN
        EXIT;

      // Setup Demonstration data.
      LibraryERMCountryData.CreateVATData;
      LibraryERMCountryData.UpdateGeneralPostingSetup;

      PurchasesPayablesSetup.GET;
      PurchasesPayablesSetup.VALIDATE("Vendor Nos.",LibraryUtility.GetGlobalNoSeriesCode);
      PurchasesPayablesSetup.MODIFY(TRUE);

      ManufacturingSetup.GET;
      WorkDate2 := CALCDATE(ManufacturingSetup."Default Safety Lead Time",WORKDATE); // to avoid Due Date Before Work Date message.
      LibraryAssembly.UpdateAssemblySetup(
        AssemblySetup,'',AssemblySetup."Copy Component Dimensions from"::"Order Header",LibraryUtility.GetGlobalNoSeriesCode);

      isInitialized := TRUE;
      COMMIT;
    END;

    [Normal]
    LOCAL PROCEDURE ShowReservationPages@2(LineType@1002 : Option);
    VAR
      AssemblyHeader@1000 : Record 900;
      AssemblyLine@1001 : Record 901;
    BEGIN
      // Setup. Create Assembly structure.
      Initialize;
      LibraryAssembly.SetupAssemblyData(AssemblyHeader,WorkDate2,Item."Costing Method"::Standard,Item."Costing Method"::Standard,
        Item."Replenishment System"::Assembly,'',TRUE);

      // Exercise. Find a random Assembly Component Line of the specified type.
      AssemblyLine.SETRANGE("Document Type",AssemblyLine."Document Type"::Order);
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,LineType);
      AssemblyLine.NEXT(RANDOM(AssemblyLine.COUNT));

      // Try to open the Reservation and the Reservation Entries page.
      // Validate: Pages are raised according to the test function handler.
      AssemblyLine.ShowReservation;
      AssemblyLine.ShowReservationEntries(TRUE);
    END;

    [Test]
    [HandlerFunctions(ResPageHandler,ResEntryPageHandler,AvailabilityWindowHandler)]
    PROCEDURE ShowItem@34();
    BEGIN
      ShowReservationPages(AssemblyLine.Type::Item);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ShowResource@35();
    BEGIN
      ShowReservationPages(AssemblyLine.Type::Resource);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ShowText@36();
    BEGIN
      ShowReservationPages(AssemblyLine.Type::" ");
    END;

    [Normal]
    LOCAL PROCEDURE TestAutoReserve@25(Reserve@1003 : Option;ExcessSupply@1008 : Decimal;FilterOnVariant@1012 : Boolean;FilterOnLocation@1013 : Boolean;DueDateDelay@1010 : Integer) : Code[20];
    VAR
      AssemblyHeader@1000 : Record 900;
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      ReservMgt@1004 : Codeunit 99000845;
      FullAutoReservation@1006 : Boolean;
      AvailToReserve@1005 : Decimal;
    BEGIN
      // Setup Reservations.
      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Reserve,
        ExcessSupply,FilterOnVariant,FilterOnLocation,DueDateDelay,2);
      AssemblyHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");

      // Exercise: Auto reserve.
      ReservMgt.SetAssemblyHeader(AssemblyHeader);
      ReservMgt.SetAssemblyLine(AssemblyLine);
      ReservMgt.AutoReserve(FullAutoReservation,'',AssemblyLine."Due Date",AssemblyLine.Quantity,AssemblyLine."Quantity (Base)");

      // Validate: Reservation entries and Reserved Qty on Assembly Line.
      AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(AvailToReserve,AssemblyLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,'Wrong Res. Qty');
      AssemblyLine.TESTFIELD("Reserved Quantity",AssemblyLine."Reserved Qty. (Base)" * AssemblyLine."Qty. per Unit of Measure");
      VerifyReservationEntries(TempReservationEntry,AssemblyLine);

      EXIT(AssemblyHeader."No.");
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ReserveOptional@3();
    BEGIN
      TestAutoReserve(Item.Reserve::Optional,0,FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ReserveNever@12();
    BEGIN
      TestAutoReserve(Item.Reserve::Never,0,FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ReserveAlways@13();
    BEGIN
      TestAutoReserve(Item.Reserve::Always,0,FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ExcessSupply@6();
    BEGIN
      TestAutoReserve(Item.Reserve::Optional,LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE InsufficientSupply@11();
    BEGIN
      TestAutoReserve(Item.Reserve::Optional,-LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE DueDateBefore@20();
    BEGIN
      TestAutoReserve(Item.Reserve::Optional,0,FALSE,FALSE,5);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE DifferentLocation@69();
    BEGIN
      TestAutoReserve(Item.Reserve::Optional,0,FALSE,TRUE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE DifferentVariant@70();
    BEGIN
      TestAutoReserve(Item.Reserve::Optional,0,TRUE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE DifferentVarAndLoc@71();
    BEGIN
      TestAutoReserve(Item.Reserve::Optional,0,TRUE,TRUE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE PostOptional@57();
    VAR
      AssemblyHeader@1000 : Record 900;
      AssemblyLine@1001 : Record 901;
      Item@1002 : Record 27;
      ReservationEntry@1003 : Record 337;
      RemainingResQty@1004 : Decimal;
      ItemNo@1005 : Code[20];
      InitialResQty@1111 : Decimal;
      InitialInventory@1112 : Decimal;
    BEGIN
      // Setup: Create an Assembly Order with reservations for components. The order must be posted partially.
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,TestAutoReserve(Item.Reserve::Optional,0,FALSE,FALSE,0));
      AssemblyHeader.VALIDATE("Quantity to Assemble (Base)",AssemblyHeader."Quantity (Base)" - 1);
      AssemblyHeader.MODIFY(TRUE);
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyLine."Document Type"::Order);
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);

      // Identify the Assembly Lines containing reservations.
      // Prepare the lines for posting.
      IF AssemblyLine.FINDSET THEN
        REPEAT
          Item.GET(AssemblyLine."No.");
          Item.CALCFIELDS(Inventory);
          AssemblyLine.VALIDATE("Quantity to Consume",Item.Inventory / AssemblyLine."Qty. per Unit of Measure");
          AssemblyLine.MODIFY(TRUE);
          AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
          IF AssemblyLine."Reserved Quantity" > 0 THEN BEGIN
            ItemNo := AssemblyLine."No.";
            InitialResQty := AssemblyLine."Reserved Qty. (Base)";
            InitialInventory := Item.Inventory;
          END;
        UNTIL AssemblyLine.NEXT = 0;

      // Exercise: Post reservations.
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Validate: Reservations are eliminated.
      ReservationEntry.RESET;
      ReservationEntry.SETRANGE(Positive,FALSE);
      ReservationEntry.SETRANGE("Source Type",901);
      ReservationEntry.SETRANGE("Source ID",AssemblyHeader."No.");
      ReservationEntry.SETRANGE("Item No.",ItemNo);

      IF InitialResQty > InitialInventory THEN
        IF ReservationEntry.FINDSET THEN BEGIN
          REPEAT
            RemainingResQty += ABS(ReservationEntry."Quantity (Base)");
          UNTIL ReservationEntry.NEXT = 0;
          Assert.AreNearlyEqual(InitialResQty - InitialInventory,RemainingResQty,LibraryERM.GetAmountRoundingPrecision,
            'Remaining reserved quantity is not correct.');
        END
        ELSE
          Assert.Fail('Reservation entry are expected when the initial res. qty ' + FORMAT(InitialResQty) + ' is higher than ' +
            FORMAT(InitialInventory))
      ELSE
        Assert.AreEqual(0,ReservationEntry.COUNT,'There shouldn''t be any reservation entries left.');
    END;

    [Normal]
    LOCAL PROCEDURE TestNormalReserve@21(ExcessSupply@1008 : Decimal;FilterOnVariant@1012 : Boolean;FilterOnLocation@1013 : Boolean);
    VAR
      Item@1002 : Record 27;
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      TrackingSpecification@1004 : Record 336;
      AssemblyLineReserve@1000 : Codeunit 926;
      ReservMgt@1005 : Codeunit 99000845;
      AvailToReserve@1003 : Decimal;
    BEGIN
      // Setup Reservations.
      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Item.Reserve::Optional,
        ExcessSupply,FilterOnVariant,FilterOnLocation,0,2);

      // Exercise: Reserve for current assembly line, using all available supply lines.
      IF TempReservationEntry.FINDSET THEN
        REPEAT
          ReservMgt.CreateTrackingSpecification(TrackingSpecification,
            TempReservationEntry."Source Type",
            TempReservationEntry."Source Subtype",
            TempReservationEntry."Source ID",
            '',0,TempReservationEntry."Source Ref. No.",
            TempReservationEntry."Variant Code",
            TempReservationEntry."Location Code",'','',
            TempReservationEntry."Qty. per Unit of Measure");
          AssemblyLineReserve.CreateReservationSetFrom(TrackingSpecification);
          // If we are expecting not to be able to create a reservation.
          IF TempReservationEntry."Quantity (Base)" = 0 THEN
            ASSERTERROR
              AssemblyLineReserve.CreateReservation(
                AssemblyLine,
                AssemblyLine.Description,
                TempReservationEntry."Expected Receipt Date",
                ROUND(TempReservationEntry."Qty. to Handle (Base)" / TempReservationEntry."Qty. per Unit of Measure",0.00001),
                TempReservationEntry."Qty. to Handle (Base)",
                // For reservation entries where expected qty. to reserve is 0, use supply qty to attempt reservation.
            '','')
          ELSE
            AssemblyLineReserve.CreateReservation(
              AssemblyLine,
              AssemblyLine.Description,
              TempReservationEntry."Expected Receipt Date",
              TempReservationEntry.Quantity,
              TempReservationEntry."Quantity (Base)",
              '','');
          COMMIT;
        UNTIL TempReservationEntry.NEXT = 0;

      // Validate: Reservation entries and Reserved Qty on Assembly Line.
      AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(AvailToReserve,AssemblyLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,'Wrong Res. Qty');
      AssemblyLine.TESTFIELD("Reserved Quantity",AssemblyLine."Reserved Qty. (Base)" * AssemblyLine."Qty. per Unit of Measure");
      VerifyReservationEntries(TempReservationEntry,AssemblyLine);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ResLineExcessSupply@23();
    BEGIN
      TestNormalReserve(LibraryRandom.RandIntInRange(7,50),FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ResLineInsuffSupply@22();
    BEGIN
      TestNormalReserve(-LibraryRandom.RandIntInRange(7,50),FALSE,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ResLineDifferentLocation@18();
    BEGIN
      TestNormalReserve(0,FALSE,TRUE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ResLineDifferentVariant@17();
    BEGIN
      TestNormalReserve(0,TRUE,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE ResLineDifferentVarAndLoc@16();
    BEGIN
      TestNormalReserve(0,TRUE,TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE TestFindHeaderRes@15(FilterOnLocation@1003 : Boolean;FilterOnVariant@1008 : Boolean;DueDateDelay@1010 : Integer);
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1000 : Record 900;
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      ReservationEntry@1009 : Record 337;
      ReservMgt@1004 : Codeunit 99000845;
      AssemblyHeaderReserve@1011 : Codeunit 925;
      FullAutoReservation@1006 : Boolean;
      AvailToReserve@1005 : Decimal;
      Multiplicity@1012 : Integer;
    BEGIN
      // Setup Reservations.
      // If negative scenarios, do not create available supply.
      IF FilterOnLocation OR FilterOnVariant OR (DueDateDelay <> 0) THEN
        Multiplicity := 0
      ELSE
        Multiplicity := 1;

      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Item.Reserve::Optional,
        0,FilterOnVariant,FilterOnLocation,DueDateDelay,Multiplicity);
      AssemblyHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");

      // Exercise: Auto reserve.
      ReservMgt.SetAssemblyHeader(AssemblyHeader);
      ReservMgt.SetAssemblyLine(AssemblyLine);
      ReservMgt.AutoReserve(FullAutoReservation,'',AssemblyLine."Due Date",AssemblyLine.Quantity,AssemblyLine."Quantity (Base)");

      // Validate: Reservation functions in CU925.
      TempReservationEntry.SETRANGE("Source Type",900);
      TempReservationEntry.FINDFIRST;
      AssemblyHeader.GET(AssemblyLine."Document Type",TempReservationEntry."Source ID");

      IF FilterOnLocation OR FilterOnVariant OR (DueDateDelay <> 0) THEN BEGIN
        Assert.IsFalse(AssemblyHeaderReserve.FindReservEntry(AssemblyHeader,ReservationEntry),'FindResEnt,Item:' + AssemblyLine."No.");
        Assert.IsFalse(AssemblyHeaderReserve.ReservEntryExist(AssemblyHeader),'ReservEntryExist,Item: ' + AssemblyLine."No.");
        Assert.IsTrue(ReservationEntry.ISEMPTY,'Item: ' + AssemblyLine."No.");
      END ELSE BEGIN
        Assert.IsTrue(
          AssemblyHeaderReserve.FindReservEntry(AssemblyHeader,ReservationEntry),'FindResEntry,Item:' + AssemblyLine."No.");
        Assert.IsTrue(AssemblyHeaderReserve.ReservEntryExist(AssemblyHeader),'ReservEntryExist, Item:' + AssemblyLine."No.");
        Assert.IsFalse(ReservationEntry.ISEMPTY,'Item: ' + AssemblyLine."No.");
      END;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HeaderResSunshine@47();
    BEGIN
      TestFindHeaderRes(FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HeaderResDiffLocation@27();
    BEGIN
      TestFindHeaderRes(TRUE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HeaderResDiffVariant@45();
    BEGIN
      TestFindHeaderRes(FALSE,TRUE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE HeaderResDueDateBefore@46();
    BEGIN
      TestFindHeaderRes(FALSE,FALSE,5);
    END;

    [Normal]
    LOCAL PROCEDURE TestFindLineRes@30(FilterOnLocation@1003 : Boolean;FilterOnVariant@1008 : Boolean;DueDateDelay@1010 : Integer);
    VAR
      Item@1002 : Record 27;
      AssemblyHeader@1000 : Record 900;
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      ReservationEntry@1009 : Record 337;
      ReservMgt@1004 : Codeunit 99000845;
      AssemblyLineReserve@1011 : Codeunit 926;
      FullAutoReservation@1006 : Boolean;
      AvailToReserve@1005 : Decimal;
      Multiplicity@1012 : Integer;
    BEGIN
      // Setup Reservations.
      // If negative scenarios, do not create available supply.
      IF FilterOnLocation OR FilterOnVariant OR (DueDateDelay <> 0) THEN
        Multiplicity := 0
      ELSE
        Multiplicity := 1;

      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Item.Reserve::Optional,
        0,FilterOnVariant,FilterOnLocation,DueDateDelay,Multiplicity);
      AssemblyHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");

      // Exercise: Auto reserve.
      ReservMgt.SetAssemblyHeader(AssemblyHeader);
      ReservMgt.SetAssemblyLine(AssemblyLine);
      ReservMgt.AutoReserve(FullAutoReservation,'',AssemblyLine."Due Date",AssemblyLine.Quantity,AssemblyLine."Quantity (Base)");

      // Validate: Reservation functions in CU926.
      IF FilterOnLocation OR FilterOnVariant OR (DueDateDelay <> 0) THEN BEGIN
        Assert.IsFalse(
          AssemblyLineReserve.FindReservEntry(AssemblyLine,ReservationEntry),'FindReservEntry,Item:' + AssemblyLine."No.");
        Assert.IsFalse(AssemblyLineReserve.ReservEntryExist(AssemblyLine),'ReservEntryExist,Item:' + AssemblyLine."No.");
        Assert.IsTrue(ReservationEntry.ISEMPTY,'Item: ' + AssemblyLine."No.");
      END ELSE BEGIN
        Assert.IsTrue(
          AssemblyLineReserve.FindReservEntry(AssemblyLine,ReservationEntry),'FindReservEntry,Item: ' + AssemblyLine."No.");
        Assert.IsTrue(AssemblyLineReserve.ReservEntryExist(AssemblyLine),'ReservEntryExist,Item: ' + AssemblyLine."No.");
        Assert.IsFalse(ReservationEntry.ISEMPTY,'ReservEntryExist,Item: ' + AssemblyLine."No.");
      END;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineResSunshine@48();
    BEGIN
      TestFindLineRes(FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineResDiffLocation@29();
    BEGIN
      TestFindLineRes(FALSE,TRUE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE LineResDueDateBefore@49();
    BEGIN
      TestFindHeaderRes(FALSE,FALSE,5);
    END;

    [Normal]
    LOCAL PROCEDURE TestUIAutoReserve@28(Reserve@1003 : Option;ExcessSupply@1008 : Decimal;FilterOnVariant@1012 : Boolean;FilterOnLocation@1013 : Boolean;DueDateDelay@1010 : Integer);
    VAR
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      AvailToReserve@1005 : Decimal;
    BEGIN
      // Setup Reservations.
      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Reserve,
        ExcessSupply,FilterOnVariant,FilterOnLocation,DueDateDelay,2);

      // No action is expected in this test for Items with Reserve <> Always.
      IF Reserve <> Item.Reserve::Always THEN BEGIN
        AvailToReserve := 0;
        TempReservationEntry.DELETEALL;
      END ELSE
        AssemblyLine.DELETE(TRUE);

      // Exercise: Auto reserve record using the page triggers.
      AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      AssemblyLine.TESTFIELD("Reserved Qty. (Base)",0);

      AddAssemblyLineOnPage(AssemblyLine);

      // Validate: Reservation entries and Reserved Qty on Assembly Line.
      AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(AvailToReserve,AssemblyLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,'Wrong Res. Qty');
      AssemblyLine.TESTFIELD("Reserved Quantity",AssemblyLine."Reserved Qty. (Base)" * AssemblyLine."Qty. per Unit of Measure");
      VerifyReservationEntries(TempReservationEntry,AssemblyLine);
    END;

    [Test]
    [HandlerFunctions(AvailModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AutoReserveOptional@44();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Optional,0,FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AutoReserveNever@43();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Never,0,FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AutoReserveAlways@42();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Always,0,FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AutoExcessSupply@41();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Always,LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(PartialResConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE AutoInsufficientSupply@40();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Always,-LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(PartialResConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE AutoInsSupplyLocation@140();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Always,-LibraryRandom.RandIntInRange(7,50),FALSE,TRUE,0);
    END;

    [Test]
    [HandlerFunctions(PartialResConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE AutoInsSupplyVariant@143();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Always,-LibraryRandom.RandIntInRange(7,50),TRUE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AutoDueDateBefore@38();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Always,0,FALSE,FALSE,5);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AutoDifferentLocation@37();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Always,0,FALSE,TRUE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AutoDifferentVariant@33();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Always,0,TRUE,FALSE,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AutoDifferentVarAndLoc@32();
    BEGIN
      TestUIAutoReserve(Item.Reserve::Always,0,TRUE,TRUE,0);
    END;

    [Normal]
    LOCAL PROCEDURE TestUIAvailToReserve@63(Reserve@1003 : Option;ExcessSupply@1008 : Decimal;FilterOnVariant@1012 : Boolean;FilterOnLocation@1013 : Boolean;DueDateDelay@1010 : Integer;ReserveTwice@1000 : Boolean);
    VAR
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      AvailToReserve@1005 : Decimal;
      Qty@1009 : Decimal;
    BEGIN
      // Setup Reservations.
      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Reserve,
        ExcessSupply,FilterOnVariant,FilterOnLocation,DueDateDelay,2);

      // Exercise: Auto reserve record using the page triggers.
      GlobalILESupply := GetTotalAvailSupply(
          TempReservationEntry,Qty,AssemblyLine."Location Code",AssemblyLine."Variant Code",AssemblyLine."Due Date",32);
      GlobalPOSupply := GetTotalAvailSupply(
          TempReservationEntry,Qty,AssemblyLine."Location Code",AssemblyLine."Variant Code",AssemblyLine."Due Date",39);
      GlobalAOSupply := GetTotalAvailSupply(
          TempReservationEntry,Qty,AssemblyLine."Location Code",AssemblyLine."Variant Code",AssemblyLine."Due Date",900);
      GlobalReserveTwice := ReserveTwice;

      AssemblyLine.ShowReservation;
      // Reservation page handler is triggered.

      // Validate: Reservation entries and Reserved Qty on Assembly Line.
      AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(AvailToReserve,AssemblyLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,'Wrong Res. Qty');
      AssemblyLine.TESTFIELD("Reserved Quantity",AssemblyLine."Reserved Qty. (Base)" * AssemblyLine."Qty. per Unit of Measure");
      VerifyReservationEntries(TempReservationEntry,AssemblyLine);
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveOptional@122();
    BEGIN
      TestUIAvailToReserve(Item.Reserve::Optional,0,FALSE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveAlways@78();
    BEGIN
      TestUIAvailToReserve(Item.Reserve::Always,0,FALSE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveNever@79();
    BEGIN
      ASSERTERROR
        TestUIAvailToReserve(Item.Reserve::Never,0,FALSE,FALSE,0,FALSE);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ErrorResNever) > 0,'Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveExcessSupply@120();
    BEGIN
      TestUIAvailToReserve(Item.Reserve::Optional,10,FALSE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,InsufSupplyMessagHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveInsufSupply@121();
    BEGIN
      TestUIAvailToReserve(Item.Reserve::Optional,-10,FALSE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveLocation@125();
    BEGIN
      TestUIAvailToReserve(Item.Reserve::Optional,0,FALSE,TRUE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveVariant@126();
    BEGIN
      TestUIAvailToReserve(Item.Reserve::Optional,0,TRUE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveVarLoc@127();
    BEGIN
      TestUIAvailToReserve(Item.Reserve::Optional,0,TRUE,TRUE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveDueDate@128();
    BEGIN
      TestUIAvailToReserve(Item.Reserve::Optional,0,FALSE,FALSE,5,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,InsufSupplyMessagHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveInsufLocation@129();
    BEGIN
      TestUIAvailToReserve(Item.Reserve::Optional,-10,FALSE,TRUE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,InsufSupplyMessagHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveInsufVariant@131();
    BEGIN
      TestUIAvailToReserve(Item.Reserve::Optional,-10,TRUE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(AvailToResModalHandler,AvailILEModalHandler,AvailPOModalHandler,AvailAOModalHandler,AvailabilityWindowHandler)]
    PROCEDURE AvailToReserveNegativeFullyRes@202();
    BEGIN
      ASSERTERROR
        TestUIAvailToReserve(Item.Reserve::Optional,0,FALSE,FALSE,0,TRUE);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ErrorFullyReserved) > 0,'Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Normal]
    LOCAL PROCEDURE TestUIReserveCancel@110(FilterOnVariant@1012 : Boolean;FilterOnLocation@1013 : Boolean;DueDateDelay@1010 : Integer;CancelReservation@1011 : Boolean;SourceType@1014 : Integer;ReserveTwice@1000 : Boolean);
    VAR
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      AvailToReserve@1005 : Decimal;
      Qty@1009 : Decimal;
    BEGIN
      // Setup Reservations.
      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Item.Reserve::Optional,0,
        FilterOnVariant,FilterOnLocation,DueDateDelay,1);
      GlobalCancelReservation := CancelReservation;
      GlobalSourceType := SourceType;

      // Exercise: Auto reserve record using the page triggers.
      GlobalSupply := GetTotalAvailSupply(TempReservationEntry,Qty,AssemblyLine."Location Code",
          AssemblyLine."Variant Code",AssemblyLine."Due Date",SourceType);
      GlobalReserveTwice := ReserveTwice;

      AssemblyLine.ShowReservation;
      // Reservation page handler is triggered.
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveLocationILE@147();
    BEGIN
      TestUIReserveCancel(FALSE,TRUE,0,FALSE,32,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveVariantILE@146();
    BEGIN
      TestUIReserveCancel(TRUE,FALSE,0,FALSE,32,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveDueDateILE@149();
    BEGIN
      TestUIReserveCancel(FALSE,FALSE,5,FALSE,32,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveVarLocILE@148();
    BEGIN
      TestUIReserveCancel(TRUE,TRUE,0,FALSE,32,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveLocationPO@153();
    BEGIN
      TestUIReserveCancel(FALSE,TRUE,0,FALSE,39,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveVariantPO@152();
    BEGIN
      TestUIReserveCancel(TRUE,FALSE,0,FALSE,39,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveDueDatePO@151();
    BEGIN
      TestUIReserveCancel(FALSE,FALSE,5,FALSE,39,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveVarLocPO@150();
    BEGIN
      TestUIReserveCancel(TRUE,TRUE,0,FALSE,39,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveLocationAO@158();
    BEGIN
      TestUIReserveCancel(FALSE,TRUE,0,FALSE,900,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveVariantAO@157();
    BEGIN
      TestUIReserveCancel(TRUE,FALSE,0,FALSE,900,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveDueDateAO@155();
    BEGIN
      TestUIReserveCancel(FALSE,FALSE,5,FALSE,900,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE ReserveVarLocAO@154();
    BEGIN
      TestUIReserveCancel(TRUE,TRUE,0,FALSE,900,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,CancelResConfirmHandler,AvailabilityWindowHandler)]
    PROCEDURE CancelAO@161();
    BEGIN
      TestUIReserveCancel(TRUE,TRUE,0,TRUE,900,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,CancelResConfirmHandler,AvailabilityWindowHandler)]
    PROCEDURE CancelPO@165();
    BEGIN
      TestUIReserveCancel(TRUE,TRUE,0,TRUE,39,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,CancelResConfirmHandler,AvailabilityWindowHandler)]
    PROCEDURE CancelILE@166();
    BEGIN
      TestUIReserveCancel(TRUE,TRUE,0,TRUE,32,FALSE);
    END;

    [Test]
    [HandlerFunctions(ReserveCancelModalHandler,AvailabilityWindowHandler)]
    PROCEDURE NegativeReserveILETwice@190();
    BEGIN
      ASSERTERROR
        TestUIReserveCancel(FALSE,TRUE,0,FALSE,32,TRUE);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ErrorNotAvail) > 0,'Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Normal]
    LOCAL PROCEDURE TestChangeLine@19(AssemblyLineFieldNo@1009 : Integer;PositiveTest@1011 : Boolean;ExcessSupply@1013 : Decimal;SupplyDelayFactor@1003 : Integer;Multiplicity@1010 : Integer);
    VAR
      AssemblyHeader@1002 : Record 900;
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      ReservMgt@1004 : Codeunit 99000845;
      NewFieldValue@1006 : Variant;
      AvailToReserve@1005 : Decimal;
      DueDateDelay@1012 : Integer;
      FullAutoReservation@1000 : Boolean;
    BEGIN
      // Setup Reservations.
      // If Due Date is changed, ensure supply outside the initial filters is created.
      IF (AssemblyLine.FIELDNO("Due Date") = AssemblyLineFieldNo) AND PositiveTest THEN
        DueDateDelay := 30;

      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Item.Reserve::Optional,ExcessSupply,
        AssemblyLine.FIELDNO("Variant Code") = AssemblyLineFieldNo,
        AssemblyLine.FIELDNO("Location Code") = AssemblyLineFieldNo,
        DueDateDelay,Multiplicity);

      AssemblyHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");
      ReservMgt.SetAssemblyHeader(AssemblyHeader);
      ReservMgt.SetAssemblyLine(AssemblyLine);
      ReservMgt.AutoReserve(FullAutoReservation,'',AssemblyLine."Due Date",AssemblyLine.Quantity,AssemblyLine."Quantity (Base)");

      // Exercise: Update Assembly Line.
      SetSupplyFilters(NewFieldValue,TempReservationEntry,AssemblyLine,AssemblyLineFieldNo,PositiveTest,
        SupplyDelayFactor * RANDOM(DueDateDelay));
      UpdateAssemblyLine(AssemblyLine,AssemblyLineFieldNo,NewFieldValue);

      // Update TempReservationEntry based on the new line, using SetQtyToReserve.
      AssemblyLine.GET(AssemblyLine."Document Type",AssemblyLine."Document No.",AssemblyLine."Line No.");
      UpdateSupplyLines(TempReservationEntry,AvailToReserve,AssemblyLine);

      // Validate: Reservation entries and Reserved Qty on Assembly Line.
      // If no eligible supply was created initially, we don't expect any reservation to be made after the line change.
      IF Multiplicity = 0 THEN BEGIN
        TempReservationEntry.RESET;
        TempReservationEntry.DELETEALL;
        AvailToReserve := 0;
      END;

      AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(AvailToReserve,AssemblyLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,'Wrong Res. Qty');
      AssemblyLine.TESTFIELD("Reserved Quantity",AssemblyLine."Reserved Qty. (Base)" * AssemblyLine."Qty. per Unit of Measure");
      VerifyReservationEntries(TempReservationEntry,AssemblyLine);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdateLocationPosOptional@72();
    BEGIN
      TestChangeLine(AssemblyLine.FIELDNO("Location Code"),TRUE,0,0,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdateLocationPosOptPartial@89();
    BEGIN
      TestChangeLine(AssemblyLine.FIELDNO("Location Code"),TRUE,-LibraryRandom.RandIntInRange(7,50),0,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdateLocationNegOptional@67();
    BEGIN
      ASSERTERROR
        TestChangeLine(AssemblyLine.FIELDNO("Location Code"),FALSE,0,0,1);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,STRSUBSTNO(ErrorChangeLine,'Location Code')) > 0,'Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdateVariantPosOptional@65();
    BEGIN
      TestChangeLine(AssemblyLine.FIELDNO("Variant Code"),TRUE,0,0,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdateVariantPosOptPartial@90();
    BEGIN
      TestChangeLine(AssemblyLine.FIELDNO("Variant Code"),TRUE,-LibraryRandom.RandIntInRange(7,50),0,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdateVariantNegOptional@64();
    BEGIN
      ASSERTERROR
        TestChangeLine(AssemblyLine.FIELDNO("Variant Code"),FALSE,0,0,1);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ErrorResQty) > 0,'Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdDueDatePosOptUnavailSupply@92();
    BEGIN
      TestChangeLine(AssemblyLine.FIELDNO("Due Date"),TRUE,0,-1,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdDueDatePosOptAvailSupply@124();
    BEGIN
      TestChangeLine(AssemblyLine.FIELDNO("Due Date"),TRUE,0,1,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler,DueDateBeforeWorkDate)]
    PROCEDURE UpdateDueDateNegOptional@109();
    BEGIN
      TestChangeLine(AssemblyLine.FIELDNO("Due Date"),FALSE,0,1,2);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdateTypeNegOptional@94();
    BEGIN
      // Bug in VerifyChange: xRec.Type <> Rec.Type is not handled.
      ASSERTERROR
        TestChangeLine(AssemblyLine.FIELDNO(Type),FALSE,0,0,1);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,STRSUBSTNO(ErrorChangeLine,'Type')) > 0,'Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdateNoNegOptional@96();
    BEGIN
      ASSERTERROR
        TestChangeLine(AssemblyLine.FIELDNO("No."),FALSE,0,0,1);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,STRSUBSTNO(ErrorChangeLine,'No.')) > 0,'Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Normal]
    LOCAL PROCEDURE TestChangeLineQty@31(Reserve@1003 : Option;ExcessSupply@1009 : Decimal;NewQtyDelta@1010 : Decimal);
    VAR
      AssemblyHeader@1004 : Record 900;
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      ReservMgt@1000 : Codeunit 99000845;
      AvailToReserve@1005 : Decimal;
      FullAutoReservation@1002 : Boolean;
    BEGIN
      // Setup Reservations.
      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Reserve,ExcessSupply,FALSE,FALSE,0,2);
      AssemblyHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");
      ReservMgt.SetAssemblyHeader(AssemblyHeader);
      ReservMgt.SetAssemblyLine(AssemblyLine);
      ReservMgt.AutoReserve(FullAutoReservation,'',AssemblyLine."Due Date",AssemblyLine.Quantity,AssemblyLine."Quantity (Base)");

      // Exercise: Update Assembly Line.
      UpdateAssemblyLine(AssemblyLine,AssemblyLine.FIELDNO("Quantity (Base)"),AssemblyLine."Quantity (Base)" + NewQtyDelta);

      // Update TempReservationEntry based on the new line, using SetQtyToReserve.
      AssemblyLine.GET(AssemblyLine."Document Type",AssemblyLine."Document No.",AssemblyLine."Line No.");
      IF (NewQtyDelta < 0) OR ((Reserve <> Item.Reserve::Optional) AND (NewQtyDelta > 0)) THEN
        UpdateSupplyLines(TempReservationEntry,AvailToReserve,AssemblyLine);

      // Validate: Reservation entries and Reserved Qty on Assembly Line.
      AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(AvailToReserve,AssemblyLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,'Wrong Res. Qty');
      AssemblyLine.TESTFIELD("Reserved Quantity",AssemblyLine."Reserved Qty. (Base)" * AssemblyLine."Qty. per Unit of Measure");
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE IncrQtyFullyResOptional@132();
    VAR
      ExcessSupply@1000 : Decimal;
    BEGIN
      ExcessSupply := LibraryRandom.RandIntInRange(7,50);
      TestChangeLineQty(Item.Reserve::Optional,ExcessSupply,LibraryRandom.RandInt(ExcessSupply - 1));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE IncrQtyPartialResOptional@134();
    VAR
      ExcessSupply@1000 : Decimal;
    BEGIN
      ExcessSupply := LibraryRandom.RandIntInRange(7,50);
      TestChangeLineQty(Item.Reserve::Optional,ExcessSupply,ExcessSupply + LibraryRandom.RandInt(25));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE DecrQtyAboveAvailOptional@135();
    VAR
      ExcessSupply@1000 : Decimal;
    BEGIN
      ExcessSupply := LibraryRandom.RandIntInRange(7,50);
      TestChangeLineQty(Item.Reserve::Optional,-ExcessSupply,-LibraryRandom.RandInt(ExcessSupply - 1));
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE DecrQtyBelowAvailOptional@136();
    VAR
      ExcessSupply@1000 : Decimal;
    BEGIN
      ExcessSupply := LibraryRandom.RandIntInRange(7,50);
      TestChangeLineQty(Item.Reserve::Optional,-ExcessSupply,-ExcessSupply - LibraryRandom.RandInt(25));
    END;

    [Normal]
    LOCAL PROCEDURE TestDeleteLine@52(Reserve@1003 : Option);
    VAR
      AssemblyHeader@1000 : Record 900;
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      ReservMgt@1004 : Codeunit 99000845;
      FullAutoReservation@1006 : Boolean;
      AvailToReserve@1005 : Decimal;
    BEGIN
      // Setup Reservations.
      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Reserve,0,FALSE,FALSE,0,2);
      AssemblyHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");
      ReservMgt.SetAssemblyHeader(AssemblyHeader);
      ReservMgt.SetAssemblyLine(AssemblyLine);
      ReservMgt.AutoReserve(FullAutoReservation,'',AssemblyLine."Due Date",AssemblyLine.Quantity,AssemblyLine."Quantity (Base)");

      // Exercise: Update Assembly Line.
      AssemblyLine.DELETE(TRUE);
      AvailToReserve := 0;
      TempReservationEntry.DELETEALL;

      // Validate: Reservation entries and Reserved Qty on Assembly Line.
      AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(AvailToReserve,AssemblyLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,'Wrong Res. Qty');
      AssemblyLine.TESTFIELD("Reserved Quantity",AssemblyLine."Reserved Qty. (Base)" * AssemblyLine."Qty. per Unit of Measure");
      VerifyReservationEntries(TempReservationEntry,AssemblyLine);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE DeleteLineOptional@156();
    BEGIN
      TestDeleteLine(Item.Reserve::Optional);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE DeleteLineAlways@159();
    BEGIN
      TestDeleteLine(Item.Reserve::Always);
    END;

    [Normal]
    LOCAL PROCEDURE TestChangeHeader@162(AssemblyHeaderFieldNo@1009 : Integer;PositiveTest@1011 : Boolean;ExcessSupply@1013 : Decimal;SupplyDelayFactor@1003 : Integer;Multiplicity@1010 : Integer);
    VAR
      AssemblyHeader@1002 : Record 900;
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      ReservMgt@1004 : Codeunit 99000845;
      NewFieldValue@1006 : Variant;
      AvailToReserve@1005 : Decimal;
      DueDateDelay@1012 : Integer;
      FullAutoReservation@1000 : Boolean;
    BEGIN
      // Setup Reservations.
      // If Due Date is changed, ensure supply outside the initial filters is created.
      IF (AssemblyHeader.FIELDNO("Due Date") = AssemblyHeaderFieldNo) AND PositiveTest THEN
        DueDateDelay := 30;

      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Item.Reserve::Optional,ExcessSupply,
        FALSE,AssemblyHeader.FIELDNO("Location Code") = AssemblyHeaderFieldNo,DueDateDelay,Multiplicity);

      AssemblyHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");
      ReservMgt.SetAssemblyHeader(AssemblyHeader);
      ReservMgt.SetAssemblyLine(AssemblyLine);
      ReservMgt.AutoReserve(FullAutoReservation,'',AssemblyLine."Due Date",AssemblyLine.Quantity,AssemblyLine."Quantity (Base)");

      // Exercise: Update Assembly Header.
      SetHeaderSupplyFilters(NewFieldValue,TempReservationEntry,AssemblyHeader,AssemblyHeaderFieldNo,PositiveTest,
        SupplyDelayFactor * RANDOM(DueDateDelay));
      UpdateAssemblyHeader(AssemblyHeader,AssemblyHeaderFieldNo,NewFieldValue);

      // Update TempReservationEntry based one the new line, using SetQtyToReserve.
      IF (Multiplicity = 0) OR (AssemblyHeaderFieldNo = AssemblyHeader.FIELDNO("Item No."))
      THEN BEGIN
        TempReservationEntry.RESET;
        TempReservationEntry.DELETEALL;
        AvailToReserve := 0;
      END
      ELSE
        IF (NOT PositiveTest) AND (AssemblyHeaderFieldNo = AssemblyHeader.FIELDNO(Quantity)) THEN BEGIN
          AssemblyLine.GET(AssemblyLine."Document Type",AssemblyLine."Document No.",AssemblyLine."Line No.");
          UpdateSupplyLines(TempReservationEntry,AvailToReserve,AssemblyLine);
        END;

      // Validate: Reservation entries and Reserved Qty on Assembly Line.
      AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(AvailToReserve,AssemblyLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,'Wrong Res. Qty');
      AssemblyLine.TESTFIELD("Reserved Quantity",AssemblyLine."Reserved Qty. (Base)" * AssemblyLine."Qty. per Unit of Measure");
      VerifyReservationEntries(TempReservationEntry,AssemblyLine);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdHdrLocationPosOptional@75();
    BEGIN
      TestChangeHeader(AssemblyHeader.FIELDNO("Location Code"),TRUE,0,0,0);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdHdrLocationPosOptPartial@74();
    BEGIN
      TestChangeHeader(AssemblyHeader.FIELDNO("Location Code"),TRUE,-LibraryRandom.RandIntInRange(7,50),0,0);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdHdrLocationNegOptional@73();
    BEGIN
      ASSERTERROR
        TestChangeHeader(AssemblyHeader.FIELDNO("Location Code"),FALSE,0,0,1);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,STRSUBSTNO(ErrorChangeLine,'Location Code')) > 0,'Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdHdrDDatePosOptUnavailSupply@61();
    BEGIN
      TestChangeLine(AssemblyLine.FIELDNO("Due Date"),TRUE,0,-1,0);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdHdrDueDatePosOptAvailSupply@60();
    BEGIN
      TestChangeHeader(AssemblyHeader.FIELDNO("Due Date"),TRUE,0,1,0);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdHdrItemNoNegOptional@56();
    BEGIN
      TestChangeHeader(AssemblyHeader.FIELDNO("Item No."),FALSE,0,0,2);
    END;

    [Test]
    [HandlerFunctions(AvailabilityWindowHandler)]
    PROCEDURE UpdHdrQtyPosOptional@82();
    BEGIN
      TestChangeHeader(AssemblyHeader.FIELDNO(Quantity),TRUE,0,0,2);
    END;

    [Normal]
    LOCAL PROCEDURE TestSalesLineReserve@86(Reserve@1003 : Option;ExcessSupply@1008 : Decimal;FilterOnVariant@1012 : Boolean;FilterOnLocation@1013 : Boolean;DueDateDelay@1010 : Integer;ReserveSalesLineFirst@1011 : Boolean) : Code[20];
    VAR
      AssemblyHeader@1000 : Record 900;
      AssemblyLine@1001 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      SalesHeader@1002 : Record 36;
      SalesLine@1009 : Record 37;
      ReservMgt@1004 : Codeunit 99000845;
      ExpectedSalesResQty@1014 : Decimal;
      ExpectedAsyResQty@1015 : Decimal;
      AvailToReserve@1005 : Decimal;
      AvailToReserve2@1017 : Decimal;
      RemainingQty@1016 : Decimal;
      FullAutoReservation@1006 : Boolean;
    BEGIN
      // Setup Reservations.
      Initialize;
      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Reserve,ExcessSupply,
        FilterOnVariant,FilterOnLocation,DueDateDelay,2);

      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,'');
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,AssemblyLine."No.",AssemblyLine.Quantity);
      SalesLine.VALIDATE("Variant Code",AssemblyLine."Variant Code");
      SalesLine.VALIDATE("Location Code",AssemblyLine."Location Code");
      SalesLine.VALIDATE("Shipment Date",AssemblyLine."Due Date");
      SalesLine.MODIFY(TRUE);

      // Exercise: Reserve Sales Line, Assembly Line in the specified order.
      IF ReserveSalesLineFirst THEN
        LibrarySales.AutoReserveSalesLine(SalesLine);

      AssemblyHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");
      ReservMgt.SetAssemblyHeader(AssemblyHeader);
      ReservMgt.SetAssemblyLine(AssemblyLine);
      ReservMgt.AutoReserve(FullAutoReservation,'',AssemblyLine."Due Date",AssemblyLine.Quantity,AssemblyLine."Quantity (Base)");

      IF NOT ReserveSalesLineFirst THEN
        LibrarySales.AutoReserveSalesLine(SalesLine);

      // Validate: Reserved Qty on Sales Line.
      RemainingQty :=
        GetTotalAvailSupply(TempReservationEntry,AvailToReserve2,AssemblyLine."Location Code",AssemblyLine."Variant Code",
          AssemblyLine."Due Date",0) - AvailToReserve;

      IF ReserveSalesLineFirst THEN BEGIN
        ExpectedSalesResQty := AvailToReserve;
        IF RemainingQty < 0 THEN
          ExpectedAsyResQty := 0
        ELSE
          ExpectedAsyResQty :=
            (AssemblyLine."Quantity (Base)" + RemainingQty - ABS(AssemblyLine."Quantity (Base)" - RemainingQty)) / 2;
      END ELSE BEGIN
        ExpectedAsyResQty := AvailToReserve;
        IF RemainingQty < 0 THEN
          ExpectedSalesResQty := 0
        ELSE
          ExpectedSalesResQty := (SalesLine."Quantity (Base)" + RemainingQty - ABS(SalesLine."Quantity (Base)" - RemainingQty)) / 2;
      END;

      // Raise Reservation page in case the remaining qty to reserve from the demand is positive.
      PAGE.RUNMODAL(PAGE::Reservation);

      SalesLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(ExpectedSalesResQty,SalesLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,
        'Wrong Res. Qty Sales Line');
      AssemblyLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(ExpectedAsyResQty,AssemblyLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,
        'Wrong Res. Qty Assembly Line');

      EXIT(SalesHeader."No.");
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE PosOptionalAssemblyFirst@91();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Optional,LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE NegOptionalAssemblyFirst@95();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Optional,-LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE PosAlwaysAssemblyFirst@98();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Always,LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE NegAlwaysAssemblyFirst@97();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Always,-LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE PosOptionalAssemblyFirstLoc@100();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Optional,LibraryRandom.RandIntInRange(7,50),TRUE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE NegOptionalAssemblyFirstVar@99();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Optional,-LibraryRandom.RandIntInRange(7,50),FALSE,TRUE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE PosOptionalAssemblyFirstDDate@102();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Optional,LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,2,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE NegOptionalAssemblyFirstDDate@101();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Optional,-LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,2,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE PosAlwaysAssemblyFirstVar@104();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Always,LibraryRandom.RandIntInRange(7,50),FALSE,TRUE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE NegAlwaysAssemblyFirstLoc@103();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Always,-LibraryRandom.RandIntInRange(7,50),TRUE,FALSE,0,FALSE);
    END;

    [Test]
    [HandlerFunctions(ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE PosOptionalSalesFirst@106();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Optional,LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,0,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE NegAlwaysSalesFirst@105();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Always,-LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,0,TRUE);
    END;

    [Test]
    [HandlerFunctions(ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE PosOptionalLocSalesFirst@108();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Optional,LibraryRandom.RandIntInRange(7,50),TRUE,FALSE,0,TRUE);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE NegOptionalDDateSalesFirst@107();
    BEGIN
      TestSalesLineReserve(Item.Reserve::Optional,-LibraryRandom.RandIntInRange(7,50),FALSE,FALSE,7,TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE PostOptionalSalesLine@93(PositiveTest@1007 : Boolean);
    VAR
      SalesHeader@1000 : Record 36;
      SalesLine@1001 : Record 37;
      Item@1002 : Record 27;
      ReservationEntry@1003 : Record 337;
      QtyToPost@1008 : Decimal;
    BEGIN
      // Setup: Create a Supply - Demand pair between a Sales Line and an Assembly Header.
      SalesHeader.GET(SalesHeader."Document Type"::Order,TestSalesLineReserve(Item.Reserve::Optional,0,FALSE,FALSE,0,TRUE));
      SalesLine.SETRANGE("Document Type",SalesHeader."Document Type");
      SalesLine.SETRANGE("Document No.",SalesHeader."No.");
      SalesLine.SETRANGE(Type,SalesLine.Type::Item);
      SalesLine.FINDFIRST;

      SalesLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Item.GET(SalesLine."No.");
      Item.CALCFIELDS(Inventory);

      // Exercise: Try to post reservations on sales header.
      IF PositiveTest THEN
        QtyToPost := Item.Inventory
      ELSE
        QtyToPost := LibraryRandom.RandIntInRange(Item.Inventory,Item.Inventory + 10);

      SalesLine.VALIDATE("Qty. to Ship (Base)",QtyToPost);
      SalesLine.MODIFY(TRUE);
      LibrarySales.PostSalesDocument(SalesHeader,TRUE,FALSE);

      // Validate: No ILE reservation entries remaining.
      FindReservationEntries(ReservationEntry,TRUE,SalesLine."No.",32,'');
      Assert.AreEqual(0,ReservationEntry.COUNT,'There are reservation entries remaining against ILEs.');
    END;

    [Test]
    [HandlerFunctions(ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE PostSalesLinePos@141();
    BEGIN
      PostOptionalSalesLine(TRUE);
    END;

    [Test]
    [HandlerFunctions(ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE PostSalesLineNeg@142();
    BEGIN
      ASSERTERROR PostOptionalSalesLine(FALSE);
      Assert.IsTrue(STRPOS(GETLASTERRORTEXT,ErrorInventory) > 0,'Actual:' + GETLASTERRORTEXT);
      CLEARLASTERROR;
    END;

    [Test]
    [HandlerFunctions(ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE PostOptionalAssemblyHeader@137();
    VAR
      SalesHeader@1000 : Record 36;
      SalesLine@1001 : Record 37;
      AssemblyHeader@1006 : Record 900;
      Item@1002 : Record 27;
      ReservationEntry@1003 : Record 337;
      PostedQty@1005 : Decimal;
      InitialResQty@1004 : Decimal;
      SourceID@1007 : Code[20];
    BEGIN
      // Setup: Create a Supply - Demand pair between a Sales Line and an Assembly Header.
      Initialize;

      SalesHeader.GET(SalesHeader."Document Type"::Order,TestSalesLineReserve(Item.Reserve::Optional,0,FALSE,FALSE,0,TRUE));
      SalesLine.SETRANGE("Document Type",SalesHeader."Document Type");
      SalesLine.SETRANGE("Document No.",SalesHeader."No.");
      SalesLine.SETRANGE(Type,SalesLine.Type::Item);
      SalesLine.FINDFIRST;

      SalesLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Item.GET(SalesLine."No.");
      Item.CALCFIELDS(Inventory);

      FindReservationEntries(ReservationEntry,TRUE,SalesLine."No.",900,'');
      ReservationEntry.FINDFIRST;
      PostedQty := ReservationEntry."Quantity (Base)";
      SourceID := ReservationEntry."Source ID";
      InitialResQty := GetReservedQty(ReservationEntry);

      // Exercise: Post Supply: Assembly Order.
      AssemblyHeader.GET(AssemblyHeader."Document Type"::Order,SourceID);
      AssemblyHeader.VALIDATE("Quantity to Assemble",PostedQty / AssemblyHeader."Qty. per Unit of Measure");
      AssemblyHeader.MODIFY(TRUE);

      LibraryAssembly.CreateAssemblyLine(AssemblyHeader,AssemblyLine,AssemblyLine.Type::Item,AssemblyHeader."Item No.",
        Item."Base Unit of Measure",LibraryRandom.RandInt(20),0,'');
      LibraryAssembly.AddCompInventory(AssemblyHeader,WorkDate2,0);
      LibraryAssembly.PostAssemblyHeader(AssemblyHeader,'');

      // Validate: Reservation entry has been shifted to ILE.
      // No more Assembly Header reservation entries.
      FindReservationEntries(ReservationEntry,TRUE,SalesLine."No.",900,AssemblyHeader."No.");
      Assert.AreEqual(0,ReservationEntry.COUNT,'There are reservation entries remaining against the Assembly Header.');

      // Sum of qty reserved against ILEs shifts with posted header qty.
      FindReservationEntries(ReservationEntry,TRUE,SalesLine."No.",32,'');
      Assert.AreNearlyEqual(InitialResQty + PostedQty,GetReservedQty(ReservationEntry),LibraryERM.GetAmountRoundingPrecision,
        'Wrong shifted qty.');
    END;

    [Normal]
    LOCAL PROCEDURE TestChangeSalesLine@112(Reserve@1015 : Option;SalesLineFieldNo@1009 : Integer;PositiveTest@1011 : Boolean;ExcessSupply@1013 : Decimal;SupplyDelayFactor@1003 : Integer;Multiplicity@1010 : Integer);
    VAR
      SalesHeader@1002 : Record 36;
      SalesLine@1001 : Record 37;
      AssemblyLine@1014 : Record 901;
      TempReservationEntry@1007 : TEMPORARY Record 337;
      NewFieldValue@1006 : Variant;
      AvailToReserve@1005 : Decimal;
      DueDateDelay@1012 : Integer;
    BEGIN
      // Setup Reservations.
      // If Due Date is changed, ensure supply outside the initial filters is created.
      IF (SalesLine.FIELDNO("Shipment Date") = SalesLineFieldNo) AND PositiveTest THEN
        DueDateDelay := 30;

      SetupReservations(TempReservationEntry,AssemblyLine,AvailToReserve,Reserve,ExcessSupply,
        SalesLine.FIELDNO("Variant Code") = SalesLineFieldNo,
        SalesLine.FIELDNO("Location Code") = SalesLineFieldNo,
        DueDateDelay,Multiplicity);

      LibrarySales.CreateSalesHeader(SalesHeader,SalesHeader."Document Type"::Order,'');
      LibrarySales.CreateSalesLine(SalesLine,SalesHeader,SalesLine.Type::Item,AssemblyLine."No.",AvailToReserve);
      LibrarySales.AutoReserveSalesLine(SalesLine);

      // Exercise: Update Sales Line.
      SetSalesSupplyFilters(NewFieldValue,TempReservationEntry,SalesLine,SalesLineFieldNo,PositiveTest,
        SupplyDelayFactor * RANDOM(DueDateDelay));
      UpdateSalesLine(SalesLine,SalesLineFieldNo,NewFieldValue);

      // Update TempReservationEntry based one the new line, using SetQtyToReserve.
      UpdateSupplyLines(TempReservationEntry,AvailToReserve,AssemblyLine);

      // Validate: Reservation entries and Reserved Qty on Assembly Line.
      IF Reserve <> Item.Reserve::Always THEN BEGIN
        TempReservationEntry.RESET;
        TempReservationEntry.DELETEALL;
        AvailToReserve := 0;
      END;

      SalesLine.CALCFIELDS("Reserved Quantity","Reserved Qty. (Base)");
      Assert.AreNearlyEqual(AvailToReserve,SalesLine."Reserved Qty. (Base)",LibraryERM.GetAmountRoundingPrecision,'Wrong Res. Qty');
      SalesLine.TESTFIELD("Reserved Quantity",SalesLine."Reserved Qty. (Base)" * SalesLine."Qty. per Unit of Measure");
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdSalesLineLocPos@85();
    BEGIN
      TestChangeSalesLine(Item.Reserve::Optional,SalesLine.FIELDNO("Location Code"),TRUE,0,0,2);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdSalesLineVarPos@84();
    BEGIN
      TestChangeSalesLine(Item.Reserve::Optional,SalesLine.FIELDNO("Variant Code"),TRUE,0,0,1);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdSalesLineLocNeg@88();
    BEGIN
      TestChangeSalesLine(Item.Reserve::Optional,SalesLine.FIELDNO("Location Code"),FALSE,0,0,2);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdSalesLineVarNeg@87();
    BEGIN
      TestChangeSalesLine(Item.Reserve::Optional,SalesLine.FIELDNO("Variant Code"),FALSE,0,0,1);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdSalesLineDueDatePos@114();
    BEGIN
      TestChangeSalesLine(Item.Reserve::Optional,SalesLine.FIELDNO("Shipment Date"),TRUE,0,1,1);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,ShipmentDateMessageHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdSalesLineDueDateNeg@111();
    BEGIN
      TestChangeSalesLine(Item.Reserve::Optional,SalesLine.FIELDNO("Shipment Date"),FALSE,0,1,2);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdSalesLineQtyIncr@117();
    BEGIN
      TestChangeSalesLine(Item.Reserve::Optional,SalesLine.FIELDNO(Quantity),TRUE,0,0,2);
    END;

    [Test]
    [HandlerFunctions(ConfirmHandler,ResPageHandler,AvailabilityWindowHandler)]
    PROCEDURE UpdSalesLineQtyDecr@118();
    BEGIN
      TestChangeSalesLine(Item.Reserve::Optional,SalesLine.FIELDNO(Quantity),FALSE,0,0,1);
    END;

    [Normal]
    LOCAL PROCEDURE SetupReservations@14(VAR TempReservationEntry@1006 : TEMPORARY Record 337;VAR AssemblyLine@1010 : Record 901;VAR AvailToReserve@1005 : Decimal;Reserve@1004 : Option;ExcessSupply@1003 : Decimal;FilterOnVariant@1002 : Boolean;FilterOnLocation@1001 : Boolean;DueDateDelay@1000 : Integer;Multiplicity@1017 : Integer);
    VAR
      Item@1013 : Record 27;
      Location@1015 : Record 14;
      AssemblyHeader@1012 : Record 900;
      GenProdPostingGr@1009 : Code[10];
      AsmInvtPostingGr@1011 : Code[10];
      CompInvtPostingGr@1014 : Code[10];
      QtyFactor@1007 : Integer;
    BEGIN
      // Setup: Create Assembly structure and order.
      Initialize;
      LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
      LibraryAssembly.SetupPostingToGL(GenProdPostingGr,AsmInvtPostingGr,CompInvtPostingGr,Location.Code);
      LibraryAssembly.CreateItem(Item,Item."Costing Method"::Standard,Item."Replenishment System"::Assembly,
        GenProdPostingGr,AsmInvtPostingGr);
      LibraryAssembly.CreateAssemblyList(Item."Costing Method"::Standard,Item."No.",TRUE,2,2,0,1,GenProdPostingGr,CompInvtPostingGr);
      UpdateBOMReservationPolicy(Item."No.",Reserve);
      LibraryAssembly.CreateAssemblyHeader(
        AssemblyHeader,WorkDate2,Item."No.",Location.Code,50 + LibraryRandom.RandInt(50),'');
      AssemblyHeader.VALIDATE("Due Date",CALCDATE(ManufacturingSetup."Default Safety Lead Time",WorkDate2));
      AssemblyHeader.MODIFY(TRUE);

      // Find any item component line for the Assembly Order.
      AssemblyLine.SETRANGE("Document Type",AssemblyLine."Document Type"::Order);
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.NEXT(RANDOM(AssemblyLine.COUNT));
      AssemblyLine.VALIDATE("Quantity per",ROUND(AssemblyLine."Quantity per",1,'<'));
      AssemblyLine.MODIFY(TRUE);

      // Create an assortment of supply for the item: ILEs, Purchase Order, Firm Planned Prod. Order, Released Prod. Order.
      // 2 supply document sets that fit the actual Assembly Order Line.
      AvailToReserve := 0;
      IF Multiplicity <> 0 THEN
        QtyFactor := 3 * Multiplicity
      ELSE
        QtyFactor := 1;

      TempReservationEntry.DELETEALL;
      CreateSupplyLines(TempReservationEntry,AvailToReserve,AssemblyLine,AssemblyLine."Variant Code",AssemblyLine."Location Code",
        AssemblyLine."Due Date",ROUND((AssemblyLine."Quantity (Base)" + ExcessSupply) / QtyFactor,1,'>'),Multiplicity);

      // Create supply that falls outside the filter, as per the passed parameters.
      CreateFilterSupply(TempReservationEntry,AvailToReserve,AssemblyLine,FilterOnVariant,FilterOnLocation,DueDateDelay,ExcessSupply);
    END;

    [Normal]
    LOCAL PROCEDURE UpdateBOMReservationPolicy@1(ParentItemNo@1000 : Code[20];Reserve@1001 : Option);
    VAR
      Item@1002 : Record 27;
      BOMComponent@1003 : Record 90;
    BEGIN
      BOMComponent.SETRANGE("Parent Item No.",ParentItemNo);
      BOMComponent.SETRANGE(Type,BOMComponent.Type::Item);
      IF BOMComponent.FINDSET THEN
        REPEAT
          Item.GET(BOMComponent."No.");
          Item.VALIDATE(Reserve,Reserve);
          Item.MODIFY(TRUE);
        UNTIL BOMComponent.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE CreateSupplyLine@5(VAR TempReservationEntry@1011 : TEMPORARY Record 337;ItemNo@1000 : Code[20];VariantCode@1009 : Code[10];LocationCode@1010 : Code[10];DueDate@1008 : Date;Type@1001 : Option;Quantity@1002 : Decimal;QtyToReserve@1012 : Decimal);
    VAR
      PurchaseHeader@1003 : Record 38;
      PurchaseLine@1004 : Record 39;
      AssemblyHeader@1006 : Record 900;
    BEGIN
      CASE Type OF
        GlobalSupplyType::"Purchase Order":
          BEGIN
            LibraryPurchase.CreatePurchHeader(PurchaseHeader,PurchaseHeader."Document Type"::Order,'');
            LibraryPurchase.CreatePurchaseLine(PurchaseLine,PurchaseHeader,PurchaseLine.Type::Item,ItemNo,Quantity);
            PurchaseLine.VALIDATE("Variant Code",VariantCode);
            PurchaseLine.VALIDATE("Location Code",LocationCode);
            PurchaseLine.VALIDATE("Expected Receipt Date",DueDate);
            PurchaseLine.MODIFY(TRUE);
            CreateReservationEntry(TempReservationEntry,ItemNo,VariantCode,LocationCode,Quantity,QtyToReserve,39,PurchaseHeader."No.",
              PurchaseLine."Line No.",DueDate);
          END;
        GlobalSupplyType::"Assembly Order":
          BEGIN
            LibraryAssembly.CreateAssemblyHeader(AssemblyHeader,DueDate,ItemNo,LocationCode,Quantity,VariantCode);
            CreateReservationEntry(TempReservationEntry,ItemNo,VariantCode,LocationCode,Quantity,
              QtyToReserve,900,AssemblyHeader."No.",0,DueDate);
          END;
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CreateSupplyLines@7(VAR TempReservationEntry@1003 : TEMPORARY Record 337;VAR AvailToReserve@1004 : Decimal;AssemblyLine@1007 : Record 901;VariantCode@1008 : Code[10];LocationCode@1009 : Code[10];DueDate@1005 : Date;Qty@1010 : Decimal;Multiplicity@1002 : Integer);
    VAR
      i@1001 : Integer;
      j@1006 : Integer;
      QtyToReserve@1000 : Decimal;
    BEGIN
      // ILEs should not be created outside the due date filter, since they are always valid, even if posted with a later date.
      IF DueDate <= AssemblyLine."Due Date" THEN
        FOR i := 1 TO Multiplicity DO BEGIN
          QtyToReserve := Qty;
          AddCompInventory(TempReservationEntry,QtyToReserve,AvailToReserve,AssemblyLine."No.",VariantCode,LocationCode,AssemblyLine);
        END;

      FOR i := 0 TO 1 DO
        FOR j := 1 TO Multiplicity DO BEGIN
          QtyToReserve := Qty;
          SetQtyToReserve(QtyToReserve,AvailToReserve,AssemblyLine,AssemblyLine."No.",VariantCode,LocationCode,DueDate);
          CreateSupplyLine(TempReservationEntry,AssemblyLine."No.",VariantCode,LocationCode,DueDate,i,Qty,QtyToReserve);
        END;
    END;

    [Normal]
    LOCAL PROCEDURE UpdateSupplyLines@50(VAR TempReservationEntry@1003 : TEMPORARY Record 337;VAR AvailToReserve@1002 : Decimal;AssemblyLine@1007 : Record 901);
    BEGIN
      AvailToReserve := 0;

      // Update expected reserved qty. for ILE supply.
      UpdateSourceTypeLines(TempReservationEntry,AvailToReserve,AssemblyLine,32);

      // Update expected reserved qty. for Purchase Order supply.
      UpdateSourceTypeLines(TempReservationEntry,AvailToReserve,AssemblyLine,900);

      // Update expected reserved qty. for Assembly Header supply.
      UpdateSourceTypeLines(TempReservationEntry,AvailToReserve,AssemblyLine,39);
    END;

    [Normal]
    LOCAL PROCEDURE UpdateSourceTypeLines@53(VAR TempReservationEntry@1003 : TEMPORARY Record 337;VAR AvailToReserve@1002 : Decimal;AssemblyLine@1007 : Record 901;SourceType@1004 : Integer);
    VAR
      QtyToReserve@1000 : Decimal;
    BEGIN
      TempReservationEntry.RESET;
      TempReservationEntry.SETRANGE("Source Type",SourceType);
      IF TempReservationEntry.FINDSET THEN
        REPEAT
          QtyToReserve := TempReservationEntry."Qty. to Handle (Base)";

          // Shifting of due date is allowed for ILE reservation entries.
          IF (TempReservationEntry."Source Type" = 32) AND
             (TempReservationEntry."Expected Receipt Date" > AssemblyLine."Due Date")
          THEN
            TempReservationEntry."Expected Receipt Date" := AssemblyLine."Due Date";

          SetQtyToReserve(QtyToReserve,AvailToReserve,AssemblyLine,TempReservationEntry."Item No.",TempReservationEntry."Variant Code",
            TempReservationEntry."Location Code",TempReservationEntry."Expected Receipt Date");
          TempReservationEntry."Quantity (Base)" := QtyToReserve;
          TempReservationEntry.MODIFY(TRUE);

        UNTIL TempReservationEntry.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE SetQtyToReserve@59(VAR QtyToReserve@1000 : Decimal;VAR AvailToReserve@1005 : Decimal;AssemblyLine@1001 : Record 901;ItemNo@1006 : Code[20];VariantCode@1002 : Code[10];LocationCode@1003 : Code[10];DueDate@1004 : Date);
    BEGIN
      // Do not expect to reserve anything outside location, variant and due date filters.
      IF (AssemblyLine."Variant Code" <> VariantCode) OR
         (AssemblyLine."Location Code" <> LocationCode) OR
         (AssemblyLine."Due Date" < DueDate) OR
         (AssemblyLine."No." <> ItemNo)
      THEN
        QtyToReserve := 0;

      // Update total available to reserve qty. until we reach the assembly line quantity.
      IF AvailToReserve + QtyToReserve > AssemblyLine."Quantity (Base)" THEN BEGIN
        QtyToReserve := AssemblyLine."Quantity (Base)" - AvailToReserve;
        AvailToReserve := AssemblyLine."Quantity (Base)";
      END ELSE
        AvailToReserve += QtyToReserve;
    END;

    [Normal]
    LOCAL PROCEDURE SetSupplyFilters@51(VAR AssemblyLineFieldValue@1001 : Variant;VAR TempReservationEntry@1003 : TEMPORARY Record 337;VAR AssemblyLine@1006 : Record 901;AssemblyLineFieldNo@1000 : Integer;PositiveTest@1002 : Boolean;SupplyDelay@1007 : Integer);
    VAR
      Location@1004 : Record 14;
      ItemVariant@1005 : Record 5401;
    BEGIN
      // Positive test: Extract expected reservation entry that will drive the line update.
      TempReservationEntry.RESET;
      IF PositiveTest THEN
        CASE AssemblyLineFieldNo OF
          AssemblyLine.FIELDNO("Location Code"):
            BEGIN
              TempReservationEntry.SETFILTER("Location Code",'<>%1',AssemblyLine."Location Code");
              TempReservationEntry.FINDFIRST;
              AssemblyLineFieldValue := TempReservationEntry."Location Code";
            END;
          AssemblyLine.FIELDNO("Variant Code"):
            BEGIN
              TempReservationEntry.SETFILTER("Variant Code",'<>%1',AssemblyLine."Variant Code");
              TempReservationEntry.FINDFIRST;
              AssemblyLineFieldValue := TempReservationEntry."Variant Code";
            END;
          AssemblyLine.FIELDNO("Due Date"):
            BEGIN
              TempReservationEntry.SETFILTER("Expected Receipt Date",'>%1',AssemblyLine."Due Date");
              TempReservationEntry.FINDFIRST;
              AssemblyLineFieldValue := CALCDATE('<' + FORMAT(SupplyDelay,0,'<sign><integer>') + 'D>',
                  TempReservationEntry."Expected Receipt Date");
              AssemblyLine.SetTestReservationDateConflict(TRUE);
            END;
          AssemblyLine.FIELDNO(Type):
            AssemblyLineFieldValue := AssemblyLine.Type::Item;
          AssemblyLine.FIELDNO("No."):
            AssemblyLineFieldValue := AssemblyLine."No.";
        END
        // Negative test: Create new filter values so that nothing will be reserved after the line changes.
      ELSE
        CASE AssemblyLineFieldNo OF
          AssemblyLine.FIELDNO("Location Code"):
            BEGIN
              LibraryWarehouse.CreateLocation(Location);
              AssemblyLineFieldValue := Location.Code;
            END;
          AssemblyLine.FIELDNO("Variant Code"):
            BEGIN
              LibraryInventory.CreateItemVariant(ItemVariant,AssemblyLine."No.");
              AssemblyLineFieldValue := ItemVariant.Code;
            END;
          AssemblyLine.FIELDNO("Due Date"):
            BEGIN
              AssemblyLineFieldValue := CALCDATE('<-7D>',AssemblyLine."Due Date");
              AssemblyLine.SetTestReservationDateConflict(TRUE);
            END;
          AssemblyLine.FIELDNO(Type):
            AssemblyLineFieldValue := AssemblyLine.Type::Resource;
          AssemblyLine.FIELDNO("No."):
            AssemblyLineFieldValue := '';
        END;
    END;

    [Normal]
    LOCAL PROCEDURE SetHeaderSupplyFilters@163(VAR AssemblyHeaderFieldValue@1001 : Variant;VAR TempReservationEntry@1003 : TEMPORARY Record 337;AssemblyHeader@1006 : Record 900;AssemblyHeaderFieldNo@1000 : Integer;PositiveTest@1002 : Boolean;SupplyDelay@1007 : Integer);
    VAR
      Location@1004 : Record 14;
      ItemVariant@1005 : Record 5401;
    BEGIN
      // Positive test: Extract expected reservation entry that will drive the header update.
      TempReservationEntry.RESET;
      IF PositiveTest THEN
        CASE AssemblyHeaderFieldNo OF
          AssemblyHeader.FIELDNO("Location Code"):
            BEGIN
              TempReservationEntry.SETFILTER("Location Code",'<>%1',AssemblyHeader."Location Code");
              TempReservationEntry.FINDFIRST;
              AssemblyHeaderFieldValue := TempReservationEntry."Location Code";
            END;
          AssemblyHeader.FIELDNO("Variant Code"):
            BEGIN
              LibraryInventory.CreateItemVariant(ItemVariant,AssemblyHeader."Item No.");
              AssemblyHeaderFieldValue := ItemVariant.Code;
            END;
          AssemblyHeader.FIELDNO("Due Date"):
            BEGIN
              TempReservationEntry.SETFILTER("Expected Receipt Date",'>%1',AssemblyHeader."Due Date");
              TempReservationEntry.FINDFIRST;
              AssemblyHeaderFieldValue := CALCDATE('<' + FORMAT(SupplyDelay,0,'<sign><integer>') + 'D>',
                  TempReservationEntry."Expected Receipt Date");
            END;
          AssemblyHeader.FIELDNO("Item No."):
            AssemblyHeaderFieldValue := '';
          AssemblyHeader.FIELDNO(Quantity),AssemblyHeader."Quantity (Base)":
            AssemblyHeaderFieldValue := LibraryRandom.RandIntInRange(AssemblyHeader."Quantity (Base)" + 1,
                AssemblyHeader."Quantity (Base)" + 10);
        END
        // Negative test: Create new filter values so that nothing will be reserved after the header changes.
      ELSE
        CASE AssemblyHeaderFieldNo OF
          AssemblyHeader.FIELDNO("Location Code"):
            BEGIN
              LibraryWarehouse.CreateLocation(Location);
              AssemblyHeaderFieldValue := Location.Code;
            END;
          AssemblyHeader.FIELDNO("Variant Code"):
            BEGIN
              LibraryInventory.CreateItemVariant(ItemVariant,AssemblyHeader."No.");
              AssemblyHeaderFieldValue := ItemVariant.Code;
            END;
          AssemblyHeader.FIELDNO("Due Date"):
            AssemblyHeaderFieldValue := CALCDATE('<-7D>',AssemblyHeader."Starting Date");
          AssemblyHeader.FIELDNO("Item No."):
            AssemblyHeaderFieldValue := '';
          AssemblyHeader.FIELDNO(Quantity),AssemblyHeader."Quantity (Base)":
            AssemblyHeaderFieldValue := LibraryRandom.RandIntInRange(AssemblyHeader."Assembled Quantity (Base)",
                AssemblyHeader."Quantity (Base)" - 1);
        END;
    END;

    [Normal]
    LOCAL PROCEDURE SetSalesSupplyFilters@113(VAR SalesLineFieldValue@1001 : Variant;VAR TempReservationEntry@1003 : TEMPORARY Record 337;SalesLine@1006 : Record 37;SalesLineFieldNo@1000 : Integer;PositiveTest@1002 : Boolean;SupplyDelay@1007 : Integer);
    VAR
      Location@1004 : Record 14;
      ItemVariant@1005 : Record 5401;
    BEGIN
      // Positive test: Extract expected reservation entry that will drive the line update.
      TempReservationEntry.RESET;
      IF PositiveTest THEN
        CASE SalesLineFieldNo OF
          SalesLine.FIELDNO("Location Code"):
            BEGIN
              TempReservationEntry.SETFILTER("Location Code",'<>%1',SalesLine."Location Code");
              TempReservationEntry.FINDFIRST;
              SalesLineFieldValue := TempReservationEntry."Location Code";
            END;
          SalesLine.FIELDNO("Variant Code"):
            BEGIN
              LibraryInventory.CreateItemVariant(ItemVariant,SalesLine."No.");
              SalesLineFieldValue := ItemVariant.Code;
            END;
          SalesLine.FIELDNO("Shipment Date"):
            BEGIN
              TempReservationEntry.SETFILTER("Expected Receipt Date",'>%1',SalesLine."Shipment Date");
              TempReservationEntry.FINDFIRST;
              SalesLineFieldValue := CALCDATE('<' + FORMAT(SupplyDelay,0,'<sign><integer>') + 'D>',
                  TempReservationEntry."Expected Receipt Date");
            END;
          SalesLine.FIELDNO("No."):
            SalesLineFieldValue := '';
          SalesLine.FIELDNO(Quantity),AssemblyHeader."Quantity (Base)":
            SalesLineFieldValue := SalesLine.Quantity + LibraryRandom.RandInt(ROUND(SalesLine.Quantity,1,'=') - 1);
        END
        // Negative test: Create new filter values so that nothing will be reserved after the line changes.
      ELSE
        CASE SalesLineFieldNo OF
          SalesLine.FIELDNO("Location Code"):
            BEGIN
              LibraryWarehouse.CreateLocation(Location);
              SalesLineFieldValue := Location.Code;
            END;
          SalesLine.FIELDNO("Variant Code"):
            BEGIN
              LibraryInventory.CreateItemVariant(ItemVariant,SalesLine."No.");
              SalesLineFieldValue := ItemVariant.Code;
            END;
          SalesLine.FIELDNO("Shipment Date"):
            SalesLineFieldValue := CALCDATE('<-7D>',SalesLine."Shipment Date");
          SalesLine.FIELDNO("No."):
            SalesLineFieldValue := '';
          SalesLine.FIELDNO(Quantity),SalesLine."Quantity (Base)":
            SalesLineFieldValue := SalesLine.Quantity - LibraryRandom.RandInt(ROUND(SalesLine.Quantity,1,'=') - 1);
        END;
    END;

    [Normal]
    LOCAL PROCEDURE AddAssemblyLineOnPage@62(VAR AssemblyLine@1000 : Record 901);
    VAR
      AssemblyHeader@1003 : Record 900;
      AssemblyOrder@1001 : TestPage 900;
    BEGIN
      AssemblyHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");

      AssemblyOrder.OPENEDIT;
      AssemblyOrder.FILTER.SETFILTER("No.",AssemblyHeader."No.");
      AssemblyOrder.GOTORECORD(AssemblyHeader);

      // Add line again to trigger page triggers.
      AssemblyOrder.Lines.NEW;
      AssemblyOrder.Lines.Type.VALUE := 'Item';
      AssemblyOrder.Lines."No.".VALUE := AssemblyLine."No.";
      AssemblyOrder.Lines."Variant Code".VALUE := AssemblyLine."Variant Code";
      AssemblyOrder.Lines."Location Code".VALUE := AssemblyLine."Location Code";
      AssemblyOrder.Lines."Unit of Measure Code".VALUE := AssemblyLine."Unit of Measure Code";
      AssemblyOrder.Lines."Quantity per".VALUE := FORMAT(AssemblyLine."Quantity per",5);

      AssemblyOrder.CLOSE;

      // Fetch the line from the database for validation.
      AssemblyLine.RESET;
      AssemblyLine.SETRANGE("Document Type",AssemblyHeader."Document Type");
      AssemblyLine.SETRANGE("Document No.",AssemblyHeader."No.");
      AssemblyLine.SETRANGE(Type,AssemblyLine.Type::Item);
      AssemblyLine.SETRANGE("No.",AssemblyLine."No.");
      AssemblyLine.FINDLAST;
    END;

    [Normal]
    LOCAL PROCEDURE AddCompInventory@10(VAR TempReservationEntry@1005 : TEMPORARY Record 337;VAR Quantity@1007 : Decimal;VAR AvailToReserve@1011 : Decimal;ItemNo@1003 : Code[20];VariantCode@1004 : Code[10];LocationCode@1006 : Code[10];AssemblyLine@1008 : Record 901);
    VAR
      ItemJournalLine@1002 : Record 83;
      ItemJournalTemplate@1001 : Record 82;
      ItemJournalBatch@1000 : Record 233;
      ItemLedgerEntry@1009 : Record 32;
      QtyToReserve@1010 : Decimal;
    BEGIN
      IF Quantity <= 0 THEN
        EXIT;
      QtyToReserve := Quantity;

      // Post the desired quantity using item journal.
      LibraryAssembly.SetupItemJournal(ItemJournalTemplate,ItemJournalBatch);
      LibraryInventory.CreateItemJournalLine(ItemJournalLine,ItemJournalTemplate.Name,ItemJournalBatch.Name,
        ItemJournalLine."Entry Type"::"Positive Adjmt.",ItemNo,Quantity);
      ItemJournalLine.VALIDATE("Posting Date",AssemblyLine."Due Date");
      ItemJournalLine.VALIDATE("Document Date",AssemblyLine."Due Date");
      ItemJournalLine.VALIDATE("Location Code",LocationCode);
      ItemJournalLine.VALIDATE("Variant Code",VariantCode);
      ItemJournalLine.VALIDATE("Unit Cost",LibraryRandom.RandDec(50,2));
      ItemJournalLine.MODIFY(TRUE);
      LibraryInventory.PostItemJournalLine(ItemJournalTemplate.Name,ItemJournalBatch.Name);

      // Do not expect to reserve if location and variant do not match the assembly line.
      IF (VariantCode <> AssemblyLine."Variant Code") OR (LocationCode <> AssemblyLine."Location Code") THEN
        QtyToReserve := 0
      ELSE
        // Do not expect to reserve for more than the Assembly line quantity.
        IF AvailToReserve + Quantity > AssemblyLine."Quantity (Base)" THEN BEGIN
          QtyToReserve := AssemblyLine."Quantity (Base)" - AvailToReserve;
          AvailToReserve := AssemblyLine."Quantity (Base)";
        END ELSE
          AvailToReserve += QtyToReserve;

      // Construct expected reservation entry.
      ItemLedgerEntry.SETRANGE("Item No.",ItemNo);
      ItemLedgerEntry.SETRANGE("Entry Type",ItemLedgerEntry."Entry Type"::"Positive Adjmt.");
      ItemLedgerEntry.SETRANGE("Location Code",LocationCode);
      ItemLedgerEntry.SETRANGE("Variant Code",VariantCode);
      ItemLedgerEntry.SETRANGE("Document No.",ItemJournalLine."Document No.");
      ItemLedgerEntry.SETRANGE(Quantity,Quantity);
      ItemLedgerEntry.FINDFIRST;
      CreateReservationEntry(TempReservationEntry,ItemNo,VariantCode,LocationCode,Quantity,QtyToReserve,32,
        FORMAT(ItemLedgerEntry."Entry No."),ItemLedgerEntry."Entry No.",WorkDate2);

      Quantity := QtyToReserve;
    END;

    [Normal]
    LOCAL PROCEDURE FindReservationEntries@130(VAR ReservationEntry@1004 : Record 337;Positive@1000 : Boolean;ItemNo@1001 : Code[20];SourceType@1002 : Integer;SourceID@1003 : Code[20]);
    BEGIN
      ReservationEntry.RESET;
      ReservationEntry.SETRANGE(Positive,Positive);
      ReservationEntry.SETRANGE("Item No.",ItemNo);
      ReservationEntry.SETRANGE("Source Type",SourceType);
      IF SourceID <> '' THEN
        ReservationEntry.SETRANGE("Source ID",SourceID);
    END;

    [Normal]
    LOCAL PROCEDURE GetReservedQty@26(VAR ReservationEntry@1000 : Record 337) : Decimal;
    VAR
      ReservedQty@1001 : Decimal;
    BEGIN
      IF ReservationEntry.FINDSET THEN
        REPEAT
          ReservedQty += ReservationEntry."Quantity (Base)";
        UNTIL ReservationEntry.NEXT = 0;

      EXIT(ReservedQty);
    END;

    [Normal]
    LOCAL PROCEDURE VerifyReservationEntries@39(VAR TempReservationEntry@1000 : TEMPORARY Record 337;AssemblyLine@1002 : Record 901);
    VAR
      ReservationEntry@1001 : Record 337;
      ReservationEntry2@1003 : Record 337;
    BEGIN
      TempReservationEntry.SETFILTER("Quantity (Base)",'<>%1',0);
      // Group the reserved qty. per source type.
      // ILEs.
      VerifyReservedQty(TempReservationEntry,32);
      // Purchase Orders.
      VerifyReservedQty(TempReservationEntry,39);
      // Assembly Orders.
      VerifyReservedQty(TempReservationEntry,900);

      // Check the number of reservation entries.
      TempReservationEntry.RESET;
      TempReservationEntry.SETFILTER("Quantity (Base)",'<>%1',0);
      ReservationEntry.RESET;
      ReservationEntry.SETRANGE(Positive,TRUE);
      ReservationEntry.SETRANGE("Item No.",AssemblyLine."No.");
      ReservationEntry.SETRANGE("Location Code",AssemblyLine."Location Code");
      ReservationEntry.SETRANGE("Variant Code",AssemblyLine."Variant Code");
      Assert.AreEqual(TempReservationEntry.COUNT,ReservationEntry.COUNT,'Too many res. for ' + AssemblyLine."Document No.");

      // Verify the pairs of reservations entries are consistent.
      IF ReservationEntry.FINDSET THEN
        REPEAT
          ReservationEntry2.GET(ReservationEntry."Entry No.",FALSE);
          ReservationEntry2.TESTFIELD("Source Type",901);
          ReservationEntry2.TESTFIELD("Source ID",AssemblyLine."Document No.");
          ReservationEntry2.TESTFIELD("Source Ref. No.",AssemblyLine."Line No.");
          ReservationEntry2.TESTFIELD("Item No.",AssemblyLine."No.");
          ReservationEntry2.TESTFIELD("Variant Code",AssemblyLine."Variant Code");
          ReservationEntry2.TESTFIELD("Location Code",AssemblyLine."Location Code");
          ReservationEntry2.TESTFIELD("Reservation Status",ReservationEntry."Reservation Status"::Reservation);
          Assert.AreEqual(-ReservationEntry."Quantity (Base)",ReservationEntry2."Quantity (Base)",'Wrong Qty base.');
        UNTIL ReservationEntry.NEXT = 0;
    END;

    [Normal]
    LOCAL PROCEDURE VerifyReservedQty@123(VAR TempReservationEntry@1000 : TEMPORARY Record 337;SourceType@1002 : Integer);
    VAR
      ReservationEntry@1001 : Record 337;
      ExpectedQty@1003 : Decimal;
      ActualQty@1004 : Decimal;
    BEGIN
      TempReservationEntry.SETRANGE("Source Type",SourceType);
      IF TempReservationEntry.FINDSET THEN BEGIN
        ReservationEntry.RESET;
        ReservationEntry.SETRANGE(Positive,TRUE);
        ReservationEntry.SETRANGE("Source Type",TempReservationEntry."Source Type");
        ReservationEntry.SETRANGE("Item No.",TempReservationEntry."Item No.");
        ReservationEntry.SETRANGE("Variant Code",TempReservationEntry."Variant Code");
        ReservationEntry.SETRANGE("Location Code",TempReservationEntry."Location Code");
        ReservationEntry.SETRANGE("Reservation Status",ReservationEntry."Reservation Status"::Reservation);
        IF ReservationEntry.FINDSET THEN BEGIN
          Assert.AreEqual(TempReservationEntry.COUNT,ReservationEntry.COUNT,
            'Too many entries for source type ' + FORMAT(SourceType));
          ExpectedQty := 0;
          REPEAT
            ExpectedQty += TempReservationEntry."Quantity (Base)";
          UNTIL TempReservationEntry.NEXT = 0;

          ActualQty := 0;
          REPEAT
            ActualQty += ReservationEntry."Quantity (Base)";
          UNTIL ReservationEntry.NEXT = 0;

          Assert.AreEqual(ExpectedQty,ActualQty,'Wrong res. qty for source type ' + FORMAT(TempReservationEntry."Source Type"));
        END;
      END;
    END;

    [Normal]
    LOCAL PROCEDURE CreateReservationEntry@55(VAR TempReservationEntry@1000 : TEMPORARY Record 337;ItemNo@1001 : Code[20];VariantCode@1003 : Code[10];LocationCode@1002 : Code[10];Quantity@1010 : Decimal;QtyToReserve@1006 : Decimal;SourceType@1004 : Integer;SourceID@1005 : Code[20];SourceRefNo@1009 : Integer;ExpectedReceiptDate@1008 : Date);
    VAR
      LastEntryNo@1007 : Integer;
    BEGIN
      IF TempReservationEntry.FINDLAST THEN
        LastEntryNo := TempReservationEntry."Entry No.";

      TempReservationEntry.INIT;
      TempReservationEntry.VALIDATE("Entry No.",LastEntryNo + 1);
      TempReservationEntry.VALIDATE(Positive,TRUE);
      TempReservationEntry.VALIDATE("Item No.",ItemNo);
      TempReservationEntry.VALIDATE("Variant Code",VariantCode);
      TempReservationEntry.VALIDATE("Location Code",LocationCode);
      TempReservationEntry.VALIDATE("Quantity (Base)",ROUND(QtyToReserve,LibraryERM.GetUnitAmountRoundingPrecision));
      // Save overall supply line qty. in an unused field.
      TempReservationEntry.VALIDATE("Qty. to Handle (Base)",Quantity);
      TempReservationEntry.VALIDATE("Reservation Status",TempReservationEntry."Reservation Status"::Reservation);
      TempReservationEntry.VALIDATE("Source Type",SourceType);
      TempReservationEntry.VALIDATE("Expected Receipt Date",ExpectedReceiptDate);
      // Except for ILE reservation entries, the subtype is 1 = Order for normal documents.
      IF SourceType = 32 THEN
        TempReservationEntry.VALIDATE("Source Subtype",0)
      ELSE
        TempReservationEntry.VALIDATE("Source Subtype",1);
      TempReservationEntry.VALIDATE("Source ID",SourceID);
      TempReservationEntry.VALIDATE("Source Ref. No.",SourceRefNo);
      TempReservationEntry.INSERT(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE CreateFilterSupply@68(VAR TempReservationEntry@1009 : TEMPORARY Record 337;VAR AvailToReserve@1010 : Decimal;AssemblyLine@1003 : Record 901;FilterOnVariant@1002 : Boolean;FilterOnLocation@1006 : Boolean;DueDateDelay@1008 : Integer;ExcessSupply@1011 : Decimal);
    VAR
      ItemVariant@1004 : Record 5401;
      Location@1005 : Record 14;
      Item@1007 : Record 27;
      VariantCode@1001 : Code[10];
      LocationCode@1000 : Code[10];
    BEGIN
      Item.GET(AssemblyLine."No.");

      IF FilterOnVariant THEN BEGIN
        LibraryInventory.CreateVariant(ItemVariant,Item);
        VariantCode := ItemVariant.Code;
      END ELSE
        VariantCode := AssemblyLine."Variant Code";

      IF FilterOnLocation THEN BEGIN
        LibraryWarehouse.CreateLocationWithInventoryPostingSetup(Location);
        LocationCode := Location.Code;
      END ELSE
        LocationCode := AssemblyLine."Location Code";

      IF FilterOnVariant OR FilterOnLocation OR (DueDateDelay <> 0) THEN
        CreateSupplyLines(TempReservationEntry,AvailToReserve,AssemblyLine,VariantCode,LocationCode,
          CALCDATE('<' + FORMAT(DueDateDelay,0,'<sign><integer>') + 'D>',AssemblyLine."Due Date"),
          RANDOM(ROUND((AssemblyLine."Quantity (Base)" + ExcessSupply) / 3,1,'>')),1);
    END;

    [Normal]
    LOCAL PROCEDURE UpdateAssemblyLine@24(VAR AssemblyLine@1000 : Record 901;FieldNo@1001 : Integer;Value@1004 : Variant);
    VAR
      AsmHeader@1005 : Record 900;
      RecRef@1002 : RecordRef;
      FieldRef@1003 : FieldRef;
    BEGIN
      RecRef.GETTABLE(AssemblyLine);
      FieldRef := RecRef.FIELD(FieldNo);

      // Testability issue for Due Date field.
      AssemblyLine.SetTestReservationDateConflict(TRUE);
      IF FieldNo = AssemblyLine.FIELDNO("Due Date") THEN BEGIN
        AsmHeader.GET(AssemblyLine."Document Type",AssemblyLine."Document No.");
        AsmHeader."Starting Date" := CALCDATE(AssemblyLine."Lead-Time Offset",Value);
        AsmHeader.ValidateDates(AssemblyHeader.FIELDNO("Starting Date"),TRUE);
        AsmHeader.MODIFY(TRUE);
      END;
      FieldRef.VALIDATE(Value);

      RecRef.SETTABLE(AssemblyLine);
      AssemblyLine.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE UpdateAssemblyHeader@164(VAR AssemblyHeader@1000 : Record 900;FieldNo@1001 : Integer;Value@1004 : Variant);
    VAR
      RecRef@1002 : RecordRef;
      FieldRef@1003 : FieldRef;
    BEGIN
      RecRef.GETTABLE(AssemblyHeader);
      FieldRef := RecRef.FIELD(FieldNo);
      FieldRef.VALIDATE(Value);
      RecRef.SETTABLE(AssemblyHeader);
      AssemblyHeader.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE UpdateSalesLine@115(VAR SalesLine@1000 : Record 37;FieldNo@1001 : Integer;Value@1004 : Variant);
    VAR
      RecRef@1002 : RecordRef;
      FieldRef@1003 : FieldRef;
    BEGIN
      RecRef.GETTABLE(SalesLine);
      FieldRef := RecRef.FIELD(FieldNo);
      FieldRef.VALIDATE(Value);
      RecRef.SETTABLE(SalesLine);
      SalesLine.MODIFY(TRUE);
    END;

    [Normal]
    LOCAL PROCEDURE GetTotalAvailSupply@119(VAR TempReservationEntry@1000 : TEMPORARY Record 337;VAR AvailToReserve@1006 : Decimal;LocationCode@1002 : Code[10];VariantCode@1003 : Code[10];DueDate@1004 : Date;SourceType@1005 : Integer) : Decimal;
    VAR
      AvailableSupply@1001 : Decimal;
    BEGIN
      TempReservationEntry.RESET;
      TempReservationEntry.SETRANGE("Location Code",LocationCode);
      TempReservationEntry.SETRANGE("Variant Code",VariantCode);
      IF SourceType <> 0 THEN
        TempReservationEntry.SETRANGE("Source Type",SourceType);

      IF TempReservationEntry.FINDSET THEN
        REPEAT
          IF ((TempReservationEntry."Source Type" <> 32) AND (TempReservationEntry."Expected Receipt Date" <= DueDate)) OR
             (TempReservationEntry."Source Type" = 32)
          THEN BEGIN
            AvailToReserve += TempReservationEntry."Quantity (Base)";
            AvailableSupply += TempReservationEntry."Qty. to Handle (Base)";
          END;
        UNTIL TempReservationEntry.NEXT = 0;

      EXIT(AvailableSupply)
    END;

    [Normal]
    LOCAL PROCEDURE VerifyEntrySummary@66(Reservation@1004 : TestPage 498;ExpectedTotalQty@1001 : Text[30];ExpectedAvailQty@1000 : Text[30];ExpectedSummaryType@1002 : Text[30]);
    BEGIN
      Assert.IsTrue(STRPOS(Reservation."Summary Type".VALUE,ExpectedSummaryType) > 0,
        'Expected: ' + ExpectedSummaryType + ' Actual: ' + Reservation."Summary Type".VALUE);
      Assert.AreEqual(ExpectedTotalQty,Reservation."Total Quantity".VALUE,'Wrong total qty for ' + ExpectedSummaryType);
      Assert.AreEqual(ExpectedAvailQty,Reservation.TotalAvailableQuantity.VALUE,'Wrong avail qty for ' + ExpectedSummaryType);
    END;

    [ModalPageHandler]
    PROCEDURE ResEntryPageHandler@9(VAR ReservationEntries@1000 : Page 497;VAR Response@1003 : Action);
    BEGIN
      Response := ACTION::None;
    END;

    [ModalPageHandler]
    PROCEDURE ResPageHandler@4(VAR Reservation@1000 : Page 498;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::LookupOK;
    END;

    [ConfirmHandler]
    PROCEDURE ConfirmHandler@54(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Reply := TRUE;
    END;

    [MessageHandler]
    PROCEDURE ShipmentDateMessageHandler@80(Message@1000 : Text[1024]);
    BEGIN
    END;

    [ModalPageHandler]
    PROCEDURE AvailModalHandler@168(VAR CheckAvailability@1000 : Page 342;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::Yes;
    END;

    [ConfirmHandler]
    PROCEDURE PartialResConfirmHandler@83(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,ErrorResAlways) > 0,'Actual:' + Question);
      Reply := TRUE;
    END;

    [ConfirmHandler]
    PROCEDURE CancelResConfirmHandler@180(Question@1000 : Text[1024];VAR Reply@1001 : Boolean);
    BEGIN
      Assert.IsTrue(STRPOS(Question,ErrorCancelRes) > 0,'Actual:' + Question);
      Reply := TRUE;
    END;

    [ModalPageHandler]
    PROCEDURE AvailToResModalHandler@76(VAR Reservation@1000 : TestPage 498);
    VAR
      counter@1001 : Integer;
    BEGIN
      Reservation.FIRST;

      // Validate: Entry summaries for various supply types.
      VerifyEntrySummary(Reservation,FORMAT(GlobalILESupply),FORMAT(GlobalILESupply),'Item Ledger Entry');
      Reservation.AvailableToReserve.INVOKE;
      Reservation.NEXT;

      VerifyEntrySummary(Reservation,FORMAT(GlobalPOSupply),FORMAT(GlobalPOSupply),'Purchase');
      Reservation.AvailableToReserve.INVOKE;
      Reservation.NEXT;

      VerifyEntrySummary(Reservation,FORMAT(GlobalAOSupply),FORMAT(GlobalAOSupply),'Assembly');
      Reservation.AvailableToReserve.INVOKE;

      Reservation.FIRST;
      IF Reservation."Summary Type".VALUE <> '' THEN
        counter := 1;
      WHILE Reservation.NEXT DO
        counter += 1;

      Assert.AreEqual(3,counter,'Wrong no. of Summary entries.');

      // Exercise: Autoreserve.
      Reservation."Auto Reserve".INVOKE;
      IF GlobalReserveTwice THEN
        Reservation."Auto Reserve".INVOKE;
    END;

    [ModalPageHandler]
    PROCEDURE ReserveCancelModalHandler@116(VAR Reservation@1000 : TestPage 498);
    VAR
      SupplyType@1001 : Text[80];
      CapableToReserve@1002 : Decimal;
      QtyToReserve@1004 : Decimal;
    BEGIN
      // Set label filtering for Entry Summary.
      CASE GlobalSourceType OF
        32:
          SupplyType := 'Item Ledger Entry';
        39:
          SupplyType := 'Purchase';
        900:
          SupplyType := 'Assembly';
      END;

      Reservation.FIRST;
      // Set the cursor on the desired supply type.
      WHILE STRPOS(Reservation."Summary Type".VALUE,SupplyType) = 0 DO
        IF NOT Reservation.NEXT THEN
          Assert.Fail('Expected line for ' + SupplyType + ' not found.');

      // Exercise: Reserve from current line.
      Reservation."Reserve from Current Line".INVOKE;
      IF GlobalReserveTwice THEN
        Reservation."Reserve from Current Line".INVOKE;

      // Validate: Reserved Qty.
      // Capable to Reserve = min(Assembly Line Qty, Avail To Reserve Qty for the current Supply Type).
      EVALUATE(QtyToReserve,Reservation.QtyToReserveBase.VALUE);
      CapableToReserve := (GlobalSupply + QtyToReserve - ABS(GlobalSupply - QtyToReserve)) / 2;

      Assert.IsTrue(STRPOS(Reservation."Summary Type".VALUE,SupplyType) > 0,'Actual:' + Reservation."Summary Type".VALUE);
      Assert.AreEqual(FORMAT(CapableToReserve),Reservation."Current Reserved Quantity".VALUE,'Wrong reserved qty for ' + SupplyType);

      // Exercise: Cancel reservation if required.
      IF GlobalCancelReservation THEN BEGIN
        Reservation.CancelReservationCurrentLine.INVOKE;
        // Validate: Reservation was canceled.
        Assert.AreEqual('',Reservation."Current Reserved Quantity".VALUE,'Wrong reserved qty for ' + SupplyType);
      END;
    END;

    [MessageHandler]
    PROCEDURE InsufSupplyMessagHandler@160(Message@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(STRPOS(Message,ErrorInsufSupply) > 0,'Actual:' + Message);
    END;

    [ModalPageHandler]
    PROCEDURE AvailILEModalHandler@138(VAR AvailableItemLedgEntries@1000 : TestPage 504);
    VAR
      ActualQty@1001 : Decimal;
      LineQty@1002 : Decimal;
    BEGIN
      AvailableItemLedgEntries.FIRST;
      IF AvailableItemLedgEntries."Remaining Quantity".VALUE <> '' THEN
        REPEAT
          EVALUATE(LineQty,AvailableItemLedgEntries."Remaining Quantity".VALUE);
          ActualQty += LineQty;
        UNTIL NOT AvailableItemLedgEntries.NEXT;

      Assert.AreEqual(GlobalILESupply,ActualQty,'Wrong drilled down ILE qty.');
    END;

    [ModalPageHandler]
    PROCEDURE AvailPOModalHandler@169(VAR AvailablePurchaseLines@1000 : TestPage 501);
    VAR
      ActualQty@1001 : Decimal;
      LineQty@1002 : Decimal;
    BEGIN
      AvailablePurchaseLines.FIRST;
      IF AvailablePurchaseLines."Outstanding Qty. (Base)".VALUE <> '' THEN
        REPEAT
          EVALUATE(LineQty,AvailablePurchaseLines."Outstanding Qty. (Base)".VALUE);
          ActualQty += LineQty;
        UNTIL NOT AvailablePurchaseLines.NEXT;

      Assert.AreEqual(GlobalPOSupply,ActualQty,'Wrong drilled down PO qty.');
    END;

    [ModalPageHandler]
    PROCEDURE AvailAOModalHandler@172(VAR AvailableAssemblyHeaders@1000 : TestPage 925);
    VAR
      ActualQty@1001 : Decimal;
      LineQty@1002 : Decimal;
    BEGIN
      AvailableAssemblyHeaders.FIRST;
      IF AvailableAssemblyHeaders."Remaining Quantity".VALUE <> '' THEN
        REPEAT
          EVALUATE(LineQty,AvailableAssemblyHeaders."Remaining Quantity".VALUE);
          ActualQty += LineQty;
        UNTIL NOT AvailableAssemblyHeaders.NEXT;

      Assert.AreEqual(GlobalAOSupply,ActualQty,'Wrong drilled down AO qty.');
    END;

    [ModalPageHandler]
    PROCEDURE AvailabilityWindowHandler@58(VAR AsmAvailability@1000 : Page 908;VAR Response@1001 : Action);
    BEGIN
      Response := ACTION::Yes; // always confirm
    END;

    [MessageHandler]
    PROCEDURE DueDateBeforeWorkDate@145(Msg@1000 : Text[1024]);
    BEGIN
      Assert.IsTrue(STRPOS(Msg,MsgDueDateBeforeWorkDate) > 0,'');
    END;

    BEGIN
    {
      // [FEATURE] [Assembly] [Reservation] [SCM]
      This CU covers the test cases for Kitting / Reservations, more specifically:
      - reserve components of an Assembly Order against various types of supply
      - reserve the output of an Assembly Order using it as supply
      - change reservations when any element in the supply-demand coupling changes
      - Available to reserve validation on the Reservations page
      - Auto Reserve, Reserve from current line, Cancel reservations using the Reservations page
      - automatic reservation for items with Reserve - Always using the Assembly Order page.
    }
    END.
  }
}

